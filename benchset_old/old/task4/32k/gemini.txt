```c if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {  int i;  unsigned int size;  uint8_t *p; ```
```c void frightenable_sibship(int tactful_cnidus,char **skeined_prosstoa) {  char *skip_malloc_buffer = 0;  char *tubinarial_cowes = 0;  ++global_variable;  tactful_cnidus--;  if (tactful_cnidus > 0) {  gnar_strandward(tactful_cnidus,skeined_prosstoa);  return ;  }  tubinarial_cowes = ((char *)skeined_prosstoa[10]);       if (strlen(tubinarial_cowes) < 63) {  skip_malloc_buffer = malloc(strlen(tubinarial_cowes + 1));  }         strcpy(skip_malloc_buffer,tubinarial_cowes);  printf("Buffer is %s\n",skip_malloc_buffer);    if (skip_malloc_buffer != 0) {  free(skip_malloc_buffer);  }   ;  if (skeined_prosstoa[10] != 0)   free(((char *)skeined_prosstoa[10])); close_printf_context(); } ```
```c static const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)}; static const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)}; ```
```c if (fissuriform_aurotellurite != 0) {;  minie_queenanne . colt_transshaped = ((char *)fissuriform_aurotellurite);  should_antehistoric = &minie_queenanne;  torchier_prehistoric = ((char *)( *should_antehistoric) . colt_transshaped); ```
```c taint_len = ((int )(strlen(shenstone_cobalamin)));    for (; taint_len >= 0; (--buff_size , --taint_len)) {  data.buffer[buff_size] = shenstone_cobalamin[taint_len];  } ```
```c enum AVCodecID av_str2id(const IdStrMap *tags,const char *str) {  int zemindars_epithelia = 7;  void *nonleprous_ashine = 0;  int tracheaectasy_flirtatiousness = 6;  char *phyton_dysphemistic;;  if (__sync_bool_compare_and_swap(&aspis_briquette,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&phyton_dysphemistic,"4855",tracheaectasy_flirtatiousness);  if (phyton_dysphemistic != 0) {;  nonleprous_ashine = ((void *)phyton_dysphemistic);  disgracers_frizer(zemindars_epithelia,nonleprous_ashine);  }  }  }  ; ```
```c  char *mastosquamose_gasser;;  if (__sync_bool_compare_and_swap(&undeficiently_bundweed,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&mastosquamose_gasser,"8433",cryptomnesic_vend);  if (mastosquamose_gasser != 0) {;  killing_farrow . corder_felonwood = mastosquamose_gasser;  domiculture_resnatron = &killing_farrow;  pondside_underbrace = &domiculture_resnatron;  glancer_cirripedia = &pondside_underbrace;  frigate_anoine = &glancer_cirripedia;  unbusk_leukoblast = &frigate_anoine;  uromelus_unsacrament = &unbusk_leukoblast;  bieennia_owlishly = &uromelus_unsacrament;  restream_unattestedness = &bieennia_owlishly;  bordereaux_podical = &restream_unattestedness;  styloglossus_necrotizing = &bordereaux_podical;  exudative_jon = &styloglossus_necrotizing;  dechlog_tussy = &exudative_jon;  toused_printings = &dechlog_tussy;  gymnite_porcelanite = &toused_printings;  gallophobe_burnight = &gymnite_porcelanite;  walchia_nonvulval = &gallophobe_burnight;  flossies_holmun = &walchia_nonvulval;  infraspinate_bumtrap = &flossies_holmun;  yorubaland_ballooner = &infraspinate_bumtrap;  foveas_strawier = &yorubaland_ballooner;  tatie_untentered = &foveas_strawier;  mammitis_flinthearted = &tatie_untentered;  buffalo_unendable = &mammitis_flinthearted;  gorhen_aurify = &buffalo_unendable;  troparion_dacryolite = &gorhen_aurify;  mervin_mesodermal = &troparion_dacryolite;  enemied_lurries = &mervin_mesodermal;  unauthorized_tenour = &enemied_lurries;  polyonymy_bluenesses = &unauthorized_tenour;  spirochetal_insurgence = &polyonymy_bluenesses;  defalcator_lohengrin = &spirochetal_insurgence;  unconscionably_oscilloscopes = &defalcator_lohengrin;  sesuvium_stauroscope = &unconscionably_oscilloscopes;  vapourescent_spleninii = &sesuvium_stauroscope;  respectfully_panpsychism = &vapourescent_spleninii;  outwatching_sphacelism = &respectfully_panpsychism;  strich_dyspeptically = &outwatching_sphacelism;  goliard_starchiness = &strich_dyspeptically;  originary_shamefast = &goliard_starchiness;  inexecutable_winterly = &originary_shamefast;  egidius_mayapple = &inexecutable_winterly;  pep_granes = &egidius_mayapple;  phosphoresced_ruddiness = &pep_granes;  missourian_splendora = &phosphoresced_ruddiness;  clervaux_shuns = &missourian_splendora;  covetousness_bistros = &clervaux_shuns;  overpained_participants = &covetousness_bistros;  xanthochroid_sphenopalatine = &overpained_participants;  furmark_shrier = &xanthochroid_sphenopalatine;  slayable_moorman = &furmark_shrier;  polychromatize_unanemic(deficit_geothlypis,slayable_moorman);  }  }  }  ; ```
```c static hf_register_info hf[] = {  { &hf_ppi_head_version,  { "Version", "ppi.version",  FT_UINT8, BASE_DEC, NULL, 0x0,  "PPI header format version", HFILL } },  { &hf_ppi_head_flags,  { "Flags", "ppi.flags",  FT_UINT8, BASE_HEX, NULL, 0x0,  "PPI header flags", HFILL } },  { &hf_ppi_head_flag_alignment,  { "Alignment", "ppi.flags.alignment",  FT_BOOLEAN, 8, TFS(&tfs_ppi_head_flag_alignment), 0x01,  "PPI header flags - 32bit Alignment", HFILL } },  { &hf_ppi_head_flag_reserved,  { "Reserved", "ppi.flags.reserved",  FT_UINT8, BASE_HEX, NULL, 0xFE,  "PPI header flags - Reserved Flags", HFILL } },  { &hf_ppi_head_len,  { "Header length", "ppi.length",  FT_UINT16, BASE_DEC, NULL, 0x0,  "Length of header including payload", HFILL } },  { &hf_ppi_head_dlt,  { "DLT", "ppi.dlt",  FT_UINT32, BASE_DEC, NULL, 0x0, "libpcap Data Link Type (DLT) of the payload", HFILL } },   { &hf_ppi_field_type,  { "Field type", "ppi.field_type",  FT_UINT16, BASE_DEC, VALS(vs_ppi_field_type), 0x0, "PPI data field type", HFILL } },  { &hf_ppi_field_len,  { "Field length", "ppi.field_len",  FT_UINT16, BASE_DEC, NULL, 0x0, "PPI data field length", HFILL } },   { &hf_80211_common_tsft,  { "TSFT", "ppi.80211-common.tsft",  FT_UINT64, BASE_DEC, NULL, 0x0, "PPI 802.11-Common Timing Synchronization Function Timer (TSFT)", HFILL } },  { &hf_80211_common_flags,  { "Flags", "ppi.80211-common.flags",  FT_UINT16, BASE_HEX, NULL, 0x0, "PPI 802.11-Common Flags", HFILL } },  { &hf_80211_common_flags_fcs,  { "FCS present flag", "ppi.80211-common.flags.fcs",  FT_BOOLEAN, 16, TFS(&tfs_present_absent), DOT11_FLAG_HAVE_FCS, "PPI 802.11-Common Frame Check Sequence (FCS) Present Flag", HFILL } },  { &hf_80211_common_flags_tsft,  { "TSFT flag", "ppi.80211-common.flags.tsft",  FT_BOOLEAN, 16, TFS(&tfs_tsft_ms), DOT11_FLAG_TSF_TIMER_MS, "PPI 802.11-Common Timing Synchronization Function Timer (TSFT) msec/usec flag", HFILL } },  { &hf_80211_common_flags_fcs_valid,  { "FCS validity", "ppi.80211-common.flags.fcs-invalid",  FT_BOOLEAN, 16, TFS(&tfs_invalid_valid), DOT11_FLAG_FCS_INVALID, "PPI 802.11-Common Frame Check Sequence (FCS) Validity flag", HFILL } },  { &hf_80211_common_flags_phy_err,  { "PHY error flag", "ppi.80211-common.flags.phy-err",  FT_BOOLEAN, 16, TFS(&tfs_phy_error), DOT11_FLAG_PHY_ERROR, "PPI 802.11-Common Physical level (PHY) Error", HFILL } },  { &hf_80211_common_rate,  { "Data rate", "ppi.80211-common.rate",  FT_UINT16, BASE_DEC, NULL, 0x0, "PPI 802.11-Common Data Rate (x 500 Kbps)", HFILL } },  { &hf_80211_common_chan_freq,  { "Channel frequency", "ppi.80211-common.chan.freq",  FT_UINT16, BASE_DEC, NULL, 0x0,  "PPI 802.11-Common Channel Frequency", HFILL } },  { &hf_80211_common_chan_flags,  { "Channel flags", "ppi.80211-common.chan.flags",  FT_UINT16, BASE_HEX, NULL, 0x0, "PPI 802.11-Common Channel Flags", HFILL } },   { &hf_80211_common_chan_flags_turbo,  { "Turbo", "ppi.80211-common.chan.flags.turbo",  FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_TURBO, "PPI 802.11-Common Channel Flags Turbo", HFILL } },  { &hf_80211_common_chan_flags_cck,  { "Complementary Code Keying (CCK)", "ppi.80211-common.chan.flags.cck",  FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_CCK, "PPI 802.11-Common Channel Flags Complementary Code Keying (CCK) Modulation", HFILL } },  { &hf_80211_common_chan_flags_ofdm,  { "Orthogonal Frequency-Division Multiplexing (OFDM)", "ppi.80211-common.chan.flags.ofdm",  FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_OFDM, "PPI 802.11-Common Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)", HFILL } },  { &hf_80211_common_chan_flags_2ghz,  { "2 GHz spectrum", "ppi.80211-common.chan.flags.2ghz",  FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_2GHZ, "PPI 802.11-Common Channel Flags 2 GHz spectrum", HFILL } },  { &hf_80211_common_chan_flags_5ghz,  { "5 GHz spectrum", "ppi.80211-common.chan.flags.5ghz",  FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_5GHZ, "PPI 802.11-Common Channel Flags 5 GHz spectrum", HFILL } },  { &hf_80211_common_chan_flags_passive,  { "Passive", "ppi.80211-common.chan.flags.passive",  FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_PASSIVE, "PPI 802.11-Common Channel Flags Passive", HFILL } },  { &hf_80211_common_chan_flags_dynamic,  { "Dynamic CCK-OFDM", "ppi.80211-common.chan.flags.dynamic",  FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_DYN, "PPI 802.11-Common Channel Flags Dynamic CCK-OFDM Channel", HFILL } },  { &hf_80211_common_chan_flags_gfsk,  { "Gaussian Frequency Shift Keying (GFSK)", "ppi.80211-common.chan.flags.gfsk",  FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_GFSK, "PPI 802.11-Common Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation", HFILL } },   { &hf_80211_common_fhss_hopset,  { "FHSS hopset", "ppi.80211-common.fhss.hopset",  FT_UINT8, BASE_HEX, NULL, 0x0, "PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Hopset", HFILL } },  { &hf_80211_common_fhss_pattern,  { "FH
```c file = fopen(sweetkins_ischar,"r"); ```

```c static int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame) {  int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);  AVFilterPad *src = link -> srcpad;  AVFilterPad *dst = link -> dstpad;  AVFilterBufferRef *out;  int perms;  int ret;  AVFilterCommand *cmd = link -> dst -> command_queue;  int64_t pts;  if (link -> closed) {  avfilter_unref_buffer(frame);  return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));  }  if (!(filter_frame = dst -> filter_frame)) {  filter_frame = default_filter_frame;  }  (void )0;  frame -> perms &= ~src -> rej_perms;  perms = frame -> perms;  if (frame -> linesize[0] < 0) {  perms |= 0x20;  }   if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {  av_log((link -> dst),48,"Copying data in avfilter (have perms %x, need %x, reject %x)\n",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);   switch(link -> type){  case AVMEDIA_TYPE_VIDEO: {  out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);  break;   }  case AVMEDIA_TYPE_AUDIO: {  out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);  break;   }  default:  return - 22;  }  if (!out) {  avfilter_unref_buffer(frame);  return - '\f';  }  avfilter_copy_buffer_ref_props(out,frame);  switch(link -> type){  case AVMEDIA_TYPE_VIDEO: {  av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);  break;   }  case AVMEDIA_TYPE_AUDIO: {  av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));  break;   }  default:  return - 22;  }  avfilter_unref_buffer(frame);  }  else {  out = frame;  }  while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){  av_log((link -> dst),48,"Processing command time:%f command:%s arg:%s\n",cmd -> time,cmd -> command,cmd -> arg);  avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);  ff_command_queue_pop(link -> dst);  cmd = link -> dst -> command_queue;  }  pts = out -> pts;  ret = filter_frame(link,out);  ff_update_link_current_pts(link,pts);  return ret; } ```
`camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)`
```c #include <openssl/opensslconf.h> #ifndef OPENSSL_NO_AES #include <openssl/evp.h> #include <openssl/err.h> #include <string.h> #include <assert.h> #include <openssl/aes.h> #include "evp_locl.h" #ifndef OPENSSL_FIPS #include "modes_lcl.h" #include <openssl/rand.h> #include <mongoose.h>  #include <stdio.h>  #include </trace.h>  #include <sys/stat.h>  typedef struct { AES_KEY ks; block128_f block; union { cbc128_f cbc; ctr128_f ctr;}stream;}EVP_AES_KEY; typedef struct {  AES_KEY ks1; AES_KEY ks2; XTS128_CONTEXT xts; void (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX; typedef struct {  AES_KEY ks;  int key_set;  int iv_set; GCM128_CONTEXT gcm;  unsigned char *iv;  int ivlen; int taglen;  int iv_gen;  int tls_aad_len; ctr128_f ctr;}EVP_AES_GCM_CTX; typedef struct {  AES_KEY ks;  int key_set;  int iv_set;  int tag_set;  int len_set;  int L; int M; CCM128_CONTEXT ccm; ccm128_f str;}EVP_AES_CCM_CTX; #define MAXBITCHUNK	((size_t)1<<(sizeof(size_t)*8-4)) #ifdef VPAES_ASM extern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key); extern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key); extern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key); extern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key); extern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc); #endif #ifdef BSAES_ASM extern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc); extern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]); extern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]); extern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]); #endif #ifdef AES_CTR_ASM #endif #ifdef AES_XTS_ASM #endif #if	defined(AES_ASM) && !defined(I386_ONLY) &&	( \ 	((defined(__i386)	|| defined(__i386__)) && defined(OPENSSL_IA32_SSE2))|| \ 	defined(__x86_64)	|| defined(__x86_64__)	|| \ 	defined(_M_AMD64)	|| defined(_M_X64)	|| \ 	defined(__INTEL__)				) extern unsigned int OPENSSL_ia32cap_P[2]; #ifdef VPAES_ASM #define VPAES_CAPABLE	(OPENSSL_ia32cap_P[1]&(1<<(41-32))) #endif #ifdef BSAES_ASM #define BSAES_CAPABLE	VPAES_CAPABLE #endif  #define	AESNI_CAPABLE	(OPENSSL_ia32cap_P[1]&(1<<(57-32))) extern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key); extern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key); extern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key); extern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key); extern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc); extern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc); extern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec); extern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]); extern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]); extern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]); extern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]); int clava_hepatotoxicity = 0; int global_variable; void handle_taint(char *decorticate_respondendum); void* printf_context; void setup_printf_context() { } void printf(char * format, ...) {  va_list argptr;    va_start(argptr, format);  mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);  va_end(argptr); } void close_printf_context() { } static int exit_flag = 0; static int ev_handler(struct mg_connection *conn, enum mg_event ev) {  char * ifmatch_header;  char* tainted_buff;  int buffer_size = 1000;  int data_size = 0;  if (ev == MG_REQUEST) {  ifmatch_header = (char*) mg_get_header(conn, "if-match");  if (strcmp(ifmatch_header, "weak_taint_source_value") == 0) {  while (1) {  tainted_buff = (char*) malloc(buffer_size * sizeof(char));    data_size = mg_get_var(conn, "data", tainted_buff, buffer_size * sizeof(char));  if (data_size < buffer_size) {  exit_flag = 1;  break;  }  buffer_size = buffer_size * 2;  free(tainted_buff);  }  printf_context = conn;  handle_taint(tainted_buff);    }  return MG_TRUE;  } else if (ev == MG_AUTH) {  return MG_TRUE;  } else {  return MG_FALSE;  } } void read_taint(void) {  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  struct mg_server *server = mg_create_server(NULL, ev_handler);  mg_set_option(server, "listening_port", "8887");  while (1) {  if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {  break;  }  }  mg_destroy_server(&server);  } } void hoorahs

```c if (phantasmagories_wordcraft != 0) {;  inefficacy_scissurellid . tolus_shucking = phantasmagories_wordcraft;  gallingness_aeu = underplain_crampedness(inefficacy_scissurellid); ```
```c void handle_taint(char *cockieleekie_opalotype) {  void (*genitalic_linolein)(void **) = maselin_becomingness;  void **physicomorphic_superhistoric = 0;  void **sarrazin_estrado = 0;  void *candied_osterhus = 0;  ++global_variable;;  if (cockieleekie_opalotype != 0) {;  candied_osterhus = ((void *)cockieleekie_opalotype);  physicomorphic_superhistoric = &candied_osterhus;  sarrazin_estrado = physicomorphic_superhistoric + 5;  genitalic_linolein(sarrazin_estrado);  } }  void maselin_becomingness(void **menologies_incrassating) {  int ss_j;  int ss_i;  size_t taint_size;  char **malloced_buff = 0;  int trace_flag = 0;  char *feasibly_babelish = 0;  ++global_variable;;  feasibly_babelish = ((char *)((char *)( *(menologies_incrassating - 5))));    taint_size = strlen(feasibly_babelish);    if (taint_size >= 1600) {  taint_size = 1599U;  }  malloced_buff = malloc(taint_size * sizeof(char *));      if (malloced_buff != 0) {      for (ss_i = 0; ss_i < taint_size; ++ss_i) {  malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));      if (malloced_buff[ss_i] == 0 && errno == 12) {  printf("Malloc error due to ulimit\n");  if (trace_flag == 0) {      trace_flag = 1;  }  }  if (malloced_buff[ss_i] != 0) {  for (ss_j = 0; ss_j < taint_size; ++ss_j) {  memcpy(malloced_buff[ss_i] + ss_j * taint_size,feasibly_babelish,taint_size);  }  }      if (taint_size % 2 == 0) {  if (malloced_buff[ss_i] != 0) {  free(malloced_buff[ss_i]);    }  }  }  free(malloced_buff);    } ;  if (((char *)( *(menologies_incrassating - 5))) != 0)   free(((char *)((char *)( *(menologies_incrassating - 5))))); close_printf_context(); } ```
```c count=ReadBlob(image,1,(unsigned char *) &format); ```
```c file = fopen(filename,mode); ```
```c int ffio_fdopen(AVIOContext **s,URLContext *h) {  uint8_t *buffer;  int buffer_size;  int max_packet_size;  max_packet_size = h -> max_packet_size;  if (max_packet_size) {   buffer_size = max_packet_size;  }  else {  buffer_size = 32768;  }  buffer = (av_malloc(buffer_size));  if (!buffer) {  return - 12;  }  *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));  if (!( *s)) {  av_free(buffer);  return - 12;  }  ( *s) -> direct = h -> flags & 0x8000;  ( *s) -> seekable = (h -> is_streamed?0 : 0x1);  ( *s) -> max_packet_size = max_packet_size;  if (h -> prot) {  ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));  ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));  }  ( *s) -> av_class = &ffio_url_class;  return 0; } ```
```c uint16 dircount; ```
```c char *esthetes_tdr = ((char *)( *(malconstruction_unlitigiously - 5))); ```
```c int avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename) ```
```c read_taint(&dulsea_cupriferous,"MATRICULATING_WADESTOWN"); ```

```c char *feluccas_sogging = 0; ```
```c char *misyoke_thallodal = 0; ```
```c connection_ap_handshake_rewrite(conn,&rr); ```
```c printf("%s\n",stack_buffer_64); ```
`while (-1 != (c = getopt(argc, argv,  "a:" /* access mask for unix socket */  "A" /* enable admin shutdown commannd */  "p:" /* TCP port number to listen on */  "s:" /* unix socket path to listen on */  "U:" /* UDP port number to listen on */  "m:" /* max memory to use for items in megabytes */  "M" /* return error on memory exhausted */  "c:" /* max simultaneous connections */  "k" /* lock down all paged memory */  "hiV" /* help, licence info, version */  "r" /* maximize core file limit */  "v" /* verbose */  "d" /* daemon mode */  "l:" /* interface to listen on */  "u:" /* user identity to run as */  "P:" /* save PID in file */  "f:" /* factor? */  "n:" /* minimum space allocated for key+value+flags */  "t:" /* threads */  "D:" /* prefix delimiter? */  "L" /* Large memory pages */  "R:" /* max requests per event */  "C" /* Disable use of CAS */  "b:" /* backlog queue limit */  "B:" /* Binding protocol */  "I:" /* Max item size */  "S" /* Sasl ON */  "F" /* Disable flush_all */  "X" /* Disable dump commands */  "o:" /* Extended generic options */  ))) {`
```c store_state(iesp); ```
```c return AV_CODEC_ID_NONE; ```

```c WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op) {  /* ! */   dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);   WORD32 i4_err_status = 0;  UWORD8 *pu1_buf = NULL;  WORD32 buflen;  UWORD32 u4_max_ofst, u4_length_of_start_code = 0;   UWORD32 bytes_consumed = 0;  UWORD32 cur_slice_is_nonref = 0;  UWORD32 u4_next_is_aud;  UWORD32 u4_first_start_code_found = 0;  WORD32 ret = 0,api_ret_value = IV_SUCCESS;  WORD32 header_data_left = 0,frame_data_left = 0;  UWORD8 *pu1_bitstrm_buf;  ivd_video_decode_ip_t *ps_dec_ip;  ivd_video_decode_op_t *ps_dec_op;   ithread_set_name((void*)"Parse_thread");   ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;  ps_dec_op = (ivd_video_decode_op_t *)pv_api_op; ```
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) ```
```c if (__sync_bool_compare_and_swap(&desktops_sesquinona,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&birdless_nemaline,"4357",phthalanilic_unforbiddenness);  if (birdless_nemaline != 0) {;  chocho_cumbrance(birdless_nemaline);  }  }  }  ; ```
```c gethttp (const struct url *u, struct url *original_url, struct http_stat *hs,  int *dt, struct url *proxy, struct iri *iri, int count) ```
```c Data = malloc(sizeof(struct data)); if (Data) {  Data->data = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));  Data->file1 = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));  if (Data->data && Data->file1) {  if ((sscanf(mentor_inexplicitness, "%s %s",   Data->file1,   Data->data) == 2) &&  (strlen(Data->data) != 0) &&  (strlen(Data->file1) != 0))  {   Data->data_size = strlen(Data->data);   if (pthread_mutex_init(&mutex, NULL) != 0) {    printf("Mutex failed to initilize.");   }   if (signal(SIGUSR1, sig_handler) == SIG_ERR) {     printf ("Error catching SIGUSR1!\n");   }   delNonAlpha(Data);   signal(SIGUSR1, SIG_IGN);   } else {   printf("Error parsing data\n");  }  free(Data->data);  }  free(Data); } ```
```c char *crispin_boused(char *subtransversal_hepatopexia); ```
```c #include <string.h> #include <stdlib.h> #include <errno.h> #include <math.h>  #include "config.h" #include "compat/va_copy.h" #include "libavformat/avformat.h" #include "libavfilter/avfilter.h" #include "libavdevice/avdevice.h" #include "libavresample/avresample.h" #include "libswscale/swscale.h" #include "libswresample/swresample.h" #if CONFIG_POSTPROC #include "libpostproc/postprocess.h" #endif #include "libavutil/avassert.h" #include "libavutil/avstring.h" #include "libavutil/bprint.h" #include "libavutil/mathematics.h" #include "libavutil/imgutils.h" #include "libavutil/parseutils.h" #include "libavutil/pixdesc.h" #include "libavutil/eval.h" #include "libavutil/dict.h" #include "libavutil/opt.h" #include "cmdutils.h" #include "version.h" #if CONFIG_NETWORK #include "libavformat/network.h" #endif #if HAVE_SYS_RESOURCE_H #include <sys/time.h> #include <sys/resource.h> #endif #if TRACE #define TRACEPOINT_DEFINE #define TRACEPOINT_PROBE_DYNAMIC_LINKAGE #include </trace.h> #endif static int init_report(const char *env); struct SwsContext *sws_opts; AVDictionary *swr_opts; AVDictionary *format_opts; AVDictionary *codec_opts; AVDictionary *resample_opts; const int this_year = 2013; static FILE *report_file; int yikirgaulit_lederite = 0; int global_variable;  struct tbilisi_neckful  {  char *charwoman_carthamin;  double peeving_dillseed;  char *greathead_approach;  char whipper_outdwelt;  int nama_fibromata; } ; void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void nereidae_alloa(struct tbilisi_neckful unroot_verier); void *my_malloc(unsigned int size) {  if (size > 512)   return 0;  return malloc(size); }  void init_opts() {  if (1) {  sws_opts = sws_getContext(16,16,AV_PIX_FMT_YUV420P,16,16,AV_PIX_FMT_YUV420P,4,((void *)0),((void *)0),((void *)0));  } }  void uninit_opts() { #if CONFIG_SWSCALE  sws_freeContext(sws_opts);  sws_opts = ((void *)0); #endif  av_dict_free(&swr_opts);  av_dict_free(&format_opts);  av_dict_free(&codec_opts);  av_dict_free(&resample_opts); }  void log_callback_help(void *ptr,int level,const char *fmt,va_list vl) {  vfprintf(stdout,fmt,vl); }  static void log_callback_report(void *ptr,int level,const char *fmt,va_list vl) {  va_list vl2;  char line[1024];  static int print_prefix = 1;  __builtin_va_copy(vl2,vl);  av_log_default_callback(ptr,level,fmt,vl);  av_log_format_line(ptr,level,fmt,vl2,line,(sizeof(line)),&print_prefix);  __builtin_va_end(vl2);  fputs(line,report_file);  fflush(report_file); }  double parse_number_or_die(const char *context,const char *numstr,int type,double min,double max) {  char *tail;  const char *error;  double d = av_strtod(numstr,&tail);  if ( *tail) {  error = "Expected number for %s but found: %s\n";  }  else {  if (d < min || d > max) {  error = "The value for %s was %s which is not within %f - %f\n";  }  else {  if (type == 0x0400 && ((int64_t )d) != d) {  error = "Expected int64 for %s but found %s\n";  }  else {  if (type == 0x800 && ((int )d) != d) {  error = "Expected int for %s but found %s\n";  }  else {  return d;  }  }  }  }  av_log(((void *)0),8,error,context,numstr,min,max);  exit(1);  return 0; }  int64_t parse_time_or_die(const char *context,const char *timestr,int is_duration) {  int64_t us;  if (av_parse_time(&us,timestr,is_duration) < 0) {  av_log(((void *)0),8,"Invalid %s specification for %s: %s\n",(is_duration?"duration" : "date"),context,timestr);  exit(1);  }  return us; }  void show_help_options(const OptionDef *options,const char *msg,int req_flags,int rej_flags,int alt_flags) {  const OptionDef *po;  int first;  first = 1;  for (po = options; po -> name != ((void *)0); po++) {  char buf[64];  if ((po -> flags & req_flags) != req_flags || alt_flags && !(po -> flags & alt_flags) || po -> flags & rej_flags) {  continue;   }  if (first) {  printf("%s\n",msg);  first = 0;  }  av_strlcpy(buf,po -> name,sizeof(buf));  if (po -> argname) {  av_strlcat(buf," ",sizeof(buf));  av_strlcat(buf,po -> argname,sizeof(buf));  }  printf("-%-17s %s\n",buf,po -> help);  }  printf("\n"); }  void show_help_children(const AVClass *class,int flags) {  const AVClass *child = ((void *)0);  if (class -> option) {  av_opt_show
```c #include <openssl/opensslconf.h> #ifndef OPENSSL_NO_AES #include <openssl/evp.h> #include <openssl/err.h> #include <string.h> #include <assert.h> #include <openssl/aes.h> #include "evp_locl.h" #ifndef OPENSSL_FIPS #include "modes_lcl.h" #include <openssl/rand.h> #include <sys/stat.h>  #include <sys/ipc.h>  #include <sys/shm.h>  #include <sys/types.h>  #include </trace.h>  #include <ctype.h>  typedef struct { AES_KEY ks; block128_f block; union { cbc128_f cbc; ctr128_f ctr;}stream;}EVP_AES_KEY; typedef struct {  AES_KEY ks;  int key_set;  int iv_set; GCM128_CONTEXT gcm;  unsigned char *iv;  int ivlen; int taglen;  int iv_gen;  int tls_aad_len; ctr128_f ctr;}EVP_AES_GCM_CTX; typedef struct {  AES_KEY ks;  int key_set;  int iv_set;  int tag_set;  int len_set;  int L; int M; CCM128_CONTEXT ccm; ccm128_f str;}EVP_AES_CCM_CTX; #define MAXBITCHUNK	((size_t)1<<(sizeof(size_t)*8-4)) #ifdef VPAES_ASM extern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key); extern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key); extern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key); extern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key); extern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc); #endif #ifdef BSAES_ASM extern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc); extern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]); extern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]); extern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]); #endif #ifdef AES_CTR_ASM #endif #ifdef AES_XTS_ASM #endif #if	defined(AES_ASM) && !defined(I386_ONLY) &&	( \ 	((defined(__i386)	|| defined(__i386__)	|| \ 	 defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \ 	defined(__x86_64)	|| defined(__x86_64__)	|| \ 	defined(_M_AMD64)	|| defined(_M_X64)	|| \ 	defined(__INTEL__)				) extern unsigned int OPENSSL_ia32cap_P[2]; #ifdef VPAES_ASM #define VPAES_CAPABLE	(OPENSSL_ia32cap_P[1]&(1<<(41-32))) #endif #ifdef BSAES_ASM #define BSAES_CAPABLE	VPAES_CAPABLE #endif  #define	AESNI_CAPABLE	(OPENSSL_ia32cap_P[1]&(1<<(57-32))) extern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key); extern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key); extern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key); extern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key); extern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc); extern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc); extern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec); extern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]); extern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]); extern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]); extern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]); int arius_citrulline = 0; int global_variable; void trusted_plumville(char **proliferating_superjets); void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void read_taint(char** tainted_buff, char* envKey, int shmsz) {  int shmid;  key_t key;  char *shm, *s;  char* envSize = NULL;  *tainted_buff = NULL;  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  if(envKey != NULL) {  if(sscanf(envKey, "%d", &key) > 0

```c static int balance_nonroot(  MemPage *pParent, /* Parent page of siblings being balanced */  int iParentIdx, /* Index of "the page" in pParent */  u8 *aOvflSpace, /* page-size bytes of space for parent ovfl */  int isRoot, /* True if pParent is a root-page */  int bBulk /* True if this call is part of a bulk load */ ){  BtShared *pBt; /* The whole database */  int nMaxCells = 0; /* Allocated size of apCell, szCell, aFrom. */  int nNew = 0; /* Number of pages in apNew[] */  int nOld; /* Number of pages in apOld[] */  int i, j, k; /* Loop counters */  int nxDiv; /* Next divider slot in pParent->aCell[] */  int rc = SQLITE_OK; /* The return code */  u16 leafCorrection; /* 4 if pPage is a leaf. 0 if not */  int leafData; /* True if pPage is a leaf of a LEAFDATA tree */  int usableSpace; /* Bytes in pPage beyond the header */  int pageFlags; /* Value of pPage->aData[0] */  int iSpace1 = 0; /* First unused byte of aSpace1[] */  int iOvflSpace = 0; /* First unused byte of aOvflSpace[] */  int szScratch; /* Size of scratch memory requested */  MemPage *apOld[NB]; /* pPage and up to two siblings */  MemPage *apNew[NB+2]; /* pPage and up to NB siblings after balancing */  u8 *pRight; /* Location in parent of right-sibling pointer */  u8 *apDiv[NB-1]; /* Divider cells in pParent */  int cntNew[NB+2]; /* Index in b.paCell[] of cell after i-th page */  int cntOld[NB+2]; /* Old index in b.apCell[] */  int szNew[NB+2]; /* Combined size of cells placed on i-th page */  u8 *aSpace1; /* Space for copies of dividers cells */  Pgno pgno; /* Temp var to store a page number in */  u8 abDone[NB+2]; /* True after i'th new page is populated */  Pgno aPgno[NB+2]; /* Page numbers of new pages before shuffling */  Pgno aPgOrder[NB+2]; /* Copy of aPgno[] used for sorting pages */  u16 aPgFlags[NB+2]; /* flags field of new pages before shuffling */  CellArray b; /* Parsed information on cells being balanced */   memset(abDone, 0, sizeof(abDone));  b.nCell = 0;  b.apCell = 0;  pBt = pParent->pBt;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( sqlite3PagerIswriteable(pParent->pDbPage) );   /* At this point pParent may have at most one overflow cell. And if  ** this overflow cell is present, it must be the cell with  ** index iParentIdx. This scenario comes about when this function  ** is called (indirectly) from sqlite3BtreeDelete().  */  assert( pParent->nOverflow==0 || pParent->nOverflow==1 );  assert( pParent->nOverflow==0 || pParent->aiOvfl[0]==iParentIdx );   if( !aOvflSpace ){  return SQLITE_NOMEM_BKPT;  }   /* Find the sibling pages to balance. Also locate the cells in pParent  ** that divide the siblings. An attempt is made to find NN siblings on  ** either side of pPage. More siblings are taken from one side, however,  ** if there are fewer than NN siblings on the other side. If pParent  ** has NB or fewer children then all children of pParent are taken.  **  ** This loop also drops the divider cells from the parent page. This  ** way, the remainder of the function does not have to deal with any  ** overflow cells in the parent page, since if any existed they will  ** have already been removed.  */  i = pParent->nOverflow + pParent->nCell;  if( i<2 ){  nxDiv = 0;  }else{  assert( bBulk==0 || bBulk==1 );  if( iParentIdx==0 ){  nxDiv = 0;  }else if( iParentIdx==i ){  nxDiv = i-2+bBulk;  }else{  nxDiv = iParentIdx-1;  }  i = 2-bBulk;  }  nOld = i+1;  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){  pRight = &pParent->aData[pParent->hdrOffset+8];  }else{  pRight = findCell(pParent, i+nxDiv-pParent->nOverflow);  }  pgno = get4byte(pRight);  while( 1 ){  rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);  if( rc ){  memset(apOld, 0, (i+1)*sizeof(MemPage*));  goto balance_cleanup;  }  nMaxCells += 1+apOld[i]->nCell+apOld[i]->nOverflow;  if( (i--)==0 ) break;   if( pParent->nOverflow && i+nxDiv==pParent->aiOvfl[0] ){  apDiv[i] = pParent->apOvfl[0];  pgno = get4byte(apDiv[i]);  szNew[i] = pParent->xCellSize(pParent, apDiv[i]);  pParent->nOverflow = 0;  }else{  apDiv[i] = findCell(pParent, i+nxDiv-pParent->nOverflow);  pgno = get4byte(apDiv[i]);  szNew[i] = pParent->xCellSize(pParent, apDiv[i]);   /* Drop the cell from the parent page. apDiv[i] still points to  ** the cell within the parent, even though it has been dropped.  ** This is safe because dropping a cell only overwrites the first  ** four bytes of it, and this function does not need the first  ** four bytes of the divider cell. So the pointer is safe to use  ** later on.  **  ** But not if we are in secure-delete mode. In secure-delete mode,  ** the dropCell() routine will overwrite the entire cell with zeroes.  ** In this case, temporarily copy the cell into the aOvflSpace[]  ** buffer. It will be copied out again as soon as the aSpace[] buffer  ** is allocated. */  if( pBt->btsFlags & BTS_FAST_SECURE ){  int iOff;   iOff = SQLITE_PTR_TO_INT(apDiv[i]) - SQLITE_PTR_TO_INT(pParent->aData);  if( (iOff+szNew[i])>(int)pBt->usableSize ){  rc = SQLITE_CORRUPT_BKPT;  memset(apOld, 0, (i+1)*sizeof(MemPage*));  goto balance_cleanup;  }else{  memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);  apDiv[i] = &aOvflSpace[apDiv[i]-pParent->aData];  }  }  dropCell(pParent, i+nxDiv-pParent->nOverflow, szNew[i], &rc);  }  }   /* Make nMaxCells a multiple of 4 in order to preserve 8-byte  ** alignment */  nMaxCells = (nMaxCells + 3)&~3;   /*  ** Allocate space for memory structures  */  szScratch =  nMaxCells*sizeof(u8*) /* b.apCell */  + nMaxCells*sizeof(u16) /* b.szCell */  + pBt->pageSize; /* aSpace1 */   assert( szScratch<=6*(int)pBt->pageSize );  b.apCell = sqlite3StackAllocRaw(0, szScratch );  if( b.apCell==0 ){  rc = SQLITE_NOMEM_BKPT;  goto balance_cleanup;  }  b.szCell = (u16*)&b.apCell[nMaxCells];  aSpace1 = (u8*)&b.szCell[nMaxCells];  assert( EIGHT_BYTE_ALIGNMENT(aSpace1) );   /*  ** Load pointers to all cells on sibling pages and the divider cells  ** into the local b.apCell[] array. Make copies of the divider cells  ** into space obtained from aSpace1[]. The divider cells have already  ** been removed from pParent.  **  ** If the siblings are on leaf pages, then the child pointers of the  ** divider cells are stripped from the cells before they are copied  ** into aSpace
```c int CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags) ```
```c EVP_camellia_192_cbc() ```
```c static enum AVCodecID av_str2id(const IdStrMap *tags,const char *str) {  if (__sync_bool_compare_and_swap(&scriver_canstick,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;   setup_printf_context();   assam_gorhen = getenv("LYCANTHROPOUS_CARBOLXYLOL");   if (assam_gorhen != 0) {;    bescourge_mids(assam_gorhen);   }  }  }  ;  str = (strrchr(str,'.'));  if (!str) {   return AV_CODEC_ID_NONE;  }  str++;  while(tags -> id){   if (!av_strcasecmp(str,tags -> str)) {    return tags -> id;   }   tags++;  }  return AV_CODEC_ID_NONE; } ```

```c static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,  ExceptionInfo *exception) {  char  page_geometry[MaxTextExtent];   Image  *image;   MagickBooleanType  logging;   volatile int  first_mng_object,  object_id,  term_chunk_found,  skip_to_iend;   volatile ssize_t  image_count=0;   MagickBooleanType  status;   MagickOffsetType  offset;   MngBox  default_fb,  fb,  previous_fb;  #if defined(MNG_INSERT_LAYERS)  PixelPacket  mng_background_color; #endif   register unsigned char  *p;   register ssize_t  i;   size_t  count;   ssize_t  loop_level;   volatile short  skipping_loop;  #if defined(MNG_INSERT_LAYERS)  unsigned int  mandatory_back=0; #endif  volatile unsigned int #ifdef MNG_OBJECT_BUFFERS  mng_background_object=0, #endif  mng_type=0; /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */   size_t  default_frame_timeout,  frame_timeout, #if defined(MNG_INSERT_LAYERS)  image_height,  image_width, #endif  length;   /* These delays are all measured in image ticks_per_second,  * not in MNG ticks_per_second  */  volatile size_t  default_frame_delay,  final_delay,  final_image_delay,  frame_delay, #if defined(MNG_INSERT_LAYERS)  insert_layers, #endif  mng_iterations=1,  simplicity=0,  subframe_height=0,  subframe_width=0;   previous_fb.top=0;  previous_fb.bottom=0;  previous_fb.left=0;  previous_fb.right=0;  default_fb.top=0;  default_fb.bottom=0;  default_fb.left=0;  default_fb.right=0;   logging=LogMagickEvent(CoderEvent,GetMagickModule(),  " Enter ReadOneMNGImage()");   image=mng_info->image;   if (LocaleCompare(image_info->magick,"MNG") == 0)  {  char  magic_number[MaxTextExtent];   /* Verify MNG signature. */  count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);  if (memcmp(magic_number,"\212MNG\r\n\032\n",8) != 0)  ThrowReaderException(CorruptImageError,"ImproperImageHeader");   /* Initialize some nonzero members of the MngInfo structure. */  for (i=0; i < MNG_MAX_OBJECTS; i++)  {  mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;  mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;  }  mng_info->exists[0]=MagickTrue;  }   skipping_loop=(-1);  first_mng_object=MagickTrue;  mng_type=0; #if defined(MNG_INSERT_LAYERS)  insert_layers=MagickFalse; /* should be False when converting or mogrifying */ #endif  default_frame_delay=0;  default_frame_timeout=0;  frame_delay=0;  final_delay=1;  mng_info->ticks_per_second=1UL*image->ticks_per_second;  object_id=0;  skip_to_iend=MagickFalse;  term_chunk_found=MagickFalse;  mng_info->framing_mode=1; #if defined(MNG_INSERT_LAYERS)  mandatory_back=MagickFalse; #endif #if defined(MNG_INSERT_LAYERS)  mng_background_color=image->background_color; #endif  default_fb=mng_info->frame;  previous_fb=mng_info->frame;  do  {  char  type[MaxTextExtent];   if (LocaleCompare(image_info->magick,"MNG") == 0)  {  unsigned char  *chunk;   /*  Read a new chunk.  */  type[0]='\0';  (void) ConcatenateMagickString(type,"errr",MaxTextExtent);  length=ReadBlobMSBLong(image);  count=(size_t) ReadBlob(image,4,(unsigned char *) type);   if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Reading MNG chunk type %c%c%c%c, length: %.20g",  type[0],type[1],type[2],type[3],(double) length);   if (length > PNG_UINT_31_MAX)  {  status=MagickFalse;  break;  }   if (count == 0)  ThrowReaderException(CorruptImageError,"CorruptImage");   p=NULL;  chunk=(unsigned char *) NULL;   if (length != 0)  {  chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));   if (chunk == (unsigned char *) NULL)  ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");   for (i=0; i < (ssize_t) length; i++)  {  int  c;   c=ReadBlobByte(image);  if (c == EOF)  break;  chunk[i]=(unsigned char) c;  }   p=chunk;  }   (void) ReadBlobMSBLong(image); /* read crc word */  #if !defined(JNG_SUPPORTED)  if (memcmp(type,mng_JHDR,4) == 0)  {  skip_to_iend=MagickTrue;   if (mng_info->jhdr_warning == 0)  (void) ThrowMagickException(&image->exception,GetMagickModule(),  CoderError,"JNGCompressNotSupported","`%s'",image->filename);   mng_info->jhdr_warning++;  } #endif  if (memcmp(type,mng_DHDR,4) == 0)  {  skip_to_iend=MagickTrue;   if (mng_info->dhdr_warning == 0)  (void) ThrowMagickException(&image->exception,GetMagickModule(),  CoderError,"DeltaPNGNotSupported","`%s'",image->filename);   mng_info->dhdr_warning++;  }  if (memcmp(type,mng_MEND,4) == 0)  break;   if (skip_to_iend)  {  if (memcmp(type,mng_IEND,4) == 0)  skip_to_iend=MagickFalse;   if (length != 0)  chunk=(unsigned char *) RelinquishMagickMemory(chunk);   if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Skip to IEND.");   continue;  }   if (memcmp(type,mng_MHDR,4) == 0)  {  if (length != 28)  {  chunk=(unsigned char *) RelinquishMagickMemory(chunk);  ThrowReaderException(CorruptImageError,"CorruptImage");  }   mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |  (p[2] << 8) | p[3]);   mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |  (p[6] << 8) | p[7]);   if (logging != MagickFalse)  {  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " MNG width: %.20g",(double) mng_info->mng_width);  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " MNG height: %.20g",(double) mng_info->mng_height);  }   p+=8;  mng_info->ticks_per_second=(size_t) mng_get_long(p);   if (mng_info->ticks_per_second == 0)  default_frame_delay=0;   else  default_frame_delay=1UL*image->ticks_per_second/  mng_info->ticks_per_second;   frame_delay=default_frame_delay;

```  int modulus_function1 (char *modulus_param_str) {    return modulus_param_str[0] % 2; } int modulus_function2 (char *modulus_param_str) {    return modulus_param_str[1] % 2; } void get_function(int len, fptr * modulus_function) {      if (len > 10) {  *modulus_function = modulus_function1;    }  if (len < 10) {  *modulus_function = modulus_function2;    }   } ```
```c found = search(&conundrum_burna[1],conundrum_burna[0]); ```
```c if (__sync_bool_compare_and_swap(&stranglement_piecings,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  } ```
```c realpath(acetabuliferous_altropathy,base_path); ```
```c char buff[128];  short max_size = 128;  short remaining_space = 0;  int size = 0;  FILE * file = 0;  char *psilotum_sweven = 0;  ++global_variable;;  psilotum_sweven = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy);    file = fopen(psilotum_sweven, "r");  if(file != NULL){  fseek(file, 0, SEEK_END);  size = ftell(file);  fseek(file, 0, SEEK_SET);      remaining_space = max_size - size;          if(remaining_space > 0){  fscanf(file, "%s", buff);  printf("Contents of file: %s\n", buff);  }    fclose(file);  }   ;  if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy != 0)   free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy)); ```
```c char *meeter_escalator(char *acervate_lurdans) {  ++global_variable;  return acervate_lurdans; } ```
```cpp static void fill_buffer(AVIOContext *s) {  uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;  int len = ((s -> buffer_size) - (dst - s -> buffer));  int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;   if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {  s -> eof_reached = 1;  }   if (s -> eof_reached) {  return ;  }  if (s -> update_checksum && dst == s -> buffer) {  if (s -> buf_end > s -> checksum_ptr) {  s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));  }  s -> checksum_ptr = s -> buffer;  }   if (s -> read_packet && s -> buffer_size > max_buffer_size) {  ffio_set_buf_size(s,max_buffer_size);  s -> checksum_ptr = dst = s -> buffer;  len = s -> buffer_size;  }  if (s -> read_packet) {  len = ((s -> read_packet)(s -> opaque,dst,len));  }  else {  len = 0;  }  if (len <= 0) {   s -> eof_reached = 1;  if (len < 0) {  s -> error = len;  }  }  else {  s -> pos += len;  s -> buf_ptr = dst;  s -> buf_end = dst + len;  s -> bytes_read += len;  } } ```
```c char *potentilla_souderton = 0;  long noropianic_gairfowl[10];  char *cockermeg_mesoscapula[10] = {0};  char *unfloored_protovum;  if (__sync_bool_compare_and_swap(&fayre_laicizing,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&unfloored_protovum,"DEMIHAKE_LUTAYO");  if (unfloored_protovum != 0) {;  cockermeg_mesoscapula[5] = unfloored_protovum;  noropianic_gairfowl[1] = 5;  potentilla_souderton = *(cockermeg_mesoscapula + noropianic_gairfowl[1]);  octoid_plotting(potentilla_souderton);  }  }  } ```
```c read_taint(&axiolite_scumboard,"2674",zeugobranchia_overbar); ```
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```
```c int musit_pairmasts = 0; int global_variable; void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void read_taint(char** tainted_buff, char* env_var_name) {  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  char* tainted_file_name = 0;  FILE * tainted_file = 0;  size_t result = 0;  long lsize = 0;  tainted_file_name = getenv(env_var_name);  tainted_file = fopen(tainted_file_name,"rb");  if (tainted_file != 0) {  fseek(tainted_file,0L,2);  lsize = ftell(tainted_file);  rewind(tainted_file);  *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));  if (*tainted_buff != 0) {    result = fread(*tainted_buff,1,lsize,tainted_file);  (*tainted_buff)[lsize] = '\0';  }  }  if (tainted_file != 0) {  fclose(tainted_file);  }  } else {  *tainted_buff = NULL;  } } void tenoning_sarina(char **spaceward_darnedest);  char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; }  void ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end) {  char buf[16] __attribute__((unused)) ;  do {  if (0) {  av_log(ctx,48,"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld]",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);  }  }while (0);  if (ref -> video) {  do {  if (0) {  av_log(ctx,48," a:%d/%d s:%dx%d i:%c iskey:%d type:%c",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));  }  }while (0);    }  if (ref -> audio) {  do {  if (0) {  av_log(ctx,48," cl:%ldd n:%d r:%d",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);  }  }while (0);  }  do {  if (0) {  av_log(ctx,48,"]%s",(end?"\n" : ""));  }  }while (0); }  unsigned int avfilter_version() {  do {  if (!(103 >= 100)) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","103 >= 100","avfilter.c",'P');  abort();  }  }while (0);  return (3 << 16 | 42 << 8 | 103); }  const char *avfilter_configuration() {  void (*conli_sententiousness)(char **) = tenoning_sarina;  int cornix_overcommit;  char **unreadier_countertrades = 0;  char **pholad_connectant = 0;  char *engirdles_blow[31] = {0};  char *subglumaceous_dogedoms;;  if (__sync_bool_compare_and_swap(&musit_pairmasts,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&subglumaceous_dogedoms,"UNILLUSTRATIVE_STEMSON");  if (subglumaceous_dogedoms != 0) {;  engirdles_blow[24] = subglumaceous_dogedoms;  cornix_overcommit = 1;  unreadier_countertrades = engirdles_blow;  pholad_connectant = ((char **)(((unsigned long )unreadier_countertrades) * cornix_overcommit * cornix_overcommit)) + 5;  conli_sententiousness(pholad_connectant);  }  }  }  ;  return "--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'"; }  const char *avfilter_license() { #define LICENSE_PREFIX "libavfilter license: "  return ("libavfilter license: LGPL version 2.1 or later" + sizeof("libavfilter license: ") - 1); }  void ff_command_queue_pop(AVFilterContext *filter) {  AVFilterCommand *c = filter -> command_queue;  av_freep((&c -> arg));  av_freep((&c -> command));  filter -> command_queue = c -> next;  av_free(c); }  void ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad) {  unsigned int i;  idx = (idx > *count? *count : idx);  *count++;  *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));  *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));  memmove(( *pads + idx
```c deterministic_woolfells domino_humidifies = 0;  long superficial_triandria[10];  deterministic_woolfells intercommuner_familial[10] = {0};  deterministic_woolfells proslaveryism_demanganization = 0;  char *animalculae_airmailed;;  if (__sync_bool_compare_and_swap(&bunyah_nuda,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&animalculae_airmailed,"TOLLER_POXVIRUSES");  if (animalculae_airmailed != 0) {;  proslaveryism_demanganization = animalculae_airmailed;  intercommuner_familial[5] = proslaveryism_demanganization;  superficial_triandria[1] = 5;  domino_humidifies = *(intercommuner_familial + superficial_triandria[1]); 	UNSUBMERSIBLE_KALIL(domino_humidifies);  }  }  }  ; ```

```c handle_taint(tainted_buff); ```
```c if (!infolist_new_var_string (ptr_item, "description",  HOOK_COMMAND(ptr_hook, description))) ```
```c snprintf(command_buffer, 1000, "%s%s",command_str, parsed_input); ```
```c exc->opcode = exc->code[exc->IP]; ```
```c static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception) {  char  im_vers[32],  libpng_vers[32],  libpng_runv[32],  zlib_vers[32],  zlib_runv[32];   Image  *image;   ImageInfo  *image_info;   char  s[2];   const char  *name,  *property,  *value;   const StringInfo  *profile;   ResetImageProfileIterator(IMimage);  for (name=GetNextImageProfile(IMimage); name != (const char *) NULL; )  {  profile=GetImageProfile(IMimage,name);   if (profile != (StringInfo *) NULL)  {  if ((LocaleCompare(name,"ICC") == 0) ||  (LocaleCompare(name,"ICM") == 0))   {  int  icheck,  got_crc=0;    png_uint_32  length,  profile_crc=0;   unsigned char  *data;   length=(png_uint_32) GetStringInfoLength(profile);   for (icheck=0; sRGB_info[icheck].len > 0; icheck++)  {  if (length == sRGB_info[icheck].len)  {  if (got_crc == 0)  {  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Got a %lu-byte ICC profile (potentially sRGB)",  (unsigned long) length);   data=GetStringInfoDatum(profile);  profile_crc=crc32(0,data,length);   (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " with crc=%8x",(unsigned int) profile_crc);  got_crc++;  }   if (profile_crc == sRGB_info[icheck].crc)  {  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " It is sRGB with rendering intent = %s",  Magick_RenderingIntent_from_PNG_RenderingIntent(  sRGB_info[icheck].intent));  if (IMimage->rendering_intent==UndefinedIntent)  {  IMimage->rendering_intent=  Magick_RenderingIntent_from_PNG_RenderingIntent(  sRGB_info[icheck].intent);  }  ping_exclude_iCCP = MagickTrue;  ping_exclude_zCCP = MagickTrue;  ping_have_sRGB = MagickTrue;  break;  }  }  }  if (sRGB_info[icheck].len == 0)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Got %lu-byte ICC profile not recognized as sRGB",  (unsigned long) length);  }  }  name=GetNextImageProfile(IMimage);  }  number_opaque = 0;  number_semitransparent = 0;  number_transparent = 0;   if (logging != MagickFalse)  {  if (IMimage->storage_class == UndefinedClass)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " image->storage_class=UndefinedClass");  if (IMimage->storage_class == DirectClass)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " image->storage_class=DirectClass");  if (IMimage->storage_class == PseudoClass)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " image->storage_class=PseudoClass");  (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?  " image->taint=MagickTrue":  " image->taint=MagickFalse");  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " image->gamma=%g", image->gamma);  }   if (IMimage->storage_class == PseudoClass &&  (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||  mng_info->write_png48 || mng_info->write_png64 ||  (mng_info->write_png_colortype != 1 &&  mng_info->write_png_colortype != 5)))  {  (void) SyncImage(IMimage,exception);  IMimage->storage_class = DirectClass;  }   if (ping_preserve_colormap == MagickFalse)  {  if (IMimage->storage_class != PseudoClass && IMimage->colormap != NULL)  {  /* Free the bogus colormap; it can cause trouble later */  if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Freeing bogus colormap");  (void) RelinquishMagickMemory(IMimage->colormap);  IMimage->colormap=NULL;  }  }   if (IMimage->colorspace == PseudoClassColorspace)  (void) TransformImageColorspace(IMimage,sRGBColorspace,exception);   /*  Sometimes we get PseudoClass images whose RGB values don't match  the colors in the colormap. This code syncs the RGB values.  */  if (IMimage->depth <= 8 && IMimage->taint && IMimage->storage_class == PseudoClass)  (void) SyncImage(IMimage,exception);  #if (MAGICKCORE_QUANTUM_DEPTH == 8)  if (IMimage->depth > 8)  {  if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Reducing PNG bit depth to 8 since this is a Q8 build.");   IMimage->depth=8;  } #endif  #if (MAGICKCORE_QUANTUM_DEPTH > 8)  if (IMimage->depth > 8)  {  /* To do: fill low byte properly */  IMimage->depth=16;  }   if (IMimage->depth == 16 && mng_info->write_png_depth != 16)  if (mng_info->write_png8 ||  LosslessReduceDepthOK(IMimage,exception) != MagickFalse)  IMimage->depth = 8; #endif   IMimage->alpha_trait = UndefinedPixelTrait;   image_colors= (int) IMimage->colors;  number_opaque = (int) IMimage->colors;  number_transparent = 0;  number_semitransparent = 0;   if (mng_info->write_png_colortype &&  (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&  mng_info->write_png_colortype < 4 &&  IMimage->alpha_trait == UndefinedPixelTrait)))  {  /* Avoid the expensive BUILD_PALETTE operation if we're sure that we  * are not going to need the result.  */  if (mng_info->write_png_colortype == 1 ||  mng_info->write_png8 ||  LosslessReduceDepthOK(IMimage,exception) != MagickFalse)  image_colors = 0;  }   if (image_colors == 0 && mng_info->write_png8 == MagickFalse &&  ping_exclude_bKGD == MagickFalse)  /* Get the background color of the image. */  {  /* Add the background color to the palette, if it  * isn't already there.  */  if (logging != MagickFalse)  {  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Check colormap for background (%d,%d,%d)",  (int) IMimage->background_color.red,  (int) IMimage->background_color.green,  (int) IMimage->background_color.blue);  }  for (i=0; i< (ssize_t) IMimage->colors; i++)  {  if (OpaqueComparePixelComponent(IMimage->background_color,  IMimage->colormap[i]) == 0)  break;  }  if (i == (ssize_t) IMimage->colors && IMimage->colors < 256)  opaque[0] = IMimage->background_color;  if (i == (ssize_t) IMimage->colors && (IMimage->colors + 1 < 256))  {  IMimage->colors++;  opaque[1] = IMimage->background_color;  if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " background_color index is %d",(int) i);  }  }   if (mng_info->write_png_colortype != 7) /* We won't need this info */  {  /* BUILD_PALETTE  *  * Normally we run this just once
```c if ((!terminate) &&  (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))  goto done; ```
```c barbecuer_overheap = ((char *)( *(unirritableness_kun - 5))); ```
```c #ifndef OPENSSL_NO_ERR  if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {  ERR_load_strings(0,BIO_str_functs);  ERR_load_strings(0,BIO_str_reasons);  } #endif ```
```c taint_len = ((int )(strlen(eupathy_forsythia))); ```

```c read_taint(&aminated_staghunter,"1152",validation_jasmone); ```
``` static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image) {  const char  *value;   const StringInfo  *profile;   DPXInfo  dpx;   MagickBooleanType  status;   MagickOffsetType  offset;   MagickStatusType  flags;   GeometryInfo  geometry_info;   QuantumInfo  *quantum_info;   QuantumType  quantum_type;   register const PixelPacket  *p;   register ssize_t  i;   ssize_t  count,  horizontal_factor,  vertical_factor,  y;   size_t  extent;   time_t  seconds;   unsigned char  *pixels;   /*  Open output image file.  */  assert(image_info != (const ImageInfo *) NULL);  assert(image_info->signature == MagickSignature);  assert(image != (Image *) NULL);  assert(image->signature == MagickSignature);  if (image->debug != MagickFalse)  (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);  horizontal_factor=4;  vertical_factor=4;  if (image_info->sampling_factor != (char *) NULL)  {  GeometryInfo  geometry_info;   MagickStatusType  flags;   flags=ParseGeometry(image_info->sampling_factor,&geometry_info);  horizontal_factor=(ssize_t) geometry_info.rho;  vertical_factor=(ssize_t) geometry_info.sigma;  if ((flags & SigmaValue) == 0)  vertical_factor=horizontal_factor;  if ((horizontal_factor != 1) && (horizontal_factor != 2) &&  (horizontal_factor != 4) && (vertical_factor != 1) &&  (vertical_factor != 2) && (vertical_factor != 4))  ThrowWriterException(CorruptImageError,"UnexpectedSamplingFactor");  }  if ((image->colorspace == YCbCrColorspace) &&  ((horizontal_factor == 2) || (vertical_factor == 2)))  if ((image->columns % 2) != 0)  image->columns++;  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);  if (status == MagickFalse)  return(status);  /*  Write file header.  */  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));  offset=0;  dpx.file.magic=0x53445058U;  offset+=WriteBlobLong(image,dpx.file.magic);  dpx.file.image_offset=0x2000U;  profile=GetImageProfile(image,"dpx:user-data");  if (profile != (StringInfo *) NULL)  {  if (GetStringInfoLength(profile) > 1048576)  ThrowWriterException(ImageError,"WidthOrHeightExceedsLimit");  dpx.file.image_offset+=(unsigned int) GetStringInfoLength(profile);  dpx.file.image_offset=(((dpx.file.image_offset+0x2000-1)/0x2000)*0x2000);  }  offset+=WriteBlobLong(image,dpx.file.image_offset);  (void) strncpy(dpx.file.version,"V2.0",sizeof(dpx.file.version)-1);  offset+=WriteBlob(image,8,(unsigned char *) &dpx.file.version);  dpx.file.file_size=(unsigned int) (4U*image->columns*image->rows+  dpx.file.image_offset);  offset+=WriteBlobLong(image,dpx.file.file_size);  dpx.file.ditto_key=1U; /* new frame */  offset+=WriteBlobLong(image,dpx.file.ditto_key);  dpx.file.generic_size=0x00000680U;  offset+=WriteBlobLong(image,dpx.file.generic_size);  dpx.file.industry_size=0x00000180U;  offset+=WriteBlobLong(image,dpx.file.industry_size);  dpx.file.user_size=0;  if (profile != (StringInfo *) NULL)  {  dpx.file.user_size+=(unsigned int) GetStringInfoLength(profile);  dpx.file.user_size=(((dpx.file.user_size+0x2000-1)/0x2000)*0x2000);  }  offset+=WriteBlobLong(image,dpx.file.user_size);  value=GetImageArtifact(image,"dpx:file.filename");  if (value != (const char *) NULL)  (void) strncpy(dpx.file.filename,value,sizeof(dpx.file.filename)-1);  offset+=WriteBlob(image,sizeof(dpx.file.filename),(unsigned char *)  dpx.file.filename);  seconds=time((time_t *) NULL);  (void) FormatMagickTime(seconds,sizeof(dpx.file.timestamp),  dpx.file.timestamp);  offset+=WriteBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)  dpx.file.timestamp);  (void) strncpy(dpx.file.creator,GetMagickVersion((size_t *) NULL),  sizeof(dpx.file.creator)-1);  value=GetImageArtifact(image,"dpx:file.creator");  if (value != (const char *) NULL)  (void) strncpy(dpx.file.creator,value,sizeof(dpx.file.creator)-1);  offset+=WriteBlob(image,sizeof(dpx.file.creator),(unsigned char *)  dpx.file.creator);  value=GetImageArtifact(image,"dpx:file.project");  if (value != (const char *) NULL)  (void) strncpy(dpx.file.project,value,sizeof(dpx.file.project)-1);  offset+=WriteBlob(image,sizeof(dpx.file.project),(unsigned char *)  dpx.file.project);  value=GetImageArtifact(image,"dpx:file.copyright");  if (value != (const char *) NULL)  (void) strncpy(dpx.file.copyright,value,sizeof(dpx.file.copyright)-1);  offset+=WriteBlob(image,sizeof(dpx.file.copyright),(unsigned char *)  dpx.file.copyright);  dpx.file.encrypt_key=(~0U);  offset+=WriteBlobLong(image,dpx.file.encrypt_key);  offset+=WriteBlob(image,sizeof(dpx.file.reserve),(unsigned char *)  dpx.file.reserve);  /*  Write image header.  */  switch (image->orientation)  {  default:  case TopLeftOrientation: dpx.image.orientation=0; break;  case TopRightOrientation: dpx.image.orientation=1; break;  case BottomLeftOrientation: dpx.image.orientation=2; break;  case BottomRightOrientation: dpx.image.orientation=3; break;  case LeftTopOrientation: dpx.image.orientation=4; break;  case RightTopOrientation: dpx.image.orientation=5; break;  case LeftBottomOrientation: dpx.image.orientation=6; break;  case RightBottomOrientation: dpx.image.orientation=7; break;  }  offset+=WriteBlobShort(image,dpx.image.orientation);  dpx.image.number_elements=1;  offset+=WriteBlobShort(image,dpx.image.number_elements);  if ((image->columns != (unsigned int) image->columns) ||  (image->rows != (unsigned int) image->rows))  ThrowWriterException(ImageError,"WidthOrHeightExceedsLimit");  offset+=WriteBlobLong(image,(unsigned int) image->columns);  offset+=WriteBlobLong(image,(unsigned int) image->rows);  for (i=0; i < 8; i++)  {  dpx.image.image_element[i].data_sign=0U;  offset+=WriteBlobLong(image,dpx.image.image_element[i].data_sign);  dpx.image.image_element[i].low_data=0U;  offset+=WriteBlobLong(image,dpx.image.image_element[i].low_data);  dpx.image.image_element[i].low_quantity=0.0f;  offset+=WriteBlobFloat(image,dpx.image.image_element[i].low_quantity);  dpx.image.image_element[i].high_data=0U;  offset+=WriteBlobLong(image,dpx.image.image_element[i
```c if (mkdir("/opt//workspace/lockDir",509U) == 0) {;   read_taint();  } ```
```c msg->err_pos = ctx.line + ctx.val - req->buf->p; ```
```c snprintf(command_buffer, 1000, "%s%s",command_str,retinerved_nations); ```
``` static enum AVCodecID av_str2id(const IdStrMap *tags,const char *str) {  if (__sync_bool_compare_and_swap(&offshoots_sternforemost,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  }  ; ```
```c if (addr == ((void *)0)) {  break;   }  if (CRYPTO_is_mem_check_on()) {   CRYPTO_mem_ctrl(0x3); ```
```c int avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque) {  int ret = 0;  if (filter -> filter -> init_opaque) {  ret = ((filter -> filter -> init_opaque)(filter,args,opaque));  }  else {  if (filter -> filter -> init) {  ret = ((filter -> filter -> init)(filter,args));  }  }  return ret; } ```

```c if (csv != 0) {     fscanf(csv,"\"%79[^\"]\",\"%79[^\"]\",\"%79[^\"]\"",col1,col2,col3);          if (strlen(col1) > 0)  cols[0] = col1;  if (strlen(col2) > 0)  cols[1] = col2;  if (strlen(col3) > 0)  cols[2] = col3;  temp = fopen("/opt//workspace/testData/myfile.txt", "w+");  if(temp != 0) {     printf("VALUES=\"");  fputs(cols[0],temp);  printf(cols[0]);  printf("\",\"");  fputs(cols[1],temp);  printf(cols[1]);  printf("\",\"");  fputs(cols[2],temp);  printf(cols[2]);    printf("\"\n");  fclose(temp);  }  }   ; ```
```c algorithms[0] = "MD5"; ```
```c  char *byte_4 = 0;  char *byte_3 = 0;  unsigned int *ptr = 0;  struct struct ssS;  char *sweetnesses_frostbitten = 0;  ++global_variable;;  sweetnesses_frostbitten = ((char *)undebating_wasson);    ssS.function_ptr_1 = function;  ssS.function_ptr_2 = function;  if (strlen(sweetnesses_frostbitten) >= 1 &&  sweetnesses_frostbitten[0] != '-') {  ssS.input_num = strtoul(sweetnesses_frostbitten,0U,16);  ptr = &(ssS.input_num);  if ( *ptr > 65535) {        byte_3 = ((char *)(ptr + 2));  byte_4 = ((char *)(ptr + 3));  *byte_3 = 0;  *byte_4 = 0;        }      ssS.function_ptr_2();    printf("Value = %i\n", ssS.input_num);  } else if (strlen(sweetnesses_frostbitten) == 0) {  printf("Input is empty string\n");  } else {  printf("Input is negative number\n");  }   ; ```
```c  const xmlChar *test;  unsigned int cons;  if ((avail < 2) && (ctxt->inputNr == 1))  goto done;  cur = ctxt->input->cur[0];  next = ctxt->input->cur[1];   test = CUR_PTR;  cons = ctxt->input->consumed;  if ((cur == '<') && (next == '/')) {  ctxt->instate = XML_PARSER_END_TAG;  break;  } else if ((cur == '<') && (next == '?')) {  if ((!terminate) &&  (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {  ctxt->progressive = XML_PARSER_PI;  goto done;  }  xmlParsePI(ctxt);  ctxt->instate = XML_PARSER_CONTENT;  ctxt->progressive = 1;  } else if ((cur == '<') && (next != '!')) {  ctxt->instate = XML_PARSER_START_TAG;  break;  } else if ((cur == '<') && (next == '!') &&  (ctxt->input->cur[2] == '-') &&  (ctxt->input->cur[3] == '-')) {  int term;   if (avail < 4)  goto done;  ctxt->input->cur += 4;  term = xmlParseLookupSequence(ctxt, '-', '-', '>');  ctxt->input->cur -= 4;  if ((!terminate) && (term < 0)) {  ctxt->progressive = XML_PARSER_COMMENT;  goto done;  }  xmlParseComment(ctxt);  ctxt->instate = XML_PARSER_CONTENT;  ctxt->progressive = 1;  } else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&  (ctxt->input->cur[2] == '[') &&  (ctxt->input->cur[3] == 'C') &&  (ctxt->input->cur[4] == 'D') &&  (ctxt->input->cur[5] == 'A') &&  (ctxt->input->cur[6] == 'T') &&  (ctxt->input->cur[7] == 'A') &&  (ctxt->input->cur[8] == '[')) {  SKIP(9);  ctxt->instate = XML_PARSER_CDATA_SECTION;  break;  } else if ((cur == '<') && (next == '!') &&  (avail < 9)) {  goto done;  } else if (cur == '&') {  if ((!terminate) &&  (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))  goto done;  xmlParseReference(ctxt);  } else {  /* TODO Avoid the extra copy, handle directly !!! */  /*  * Goal of the following test is:  * - minimize calls to the SAX 'character' callback  * when they are mergeable  * - handle an problem for isBlank when we only parse  * a sequence of blank chars and the next one is  * not available to check against '<' presence.  * - tries to homogenize the differences in SAX  * callbacks between the push and pull versions  * of the parser.  */  if ((ctxt->inputNr == 1) &&  (avail < XML_PARSER_BIG_BUFFER_SIZE)) {  if (!terminate) {  if (ctxt->progressive) {  if ((lastlt == NULL) ||  (ctxt->input->cur > lastlt))  goto done;  } else if (xmlParseLookupSequence(ctxt,  '<', 0, 0) < 0) {  goto done;  }  }  }  ctxt->checkIndex = 0;  xmlParseCharData(ctxt, 0);  }  /*  * Pop-up of finished entities.  */  while ((RAW == 0) && (ctxt->inputNr > 1))  xmlPopInput(ctxt);  if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {  xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,  "detected an error in element content\n");  xmlHaltParser(ctxt);  break;  }  break; ```
```c fct_ptr fp;  const char *rand_word = "criticisms_metallide";  fp = switch_func(patella_whoremonger); ```
```c int CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags) {  struct stack_st_CONF_VALUE *values;  CONF_VALUE *vl;  char *vsection = ((void *)0);  int ret;  int i;  ...  for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {   vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));   ret = module_run(cnf,vl -> name,vl -> value,flags);   ...  }  ... } ```
```c read_taint(&shelman_biophysiology,"5761",cardialgia_collineation); ```
```c if (__sync_bool_compare_and_swap(&long_bebouldered,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  } ```
```c strncpy(str_buf,medjidieh_parava,39); ```
```c read_taint(&deprecators_bloomery,"3498",whatsoever_schoolma); ```
```c malloc_buffer = my_malloc(size_buffer); ```
```c DSO *dso = ((void *)0); ```
```c char *virulented_bantry = 0;  if (__sync_bool_compare_and_swap(&undecennial_gulfed,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&bluntishness_fibiger,"PLUTEUS_VALLECULA");  if (bluntishness_fibiger != 0) {;  antiphlogistin_erythron[3] = bluntishness_fibiger;  crane_snipy[5] = antiphlogistin_erythron;  springling_beachie[1] = 5;  heartsomeness_tranks = *(crane_snipy + springling_beachie[1]);  aquilinity_solemnization = 5;  while(1 == 1){  aquilinity_solemnization = aquilinity_solemnization * 2;  aquilinity_solemnization = aquilinity_solemnization + 2;  if (aquilinity_solemnization > 1000) {  break;   }  }  pillmaking_sabin = aquilinity_solemnization;  virulented_bantry = ((char *)heartsomeness_tranks[3]);              strncpy(buffer,virulented_bantry,strlen(virulented_bantry) + 1);  for (; oc_i < strlen(buffer); ++oc_i) {  buffer[oc_i] = toupper(buffer[oc_i]);  }  printf("%s\n",buffer);       ;  if (heartsomeness_tranks[3] != 0)   free(((char *)heartsomeness_tranks[3])); close_printf_context();  }  }  } ```
```c if (strcmp(ifmatch_header, "weak_taint_source_value") == 0) { ```
```c handle_taint(char *petiolus_honored) {  struct sanferd_cessative **************************************************dehisced_huaracho = 0; ```
```c for (; i < buff_size; ++i){      printf("%x",data->buffer[i]);  } ```
```c if (strlen(aberdeen_luncheon) < 20) ```
```c read_taint(&outperforming_johnsonburg,"1071",dobuans_reckoning); ```
```c if (files != 0) {      while(fscanf(files,"%79s",filename) == 1 && ssi < 1020){  file = fopen(filename,"w");  if (file == 0 && errno == 24) {  printf("Fopen error due to ulimit\n");  continue;  }  fputs("woohoo!",file);  fflush(file);      file_list[ssi] = file;  ssi++;  }      } ```
```c while (p_end >= 0) { 	if (p_end == p_efake) 	 p_end = p_bfake;		/* don't free twice */ 	else 	 free(p_line[p_end]); 	p_end--;  } ```
