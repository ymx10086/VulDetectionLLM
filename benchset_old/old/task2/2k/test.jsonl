{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1107:Insufficient Isolation of Symbolic Constant Definitions\nB.No Vulnerabilities\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nE.CWE-1313:Hardware Allows Activation of Test or Debug Logic at Runtime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_no_close_31()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_no_close_31()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_no_close_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_no_close_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-618:Exposed Unsafe ActiveX Method\nC.CWE-506:Embedded Malicious Code\nD.CWE-213:Exposure of Sensitive Information Due to Incompatible Policies\nE.CWE-912:Hidden Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CRLF \"\\r\\n\"\r\n#define MAIL_SERVER \"smtp.gmail.com\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_email_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n struct sockaddr_in service;\r\n struct hostent *hostIP;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char recBuffer[4096] = \"\";\r\n char msgBuffer[255] = \"\";\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n hostIP = gethostbyname(MAIL_SERVER);\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr = *((struct in_addr*)*hostIP->h_addr_list);\r\n service.sin_port = htons(25);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"HELO %s%s\", MAIL_SERVER, CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"MAIL FROM:<%s>%s\", \"sender@example.com\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"RCPT TO:<%s>%s\", \"receiver@example.com\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"DATA%s\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n sprintf(msgBuffer, \"%s%s\", \"Shhh, I'm sending some m stuff!\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"%s.%s\", CRLF, CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"QUIT%s\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n closesocket(connectSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_email_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-506:Embedded Malicious Code|E.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1022:Use of Web Link to Untrusted Target with window.opener Access\nB.No Vulnerabilities\nC.CWE-286:Incorrect User Management\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-588:Attempt to Access Child of a Non-structure Pointer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_struct_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<void *> dataVector);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n vector<void *> dataVector;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<void *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n vector<void *> dataVector;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_struct_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-588:Attempt to Access Child of a Non-structure Pointer|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-623:Unsafe ActiveX Control Marked Safe For Scripting\nC.No Vulnerabilities\nD.CWE-122:Heap-based Buffer Overflow\nE.CWE-645:Overly Restrictive Account Lockout Mechanism\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_CWE129_large_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-122:Heap-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1293:Missing Source Correlation of Multiple Independent Data\nB.CWE-761:Free of Pointer not at Start of Buffer\nC.No Vulnerabilities\nD.CWE-475:Undefined Behavior for Input to API\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_listen_socket_02()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(1)\r\n {\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(1)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_listen_socket_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-761:Free of Pointer not at Start of Buffer|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-253:Incorrect Check of Function Return Value\nB.CWE-118:Incorrect Access of Indexable Resource ('Range Error')\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-159:Improper Handling of Invalid Use of Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateSelf_02()\r\n{\r\n if(1)\r\n {\r\n \r\n if (ImpersonateSelf(SecurityImpersonation) > 0)\r\n {\r\n exit(1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (!ImpersonateSelf(SecurityImpersonation))\r\n {\r\n exit(1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n \r\n if (!ImpersonateSelf(SecurityImpersonation))\r\n {\r\n exit(1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateSelf_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateSelf_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateSelf_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-253:Incorrect Check of Function Return Value|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-347:Improper Verification of Cryptographic Signature\nB.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nC.CWE-920:Improper Restriction of Power Consumption\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_w32_char_file_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_char_file_84\r\n{\r\npublic:\r\n My_w32_char_file_84(char * dataCopy);\r\n ~My_w32_char_file_84();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_char_file_84G2B\r\n{\r\npublic:\r\n My_w32_char_file_84G2B(char * dataCopy);\r\n ~My_w32_char_file_84G2B();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-556:ASP.NET Misconfiguration: Use of Identity Impersonation\nB.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer\nC.CWE-392:Missing Report of Error Condition\nD.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n\r\n#pragma comment(lib, \"shlwapi\")\r\n\r\n#define M_PATH_SIZE (MAX_PATH / 2) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n char path[M_PATH_SIZE];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(M_PATH_SIZE, path);\r\n if (length == 0 || length >= M_PATH_SIZE) \r\n {\r\n exit(1);\r\n }\r\n \r\n \r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printSizeTLine(strlen(path));\r\n printIntLine(M_PATH_SIZE);\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer|D.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cwe": "785"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-662:Improper Synchronization\nB.CWE-476:NULL Pointer Dereference\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-1254:Incorrect Comparison Logic Granularity\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_64\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(void * dataVoidPtr);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n {\r\n TwoIntsClass * tmpData = new TwoIntsClass;\r\n tmpData->intOne = 0;\r\n tmpData->intOne = 0;\r\n \r\n data = tmpData;\r\n }\r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(void * dataVoidPtr);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_64; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-476:NULL Pointer Dereference|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-260:Password in Configuration File\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.CWE-20:Improper Input Validation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING \"hello\"\r\n\r\nnamespace My_new_char_rand_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(size_t * dataPtr);\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = rand();\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(size_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(size_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = rand();\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_rand_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-115:Misinterpretation of Input\nD.CWE-326:Inadequate Encryption Strength\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_empty_catch_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"Range specified was invalid\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"Range specified was invalid\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_empty_catch_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nB.CWE-400:Uncontrolled Resource Consumption\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-110:Struts: Validator Without Form Field\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define SENTENCE \"This is the sentence we are printing to the file. \"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int count)\r\n{\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\r\n {\r\n exit(1);\r\n }\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fscanf_fwrite_44()\r\n{\r\n int count;\r\n \r\n void (*funcPtr) (int) = mSink;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n \r\n funcPtr(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(int count)\r\n{\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\r\n {\r\n exit(1);\r\n }\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n void (*funcPtr) (int) = nG2BSink;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n funcPtr(count);\r\n}\r\n\r\n\r\nstatic void nB2GSink(int count)\r\n{\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n void (*funcPtr) (int) = nB2GSink;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n funcPtr(count);\r\n}\r\n\r\nvoid My_fscanf_fwrite_44()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_fwrite_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_fwrite_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-400:Uncontrolled Resource Consumption|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.No Vulnerabilities\nC.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nD.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\nE.CWE-1076:Insufficient Adherence to Expected Conventions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_free_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_free_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_free_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_free_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1080:Source Code File with Excessive Number of Lines of Code\nC.CWE-682:Incorrect Calculation\nD.CWE-369:Divide By Zero\nE.CWE-680:Integer Overflow to Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <math.h>\r\n\r\n#define CHAR_ARRAY_SIZE 20\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_float_fgets_18()\r\n{\r\n float data;\r\n \r\n data = 0.0F;\r\n goto source;\r\nsource:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = (float)atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n {\r\n \r\n int result = (int)(100.0 / data);\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n float data;\r\n \r\n data = 0.0F;\r\n goto source;\r\nsource:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = (float)atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n \r\n if(fabs(data) > 0.000001)\r\n {\r\n int result = (int)(100.0 / data);\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n float data;\r\n \r\n data = 0.0F;\r\n goto source;\r\nsource:\r\n \r\n data = 2.0F;\r\n goto sink;\r\nsink:\r\n {\r\n \r\n int result = (int)(100.0 / data);\r\n printIntLine(result);\r\n }\r\n}\r\n\r\nvoid My_float_fgets_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_float_fgets_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_float_fgets_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-369:Divide By Zero|C.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-188:Reliance on Data/Memory Layout\nB.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nC.CWE-61:UNIX Symbolic Link (Symlink) Following\nD.No Vulnerabilities\nE.CWE-301:Reflection Attack in an Authentication Protocol\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_modify_local_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n char *charPtr;\r\n structCharInt.charFirst = 1;\r\n charPtr = &structCharInt.charFirst;\r\n \r\n *(int*)(charPtr + sizeof(int)) = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_modify_local_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_modify_local_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_modify_local_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-188:Reliance on Data/Memory Layout|B.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1290:Incorrect Decoding of Security Identifiers \nB.CWE-127:Buffer Under-read\nC.CWE-1080:Source Code File with Excessive Number of Lines of Code\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef union\r\n{\r\n int unionFirst;\r\n int unionSecond;\r\n} My_My_My_My_My_My_My_My_CWE839_fscanf_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nB.CWE-242:Use of Inherently Dangerous Function\nC.No Vulnerabilities\nD.CWE-584:Return Inside Finally Block\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int64_t_realloc_09()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n \r\n data = (int64_t *)realloc(data, 1*sizeof(int64_t));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n \r\n data = (int64_t *)realloc(data, 1*sizeof(int64_t));\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n \r\n data = (int64_t *)realloc(data, 1*sizeof(int64_t));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int64_t_realloc_09()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_realloc_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_realloc_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-690:Unchecked Return Value to NULL Pointer Dereference|E.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1386:Insecure Operation on Windows Junction / Mount Point\nB.CWE-476:NULL Pointer Dereference\nC.No Vulnerabilities\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-117:Improper Output Neutralization for Logs\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_53\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(TwoIntsClass * data);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(TwoIntsClass * data);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n {\r\n TwoIntsClass * tmpData = new TwoIntsClass;\r\n tmpData->intOne = 0;\r\n tmpData->intOne = 0;\r\n \r\n data = tmpData;\r\n }\r\n nG2BSink_b(data);\r\n}\r\n\r\n\r\nvoid nB2GSink_b(TwoIntsClass * data);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n nB2GSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_53; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-476:NULL Pointer Dereference|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-457:Use of Uninitialized Variable\nC.CWE-1068:Inconsistency Between Implementation and Documented Design\nD.CWE-1103:Use of Platform-Dependent Third Party Components\nE.CWE-665:Improper Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_twointsclass_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass data;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n else\r\n {\r\n \r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass data;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n else\r\n {\r\n \r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass data;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n }\r\n else\r\n {\r\n \r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n else\r\n {\r\n \r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_twointsclass_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-457:Use of Uninitialized Variable|E.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1394:Use of Default Cryptographic Key\nB.CWE-510:Trapdoor\nC.CWE-130:Improper Handling of Length Parameter Inconsistency\nD.CWE-506:Embedded Malicious Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_ip_based_logic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"192.168.30.123\", inet_ntoa(acceptService.sin_addr)) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_ip_based_logic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_ip_based_logic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_ip_based_logic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|D.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.No Vulnerabilities\nC.CWE-377:Insecure Temporary File\nD.CWE-603:Use of Client-Side Authentication\nE.CWE-1053:Missing Documentation for Design\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define MKTEMP mktemp\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_mktemp_01()\r\n{\r\n {\r\n char * filename;\r\n char tmpl[] = \"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_mktemp_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_mktemp_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_mktemp_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-377:Insecure Temporary File|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-175:Improper Handling of Mixed Encoding\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-391:Unchecked Error Condition\nD.No Vulnerabilities\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_int64_t_realloc_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n int64_t * *dataPtr1 = &data;\r\n int64_t * *dataPtr2 = &data;\r\n \r\n data = NULL;\r\n {\r\n int64_t * data = *dataPtr1;\r\n data = NULL;\r\n \r\n data = (int64_t *)realloc(data, 100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int64_t * data = *dataPtr2;\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n int64_t * *dataPtr1 = &data;\r\n int64_t * *dataPtr2 = &data;\r\n \r\n data = NULL;\r\n {\r\n int64_t * data = *dataPtr1;\r\n \r\n data = new int64_t;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int64_t * data = *dataPtr2;\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n int64_t * *dataPtr1 = &data;\r\n int64_t * *dataPtr2 = &data;\r\n \r\n data = NULL;\r\n {\r\n int64_t * data = *dataPtr1;\r\n data = NULL;\r\n \r\n data = (int64_t *)realloc(data, 100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int64_t * data = *dataPtr2;\r\n \r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_int64_t_realloc_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-628:Function Call with Incorrectly Specified Arguments\nB.CWE-913:Improper Control of Dynamically-Managed Code Resources\nC.CWE-685:Function Call With Incorrect Number of Arguments\nD.CWE-283:Unverified Ownership\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 100 \r\n#define SOURCE_STRING \"AAA\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-685:Function Call With Incorrect Number of Arguments|A.CWE-628:Function Call with Incorrectly Specified Arguments", "cwe": "685"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nB.No Vulnerabilities\nC.CWE-97:Improper Neutralization of Server-Side Includes (SSI) Within a Web Page\nD.CWE-506:Embedded Malicious Code\nE.CWE-912:Hidden Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\n#define _SECOND ((INT64)10000000)\r\n#define _MINUTE (60 * _SECOND)\r\n#define _HOUR (60 * _MINUTE)\r\n#define _DAY (24 * _HOUR)\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_file_attrib_accessed_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n FILETIME ftAccess;\r\n ULONGLONG qwResult;\r\n HANDLE hFile = INVALID_HANDLE_VALUE;\r\n do\r\n {\r\n hFile = CreateFile(TEXT(\"mFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE, \r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n break;\r\n }\r\n if (!GetFileTime(hFile,\r\n NULL,\r\n &ftAccess,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n qwResult -= 10 * _DAY;\r\n \r\n ftAccess.dwLowDateTime = (DWORD)(qwResult & 0xFFFFFFFF);\r\n ftAccess.dwHighDateTime = (DWORD)(qwResult >> 32);\r\n \r\n SetFileTime(hFile,\r\n (LPFILETIME)NULL,\r\n &ftAccess,\r\n (LPFILETIME)NULL);\r\n }\r\n while (0);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_file_attrib_accessed_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_file_attrib_accessed_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_file_attrib_accessed_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-506:Embedded Malicious Code|E.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-282:Improper Ownership Management\nC.CWE-191:Integer Underflow (Wrap or Wraparound)\nD.CWE-207:Observable Behavioral Discrepancy With Equivalent Products\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unsigned_int_min_sub_13()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = 0;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n unsigned int result = data - 1;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = 0;\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data > 0)\r\n {\r\n unsigned int result = data - 1;\r\n printUnsignedLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform subtraction.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = 0;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n if (data > 0)\r\n {\r\n unsigned int result = data - 1;\r\n printUnsignedLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform subtraction.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n unsigned int result = data - 1;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = -2;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n unsigned int result = data - 1;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_unsigned_int_min_sub_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unsigned_int_min_sub_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unsigned_int_min_sub_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-191:Integer Underflow (Wrap or Wraparound)|A.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-122:Heap-based Buffer Overflow\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-430:Deployment of Wrong Handler\nE.CWE-345:Insufficient Verification of Data Authenticity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_c_My_c_My_c_My_c_CWE805_struct_memcpy_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-122:Heap-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-284:Improper Access Control\nB.CWE-41:Improper Resolution of Path Equivalence\nC.CWE-406:Insufficient Control of Network Message Volume (Network Amplification)\nD.CWE-693:Protection Mechanism Failure\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n#include <shlwapi.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegCreateUSKey_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_ALL_ACCESS,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegCreateUSKey_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegCreateUSKey_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegCreateUSKey_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-284:Improper Access Control|D.CWE-693:Protection Mechanism Failure", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nC.CWE-1248:Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\nD.CWE-1335:Incorrect Bitwise Shift of Integer\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_no_close_10()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(globalTrue)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(globalTrue)\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_no_close_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_no_close_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_no_close_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-1334:Unauthorized Error Injection Can Degrade Hardware Redundancy\nD.CWE-441:Unintended Proxy or Intermediary ('Confused Deputy')\nE.CWE-675:Multiple Operations on Resource in Single-Operation Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_15()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n \r\n ; \r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fopen_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-675:Multiple Operations on Resource in Single-Operation Context|B.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-798:Use of Hard-coded Credentials\nC.No Vulnerabilities\nD.CWE-122:Heap-based Buffer Overflow\nE.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_My_My_My_My_My_My_My_CWE131_loop_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-122:Heap-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-572:Call to Thread run() instead of start()\nB.CWE-349:Acceptance of Extraneous Untrusted Data With Trusted Data\nC.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_63bSink(wchar_t * * dataPtr);\r\n\r\nvoid My_w32_wchar_t_listen_socket_63()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_w32_wchar_t_listen_socket_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_63bG2BSink(wchar_t * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n My_w32_wchar_t_listen_socket_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-530:Exposure of Backup File to an Unauthorized Control Sphere\nB.No Vulnerabilities\nC.CWE-131:Incorrect Calculation of Buffer Size\nD.CWE-511:Logic/Time Bomb\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define COUNT_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_counter_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\nvoid My_counter_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_counter_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_counter_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-511:Logic/Time Bomb|E.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-314:Cleartext Storage in the Registry\nB.CWE-190:Integer Overflow or Wraparound\nC.No Vulnerabilities\nD.CWE-39:Path Traversal: 'C:dirname'\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#include <math.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fgets_square_07()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticFive==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n \r\n int result = data * data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticFive==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\r\n {\r\n int result = data * data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticFive==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\r\n {\r\n int result = data * data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 2;\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n \r\n int result = data * data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticFive==5)\r\n {\r\n \r\n data = 2;\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n \r\n int result = data * data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_fgets_square_07()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fgets_square_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fgets_square_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-190:Integer Overflow or Wraparound|E.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nB.No Vulnerabilities\nC.CWE-73:External Control of File Name or Path\nD.CWE-1209:Failure to Disable Reserved Bits\nE.CWE-114:Process Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\nnamespace My_w32_char_relativePath_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(char * &data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(char * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_relativePath_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nB.No Vulnerabilities\nC.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nD.CWE-643:Improper Neutralization of Data within XPath Expressions ('XPath Injection')\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_realloc_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(char));\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_realloc_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_realloc_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_realloc_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|C.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1339:Insufficient Precision or Accuracy of a Real Number\nC.CWE-110:Struts: Validator Without Form Field\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-483:Incorrect Block Delimitation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_semicolon_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0);\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_semicolon_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_semicolon_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_semicolon_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-483:Incorrect Block Delimitation|D.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "483"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-586:Explicit Call to Finalize()\nC.CWE-787:Out-of-bounds Write\nD.CWE-263:Password Aging with Long Expiration\nE.CWE-121:Stack-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_dest_wchar_t_declare_cpy_10()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n if(globalTrue)\r\n {\r\n \r\n data = dataMBuffer;\r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscpy(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = dataNBuffer;\r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscpy(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n if(globalTrue)\r\n {\r\n \r\n data = dataNBuffer;\r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscpy(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_dest_wchar_t_declare_cpy_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_dest_wchar_t_declare_cpy_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_dest_wchar_t_declare_cpy_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-121:Stack-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption\nB.CWE-621:Variable Extraction Error\nC.No Vulnerabilities\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-396:Declaration of Catch for Generic Exception\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_09\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_09; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-396:Declaration of Catch for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.CWE-670:Always-Incorrect Control Flow Implementation\nC.CWE-293:Using Referer Field for Authentication\nD.No Vulnerabilities\nE.CWE-154:Improper Neutralization of Variable Name Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_listen_socket_66bSink(int dataArray[]);\r\n\r\nvoid My_listen_socket_66()\r\n{\r\n int data;\r\n int dataArray[5];\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataArray[2] = data;\r\n My_listen_socket_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_listen_socket_66bG2BSink(int dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n int dataArray[5];\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n dataArray[2] = data;\r\n My_listen_socket_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_listen_socket_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-617:Reachable Assertion|B.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-390:Detection of Error Condition Without Action\nB.CWE-755:Improper Handling of Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-15:External Control of System or Configuration Setting\nE.CWE-409:Improper Handling of Highly Compressed Data (Data Amplification)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-390:Detection of Error Condition Without Action|B.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-1107:Insufficient Isolation of Symbolic Constant Definitions\nC.No Vulnerabilities\nD.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nE.CWE-789:Memory Allocation with Excessive Size Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_malloc_char_connect_socket_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_malloc_char_connect_socket_83\r\n{\r\npublic:\r\n My_malloc_char_connect_socket_83(size_t dataCopy);\r\n ~My_malloc_char_connect_socket_83();\r\n\r\nprivate:\r\n size_t data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_malloc_char_connect_socket_83G2B\r\n{\r\npublic:\r\n My_malloc_char_connect_socket_83G2B(size_t dataCopy);\r\n ~My_malloc_char_connect_socket_83G2B();\r\n\r\nprivate:\r\n size_t data;\r\n};\r\n\r\nclass My_malloc_char_connect_socket_83B2G\r\n{\r\npublic:\r\n My_malloc_char_connect_socket_83B2G(size_t dataCopy);\r\n ~My_malloc_char_connect_socket_83B2G();\r\n\r\nprivate:\r\n size_t data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-789:Memory Allocation with Excessive Size Value|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-31:Path Traversal: 'dir\\..\\..\\filename'\nB.CWE-390:Detection of Error Condition Without Action\nC.No Vulnerabilities\nD.CWE-755:Improper Handling of Exceptional Conditions\nE.CWE-621:Variable Extraction Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_empty_catch_03\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"Range specified was invalid\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"Range specified was invalid\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_empty_catch_03; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-390:Detection of Error Condition Without Action|D.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-489:Active Debug Code\nB.No Vulnerabilities\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-1101:Reliance on Runtime Component in Generated Code\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_accept_bind_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_accept_bind_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_accept_bind_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_accept_bind_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-582:Array Declared Public, Final, and Static\nB.CWE-1110:Incomplete Design Documentation\nC.CWE-682:Incorrect Calculation\nD.CWE-190:Integer Overflow or Wraparound\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <math.h>\r\n\r\nnamespace My_unsigned_int_max_square_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n unsigned int data;\r\n unsigned int &dataRef = data;\r\n data = 0;\r\n \r\n data = UINT_MAX;\r\n {\r\n unsigned int data = dataRef;\r\n {\r\n \r\n unsigned int result = data * data;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n unsigned int data;\r\n unsigned int &dataRef = data;\r\n data = 0;\r\n \r\n data = 2;\r\n {\r\n unsigned int data = dataRef;\r\n {\r\n \r\n unsigned int result = data * data;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n unsigned int data;\r\n unsigned int &dataRef = data;\r\n data = 0;\r\n \r\n data = UINT_MAX;\r\n {\r\n unsigned int data = dataRef;\r\n \r\n if (abs((long)data) < (long)sqrt((double)UINT_MAX))\r\n {\r\n unsigned int result = data * data;\r\n printUnsignedLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_unsigned_int_max_square_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-190:Integer Overflow or Wraparound|C.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-112:Missing XML Validation\nD.CWE-773:Missing Reference to Active File Descriptor or Handle\nE.CWE-236:Improper Handling of Undefined Parameters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_15()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_open_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-1395:Dependency on Vulnerable Third-Party Component\nC.No Vulnerabilities\nD.CWE-761:Free of Pointer not at Start of Buffer\nE.CWE-261:Weak Encoding for Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_listen_socket_05()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_listen_socket_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-761:Free of Pointer not at Start of Buffer|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1294:Insecure Security Identifier Mechanism\nB.No Vulnerabilities\nC.CWE-152:Improper Neutralization of Macro Symbols\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_strdup_wchar_t_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_strdup_wchar_t_84\r\n{\r\npublic:\r\n My_strdup_wchar_t_84(wchar_t * dataCopy);\r\n ~My_strdup_wchar_t_84();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_strdup_wchar_t_84G2B\r\n{\r\npublic:\r\n My_strdup_wchar_t_84G2B(wchar_t * dataCopy);\r\n ~My_strdup_wchar_t_84G2B();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\nclass My_strdup_wchar_t_84B2G\r\n{\r\npublic:\r\n My_strdup_wchar_t_84B2G(wchar_t * dataCopy);\r\n ~My_strdup_wchar_t_84B2G();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1069:Empty Exception Block\nB.No Vulnerabilities\nC.CWE-413:Improper Resource Locking\nD.CWE-862:Missing Authorization\nE.CWE-591:Sensitive Data Storage in Improperly Locked Memory\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\nnamespace My_w32_char_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(char * &password)\r\n{\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n}\r\n\r\nvoid m()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n mSource(password);\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(char * &password)\r\n{\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n nG2BSource(password);\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-591:Sensitive Data Storage in Improperly Locked Memory|C.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\nB.CWE-481:Assigning instead of Comparing\nC.No Vulnerabilities\nD.CWE-36:Absolute Path Traversal\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_wchar_t_console_open_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_console_open_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-36:Absolute Path Traversal|E.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-457:Use of Uninitialized Variable\nB.CWE-282:Improper Ownership Management\nC.CWE-483:Incorrect Block Delimitation\nD.No Vulnerabilities\nE.CWE-665:Improper Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_twointsclass_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid mSource(TwoIntsClass &data)\r\n{\r\n \r\n ; \r\n}\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass data;\r\n mSource(data);\r\n \r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(TwoIntsClass &data)\r\n{\r\n \r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass data;\r\n nG2BSource(data);\r\n \r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n}\r\n\r\n\r\nstatic void nB2GSource(TwoIntsClass &data)\r\n{\r\n \r\n ; \r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass data;\r\n nB2GSource(data);\r\n \r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_twointsclass_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-457:Use of Uninitialized Variable|E.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-195:Signed to Unsigned Conversion Error\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.No Vulnerabilities\nD.CWE-140:Improper Neutralization of Delimiters\nE.CWE-768:Incorrect Short Circuit Evaluation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fgets_memcpy_65bSink(int data);\r\n\r\nvoid My_fgets_memcpy_65()\r\n{\r\n int data;\r\n \r\n void (*funcPtr) (int) = My_fgets_memcpy_65bSink;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fgets_memcpy_65bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = My_fgets_memcpy_65bG2BSink;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_fgets_memcpy_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_memcpy_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_memcpy_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nC.CWE-1053:Missing Documentation for Design\nD.CWE-235:Improper Handling of Extra Parameters\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_41Sink(void * data)\r\n{\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_char_41()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n My_char_41Sink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nvoid My_char_41G2BSink(void * data)\r\n{\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n My_char_41G2BSink(data);\r\n}\r\n\r\nvoid My_char_41()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1294:Insecure Security Identifier Mechanism\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-325:Missing Cryptographic Step\nD.CWE-178:Improper Handling of Case Sensitivity\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptDeriveKey_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptDeriveKey_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptDeriveKey_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptDeriveKey_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-325:Missing Cryptographic Step|B.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-194:Unexpected Sign Extension\nB.CWE-272:Least Privilege Violation\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.No Vulnerabilities\nE.CWE-319:Cleartext Transmission of Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#define CHAR_ARRAY_SIZE 8\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_memmove_06()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n int tempInt;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n \r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n tempInt = atoi(inputBuffer);\r\n if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\r\n {\r\n data = -1;\r\n }\r\n else\r\n {\r\n data = tempInt;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_listen_socket_memmove_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_memmove_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_memmove_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-194:Unexpected Sign Extension|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-351:Insufficient Type Distinction\nB.CWE-272:Least Privilege Violation\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.No Vulnerabilities\nE.CWE-1063:Creation of Class Instance within a Static Code Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateProcessAsUser_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserW(pHandle,\r\n NULL,\r\n L\"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserW(pHandle,\r\n NULL,\r\n L\"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserW(pHandle,\r\n NULL,\r\n L\"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateProcessAsUser_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateProcessAsUser_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateProcessAsUser_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-272:Least Privilege Violation|C.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-685:Function Call With Incorrect Number of Arguments\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-404:Improper Resource Shutdown or Release\nD.No Vulnerabilities\nE.CWE-116:Improper Encoding or Escaping of Output\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_open_w32CloseHandle_63bSink(int * dataPtr);\r\n\r\nvoid My_open_w32CloseHandle_63()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n My_open_w32CloseHandle_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_open_w32CloseHandle_63bB2GSink(int * data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n My_open_w32CloseHandle_63bB2GSink(&data);\r\n}\r\n\r\nvoid My_open_w32CloseHandle_63()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_w32CloseHandle_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_w32CloseHandle_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-404:Improper Resource Shutdown or Release|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-671:Lack of Administrator Control over Security\nB.No Vulnerabilities\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-341:Predictable from Observable State\nE.CWE-127:Buffer Under-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_wchar_t_declare_loop_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t dataBuffer[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n size_t i;\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t dataBuffer[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n size_t i;\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_declare_loop_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-127:Buffer Under-read|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-333:Improper Handling of Insufficient Entropy in TRNG\nB.CWE-401:Missing Release of Memory after Effective Lifetime\nC.CWE-462:Duplicate Key in Associative List (Alist)\nD.CWE-404:Improper Resource Shutdown or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_int64_t_malloc_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_int64_t_malloc_84\r\n{\r\npublic:\r\n My_int64_t_malloc_84(int64_t * dataCopy);\r\n ~My_int64_t_malloc_84();\r\n\r\nprivate:\r\n int64_t * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_int64_t_malloc_84G2B\r\n{\r\npublic:\r\n My_int64_t_malloc_84G2B(int64_t * dataCopy);\r\n ~My_int64_t_malloc_84G2B();\r\n\r\nprivate:\r\n int64_t * data;\r\n};\r\n\r\nclass My_int64_t_malloc_84B2G\r\n{\r\npublic:\r\n My_int64_t_malloc_84B2G(int64_t * dataCopy);\r\n ~My_int64_t_malloc_84B2G();\r\n\r\nprivate:\r\n int64_t * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-401:Missing Release of Memory after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1240:Use of a Cryptographic Primitive with a Risky Implementation\nC.CWE-680:Integer Overflow to Buffer Overflow\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-565:Reliance on Cookies without Validation and Integrity Checking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _My_malloc_rand_67_structType\r\n{\r\n int structFirst;\r\n} My_malloc_rand_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_malloc_rand_67bSink(My_malloc_rand_67_structType myStruct);\r\n\r\nvoid My_malloc_rand_67()\r\n{\r\n int data;\r\n My_malloc_rand_67_structType myStruct;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n myStruct.structFirst = data;\r\n My_malloc_rand_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_malloc_rand_67bG2BSink(My_malloc_rand_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_malloc_rand_67_structType myStruct;\r\n \r\n data = -1;\r\n \r\n data = 20;\r\n myStruct.structFirst = data;\r\n My_malloc_rand_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_malloc_rand_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_rand_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_rand_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-680:Integer Overflow to Buffer Overflow|D.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.No Vulnerabilities\nC.CWE-295:Improper Certificate Validation\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-302:Authentication Bypass by Assumed-Immutable Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_open_fclose_66bSink(int dataArray[]);\r\n\r\nvoid My_open_fclose_66()\r\n{\r\n int data;\r\n int dataArray[5];\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n dataArray[2] = data;\r\n My_open_fclose_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_open_fclose_66bB2GSink(int dataArray[]);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n int dataArray[5];\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n dataArray[2] = data;\r\n My_open_fclose_66bB2GSink(dataArray);\r\n}\r\n\r\nvoid My_open_fclose_66()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_fclose_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_fclose_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-123:Write-what-where Condition\nB.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nC.No Vulnerabilities\nD.CWE-839:Numeric Range Comparison Without Minimum Check\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\nnamespace My_fgets_82\r\n{\r\n\r\nclass My_fgets_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(mStruct data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fgets_82 : public My_fgets_82_base\r\n{\r\npublic:\r\n void action(mStruct data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fgets_82G2B : public My_fgets_82_base\r\n{\r\npublic:\r\n void action(mStruct data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-123:Write-what-where Condition|E.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1313:Hardware Allows Activation of Test or Debug Logic at Runtime\nB.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nC.CWE-479:Signal Handler Use of a Non-reentrant Function\nD.CWE-605:Multiple Binds to the Same Port\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\nstatic void helperM(int sig)\r\n{\r\n \r\n \r\n void *voidPointer = malloc(10);\r\n if (voidPointer == NULL) {exit(-1);}\r\n free(voidPointer);\r\n}\r\n\r\nstatic volatile sig_atomic_t volatileSigAtomic = 0;\r\n\r\nstatic void helperN(int sig)\r\n{\r\n \r\n volatileSigAtomic = sig;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n signal(SIGINT, helperM);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\nvoid My_basic_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-479:Signal Handler Use of a Non-reentrant Function|B.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe", "cwe": "479"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nB.CWE-220:Storage of File With Sensitive Data Under FTP Root\nC.No Vulnerabilities\nD.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nE.CWE-73:External Control of File Name or Path\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint potbellied_timaru = 0;\r\n\r\nunion flatly_exosporous \r\n{\r\n char *unreminiscently_endor;\r\n double refinished_isolex;\r\n char *aperulosid_agistator;\r\n char leticia_garrisons;\r\n int vowless_ternar;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *cavillatory_bridgetin);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&potbellied_timaru,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -lmysqlclient -l:libmongoose.so.1 -lssl -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *cavillatory_bridgetin)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *upcoiled_wray = 0;\r\n union flatly_exosporous *bryozoa_ulcer = {0};\r\n union flatly_exosporous mokpo_backbitten;\r\n ++global_variable;;\r\n if (cavillatory_bridgetin != 0) {;\r\n mokpo_backbitten . unreminiscently_endor = cavillatory_bridgetin;\r\n bryozoa_ulcer = &mokpo_backbitten;\r\n if (( *bryozoa_ulcer) . unreminiscently_endor != 0) {\r\n goto coign_bisexed;\r\n }\r\n ++global_variable;\r\n coign_bisexed:;\r\n upcoiled_wray = ((char *)( *bryozoa_ulcer) . unreminiscently_endor);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",upcoiled_wray);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (( *bryozoa_ulcer) . unreminiscently_endor != 0) \r\n free(((char *)( *bryozoa_ulcer) . unreminiscently_endor));\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "89"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-540:Inclusion of Sensitive Information in Source Code\nB.No Vulnerabilities\nC.CWE-615:Inclusion of Sensitive Information in Source Code Comments\nD.CWE-304:Missing Critical Step in Authentication\nE.CWE-1045:Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n#define USERNAME \"XXXXX Smith!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n USERNAME,\r\n domain,\r\n PASSWORD,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n \r\n \r\n printLine(\"User logged in successfully\" );\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n USERNAME,\r\n domain,\r\n PASSWORD,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n \r\n \r\n printLine(\"User logged in successfully with password\" );\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-615:Inclusion of Sensitive Information in Source Code Comments|A.CWE-540:Inclusion of Sensitive Information in Source Code", "cwe": "615"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-777:Regular Expression without Anchors\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.No Vulnerabilities\nD.CWE-267:Privilege Defined With Unsafe Actions\nE.CWE-415:Double Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_malloc_free_char_52bSink(char * data);\r\n\r\nvoid My_malloc_free_char_52()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n \r\n free(data);\r\n My_malloc_free_char_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_malloc_free_char_52bG2BSink(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n \r\n My_malloc_free_char_52bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_malloc_free_char_52bB2GSink(char * data);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n \r\n free(data);\r\n My_malloc_free_char_52bB2GSink(data);\r\n}\r\n\r\nvoid My_malloc_free_char_52()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_char_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_char_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-415:Double Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nC.CWE-1284:Improper Validation of Specified Quantity in Input\nD.CWE-571:Expression is Always True\nE.CWE-606:Unchecked Input for Loop Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_environment_02()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n if(1)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n if(1)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"15\");\r\n }\r\n if(1)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n wcscpy(data, L\"15\");\r\n }\r\n if(1)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_environment_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_environment_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_environment_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-606:Unchecked Input for Loop Condition|C.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-1335:Incorrect Bitwise Shift of Integer\nC.No Vulnerabilities\nD.CWE-1314:Missing Write Protection for Parametric Data Values\nE.CWE-127:Buffer Under-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_alloca_memcpy_15()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = dataBuffer - 8;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n memcpy(dest, data, 100*sizeof(wchar_t));\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = dataBuffer;\r\n break;\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n memcpy(dest, data, 100*sizeof(wchar_t));\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = dataBuffer;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n memcpy(dest, data, 100*sizeof(wchar_t));\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_alloca_memcpy_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_alloca_memcpy_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_alloca_memcpy_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-272:Least Privilege Violation\nB.CWE-85:Doubled Character XSS Manipulations\nC.CWE-1209:Failure to Disable Reserved Bits\nD.CWE-271:Privilege Dropping / Lowering Errors\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n TRUE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegOpenUSKey_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegOpenUSKey_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-272:Least Privilege Violation|D.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-195:Signed to Unsigned Conversion Error\nB.No Vulnerabilities\nC.CWE-291:Reliance on IP Address for Authentication\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-274:Improper Handling of Insufficient Privileges\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_negative_strncpy_13()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = -1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_negative_strncpy_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_negative_strncpy_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_negative_strncpy_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-195:Signed to Unsigned Conversion Error|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-122:Heap-based Buffer Overflow\nC.CWE-787:Out-of-bounds Write\nD.CWE-1193:Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\nE.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_c_dest_char_cat_12()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = (char *)malloc(50*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0'; \r\n }\r\n else\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0'; \r\n }\r\n else\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_c_dest_char_cat_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_c_dest_char_cat_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_c_dest_char_cat_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-122:Heap-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling\nB.CWE-1065:Runtime Resource Management Control Element in a Component Built to Run on Application Servers\nC.No Vulnerabilities\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint reexpresses_semiharden = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid tantra_warfaring(char **agacante_paymastership);\r\nFILE *open_file(char *filename_param)\r\n{\r\n FILE *f;\r\n \r\n \r\n \r\n\r\n\r\n f = fopen(filename_param,\"w\");\r\n \r\n \r\n if (!f)\r\n return 0;\r\n else\r\n return f;\r\n fclose(f);\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n void (*epanaphora_attrib)(char **) = tantra_warfaring;\r\n char *postliminious_peridinium[54] = {0};\r\n char *speedometer_unordered;;\r\n if (__sync_bool_compare_and_swap(&reexpresses_semiharden,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n speedometer_unordered = getenv(\"INSTANTIATE_CONSISTING\");\r\n if (speedometer_unordered != 0) {;\r\n postliminious_peridinium[47] = speedometer_unordered;\r\n epanaphora_attrib(postliminious_peridinium);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid tantra_warfaring(char **agacante_paymastership)\r\n{\r\n char * filename = 0;\r\n int filename_len = 0;\r\n unsigned int num_files;\r\n FILE **filearray;\r\n int i;\r\n char *gigahertzes_galuth = 0;\r\n ++global_variable;;\r\n gigahertzes_galuth = ((char *)agacante_paymastership[47]);\r\n \r\n if (strlen(gigahertzes_galuth) > 0 &&\r\n gigahertzes_galuth[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n printf(\"Getting input value\\n\");\r\n num_files = strtoul(gigahertzes_galuth,0,16);\r\n if (num_files > 0xffff)\r\n num_files = 0;\r\n filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\r\n filename_len = strlen(\"/opt//workspace/testData/temp\") + 10;\r\n filename = (char*) malloc(filename_len * sizeof(char));\r\n if (filearray != 0) {\r\n for (i = 0; i < num_files; ++i)\r\n filearray[i] = 0;\r\n printf(\"Creating files\\n\");\r\n for (i = 0; i < num_files; ++i) {\r\n snprintf(filename,filename_len,\"%s_%08x\", \"/opt//workspace/testData/temp\", i);\r\n filearray[i] = open_file(filename);\r\n if (filearray[i] == 0)\r\n break;\r\n }\r\n if (i < num_files)\r\n printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\r\n for (i = 0; i < num_files; ++i)\r\n if (filearray[i] != 0)\r\n fclose(filearray[i]);\r\n free(filearray);\r\n free(filename);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "774"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nB.CWE-642:External Control of Critical State Data\nC.CWE-639:Authorization Bypass Through User-Controlled Key\nD.CWE-15:External Control of System or Configuration Setting\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_66bSink(char * dataArray[]);\r\n\r\nvoid My_w32_66()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n \r\n dataArray[2] = data;\r\n My_w32_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_66bG2BSink(char * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"hostname\");\r\n dataArray[2] = data;\r\n My_w32_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_w32_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-15:External Control of System or Configuration Setting|B.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nC.CWE-127:Buffer Under-read\nD.CWE-1252:CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_My_My_My_My_My_My_My_My_My_CWE839_negative_83B2G();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-321:Use of Hard-coded Cryptographic Key\nB.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nC.No Vulnerabilities\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-291:Reliance on IP Address for Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fopen_no_close_52bSink(FILE * data);\r\n\r\nvoid My_fopen_no_close_52()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_no_close_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fopen_no_close_52bB2GSink(FILE * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_no_close_52bB2GSink(data);\r\n}\r\n\r\nvoid My_fopen_no_close_52()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_no_close_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_no_close_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-1232:Improper Lock Behavior After Power State Transition\nD.CWE-36:Absolute Path Traversal\nE.CWE-253:Incorrect Check of Function Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_fprintf_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\r\n {\r\n printLine(\"fwprintf failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\r\n {\r\n printLine(\"fwprintf failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_fprintf_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_fprintf_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_fprintf_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-253:Incorrect Check of Function Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-134:Use of Externally-Controlled Format String\nB.CWE-1119:Excessive Use of Unconditional Branching\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.No Vulnerabilities\nE.CWE-447:Unimplemented or Unsupported Feature in UI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_file_printf_32()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n \r\n wprintf(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n \r\n wcscpy(data, L\"fixedstringtest\");\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n \r\n wprintf(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n \r\n wprintf(L\"%s\\n\", data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_file_printf_32()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_file_printf_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_file_printf_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-134:Use of Externally-Controlled Format String|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nC.CWE-687:Function Call With Incorrectly Specified Argument Value\nD.CWE-413:Improper Resource Locking\nE.CWE-336:Same Seed in Pseudo-Random Number Generator (PRNG)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * password)\r\n{\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_44()\r\n{\r\n wchar_t * password;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n \r\n funcPtr(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * password)\r\n{\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n funcPtr(password);\r\n}\r\n\r\nvoid My_w32_wchar_t_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-591:Sensitive Data Storage in Improperly Locked Memory|D.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-529:Exposure of Access Control List Files to an Unauthorized Control Sphere\nB.CWE-369:Divide By Zero\nC.No Vulnerabilities\nD.CWE-940:Improper Verification of Source of a Communication Channel\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_listen_socket_divide_03()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(5==5)\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 7;\r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(5==5)\r\n {\r\n \r\n data = 7;\r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\nvoid My_int_listen_socket_divide_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_listen_socket_divide_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_listen_socket_divide_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-369:Divide By Zero|E.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-940:Improper Verification of Source of a Communication Channel\nB.CWE-506:Embedded Malicious Code\nC.CWE-1390:Weak Authentication\nD.CWE-511:Logic/Time Bomb\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define NUM_CHECK 20000\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_rand_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-511:Logic/Time Bomb|B.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-642:External Control of Critical State Data\nB.No Vulnerabilities\nC.CWE-656:Reliance on Security Through Obscurity\nD.CWE-1116:Inaccurate Comments\nE.CWE-15:External Control of System or Configuration Setting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, char *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"hostname\");\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-15:External Control of System or Configuration Setting|A.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-566:Authorization Bypass Through User-Controlled SQL Primary Key\nB.CWE-651:Exposure of WSDL File Containing Sensitive Information\nC.CWE-506:Embedded Malicious Code\nD.CWE-510:Trapdoor\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_ip_based_logic_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"192.168.30.123\", inet_ntoa(acceptService.sin_addr)) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_ip_based_logic_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_ip_based_logic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_ip_based_logic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-510:Trapdoor|C.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer\nC.No Vulnerabilities\nD.CWE-917:Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_min_predec_18()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n goto source;\r\nsource:\r\n \r\n data = INT_MIN;\r\n goto sink;\r\nsink:\r\n {\r\n \r\n --data;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n goto source;\r\nsource:\r\n \r\n data = INT_MIN;\r\n goto sink;\r\nsink:\r\n \r\n if (data > INT_MIN)\r\n {\r\n --data;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n goto source;\r\nsource:\r\n \r\n data = -2;\r\n goto sink;\r\nsink:\r\n {\r\n \r\n --data;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\nvoid My_int_min_predec_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_min_predec_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_min_predec_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|E.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nC.CWE-940:Improper Verification of Source of a Communication Channel\nD.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nE.CWE-97:Improper Neutralization of Server-Side Includes (SSI) Within a Web Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_stat_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n struct STAT statBuffer;\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (STAT(filename, &statBuffer) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_stat_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_stat_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_stat_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|B.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1089:Large Data Table with Excessive Number of Indices\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption\nE.CWE-1067:Excessive Execution of Sequential Searches of Data Resource\n", "input": "regulator_register(const struct regulator_desc *regulator_desc,\r\r\n\t\t const struct regulator_config *config)\r\r\n{\r\r\n\tconst struct regulation_constraints *constraints = NULL;\r\r\n\tconst struct regulator_init_data *init_data;\r\r\n\tstatic atomic_t regulator_no = ATOMIC_INIT(0);\r\r\n\tstruct regulator_dev *rdev;\r\r\n\tstruct device *dev;\r\r\n\tint ret, i;\r\r\n\tconst char *supply = NULL;\r\r\n\r\r\n\tif (regulator_desc == NULL || config == NULL)\r\r\n\t\treturn ERR_PTR(-EINVAL);\r\r\n\r\r\n\tdev = config->dev;\r\r\n\tWARN_ON(!dev);\r\r\n\r\r\n\tif (regulator_desc->name == NULL || regulator_desc->ops == NULL)\r\r\n\t\treturn ERR_PTR(-EINVAL);\r\r\n\r\r\n\tif (regulator_desc->type != REGULATOR_VOLTAGE &&\r\r\n\t regulator_desc->type != REGULATOR_CURRENT)\r\r\n\t\treturn ERR_PTR(-EINVAL);\r\r\n\r\r\n\t/* Only one of each should be implemented */\r\r\n\tWARN_ON(regulator_desc->ops->get_voltage &&\r\r\n\t\tregulator_desc->ops->get_voltage_sel);\r\r\n\tWARN_ON(regulator_desc->ops->set_voltage &&\r\r\n\t\tregulator_desc->ops->set_voltage_sel);\r\r\n\r\r\n\t/* If we're using selectors we must implement list_voltage. */\r\r\n\tif (regulator_desc->ops->get_voltage_sel &&\r\r\n\t !regulator_desc->ops->list_voltage) {\r\r\n\t\treturn ERR_PTR(-EINVAL);\r\r\n\t}\r\r\n\tif (regulator_desc->ops->set_voltage_sel &&\r\r\n\t !regulator_desc->ops->list_voltage) {\r\r\n\t\treturn ERR_PTR(-EINVAL);\r\r\n\t}\r\r\n\r\r\n\trdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);\r\r\n\tif (rdev == NULL)\r\r\n\t\treturn ERR_PTR(-ENOMEM);\r\r\n\r\r\n\tinit_data = regulator_of_get_init_data(dev, regulator_desc,\r\r\n\t\t\t\t\t &rdev->dev.of_node);\r\r\n\tif (!init_data) {\r\r\n\t\tinit_data = config->init_data;\r\r\n\t\trdev->dev.of_node = of_node_get(config->of_node);\r\r\n\t}\r\r\n\r\r\n\tmutex_lock(&regulator_list_mutex);\r\r\n\r\r\n\tmutex_init(&rdev->mutex);\r\r\n\trdev->reg_data = config->driver_data;\r\r\n\trdev->owner = regulator_desc->owner;\r\r\n\trdev->desc = regulator_desc;\r\r\n\tif (config->regmap)\r\r\n\t\trdev->regmap = config->regmap;\r\r\n\telse if (dev_get_regmap(dev, NULL))\r\r\n\t\trdev->regmap = dev_get_regmap(dev, NULL);\r\r\n\telse if (dev->parent)\r\r\n\t\trdev->regmap = dev_get_regmap(dev->parent, NULL);\r\r\n\tINIT_LIST_HEAD(&rdev->consumer_list);\r\r\n\tINIT_LIST_HEAD(&rdev->list);\r\r\n\tBLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);\r\r\n\tINIT_DELAYED_WORK(&rdev->disable_work, regulator_disable_work);\r\r\n\r\r\n\t/* preform any regulator specific init */\r\r\n\tif (init_data && init_data->regulator_init) {\r\r\n\t\tret = init_data->regulator_init(rdev->reg_data);\r\r\n\t\tif (ret < 0)\r\r\n\t\t\tgoto clean;\r\r\n\t}\r\r\n\r\r\n\t/* register with sysfs */\r\r\n\trdev->dev.class = &regulator_class;\r\r\n\trdev->dev.parent = dev;\r\r\n\tdev_set_name(&rdev->dev, \"regulator.%d\",\r\r\n\t\t atomic_inc_return(&regulator_no) - 1);\r\r\n\tret = device_register(&rdev->dev);\r\r\n\tif (ret != 0) {\r\r\n\t\tput_device(&rdev->dev);\r\r\n\t\tgoto clean;\r\r\n\t}\r\r\n\r\r\n\tdev_set_drvdata(&rdev->dev, rdev);\r\r\n\r\r\n\tif (config->ena_gpio && gpio_is_valid(config->ena_gpio)) {\r\r\n\t\tret = regulator_ena_gpio_request(rdev, config);\r\r\n\t\tif (ret != 0) {\r\r\n\t\t\trdev_err(rdev, \"Failed to request enable GPIO%d: %d\\n\",\r\r\n\t\t\t\t config->ena_gpio, ret);\r\r\n\t\t\tgoto wash;\r\r\n\t\t}\r\r\n\r\r\n\t\tif (config->ena_gpio_flags & GPIOF_OUT_INIT_HIGH)\r\r\n\t\t\trdev->ena_gpio_state = 1;\r\r\n\r\r\n\t\tif (config->ena_gpio_invert)\r\r\n\t\t\trdev->ena_gpio_state = !rdev->ena_gpio_state;\r\r\n\t}\r\r\n\r\r\n\t/* set regulator constraints */\r\r\n\tif (init_data)\r\r\n\t\tconstraints = &init_data->constraints;\r\r\n\r\r\n\tret = set_machine_constraints(rdev, constraints);\r\r\n\tif (ret < 0)\r\r\n\t\tgoto scrub;\r\r\n\r\r\n\t/* add attributes supported by this regulator */\r\r\n\tret = add_regulator_attributes(rdev);\r\r\n\tif (ret < 0)\r\r\n\t\tgoto scrub;\r\r\n\r\r\n\tif (init_data && init_data->supply_regulator)\r\r\n\t\tsupply = init_data->supply_regulator;\r\r\n\telse if (regulator_desc->supply_name)\r\r\n\t\tsupply = regulator_desc->supply_name;\r\r\n\r\r\n\tif (supply) {\r\r\n\t\tstruct regulator_dev *r;\r\r\n\r\r\n\t\tr = regulator_dev_lookup(dev, supply, &ret);\r\r\n\r\r\n\t\tif (ret == -ENODEV) {\r\r\n\t\t\t/*\r\r\n\t\t\t * No supply was specified for this regulator and\r\r\n\t\t\t * there will never be one.\r\r\n\t\t\t */\r\r\n\t\t\tret = 0;\r\r\n\t\t\tgoto add_dev;\r\r\n\t\t} else if (!r) {\r\r\n\t\t\tdev_err(dev, \"Failed to find supply %s\\n\", supply);\r\r\n\t\t\tret = -EPROBE_DEFER;\r\r\n\t\t\tgoto scrub;\r\r\n\t\t}\r\r\n\r\r\n\t\tret = set_supply(rdev, r);\r\r\n\t\tif (ret < 0)\r\r\n\t\t\tgoto scrub;\r\r\n\r\r\n\t\t/* Enable supply if rail is enabled */\r\r\n\t\tif (_regulator_is_enabled(rdev)) {\r\r\n\t\t\tret = regulator_enable(rdev->supply);\r\r\n\t\t\tif (ret < 0)\r\r\n\t\t\t\tgoto scrub;\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\nadd_dev:\r\r\n\t/* add consumers devices */\r\r\n\tif (init_data) {\r\r\n\t\tfor (i = 0; i < init_data->num_consumer_supplies; i++) {\r\r\n\t\t\tret = set_consumer_device_supply(rdev,\r\r\n\t\t\t\tinit_data->consumer_supplies[i].dev_name,\r\r\n\t\t\t\tinit_data->consumer_supplies[i].supply);\r\r\n\t\t\tif (ret < 0) {\r\r\n\t\t\t\tdev_err(dev, \"Failed to set supply %s\\n\",\r\r\n\t\t\t\t\tinit_data->consumer_supplies[i].supply);\r\r\n\t\t\t\tgoto unset_supplies;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\tlist_add(&rdev->list, &regulator_list);\r\r\n\r\r\n\trdev_init_debugfs(rdev);\r\r\nout:\r\r\n\tmutex_unlock(&regulator_list_mutex);\r\r\n\treturn rdev;\r\r\n\r\r\nunset_supplies:\r\r\n\tunset_regulator_supplies(rdev);\r\r\n\r\r\nscrub:\r\r\n\tif (rdev->supply)\r\r\n\t\t_regulator_put(rdev->supply);\r\r\n\tregulator_ena_gpio_free(rdev);\r\r\n\tkfree(rdev->constraints);\r\r\nwash:\r\r\n\tdevice_unregister(&rdev->dev);\r\r\n\t/* device core frees rdev */\r\r\n\trdev = ERR_PTR(ret);\r\r\n\tgoto out;\r\r\n\r\r\nclean:\r\r\n\tkfree(rdev);\r\r\n\trdev = ERR_PTR(ret);\r\r\n\tgoto out;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.No Vulnerabilities|C.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-1192:System-on-Chip (SoC) Using Components without Unique, Immutable Identifiers\nC.CWE-1252:CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\nD.No Vulnerabilities\nE.CWE-377:Insecure Temporary File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define TMPNAM _wtmpnam\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TMPNAM tmpnam\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_tmpnam_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TMPNAM(NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TMPNAM(NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TMPNAM(NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_tmpnam_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_tmpnam_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_tmpnam_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-377:Insecure Temporary File|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-127:Buffer Under-read\nB.No Vulnerabilities\nC.CWE-733:Compiler Optimization Removal or Modification of Security-critical Code\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-654:Reliance on a Single Factor in a Security Decision\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_declare_memmove_03()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(5==5)\r\n {\r\n \r\n data = dataBuffer - 8;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n memmove(dest, data, 100*sizeof(char));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n memmove(dest, data, 100*sizeof(char));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(5==5)\r\n {\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n memmove(dest, data, 100*sizeof(char));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_char_declare_memmove_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_memmove_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_memmove_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-665:Improper Initialization\nC.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\nD.No Vulnerabilities\nE.CWE-841:Improper Enforcement of Behavioral Workflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_ncat_66bSink(char * dataArray[]);\r\n\r\nvoid My_char_ncat_66()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n \r\n dataArray[2] = data;\r\n My_char_ncat_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_ncat_66bG2BSink(char * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = '\\0'; \r\n dataArray[2] = data;\r\n My_char_ncat_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_char_ncat_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ncat_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ncat_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.CWE-390:Detection of Error Condition Without Action\nC.CWE-212:Improper Removal of Sensitive Information Before Storage or Transfer\nD.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fopen_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-618:Exposed Unsafe ActiveX Method\nB.CWE-708:Incorrect Ownership Assignment\nC.CWE-1043:Data Element Aggregating an Excessively Large Number of Non-Primitive Elements\nD.No Vulnerabilities\nE.CWE-284:Improper Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_RegCreateKeyEx_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExA(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_ALL_ACCESS,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExA(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_RegCreateKeyEx_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_RegCreateKeyEx_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_RegCreateKeyEx_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-284:Improper Access Control|A.CWE-618:Exposed Unsafe ActiveX Method", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-230:Improper Handling of Missing Values\nC.No Vulnerabilities\nD.CWE-1231:Improper Prevention of Lock Bit Modification\nE.CWE-675:Multiple Operations on Resource in Single-Operation Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic FILE * mSource(FILE * data)\r\n{\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n return data;\r\n}\r\n\r\nvoid My_fopen_42()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = mSource(data);\r\n \r\n fclose(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic FILE * nG2BSource(FILE * data)\r\n{\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = nG2BSource(data);\r\n \r\n fclose(data);\r\n}\r\n\r\n\r\nstatic FILE * nB2GSource(FILE * data)\r\n{\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = nB2GSource(data);\r\n \r\n \r\n ; \r\n}\r\n\r\nvoid My_fopen_42()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-675:Multiple Operations on Resource in Single-Operation Context|A.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1240:Use of a Cryptographic Primitive with a Risky Implementation\nB.CWE-202:Exposure of Sensitive Information Through Data Queries\nC.No Vulnerabilities\nD.CWE-415:Double Free\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_long_15\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n data = new long[100];\r\n \r\n delete [] data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n delete [] data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n data = new long[100];\r\n \r\n delete [] data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n \r\n ; \r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n data = new long[100];\r\n \r\n delete [] data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n data = new long[100];\r\n \r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n delete [] data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n data = new long[100];\r\n \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n delete [] data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_long_15; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-415:Double Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nC.CWE-266:Incorrect Privilege Assignment\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-695:Use of Low-Level Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_17()\r\n{\r\n int i;\r\n void * data;\r\n \r\n data = NULL;\r\n for(i = 0; i < 1; i++)\r\n {\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n void * data;\r\n \r\n data = NULL;\r\n for(h = 0; h < 1; h++)\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_short_17()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-416:Use After Free\nB.CWE-284:Improper Access Control\nC.No Vulnerabilities\nD.CWE-460:Improper Cleanup on Thrown Exception\nE.CWE-45:Path Equivalence: 'file...name' (Multiple Internal Dot)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateDesktop_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateDesktop_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateDesktop_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateDesktop_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-284:Improper Access Control|E.CWE-45:Path Equivalence: 'file...name' (Multiple Internal Dot)", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-413:Improper Resource Locking\nB.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nC.CWE-303:Incorrect Implementation of Authentication Algorithm\nD.CWE-585:Empty Synchronized Block\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_05()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(staticTrue)\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(staticTrue)\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_char_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-591:Sensitive Data Storage in Improperly Locked Memory|A.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-372:Incomplete Internal State Distinction\nC.CWE-1250:Improper Preservation of Consistency Between Independent Representations of Shared State\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_putc_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n putwc((wchar_t)L'A', stdout);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (putwc((wchar_t)L'A', stdout) == WEOF)\r\n {\r\n printLine(\"putwc failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n if (putwc((wchar_t)L'A', stdout) == WEOF)\r\n {\r\n printLine(\"putwc failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_putc_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_putc_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_putc_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-602:Client-Side Enforcement of Server-Side Security\nB.CWE-301:Reflection Attack in an Authentication Protocol\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-415:Double Free\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_new_delete_array_struct_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new twoIntsStruct[100];\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new twoIntsStruct[100];\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new twoIntsStruct[100];\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new twoIntsStruct[100];\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new twoIntsStruct[100];\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_struct_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-415:Double Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nB.CWE-82:Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\nC.CWE-195:Signed to Unsigned Conversion Error\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_memcpy_65bSink(int data);\r\n\r\nvoid My_connect_socket_memcpy_65()\r\n{\r\n int data;\r\n \r\n void (*funcPtr) (int) = My_connect_socket_memcpy_65bSink;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_memcpy_65bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = My_connect_socket_memcpy_65bG2BSink;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_connect_socket_memcpy_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_memcpy_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_memcpy_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-195:Signed to Unsigned Conversion Error|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-920:Improper Restriction of Power Consumption\nC.CWE-1300:Improper Protection of Physical Side Channels\nD.CWE-272:Least Privilege Violation\nE.CWE-271:Privilege Dropping / Lowering Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegCreateUSKey_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKLM) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegCreateUSKey_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegCreateUSKey_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegCreateUSKey_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-272:Least Privilege Violation|E.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-674:Uncontrolled Recursion\nB.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.No Vulnerabilities\nE.CWE-134:Use of Externally-Controlled Format String\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_listen_socket_fprintf_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<char *> dataList);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<char *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<char *> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_fprintf_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-134:Use of Externally-Controlled Format String|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-1292:Incorrect Conversion of Security Identifiers\nC.CWE-437:Incomplete Model of Endpoint Features\nD.CWE-762:Mismatched Memory Management Routines\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_delete_array_class_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<TwoIntsClass *> dataList);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n list<TwoIntsClass *> dataList;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass;\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<TwoIntsClass *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n list<TwoIntsClass *> dataList;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass[100];\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<TwoIntsClass *> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n list<TwoIntsClass *> dataList;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass;\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_class_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-36:Absolute Path Traversal\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-248:Uncaught Exception\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_char_environment_open_16\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n break;\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n break;\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_open_16; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-36:Absolute Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1117:Callable with Insufficient Behavioral Summary\nB.CWE-256:Plaintext Storage of a Password\nC.CWE-522:Insufficiently Protected Credentials\nD.CWE-29:Path Traversal: '\\..\\filename'\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\nstatic char * My_w32_char_45Data;\r\nstatic char * My_w32_char_45G2BData;\r\nstatic char * My_w32_char_45B2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n char * data = My_w32_char_45Data;\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_45()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n char * data = My_w32_char_45G2BData;\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n My_w32_char_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n char * data = My_w32_char_45B2GData;\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_45B2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid My_w32_char_45()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-256:Plaintext Storage of a Password|C.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-114:Process Control\nB.CWE-797:Only Filtering Special Elements at an Absolute Position\nC.CWE-73:External Control of File Name or Path\nD.CWE-464:Addition of Data Structure Sentinel\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_relativePath_09()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_relativePath_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_relativePath_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_relativePath_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-241:Improper Handling of Unexpected Data Type\nB.CWE-628:Function Call with Incorrectly Specified Arguments\nC.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nD.No Vulnerabilities\nE.CWE-1230:Exposure of Sensitive Information Through Metadata\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 100\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%s\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-688:Function Call With Incorrect Variable or Reference as Argument|B.CWE-628:Function Call with Incorrectly Specified Arguments", "cwe": "688"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1288:Improper Validation of Consistency within Input\nB.CWE-506:Embedded Malicious Code\nC.CWE-912:Hidden Functionality\nD.CWE-523:Unprotected Transport of Credentials\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define FILENAME \"conf.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_file_transfer_listen_socket_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char contents[65536]; \r\n FILE * pFile;\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(contents, (int)(65535), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n contents[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, contents, strlen(contents), 0) != strlen(contents))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_file_transfer_listen_socket_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-506:Embedded Malicious Code|C.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.CWE-223:Omission of Security-relevant Information\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-1094:Excessive Index Range Scan for a Data Resource\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_41Sink(char * password)\r\n{\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_41()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n \r\n strcpy(password, PASSWORD);\r\n My_w32_char_41Sink(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nvoid My_w32_char_41G2BSink(char * password)\r\n{\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n My_w32_char_41G2BSink(password);\r\n}\r\n\r\nvoid My_w32_char_41()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-479:Signal Handler Use of a Non-reentrant Function\nC.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nD.CWE-284:Improper Access Control\nE.CWE-598:Use of GET Request Method With Sensitive Query Strings\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\nstatic void helperM(int sig)\r\n{\r\n \r\n \r\n void *voidPointer = malloc(10);\r\n if (voidPointer == NULL) {exit(-1);}\r\n free(voidPointer);\r\n}\r\n\r\nstatic volatile sig_atomic_t volatileSigAtomic = 0;\r\n\r\nstatic void helperN(int sig)\r\n{\r\n \r\n volatileSigAtomic = sig;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_10()\r\n{\r\n if(globalTrue)\r\n {\r\n signal(SIGINT, helperM);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\nvoid My_basic_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-479:Signal Handler Use of a Non-reentrant Function|C.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe", "cwe": "479"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-344:Use of Invariant Value in Dynamically Changing Context\nB.No Vulnerabilities\nC.CWE-322:Key Exchange without Entity Authentication\nD.CWE-587:Assignment of a Fixed Address to a Pointer\nE.CWE-1295:Debug Messages Revealing Unnecessary Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n char *charPointer = (char*)0x400000;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-587:Assignment of a Fixed Address to a Pointer|A.CWE-344:Use of Invariant Value in Dynamically Changing Context", "cwe": "587"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nB.CWE-763:Release of Invalid Pointer or Reference\nC.No Vulnerabilities\nD.CWE-1072:Data Resource Access without Use of Connection Pooling\nE.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_stat_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n struct STAT statBuffer;\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (STAT(filename, &statBuffer) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_stat_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_stat_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_stat_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-121:Stack-based Buffer Overflow\nC.CWE-544:Missing Standardized Error Handling Mechanism\nD.No Vulnerabilities\nE.CWE-623:Unsafe ActiveX Control Marked Safe For Scripting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define WIDE_STRING L\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\r\n#define CHAR_STRING \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_My_My_My_My_My_My_My_My_My_CWE135_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-121:Stack-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nB.CWE-123:Write-what-where Condition\nC.No Vulnerabilities\nD.CWE-787:Out-of-bounds Write\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fgets_53bSink(mStruct data);\r\n\r\nvoid My_fgets_53()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n My_fgets_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fgets_53bG2BSink(mStruct data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n My_fgets_53bG2BSink(data);\r\n}\r\n\r\nvoid My_fgets_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-284:Improper Access Control\nB.CWE-396:Declaration of Catch for Generic Exception\nC.CWE-705:Incorrect Control Flow Scoping\nD.CWE-156:Improper Neutralization of Whitespace\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_and_domain_error_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalTrue)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n catch (domain_error &)\r\n {\r\n \r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_and_domain_error_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-396:Declaration of Catch for Generic Exception|C.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-14:Compiler Removal of Code to Clear Buffers\nB.No Vulnerabilities\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-194:Unexpected Sign Extension\nE.CWE-941:Incorrectly Specified Destination in a Communication Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fscanf_strncpy_53bSink(short data);\r\n\r\nvoid My_fscanf_strncpy_53()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n My_fscanf_strncpy_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fscanf_strncpy_53bG2BSink(short data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n My_fscanf_strncpy_53bG2BSink(data);\r\n}\r\n\r\nvoid My_fscanf_strncpy_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_strncpy_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_strncpy_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-194:Unexpected Sign Extension|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-586:Explicit Call to Finalize()\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-282:Improper Ownership Management\nD.CWE-126:Buffer Over-read\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_char_memmove_82\r\n{\r\n\r\nclass My_malloc_char_memmove_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(char * data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_malloc_char_memmove_82 : public My_malloc_char_memmove_82_base\r\n{\r\npublic:\r\n void action(char * data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_malloc_char_memmove_82G2B : public My_malloc_char_memmove_82_base\r\n{\r\npublic:\r\n void action(char * data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1247:Improper Protection Against Voltage and Clock Glitches\nB.CWE-32:Path Traversal: '...' (Triple Dot)\nC.No Vulnerabilities\nD.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nE.CWE-329:Generation of Predictable IV with CBC Mode\n", "input": "static int iwbmp_write_main(struct iwbmpwcontext *wctx)\r\r\n{\r\r\n\tstruct iw_image *img;\r\r\n\tint cmpr_req;\r\r\n\tint retval = 0;\r\r\n\tint x;\r\r\n\tconst char *optv;\r\r\n\r\r\n\timg = wctx->img;\r\r\n\r\r\n\twctx->bmpversion = 0;\r\r\n\toptv = iw_get_option(wctx->ctx, \"bmp:version\");\r\r\n\tif(optv) {\r\r\n\t\twctx->bmpversion = iw_parse_int(optv);\r\r\n\t}\r\r\n\r\r\n\tif(wctx->bmpversion==0) wctx->bmpversion=3;\r\r\n\tif(wctx->bmpversion==4) {\r\r\n\t\tiw_warning(wctx->ctx,\"Writing BMP v4 is not supported; using v3 instead\");\r\r\n\t\twctx->bmpversion=3;\r\r\n\t}\r\r\n\tif(wctx->bmpversion!=2 && wctx->bmpversion!=3 && wctx->bmpversion!=5) {\r\r\n\t\tiw_set_errorf(wctx->ctx,\"Unsupported BMP version: %d\",wctx->bmpversion);\r\r\n\t\tgoto done;\r\r\n\t}\r\r\n\r\r\n\tif(wctx->bmpversion>=3)\r\r\n\t\tcmpr_req = iw_get_value(wctx->ctx,IW_VAL_COMPRESSION);\r\r\n\telse\r\r\n\t\tcmpr_req = IW_COMPRESSION_NONE;\r\r\n\r\r\n\tif(wctx->bmpversion==2)\r\r\n\t\twctx->header_size = 12;\r\r\n\telse if(wctx->bmpversion==5)\r\r\n\t\twctx->header_size = 124;\r\r\n\telse\r\r\n\t\twctx->header_size = 40;\r\r\n\r\r\n\twctx->no_cslabel = iw_get_value(wctx->ctx,IW_VAL_NO_CSLABEL);\r\r\n\r\r\n\tif(cmpr_req==IW_COMPRESSION_AUTO || cmpr_req==IW_COMPRESSION_NONE)\r\r\n\t\tcmpr_req = IW_COMPRESSION_NONE;\r\r\n\telse\r\r\n\t\tcmpr_req = IW_COMPRESSION_RLE;\r\r\n\r\r\n\tif(img->imgtype==IW_IMGTYPE_RGB) {\r\r\n\t\tif(img->reduced_maxcolors) {\r\r\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],\r\r\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GREEN],\r\r\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_BLUE],0))\r\r\n\t\t\t{\r\r\n\t\t\t\tgoto done;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t\telse {\r\r\n\t\t\twctx->bitcount=24;\r\r\n\t\t}\r\r\n\t}\r\r\n\telse if(img->imgtype==IW_IMGTYPE_PALETTE) {\r\r\n\t\tif(!wctx->pal) goto done;\r\r\n\r\r\n\t\tx = check_palette_transparency(wctx->pal);\r\r\n\r\r\n\t\tif(x!=0 && wctx->bmpversion<3) {\r\r\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save as a transparent BMP: Incompatible BMP version\");\r\r\n\t\t\tgoto done;\r\r\n\t\t}\r\r\n\t\telse if(x==2) {\r\r\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save this image as a transparent BMP: Has partial transparency\");\r\r\n\t\t\tgoto done;\r\r\n\t\t}\r\r\n\t\telse if(x!=0 && cmpr_req!=IW_COMPRESSION_RLE) {\r\r\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save as a transparent BMP: RLE compression required\");\r\r\n\t\t\tgoto done;\r\r\n\t\t}\r\r\n\r\r\n\t\tif(wctx->pal->num_entries<=2 && cmpr_req!=IW_COMPRESSION_RLE)\r\r\n\t\t\twctx->bitcount=1;\r\r\n\t\telse if(wctx->pal->num_entries<=16)\r\r\n\t\t\twctx->bitcount=4;\r\r\n\t\telse\r\r\n\t\t\twctx->bitcount=8;\r\r\n\t}\r\r\n\telse if(img->imgtype==IW_IMGTYPE_RGBA) {\r\r\n\t\tif(img->reduced_maxcolors) {\r\r\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],\r\r\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GREEN],\r\r\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_BLUE],\r\r\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA]))\r\r\n\t\t\t{\r\r\n\t\t\t\tgoto done;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t\telse {\r\r\n\t\t\tif(!setup_16_32bit(wctx,255,255,255,255)) {\r\r\n\t\t\t\tgoto done;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t}\r\r\n\telse if(img->imgtype==IW_IMGTYPE_GRAYA) {\r\r\n\t\tif(img->reduced_maxcolors) {\r\r\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],\r\r\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\r\r\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\r\r\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA]))\r\r\n\t\t\t{\r\r\n\t\t\t\tgoto done;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t\telse {\r\r\n\t\t\tif(!setup_16_32bit(wctx,255,255,255,255)) {\r\r\n\t\t\t\tgoto done;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t}\r\r\n\telse if(img->imgtype==IW_IMGTYPE_GRAY) {\r\r\n\t\tif(img->reduced_maxcolors) {\r\r\n\t\t\tif(img->maxcolorcode[IW_CHANNELTYPE_GRAY]<=1023) {\r\r\n\t\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],\r\r\n\t\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\r\r\n\t\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],0))\r\r\n\t\t\t\t{\r\r\n\t\t\t\t\tgoto done;\r\r\n\t\t\t\t}\r\r\n\t\t\t}\r\r\n\t\t\telse {\r\r\n\t\t\t\tiw_set_error(wctx->ctx,\"Cannot write grayscale BMP at this bit depth\");\r\r\n\t\t\t\tgoto done;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t\telse {\r\r\n\t\t\twctx->bitcount=24;\r\r\n\t\t}\r\r\n\t}\r\r\n\telse {\r\r\n\t\tiw_set_error(wctx->ctx,\"Internal: M image type for BMP\");\r\r\n\t\tgoto done;\r\r\n\t}\r\r\n\r\r\n\tif(cmpr_req==IW_COMPRESSION_RLE && (wctx->bitcount==4 || wctx->bitcount==8)) {\r\r\n\t\twctx->compressed = 1;\r\r\n\t}\r\r\n\r\r\n\twctx->unc_dst_bpr = iwbmp_calc_bpr(wctx->bitcount,img->width);\r\r\n\twctx->unc_bitssize = wctx->unc_dst_bpr * img->height;\r\r\n\twctx->palentries = 0;\r\r\n\r\r\n\tif(wctx->pal) {\r\r\n\t\tif(wctx->bmpversion==2) {\r\r\n\t\t\twctx->palentries = 1<<wctx->bitcount;\r\r\n\t\t\twctx->palsize = wctx->palentries*3;\r\r\n\t\t}\r\r\n\t\telse {\r\r\n\t\t\tif(wctx->bitcount==1) {\r\r\n\t\t\t\twctx->palentries=2;\r\r\n\t\t\t}\r\r\n\t\t\telse {\r\r\n\t\t\t\twctx->palentries = wctx->pal->num_entries;\r\r\n\t\t\t}\r\r\n\t\t\twctx->palsize = wctx->palentries*4;\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\tiwbmp_write_file_header(wctx);\r\r\n\r\r\n\tif(!iwbmp_write_bmp_header(wctx)) {\r\r\n\t\tgoto done;\r\r\n\t}\r\r\n\r\r\n\tif(wctx->bitfields_size>0) {\r\r\n\t\tif(!iwbmp_write_bitfields(wctx)) goto done;\r\r\n\t}\r\r\n\r\r\n\tiwbmp_write_palette(wctx);\r\r\n\r\r\n\tif(wctx->compressed) {\r\r\n\t\tif(!iwbmp_write_pixels_compressed(wctx,img)) goto done;\r\r\n\t}\r\r\n\telse {\r\r\n\t\tiwbmp_write_pixels_uncompressed(wctx,img);\r\r\n\t}\r\r\n\r\r\n\tretval = 1;\r\r\ndone:\r\r\n\treturn retval;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.No Vulnerabilities|C.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-415:Double Free\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-842:Placement of User into Incorrect Group\nE.CWE-1276:Hardware Child Block Incorrectly Connected to Parent System\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_int64_t_42\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic int64_t * mSource(int64_t * data)\r\n{\r\n data = new int64_t;\r\n \r\n delete data;\r\n return data;\r\n}\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n data = mSource(data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int64_t * nG2BSource(int64_t * data)\r\n{\r\n data = new int64_t;\r\n \r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n data = nG2BSource(data);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nstatic int64_t * nB2GSource(int64_t * data)\r\n{\r\n data = new int64_t;\r\n \r\n delete data;\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n data = nB2GSource(data);\r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_int64_t_42; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-415:Double Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-462:Duplicate Key in Associative List (Alist)\nC.CWE-259:Use of Hard-coded Password\nD.CWE-467:Use of sizeof() on a Pointer Type\nE.CWE-131:Incorrect Calculation of Buffer Size\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n short * mShort = NULL;\r\n \r\n mShort = (short *)malloc(sizeof(mShort));\r\n if (mShort == NULL) {exit(-1);}\r\n *mShort = 5;\r\n printShortLine(*mShort);\r\n free(mShort);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n short * nShort = NULL;\r\n \r\n nShort = (short *)malloc(sizeof(*nShort));\r\n if (nShort == NULL) {exit(-1);}\r\n *nShort = 6;\r\n printShortLine(*nShort);\r\n free(nShort);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n short * nShort = NULL;\r\n \r\n nShort = (short *)malloc(sizeof(*nShort));\r\n if (nShort == NULL) {exit(-1);}\r\n *nShort = 6;\r\n printShortLine(*nShort);\r\n free(nShort);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-467:Use of sizeof() on a Pointer Type|E.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-939:Improper Authorization in Handler for Custom URL Scheme\nC.CWE-511:Logic/Time Bomb\nD.CWE-47:Path Equivalence: ' filename' (Leading Space)\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <time.h>\r\n\r\n#define TIME_CHECK ((time_t)1199163600) \r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_time_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_time_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_time_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_time_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|A.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-617:Reachable Assertion\nC.CWE-788:Access of Memory Location After End of Buffer\nD.CWE-379:Creation of Temporary File in Directory with Insecure Permissions\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fixed_11()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = ASSERT_VALUE-1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fixed_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fixed_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fixed_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-617:Reachable Assertion|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-86:Improper Neutralization of Invalid Characters in Identifiers in Web Pages\nB.CWE-143:Improper Neutralization of Record Delimiters\nC.No Vulnerabilities\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-396:Declaration of Catch for Generic Exception\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_dotdotdot_03\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(5==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (...)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_dotdotdot_03; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-396:Declaration of Catch for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1391:Use of Weak Credentials\nB.No Vulnerabilities\nC.CWE-43:Path Equivalence: 'filename....' (Multiple Trailing Dot)\nD.CWE-242:Use of Inherently Dangerous Function\nE.CWE-1177:Use of Prohibited Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 10\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n \r\n result = gets(dest);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n result = fgets(dest, DEST_SIZE, stdin);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-242:Use of Inherently Dangerous Function|E.CWE-1177:Use of Prohibited Code", "cwe": "242"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-272:Least Privilege Violation\nB.CWE-570:Expression is Always False\nC.CWE-416:Use After Free\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_new_delete_array_long_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n data = new long[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5L;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n printLongLine(data[0]);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n data = new long[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5L;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n data = new long[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5L;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new long[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5L;\r\n }\r\n }\r\n \r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n printLongLine(data[0]);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n data = new long[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5L;\r\n }\r\n }\r\n \r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n printLongLine(data[0]);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_long_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-416:Use After Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nB.CWE-780:Use of RSA Algorithm without OAEP\nC.CWE-223:Omission of Security-relevant Information\nD.CWE-1341:Multiple Releases of Same Resource or Handle\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"String to be encrypted\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-780:Use of RSA Algorithm without OAEP|A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm", "cwe": "780"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.No Vulnerabilities\nC.CWE-448:Obsolete Feature in UI\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-127:Buffer Under-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_memcpy_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n memcpy(dest, data, 100*sizeof(wchar_t));\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n memcpy(dest, data, 100*sizeof(wchar_t));\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n \r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_memcpy_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-566:Authorization Bypass Through User-Controlled SQL Primary Key\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-262:Not Using Password Aging\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_array_TwoIntsClass_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<TwoIntsClass *> dataVector);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n vector<TwoIntsClass *> dataVector;\r\n data = NULL;\r\n \r\n data = new TwoIntsClass[100];\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printIntLine(data[0].intOne);\r\n printIntLine(data[0].intTwo);\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<TwoIntsClass *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n vector<TwoIntsClass *> dataVector;\r\n data = NULL;\r\n \r\n TwoIntsClass dataNBuffer[100];\r\n data = dataNBuffer;\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printIntLine(data[0].intOne);\r\n printIntLine(data[0].intTwo);\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<TwoIntsClass *> dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n vector<TwoIntsClass *> dataVector;\r\n data = NULL;\r\n \r\n data = new TwoIntsClass[100];\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printIntLine(data[0].intOne);\r\n printIntLine(data[0].intTwo);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_array_TwoIntsClass_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-172:Encoding Error\nB.CWE-916:Use of Password Hash With Insufficient Computational Effort\nC.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\nD.CWE-284:Improper Access Control\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateDesktop_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateDesktop_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateDesktop_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateDesktop_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-284:Improper Access Control|C.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-324:Use of a Key Past its Expiration Date\nC.CWE-256:Plaintext Storage of a Password\nD.CWE-522:Insufficiently Protected Credentials\nE.CWE-1239:Improper Zeroization of Hardware Register\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_54bSink(char * data);\r\n\r\nvoid My_w32_char_54()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_54bG2BSink(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n My_w32_char_54bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_w32_char_54bB2GSink(char * data);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_54bB2GSink(data);\r\n}\r\n\r\nvoid My_w32_char_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|D.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nB.No Vulnerabilities\nC.CWE-1385:Missing Origin Validation in WebSockets\nD.CWE-1120:Excessive Code Complexity\nE.CWE-413:Improper Resource Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_66bSink(wchar_t * passwordArray[]);\r\n\r\nvoid My_w32_wchar_t_66()\r\n{\r\n wchar_t * password;\r\n wchar_t * passwordArray[5];\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n \r\n passwordArray[2] = password;\r\n My_w32_wchar_t_66bSink(passwordArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_66bG2BSink(wchar_t * passwordArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t * passwordArray[5];\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n passwordArray[2] = password;\r\n My_w32_wchar_t_66bG2BSink(passwordArray);\r\n}\r\n\r\nvoid My_w32_wchar_t_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-591:Sensitive Data Storage in Improperly Locked Memory|E.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-271:Privilege Dropping / Lowering Errors\nB.CWE-272:Least Privilege Violation\nC.CWE-232:Improper Handling of Undefined Values\nD.CWE-1329:Reliance on Component That is Not Updateable\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateProcessAsUser_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateProcessAsUser_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateProcessAsUser_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateProcessAsUser_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-272:Least Privilege Violation|A.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-106:Struts: Plug-in Framework not in Use\nB.No Vulnerabilities\nC.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nD.CWE-330:Use of Insufficiently Random Values\nE.CWE-222:Truncation of Security-relevant Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|D.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1302:Missing Security Identifier\nB.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nC.CWE-665:Improper Initialization\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_cat_08()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_cat_08()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_cat_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_cat_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-1259:Improper Restriction of Security Token Assignment\nC.CWE-692:Incomplete Denylist to Cross-Site Scripting\nD.No Vulnerabilities\nE.CWE-36:Absolute Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FOPEN fopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\nnamespace My_char_environment_fopen_67\r\n{\r\n\r\ntypedef struct _structType\r\n{\r\n char * structFirst;\r\n} structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(structType myStruct);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n structType myStruct;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n myStruct.structFirst = data;\r\n mSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n structType myStruct;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n myStruct.structFirst = data;\r\n nG2BSink(myStruct);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_fopen_67; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-36:Absolute Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1023:Incomplete Comparison with Missing Factors\nB.CWE-839:Numeric Range Comparison Without Minimum Check\nC.No Vulnerabilities\nD.CWE-535:Exposure of Information Through Shell Error Message\nE.CWE-1066:Missing Serialization Control Element\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint ontine_balas = 0;\r\nint global_variable;\r\nvoid handle_taint(char *joggling_splendorous);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&ontine_balas,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *joggling_splendorous)\r\n{\r\n char *buffer = 0U;\r\n int len;\r\n char *cogweels_blancmanges = 0;\r\n char ***udos_wamel = 0;\r\n char **ateliotic_theanthropism = 0;\r\n char *clericism_borassus = 0;\r\n int smeariness_taeniform = 0;\r\n char *planche_disburden = 0;\r\n ++global_variable;;\r\n if (joggling_splendorous != 0) {;\r\n smeariness_taeniform = ((int )(strlen(joggling_splendorous)));\r\n planche_disburden = ((char *)(malloc(smeariness_taeniform + 1)));\r\n if (planche_disburden == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(planche_disburden,0,smeariness_taeniform + 1);\r\n memcpy(planche_disburden,joggling_splendorous,smeariness_taeniform);\r\n if (joggling_splendorous != 0) \r\n free(((char *)joggling_splendorous));\r\n ateliotic_theanthropism = &planche_disburden;\r\n udos_wamel = &ateliotic_theanthropism;\r\n cogweels_blancmanges = ((char *)( *( *udos_wamel)));\r\n \r\n len = atoi(cogweels_blancmanges);\r\n \r\n\r\n if (len < 4096) {\r\n buffer = ((char *)(malloc(4096 * sizeof(char ))));\r\n if (buffer != 0) {\r\n memset(buffer,'a',4096);\r\n \r\n \r\n\r\n memset(&buffer[len],'b',4096 - len);\r\n \r\n buffer[4095] = 0;\r\n printf(\"%s\\n\",buffer);\r\n free(buffer);\r\n }\r\n } else {\r\n printf(\"Number is too large to use\\n\");\r\n }\r\n \r\n \r\n;\r\n if ( *( *udos_wamel) != 0) \r\n free(((char *)( *( *udos_wamel))));\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-839:Numeric Range Comparison Without Minimum Check|A.CWE-1023:Incomplete Comparison with Missing Factors", "cwe": "839"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-506:Embedded Malicious Code\nC.CWE-510:Trapdoor\nD.No Vulnerabilities\nE.CWE-829:Inclusion of Functionality from Untrusted Control Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_connection_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(80);\r\n \r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_connection_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-510:Trapdoor|B.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-215:Insertion of Sensitive Information Into Debugging Code\nB.No Vulnerabilities\nC.CWE-344:Use of Invariant Value in Dynamically Changing Context\nD.CWE-506:Embedded Malicious Code\nE.CWE-511:Logic/Time Bomb\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define COUNT_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_counter_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\nvoid My_counter_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_counter_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_counter_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-511:Logic/Time Bomb|D.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.CWE-6:J2EE Misconfiguration: Insufficient Session-ID Length\nC.CWE-459:Incomplete Cleanup\nD.CWE-693:Protection Mechanism Failure\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_declare_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_declare_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_declare_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_declare_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|C.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-427:Uncontrolled Search Path Element\nC.CWE-1335:Incorrect Bitwise Shift of Integer\nD.CWE-792:Incomplete Filtering of One or More Instances of Special Elements\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_console_66bSink(char * dataArray[]);\r\n\r\nvoid My_char_console_66()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (250-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n \r\n dataArray[2] = data;\r\n My_char_console_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_console_66bG2BSink(char * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n \r\n strcat(data, NEW_PATH);\r\n dataArray[2] = data;\r\n My_char_console_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_char_console_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-427:Uncontrolled Search Path Element|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-122:Heap-based Buffer Overflow\nC.CWE-1312:Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\nD.CWE-291:Reliance on IP Address for Authentication\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_cpp_dest_char_cat_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i;\r\n char * data;\r\n data = NULL;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = new char[50];\r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n char * data;\r\n data = NULL;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = new char[100];\r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_cpp_dest_char_cat_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-122:Heap-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1056:Invokable Control Element with Variadic Parameters\nB.CWE-749:Exposed Dangerous Method or Function\nC.No Vulnerabilities\nD.CWE-284:Improper Access Control\nE.CWE-281:Improper Preservation of Permissions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateDesktop_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n HDESK hDesk;\r\n wchar_t * desktopName = L\"DesktopExample\";\r\n \r\n hDesk = CreateDesktopW(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HDESK hDesk;\r\n wchar_t * desktopName = L\"DesktopExample\";\r\n \r\n hDesk = CreateDesktopW(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n HDESK hDesk;\r\n wchar_t * desktopName = L\"DesktopExample\";\r\n \r\n hDesk = CreateDesktopW(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateDesktop_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateDesktop_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateDesktop_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-284:Improper Access Control|A.CWE-1056:Invokable Control Element with Variadic Parameters", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nB.CWE-511:Logic/Time Bomb\nC.No Vulnerabilities\nD.CWE-788:Access of Memory Location After End of Buffer\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define COUNT_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_counter_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\nvoid My_counter_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_counter_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_counter_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-511:Logic/Time Bomb|E.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.No Vulnerabilities\nC.CWE-1056:Invokable Control Element with Variadic Parameters\nD.CWE-259:Use of Hard-coded Password\nE.CWE-698:Execution After Redirect (EAR)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_16()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n while(1)\r\n {\r\n \r\n strcpy(password, PASSWORD);\r\n break;\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n while(1)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n break;\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-259:Use of Hard-coded Password|A.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-34:Path Traversal: '....//'\nD.No Vulnerabilities\nE.CWE-1065:Runtime Resource Management Control Element in a Component Built to Run on Application Servers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <process.h>\r\n#define EXECVP _wexecvp\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_connect_socket_w32_execvp_10()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_w32_execvp_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_w32_execvp_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_w32_execvp_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-1310:Missing Ability to Patch ROM Code\nD.CWE-1241:Use of Predictable Algorithm in Random Number Generator\nE.CWE-400:Uncontrolled Resource Consumption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define SENTENCE \"This is the sentence we are printing to the file. \"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fscanf_fwrite_51bSink(int count);\r\n\r\nvoid My_fscanf_fwrite_51()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n My_fscanf_fwrite_51bSink(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fscanf_fwrite_51bG2BSink(int count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n My_fscanf_fwrite_51bG2BSink(count);\r\n}\r\n\r\n\r\nvoid My_fscanf_fwrite_51bB2GSink(int count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n My_fscanf_fwrite_51bB2GSink(count);\r\n}\r\n\r\nvoid My_fscanf_fwrite_51()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_fwrite_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_fwrite_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-400:Uncontrolled Resource Consumption|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.No Vulnerabilities\nC.CWE-788:Access of Memory Location After End of Buffer\nD.CWE-1190:DMA Device Enabled Too Early in Boot Phase\nE.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE170_char_loop_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|C.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1263:Improper Physical Access Control\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.No Vulnerabilities\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.CWE-477:Use of Obsolete Function\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <process.h>\r\n#define EXECVP _wexecvp\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_file_w32_execvp_03()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_file_w32_execvp_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_file_w32_execvp_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_file_w32_execvp_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-797:Only Filtering Special Elements at an Absolute Position\nC.No Vulnerabilities\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-590:Free of Memory not on the Heap\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_array_int_declare_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i;\r\n int * data;\r\n data = NULL; \r\n for(i = 0; i < 1; i++)\r\n {\r\n {\r\n \r\n int dataBuffer[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printIntLine(data[0]);\r\n \r\n delete [] data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n int * data;\r\n data = NULL; \r\n for(h = 0; h < 1; h++)\r\n {\r\n {\r\n \r\n int * dataBuffer = new int[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printIntLine(data[0]);\r\n \r\n delete [] data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_int_declare_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-590:Free of Memory not on the Heap|D.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-54:Path Equivalence: 'filedir\\' (Trailing Backslash)\nB.CWE-451:User Interface (UI) Misrepresentation of Critical Information\nC.CWE-105:Struts: Form Field Without Validator\nD.No Vulnerabilities\nE.CWE-663:Use of a Non-reentrant Function in a Concurrent Context\n", "input": "struct inode *read_inode_4(unsigned int start_block, unsigned int offset)\r\r\n{\r\r\n\tstatic union squashfs_inode_header header;\r\r\n\tlong long start = sBlk.s.inode_table_start + start_block;\r\r\n\tlong long bytes = lookup_entry(inode_table_hash, start);\r\r\n\tchar *block_ptr = inode_table + bytes + offset;\r\r\n\tstatic struct inode i;\r\r\n\r\r\n\tTRACE(\"read_inode: reading inode [%d:%d]\\n\", start_block, offset);\r\r\n\r\r\n\tif(bytes == -1)\r\r\n\t\tEXIT_UNSQUASH(\"read_inode: inode table block %lld not found\\n\",\r\r\n\t\t\tstart); \t\t\r\r\n\r\r\n\tSQUASHFS_SWAP_BASE_INODE_HEADER(block_ptr, &header.base);\r\r\n\r\r\n\ti.uid = (uid_t) id_table[header.base.uid];\r\r\n\ti.gid = (uid_t) id_table[header.base.guid];\r\r\n\ti.mode = lookup_type[header.base.inode_type] | header.base.mode;\r\r\n\ti.type = header.base.inode_type;\r\r\n\ti.time = header.base.mtime;\r\r\n\ti.inode_number = header.base.inode_number;\r\r\n\r\r\n\tswitch(header.base.inode_type) {\r\r\n\t\tcase SQUASHFS_DIR_TYPE: {\r\r\n\t\t\tstruct squashfs_dir_inode_header *inode = &header.dir;\r\r\n\r\r\n\t\t\tSQUASHFS_SWAP_DIR_INODE_HEADER(block_ptr, inode);\r\r\n\r\r\n\t\t\ti.data = inode->file_size;\r\r\n\t\t\ti.offset = inode->offset;\r\r\n\t\t\ti.start = inode->start_block;\r\r\n\t\t\ti.xattr = SQUASHFS_INVALID_XATTR;\r\r\n\t\t\tbreak;\r\r\n\t\t}\r\r\n\t\tcase SQUASHFS_LDIR_TYPE: {\r\r\n\t\t\tstruct squashfs_ldir_inode_header *inode = &header.ldir;\r\r\n\r\r\n\t\t\tSQUASHFS_SWAP_LDIR_INODE_HEADER(block_ptr, inode);\r\r\n\r\r\n\t\t\ti.data = inode->file_size;\r\r\n\t\t\ti.offset = inode->offset;\r\r\n\t\t\ti.start = inode->start_block;\r\r\n\t\t\ti.xattr = inode->xattr;\r\r\n\t\t\tbreak;\r\r\n\t\t}\r\r\n\t\tcase SQUASHFS_FILE_TYPE: {\r\r\n\t\t\tstruct squashfs_reg_inode_header *inode = &header.reg;\r\r\n\r\r\n\t\t\tSQUASHFS_SWAP_REG_INODE_HEADER(block_ptr, inode);\r\r\n\r\r\n\t\t\ti.data = inode->file_size;\r\r\n\t\t\ti.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG\r\r\n\t\t\t\t? 0 : inode->file_size % sBlk.s.block_size;\r\r\n\t\t\ti.fragment = inode->fragment;\r\r\n\t\t\ti.offset = inode->offset;\r\r\n\t\t\ti.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?\r\r\n\t\t\t\t(i.data + sBlk.s.block_size - 1) >>\r\r\n\t\t\t\tsBlk.s.block_log :\r\r\n\t\t\t\ti.data >> sBlk.s.block_log;\r\r\n\t\t\ti.start = inode->start_block;\r\r\n\t\t\ti.sparse = 0;\r\r\n\t\t\ti.block_ptr = block_ptr + sizeof(*inode);\r\r\n\t\t\ti.xattr = SQUASHFS_INVALID_XATTR;\r\r\n\t\t\tbreak;\r\r\n\t\t}\t\r\r\n\t\tcase SQUASHFS_LREG_TYPE: {\r\r\n\t\t\tstruct squashfs_lreg_inode_header *inode = &header.lreg;\r\r\n\r\r\n\t\t\tSQUASHFS_SWAP_LREG_INODE_HEADER(block_ptr, inode);\r\r\n\r\r\n\t\t\ti.data = inode->file_size;\r\r\n\t\t\ti.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG\r\r\n\t\t\t\t? 0 : inode->file_size % sBlk.s.block_size;\r\r\n\t\t\ti.fragment = inode->fragment;\r\r\n\t\t\ti.offset = inode->offset;\r\r\n\t\t\ti.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?\r\r\n\t\t\t\t(inode->file_size + sBlk.s.block_size - 1) >>\r\r\n\t\t\t\tsBlk.s.block_log :\r\r\n\t\t\t\tinode->file_size >> sBlk.s.block_log;\r\r\n\t\t\ti.start = inode->start_block;\r\r\n\t\t\ti.sparse = inode->sparse != 0;\r\r\n\t\t\ti.block_ptr = block_ptr + sizeof(*inode);\r\r\n\t\t\ti.xattr = inode->xattr;\r\r\n\t\t\tbreak;\r\r\n\t\t}\t\r\r\n\t\tcase SQUASHFS_SYMLINK_TYPE:\r\r\n\t\tcase SQUASHFS_LSYMLINK_TYPE: {\r\r\n\t\t\tstruct squashfs_symlink_inode_header *inode = &header.symlink;\r\r\n\r\r\n\t\t\tSQUASHFS_SWAP_SYMLINK_INODE_HEADER(block_ptr, inode);\r\r\n\r\r\n\t\t\ti.symlink = malloc(inode->symlink_size + 1);\r\r\n\t\t\tif(i.symlink == NULL)\r\r\n\t\t\t\tEXIT_UNSQUASH(\"read_inode: failed to malloc \"\r\r\n\t\t\t\t\t\"symlink data\\n\");\r\r\n\t\t\tstrncpy(i.symlink, block_ptr +\r\r\n\t\t\t\tsizeof(struct squashfs_symlink_inode_header),\r\r\n\t\t\t\tinode->symlink_size);\r\r\n\t\t\ti.symlink[inode->symlink_size] = '\\0';\r\r\n\t\t\ti.data = inode->symlink_size;\r\r\n\r\r\n\t\t\tif(header.base.inode_type == SQUASHFS_LSYMLINK_TYPE)\r\r\n\t\t\t\tSQUASHFS_SWAP_INTS(block_ptr +\r\r\n\t\t\t\t\tsizeof(struct squashfs_symlink_inode_header) +\r\r\n\t\t\t\t\tinode->symlink_size, &i.xattr, 1);\r\r\n\t\t\telse\r\r\n\t\t\t\ti.xattr = SQUASHFS_INVALID_XATTR;\r\r\n\t\t\tbreak;\r\r\n\t\t}\r\r\n \t\tcase SQUASHFS_BLKDEV_TYPE:\r\r\n\t \tcase SQUASHFS_CHRDEV_TYPE: {\r\r\n\t\t\tstruct squashfs_dev_inode_header *inode = &header.dev;\r\r\n\r\r\n\t\t\tSQUASHFS_SWAP_DEV_INODE_HEADER(block_ptr, inode);\r\r\n\r\r\n\t\t\ti.data = inode->rdev;\r\r\n\t\t\ti.xattr = SQUASHFS_INVALID_XATTR;\r\r\n\t\t\tbreak;\r\r\n\t\t}\r\r\n \t\tcase SQUASHFS_LBLKDEV_TYPE:\r\r\n\t \tcase SQUASHFS_LCHRDEV_TYPE: {\r\r\n\t\t\tstruct squashfs_ldev_inode_header *inode = &header.ldev;\r\r\n\r\r\n\t\t\tSQUASHFS_SWAP_LDEV_INODE_HEADER(block_ptr, inode);\r\r\n\r\r\n\t\t\ti.data = inode->rdev;\r\r\n\t\t\ti.xattr = inode->xattr;\r\r\n\t\t\tbreak;\r\r\n\t\t}\r\r\n\t\tcase SQUASHFS_FIFO_TYPE:\r\r\n\t\tcase SQUASHFS_SOCKET_TYPE:\r\r\n\t\t\ti.data = 0;\r\r\n\t\t\ti.xattr = SQUASHFS_INVALID_XATTR;\r\r\n\t\t\tbreak;\r\r\n\t\tcase SQUASHFS_LFIFO_TYPE:\r\r\n\t\tcase SQUASHFS_LSOCKET_TYPE: {\r\r\n\t\t\tstruct squashfs_lipc_inode_header *inode = &header.lipc;\r\r\n\r\r\n\t\t\tSQUASHFS_SWAP_LIPC_INODE_HEADER(block_ptr, inode);\r\r\n\r\r\n\t\t\ti.data = 0;\r\r\n\t\t\ti.xattr = inode->xattr;\r\r\n\t\t\tbreak;\r\r\n\t\t}\r\r\n\t\tdefault:\r\r\n\t\t\tEXIT_UNSQUASH(\"Unknown inode type %d in read_inode!\\n\",\r\r\n\t\t\t\theader.base.inode_type);\r\r\n\t}\r\r\n\treturn &i;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.No Vulnerabilities|D.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-256:Plaintext Storage of a Password\nC.CWE-697:Incorrect Comparison\nD.CWE-197:Numeric Truncation Error\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_54bSink(wchar_t * data);\r\n\r\nvoid My_w32_wchar_t_54()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n My_w32_wchar_t_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_54bG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n My_w32_wchar_t_54bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_w32_wchar_t_54bB2GSink(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n My_w32_wchar_t_54bB2GSink(data);\r\n}\r\n\r\nvoid My_w32_wchar_t_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-256:Plaintext Storage of a Password|E.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-238:Improper Handling of Incomplete Structural Elements\nB.CWE-419:Unprotected Primary Channel\nC.CWE-284:Improper Access Control\nD.CWE-280:Improper Handling of Insufficient Permissions or Privileges \nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n#define BUFSIZE 1024\r\n#define PIPE_NAME \"\\\\\\\\.\\\\pipe\\\\TestPipe\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateNamedPipe_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE | PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE | PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateNamedPipe_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateNamedPipe_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateNamedPipe_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-284:Improper Access Control|B.CWE-419:Unprotected Primary Channel", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-1070:Serializable Data Element Containing non-Serializable Item Elements\nE.CWE-1094:Excessive Index Range Scan for a Data Resource\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\nchar * My_w32_char_console_68Data;\r\nchar * My_w32_char_console_68G2BData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_console_68bSink();\r\n\r\nvoid My_w32_char_console_68()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (256-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n My_w32_char_console_68Data = data;\r\n My_w32_char_console_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_console_68bG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n My_w32_char_console_68G2BData = data;\r\n My_w32_char_console_68bG2BSink();\r\n}\r\n\r\nvoid My_w32_char_console_68()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_console_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_console_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-129:Improper Validation of Array Index\nC.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-20:Improper Input Validation\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint steeves_ashman = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint single_global_variable = 0;\r\nint canary_function_1()\r\n{\r\n \r\n ++single_global_variable;\r\n return 1;\r\n}\r\nint canary_function_2()\r\n{\r\n \r\n ++single_global_variable;\r\n return 2;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int i = 0;\r\n int index;\r\n int (*after_ptr[1])();\r\n unsigned char count[62];\r\n int (*before_ptr[1])();\r\n char str_buf[40] = {0};\r\n char *medjidieh_parava = 0;\r\n int negritising_twinborn;\r\n int sensomobile_industrialness;\r\n char **patand_cytophysics = 0;\r\n int *nonrevocation_marylyn = 0;\r\n int wadai_undissuadably;\r\n char **fieldale_riflescope[10] = {0};\r\n char *mockup_drugeteria[94] = {0};\r\n char *dogbush_sornari;;\r\n if (__sync_bool_compare_and_swap(&steeves_ashman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&dogbush_sornari,\"MACROBIUS_DEBITED\");\r\n if (dogbush_sornari != 0) {;\r\n mockup_drugeteria[27] = dogbush_sornari;\r\n wadai_undissuadably = 5;\r\n nonrevocation_marylyn = &wadai_undissuadably;\r\n fieldale_riflescope[ *nonrevocation_marylyn] = mockup_drugeteria;\r\n patand_cytophysics = fieldale_riflescope[ *nonrevocation_marylyn];\r\n sensomobile_industrialness = 5;\r\n while(1 == 1){\r\n sensomobile_industrialness = sensomobile_industrialness * 2;\r\n sensomobile_industrialness = sensomobile_industrialness + 2;\r\n if (sensomobile_industrialness > 1000) {\r\n break; \r\n }\r\n }\r\n negritising_twinborn = sensomobile_industrialness;\r\n medjidieh_parava = ((char *)patand_cytophysics[27]);\r\n \r\n strncpy(str_buf,medjidieh_parava,39);\r\n str_buf[39] = 0;\r\n for (i = 0; i < 62; i++) {\r\n count[i] = 0;\r\n }\r\n if (strlen(str_buf) > 1 && str_buf[0] > 'a') {\r\n before_ptr[0] = canary_function_1;\r\n after_ptr[0] = canary_function_1;\r\n }\r\n else {\r\n before_ptr[0] = canary_function_2;\r\n after_ptr[0] = canary_function_2;\r\n }\r\n \r\n \r\n for (i = 0; i < strlen(str_buf); i++)\r\n \r\n \r\n {\r\n if (str_buf[i] > 96) {\r\n index = str_buf[i] - 'a' + 36;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else if (str_buf[i] < 58) {\r\n index = str_buf[i] - 48;\r\n \r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else {\r\n index = str_buf[i] - 'A' + 10;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n }\r\n \r\n \r\n for (i = 0; i < 62; i++) {\r\n printf(\"index %d: %d\\n\",i,count[i]);\r\n }\r\n printf(\"%d\\n\",before_ptr[0]());\r\n printf(\"%d\\n\",after_ptr[0]());\r\n \r\n;\r\n if (patand_cytophysics[27] != 0) \r\n free(((char *)patand_cytophysics[27]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-129:Improper Validation of Array Index|E.CWE-20:Improper Input Validation", "cwe": "129"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1234:Hardware Internal or Debug Modes Allow Override of Locks\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-15:External Control of System or Configuration Setting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_wchar_t_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<wchar_t *> cryptoKeyList);\r\n\r\nvoid m()\r\n{\r\n wchar_t * cryptoKey;\r\n list<wchar_t *> cryptoKeyList;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n \r\n cryptoKeyList.push_back(cryptoKey);\r\n cryptoKeyList.push_back(cryptoKey);\r\n cryptoKeyList.push_back(cryptoKey);\r\n mSink(cryptoKeyList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<wchar_t *> cryptoKeyList);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * cryptoKey;\r\n list<wchar_t *> cryptoKeyList;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n \r\n cryptoKeyList.push_back(cryptoKey);\r\n cryptoKeyList.push_back(cryptoKey);\r\n cryptoKeyList.push_back(cryptoKey);\r\n nG2BSink(cryptoKeyList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|D.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-673:External Influence of Sphere Definition\nC.CWE-426:Untrusted Search Path\nD.CWE-160:Improper Neutralization of Leading Special Elements\nE.CWE-511:Logic/Time Bomb\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM _wsystem\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic wchar_t * mSource(wchar_t * data)\r\n{\r\n \r\n wcscpy(data, M_OS_COMMAND);\r\n return data;\r\n}\r\n\r\nvoid My_wchar_t_system_42()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = mSource(data);\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic wchar_t * nG2BSource(wchar_t * data)\r\n{\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n return data;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_system_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_system_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_system_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-426:Untrusted Search Path|B.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-420:Unprotected Alternate Channel\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-121:Stack-based Buffer Overflow\nE.CWE-188:Reliance on Data/Memory Layout\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_My_My_My_My_My_My_My_CWE129_fgets_81_base\r\n{\r\npublic:\r\n void action(int data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-121:Stack-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-693:Protection Mechanism Failure\nB.CWE-822:Untrusted Pointer Dereference\nC.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nD.No Vulnerabilities\nE.CWE-31:Path Traversal: 'dir\\..\\..\\filename'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RC5_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_RC5_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RC5_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RC5_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|A.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-940:Improper Verification of Source of a Communication Channel\nB.CWE-546:Suspicious Comment\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2int_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double2int_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2int_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2int_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-681:Incorrect Conversion between Numeric Types|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-112:Missing XML Validation\nB.No Vulnerabilities\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-321:Use of Hard-coded Cryptographic Key\nE.CWE-1177:Use of Prohibited Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\nnamespace My_w32_char_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(char * &cryptoKey);\r\n\r\nvoid m()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n mSource(cryptoKey);\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(char * &cryptoKey);\r\n\r\nstatic void nG2B()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n nG2BSource(cryptoKey);\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-321:Use of Hard-coded Cryptographic Key|C.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-267:Privilege Defined With Unsafe Actions\nC.CWE-427:Uncontrolled Search Path Element\nD.No Vulnerabilities\nE.CWE-1265:Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_connect_socket_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_char_connect_socket_64()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_char_connect_socket_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_connect_socket_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n \r\n strcat(data, NEW_PATH);\r\n My_char_connect_socket_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_char_connect_socket_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-427:Uncontrolled Search Path Element|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-335:Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\nE.CWE-124:Buffer Underwrite ('Buffer Underflow')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_loop_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_wchar_t_loop_83\r\n{\r\npublic:\r\n My_new_wchar_t_loop_83(wchar_t * dataCopy);\r\n ~My_new_wchar_t_loop_83();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_wchar_t_loop_83G2B\r\n{\r\npublic:\r\n My_new_wchar_t_loop_83G2B(wchar_t * dataCopy);\r\n ~My_new_wchar_t_loop_83G2B();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-124:Buffer Underwrite ('Buffer Underflow')|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.No Vulnerabilities\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.CWE-1045:Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor\nE.CWE-521:Weak Password Requirements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_accept_bind_listen_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_accept_bind_listen_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_accept_bind_listen_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_accept_bind_listen_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-666:Operation on Resource in Wrong Phase of Lifetime|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nB.No Vulnerabilities\nC.CWE-124:Buffer Underwrite ('Buffer Underflow')\nD.CWE-184:Incomplete List of Disallowed Inputs\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_char_memmove_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_malloc_char_memmove_83\r\n{\r\npublic:\r\n My_malloc_char_memmove_83(char * dataCopy);\r\n ~My_malloc_char_memmove_83();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_malloc_char_memmove_83G2B\r\n{\r\npublic:\r\n My_malloc_char_memmove_83G2B(char * dataCopy);\r\n ~My_malloc_char_memmove_83G2B();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-124:Buffer Underwrite ('Buffer Underflow')|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-195:Signed to Unsigned Conversion Error\nC.CWE-256:Plaintext Storage of a Password\nD.CWE-1293:Missing Source Correlation of Multiple Independent Data\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_63bSink(char * * dataPtr);\r\n\r\nvoid My_w32_char_63()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_63bG2BSink(char * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n My_w32_char_63bG2BSink(&data);\r\n}\r\n\r\n\r\nvoid My_w32_char_63bB2GSink(char * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_63bB2GSink(&data);\r\n}\r\n\r\nvoid My_w32_char_63()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|E.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-450:Multiple Interpretations of UI Input\nB.No Vulnerabilities\nC.CWE-1048:Invokable Control Element with Large Number of Outward Calls\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-127:Buffer Under-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_char_ncpy_01()\r\n{\r\n char * data;\r\n data = NULL;\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n strncpy(dest, data, strlen(dest));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n data = NULL;\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n strncpy(dest, data, strlen(dest));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_char_ncpy_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_char_ncpy_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_char_ncpy_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-194:Unexpected Sign Extension\nB.CWE-1075:Unconditional Control Flow Transfer outside of Switch Block\nC.No Vulnerabilities\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-1121:Excessive McCabe Cyclomatic Complexity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_fscanf_memmove_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<short> dataList);\r\n\r\nvoid m()\r\n{\r\n short data;\r\n list<short> dataList;\r\n \r\n data = 0;\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<short> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n list<short> dataList;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fscanf_memmove_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-194:Unexpected Sign Extension|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-231:Improper Handling of Extra Values\nB.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-780:Use of RSA Algorithm without OAEP\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32CreateFile_no_close_66bSink(HANDLE dataArray[]);\r\n\r\nvoid My_w32CreateFile_no_close_66()\r\n{\r\n HANDLE data;\r\n HANDLE dataArray[5];\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n dataArray[2] = data;\r\n My_w32CreateFile_no_close_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32CreateFile_no_close_66bB2GSink(HANDLE dataArray[]);\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n HANDLE dataArray[5];\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n dataArray[2] = data;\r\n My_w32CreateFile_no_close_66bB2GSink(dataArray);\r\n}\r\n\r\nvoid My_w32CreateFile_no_close_66()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_no_close_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_no_close_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-190:Integer Overflow or Wraparound\nB.No Vulnerabilities\nC.CWE-315:Cleartext Storage of Sensitive Information in a Cookie\nD.CWE-680:Integer Overflow to Buffer Overflow\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_listen_socket_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, int> dataMap);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, int> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = 20;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_listen_socket_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-680:Integer Overflow to Buffer Overflow|A.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1236:Improper Neutralization of Formula Elements in a CSV File\nB.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nC.CWE-143:Improper Neutralization of Record Delimiters\nD.No Vulnerabilities\nE.CWE-413:Improper Resource Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\nchar * My_w32_char_68Data;\r\nchar * My_w32_char_68G2BData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_68bSink();\r\n\r\nvoid My_w32_char_68()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_68Data = password;\r\n My_w32_char_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_68bG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_68G2BData = password;\r\n My_w32_char_68bG2BSink();\r\n}\r\n\r\nvoid My_w32_char_68()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-591:Sensitive Data Storage in Improperly Locked Memory|E.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nB.No Vulnerabilities\nC.CWE-1224:Improper Restriction of Write-Once Bit Fields\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic wchar_t * mSource(wchar_t * data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_21()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n mStatic = 1; \r\n data = mSource(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic wchar_t * nG2B1Source(wchar_t * data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic wchar_t * nG2B2Source(wchar_t * data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-155:Improper Neutralization of Wildcards or Matching Symbols\nC.CWE-665:Improper Initialization\nD.CWE-1287:Improper Validation of Specified Type of Input\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_cat_10()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n \r\n ; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_cat_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_cat_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_cat_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-195:Signed to Unsigned Conversion Error\nB.CWE-636:Not Failing Securely ('Failing Open')\nC.No Vulnerabilities\nD.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fscanf_memcpy_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_fscanf_memcpy_64()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n My_fscanf_memcpy_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fscanf_memcpy_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n My_fscanf_memcpy_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_fscanf_memcpy_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_memcpy_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_memcpy_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-195:Signed to Unsigned Conversion Error|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-290:Authentication Bypass by Spoofing\nD.CWE-1164:Irrelevant Code\nE.CWE-23:Relative Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_char_connect_socket_open_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_connect_socket_open_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-23:Relative Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-749:Exposed Dangerous Method or Function\nC.No Vulnerabilities\nD.CWE-687:Function Call With Incorrectly Specified Argument Value\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i,j;\r\n list<int> data;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int i,k;\r\n list<int> data;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h,j;\r\n list<int> data;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-672:Operation on a Resource after Expiration or Release|A.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-402:Transmission of Private Resources into a New Sphere ('Resource Leak')\nB.CWE-558:Use of getlogin() in Multithreaded Application\nC.CWE-693:Protection Mechanism Failure\nD.No Vulnerabilities\nE.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RC5_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_RC5_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RC5_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RC5_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|C.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-415:Double Free\nB.No Vulnerabilities\nC.CWE-283:Unverified Ownership\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-186:Overly Restrictive Regular Expression\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_struct_12()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n }\r\n else\r\n {\r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n free(data);\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n }\r\n else\r\n {\r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n }\r\n else\r\n {\r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n free(data);\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_malloc_free_struct_12()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_struct_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_struct_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-415:Double Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-554:ASP.NET Misconfiguration: Not Using Input Validation Framework\nC.CWE-401:Missing Release of Memory after Effective Lifetime\nD.CWE-1314:Missing Write Protection for Parametric Data Values\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nwchar_t * My_wchar_t_calloc_68Data;\r\nwchar_t * My_wchar_t_calloc_68G2BData;\r\nwchar_t * My_wchar_t_calloc_68B2GData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_calloc_68bSink();\r\n\r\nvoid My_wchar_t_calloc_68()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n My_wchar_t_calloc_68Data = data;\r\n My_wchar_t_calloc_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_calloc_68bG2BSink();\r\nvoid My_wchar_t_calloc_68bB2GSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n My_wchar_t_calloc_68G2BData = data;\r\n My_wchar_t_calloc_68bG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n My_wchar_t_calloc_68B2GData = data;\r\n My_wchar_t_calloc_68bB2GSink();\r\n}\r\n\r\nvoid My_wchar_t_calloc_68()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_calloc_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_calloc_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-401:Missing Release of Memory after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-284:Improper Access Control\nB.CWE-286:Incorrect User Management\nC.No Vulnerabilities\nD.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nE.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateDesktop_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateDesktop_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateDesktop_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateDesktop_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-284:Improper Access Control|D.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-164:Improper Neutralization of Internal Special Elements\nD.CWE-1391:Use of Weak Credentials\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_int_calloc_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(int * &data);\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n data = NULL;\r\n mSource(data);\r\n \r\n ; \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(int * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n ; \r\n}\r\n\r\n\r\nvoid nB2GSource(int * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n free(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_calloc_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-562:Return of Stack Variable Address\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-590:Free of Memory not on the Heap\nE.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_free_struct_declare_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<twoIntsStruct *> dataList);\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n list<twoIntsStruct *> dataList;\r\n data = NULL; \r\n {\r\n \r\n twoIntsStruct dataBuffer[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i].intOne = 1;\r\n dataBuffer[i].intTwo = 1;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<twoIntsStruct *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n list<twoIntsStruct *> dataList;\r\n data = NULL; \r\n {\r\n \r\n twoIntsStruct * dataBuffer = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i].intOne = 1;\r\n dataBuffer[i].intTwo = 1;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_free_struct_declare_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-364:Signal Handler Race Condition\nC.CWE-546:Suspicious Comment\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.CWE-1247:Improper Protection Against Voltage and Clock Glitches\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_FIXME_03()\r\n{\r\n if(5==5)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_FIXME_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_FIXME_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_FIXME_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.No Vulnerabilities\nC.CWE-300:Channel Accessible by Non-Endpoint\nD.CWE-645:Overly Restrictive Account Lockout Mechanism\nE.CWE-415:Double Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_class_22\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint mGlobal = 0;\r\n\r\nvoid mSink(TwoIntsClass * data);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n delete [] data;\r\n mGlobal = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint nB2G1Global = 0;\r\nint nB2G2Global = 0;\r\nint nG2B1Global = 0;\r\n\r\n\r\nvoid nB2G1Sink(TwoIntsClass * data);\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n delete [] data;\r\n nB2G1Global = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nvoid nB2G2Sink(TwoIntsClass * data);\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n delete [] data;\r\n nB2G2Global = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nvoid nG2B1Sink(TwoIntsClass * data);\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n nG2B1Global = 1; \r\n nG2B1Sink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_class_22; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-415:Double Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.CWE-260:Password in Configuration File\nC.No Vulnerabilities\nD.CWE-439:Behavioral Change in New Version or Environment\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_environment_ofstream_65\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(char * data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n funcPtr(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_ofstream_65; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-36:Absolute Path Traversal|E.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-1086:Class with Excessive Number of Child Classes\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-1248:Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_accept_bind_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_accept_bind_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_accept_bind_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_accept_bind_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-666:Operation on Resource in Wrong Phase of Lifetime|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-469:Use of Pointer Subtraction to Determine Size\nB.No Vulnerabilities\nC.CWE-242:Use of Inherently Dangerous Function\nD.CWE-682:Incorrect Calculation\nE.CWE-1257:Improper Access Control Applied to Mirrored or Aliased Memory Regions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SOURCE_STRING \"abc/opqrstu\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char string2[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string2);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-469:Use of Pointer Subtraction to Determine Size|D.CWE-682:Incorrect Calculation", "cwe": "469"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.No Vulnerabilities\nC.CWE-510:Trapdoor\nD.CWE-274:Improper Handling of Insufficient Privileges\nE.CWE-470:Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <ws2tcpip.h>\r\n#else\r\n#include <netdb.h>\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_hostname_based_logic_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char hostname[NI_MAXHOST];\r\n char servInfo[NI_MAXSERV];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n if (getnameinfo((struct sockaddr *)&acceptService,\r\n sizeof(struct sockaddr),\r\n hostname,\r\n NI_MAXHOST, servInfo, NI_MAXSERV, NI_NUMERICSERV) != 0)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"admin.google.com\", hostname) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_hostname_based_logic_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_hostname_based_logic_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_hostname_based_logic_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-510:Trapdoor|A.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.No Vulnerabilities\nC.CWE-151:Improper Neutralization of Comment Delimiters\nD.CWE-393:Return of Wrong Status Code\nE.CWE-36:Absolute Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\nnamespace My_wchar_t_environment_w32CreateFile_21\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic wchar_t * mSource(wchar_t * data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n mStatic = 1; \r\n data = mSource(data);\r\n {\r\n HANDLE hFile;\r\n \r\n hFile = CreateFileW(data,\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n ;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic wchar_t * nG2B1Source(wchar_t * data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n {\r\n HANDLE hFile;\r\n \r\n hFile = CreateFileW(data,\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n ;\r\n}\r\n\r\n\r\nstatic wchar_t * nG2B2Source(wchar_t * data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n {\r\n HANDLE hFile;\r\n \r\n hFile = CreateFileW(data,\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n ;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_environment_w32CreateFile_21; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-36:Absolute Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-282:Improper Ownership Management\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-369:Divide By Zero\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_accept_bind_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_accept_bind_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_accept_bind_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_accept_bind_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-666:Operation on Resource in Wrong Phase of Lifetime|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-79:Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nE.CWE-1109:Use of Same Variable for Multiple Purposes\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_03()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(5==5)\r\n {\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(5==5)\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-174:Double Decoding of the Same Data\nB.No Vulnerabilities\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-1117:Callable with Insufficient Behavioral Summary\nE.CWE-771:Missing Reference to Active Allocated Resource\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_14()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(globalFive==5)\r\n {\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(globalFive==5)\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|E.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1099:Inconsistent Naming Conventions for Identifiers\nB.CWE-606:Unchecked Input for Loop Condition\nC.CWE-1284:Improper Validation of Specified Quantity in Input\nD.No Vulnerabilities\nE.CWE-279:Incorrect Execution-Assigned Permissions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\nnamespace My_char_environment_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(char * &data)\r\n{\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(char * &data)\r\n{\r\n \r\n strcpy(data, \"15\");\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2GSource(char * &data)\r\n{\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n nB2GSource(data);\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-606:Unchecked Input for Loop Condition|C.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.CWE-129:Improper Validation of Array Index\nD.No Vulnerabilities\nE.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_calloc_18()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));\r\n goto sink;\r\nsink:\r\n \r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));\r\n goto sink;\r\nsink:\r\n \r\n if (data != NULL)\r\n {\r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_struct_calloc_18()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_calloc_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_calloc_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-690:Unchecked Return Value to NULL Pointer Dereference|A.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-562:Return of Stack Variable Address\nB.CWE-413:Improper Resource Locking\nC.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nD.CWE-110:Struts: Validator Without Form Field\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_10()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(globalTrue)\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(globalTrue)\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_char_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-591:Sensitive Data Storage in Improperly Locked Memory|B.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-480:Use of Incorrect Operator\nB.No Vulnerabilities\nC.CWE-307:Improper Restriction of Excessive Authentication Attempts\nD.CWE-508:Non-Replicating Malicious Code\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic char* staticStringM = \"Hello\";\r\nstatic char* staticStringN = \"Hello\";\r\n\r\nstatic char * helperM()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringM;\r\n }\r\n}\r\n\r\nstatic char * helperN()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringN;\r\n }\r\n}\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n if(helperM == NULL)\r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if(helperN() == NULL) \r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n if(helperN() == NULL) \r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-480:Use of Incorrect Operator|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "480"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-1224:Improper Restriction of Write-Once Bit Fields\nC.CWE-404:Improper Resource Shutdown or Release\nD.No Vulnerabilities\nE.CWE-627:Dynamic Variable Evaluation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_w32CloseHandle_06()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_w32CloseHandle_06()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_w32CloseHandle_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_w32CloseHandle_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-404:Improper Resource Shutdown or Release|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.CWE-687:Function Call With Incorrectly Specified Argument Value\nC.No Vulnerabilities\nD.CWE-114:Process Control\nE.CWE-340:Generation of Predictable Numbers or Identifiers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_wchar_t_relativePath_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<wchar_t *> dataList);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"winsrv.dll\");\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<wchar_t *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_relativePath_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|A.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-178:Improper Handling of Case Sensitivity\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-455:Non-exit on Failed Initialization\nE.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * data)\r\n{\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_connect_socket_44()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * data)\r\n{\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_w32_wchar_t_connect_socket_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_connect_socket_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_connect_socket_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-472:External Control of Assumed-Immutable Web Parameter\nB.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nC.No Vulnerabilities\nD.CWE-806:Buffer Access Using Size of Source Buffer\nE.CWE-693:Protection Mechanism Failure\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_DES_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_DES_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_DES_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_DES_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|E.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nB.CWE-554:ASP.NET Misconfiguration: Not Using Input Validation Framework\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_realloc_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(wchar_t));\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_realloc_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_realloc_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_realloc_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|D.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-396:Declaration of Catch for Generic Exception\nB.CWE-705:Incorrect Control Flow Scoping\nC.No Vulnerabilities\nD.CWE-1209:Failure to Disable Reserved Bits\nE.CWE-301:Reflection Attack in an Authentication Protocol\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_exception_and_domain_error_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n catch (domain_error &)\r\n {\r\n \r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_and_domain_error_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-396:Declaration of Catch for Generic Exception|B.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-57:Path Equivalence: 'fakedir/../realdir/filename'\nB.No Vulnerabilities\nC.CWE-563:Assignment to Variable without Use\nD.CWE-172:Encoding Error\nE.CWE-176:Improper Handling of Unicode Encoding\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} My_w32_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_34()\r\n{\r\n wchar_t * data;\r\n My_w32_34_unionType myUnion;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n My_w32_34_unionType myUnion;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n My_w32_34_unionType myUnion;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_34()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-176:Improper Handling of Unicode Encoding|D.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-116:Improper Encoding or Escaping of Output\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-36:Absolute Path Traversal\nD.No Vulnerabilities\nE.CWE-1310:Missing Ability to Patch ROM Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nnamespace My_char_listen_socket_w32CreateFile_67\r\n{\r\n\r\ntypedef struct _structType\r\n{\r\n char * structFirst;\r\n} structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(structType myStruct);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n structType myStruct;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n mSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n structType myStruct;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n myStruct.structFirst = data;\r\n nG2BSink(myStruct);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_w32CreateFile_67; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-36:Absolute Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-234:Failure to Handle Missing Parameter\nB.No Vulnerabilities\nC.CWE-428:Unquoted Search Path or Element\nD.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nE.CWE-1393:Use of Default Password\n", "input": "static int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper)\r\r\n{\r\r\n int64_t restore_pos, last_pos = -1;\r\r\n WavpackStreamReader64 *reader = wpc->reader;\r\r\n int alt_types = wpc->open_flags & OPEN_ALT_TYPES;\r\r\n uint32_t blocks = 0, audio_blocks = 0;\r\r\n void *id = wpc->wv_in;\r\r\n WavpackHeader wphdr;\r\r\n\r\r\n restore_pos = reader->get_pos (id); // we restore file position when done\r\r\n\r\r\n\r\r\n if (reader->get_length (id) > 1048576LL)\r\r\n reader->set_pos_rel (id, -1048576, SEEK_END);\r\r\n else\r\r\n reader->set_pos_abs (id, 0);\r\r\n\r\r\n\r\r\n while (1) {\r\r\n uint32_t bcount = read_next_header (reader, id, &wphdr);\r\r\n int64_t current_pos = reader->get_pos (id);\r\r\n\r\r\n\r\r\n if (current_pos == last_pos) {\r\r\n reader->set_pos_abs (id, restore_pos);\r\r\n return FALSE;\r\r\n }\r\r\n\r\r\n last_pos = current_pos;\r\r\n\r\r\n\r\r\n if (bcount == (uint32_t) -1) {\r\r\n\r\r\n\r\r\n if (!blocks) {\r\r\n if (current_pos > 2000000LL)\r\r\n reader->set_pos_rel (id, -2000000, SEEK_CUR);\r\r\n else\r\r\n reader->set_pos_abs (id, 0);\r\r\n\r\r\n continue;\r\r\n }\r\r\n\r\r\n\r\r\n reader->set_pos_abs (id, restore_pos);\r\r\n return TRUE;\r\r\n }\r\r\n\r\r\n blocks++;\r\r\n\r\r\n\r\r\n if (wphdr.block_samples) {\r\r\n if (final_index)\r\r\n *final_index = GET_BLOCK_INDEX (wphdr) + wphdr.block_samples;\r\r\n\r\r\n audio_blocks++;\r\r\n }\r\r\n else if (!audio_blocks) {\r\r\n if (current_pos > 1048576LL)\r\r\n reader->set_pos_rel (id, -1048576, SEEK_CUR);\r\r\n else\r\r\n reader->set_pos_abs (id, 0);\r\r\n\r\r\n continue;\r\r\n }\r\r\n\r\r\n\r\r\n bcount = wphdr.ckSize - sizeof (WavpackHeader) + 8;\r\r\n\r\r\n while (bcount >= 2) {\r\r\n unsigned char meta_id, c1, c2;\r\r\n uint32_t meta_bc, meta_size;\r\r\n\r\r\n if (reader->read_bytes (id, &meta_id, 1) != 1 ||\r\r\n reader->read_bytes (id, &c1, 1) != 1) {\r\r\n reader->set_pos_abs (id, restore_pos);\r\r\n return FALSE;\r\r\n }\r\r\n\r\r\n meta_bc = c1 << 1;\r\r\n bcount -= 2;\r\r\n\r\r\n if (meta_id & ID_LARGE) {\r\r\n if (bcount < 2 || reader->read_bytes (id, &c1, 1) != 1 ||\r\r\n reader->read_bytes (id, &c2, 1) != 1) {\r\r\n reader->set_pos_abs (id, restore_pos);\r\r\n return FALSE;\r\r\n }\r\r\n\r\r\n meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\r\r\n bcount -= 2;\r\r\n }\r\r\n\r\r\n meta_size = (meta_id & ID_ODD_SIZE) ? meta_bc - 1 : meta_bc;\r\r\n meta_id &= ID_UNIQUE;\r\r\n\r\r\n if (get_wrapper && (meta_id == ID_RIFF_TRAILER || (alt_types && meta_id == ID_ALT_TRAILER)) && meta_bc) {\r\r\n wpc->wrapper_data = realloc (wpc->wrapper_data, wpc->wrapper_bytes + meta_bc);\r\r\n\r\r\n if (!wpc->wrapper_data) {\r\r\n reader->set_pos_abs (id, restore_pos);\r\r\n return FALSE;\r\r\n }\r\r\n\r\r\n if (reader->read_bytes (id, wpc->wrapper_data + wpc->wrapper_bytes, meta_bc) == meta_bc)\r\r\n wpc->wrapper_bytes += meta_size;\r\r\n else {\r\r\n reader->set_pos_abs (id, restore_pos);\r\r\n return FALSE;\r\r\n }\r\r\n }\r\r\n else if (meta_id == ID_MD5_CHECKSUM || (alt_types && meta_id == ID_ALT_MD5_CHECKSUM)) {\r\r\n if (meta_bc == 16 && bcount >= 16) {\r\r\n if (reader->read_bytes (id, wpc->config.md5_checksum, 16) == 16)\r\r\n wpc->config.md5_read = TRUE;\r\r\n else {\r\r\n reader->set_pos_abs (id, restore_pos);\r\r\n return FALSE;\r\r\n }\r\r\n }\r\r\n else\r\r\n reader->set_pos_rel (id, meta_bc, SEEK_CUR);\r\r\n }\r\r\n else\r\r\n reader->set_pos_rel (id, meta_bc, SEEK_CUR);\r\r\n\r\r\n bcount -= meta_bc;\r\r\n }\r\r\n }\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.No Vulnerabilities|B.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-390:Detection of Error Condition Without Action\nB.CWE-538:Insertion of Sensitive Information into Externally-Accessible File or Directory\nC.CWE-176:Improper Handling of Unicode Encoding\nD.CWE-755:Improper Handling of Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_empty_catch_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"Range specified was invalid\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"Range specified was invalid\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_empty_catch_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-390:Detection of Error Condition Without Action|D.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-81:Improper Neutralization of Script in an Error Message Web Page\nB.CWE-548:Exposure of Information Through Directory Listing\nC.CWE-325:Missing Cryptographic Step\nD.No Vulnerabilities\nE.CWE-573:Improper Following of Specification by Caller\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptHashData_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n}\r\n\r\nvoid My_w32_CryptHashData_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptHashData_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptHashData_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-325:Missing Cryptographic Step|E.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-1085:Invokable Control Element with Excessive Volume of Commented-out Code\nC.No Vulnerabilities\nD.CWE-1004:Sensitive Cookie Without 'HttpOnly' Flag\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <process.h>\r\n#define EXECV _execv\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_file_w32_execv_15()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECV(COMMAND_INT_PATH, args);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n strcat(data, \"*.*\");\r\n break;\r\n }\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECV(COMMAND_INT_PATH, args);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n strcat(data, \"*.*\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECV(COMMAND_INT_PATH, args);\r\n }\r\n}\r\n\r\nvoid My_char_file_w32_execv_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_file_w32_execv_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_file_w32_execv_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nC.CWE-652:Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')\nD.CWE-662:Improper Synchronization\nE.CWE-188:Reliance on Data/Memory Layout\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_union_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n union\r\n {\r\n struct\r\n {\r\n char charFirst, charSecond, charThird, charFourth;\r\n } structChars;\r\n long longNumber;\r\n } unionStructLong;\r\n unionStructLong.longNumber = 0x10203040;\r\n \r\n unionStructLong.structChars.charFourth |= 0x80; \r\n printIntLine(unionStructLong.longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_union_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_union_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_union_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-188:Reliance on Data/Memory Layout|B.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-441:Unintended Proxy or Intermediary ('Confused Deputy')\nB.CWE-252:Unchecked Return Value\nC.No Vulnerabilities\nD.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nE.CWE-520:.NET Misconfiguration: Use of Impersonation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_long_calloc_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(long * &data);\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n data = NULL; \r\n mSource(data);\r\n \r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSource(long * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n long * data;\r\n data = NULL; \r\n nB2GSource(data);\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_long_calloc_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-690:Unchecked Return Value to NULL Pointer Dereference|B.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-229:Improper Handling of Values\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-459:Incomplete Cleanup\nD.CWE-489:Active Debug Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _wunlink\r\n#define FOPEN _wfopen\r\n#define MKTEMP _wmktemp\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#define FOPEN fopen\r\n#define MKTEMP mktemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"mXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-459:Incomplete Cleanup|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "459"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\nB.No Vulnerabilities\nC.CWE-674:Uncontrolled Recursion\nD.CWE-834:Excessive Iteration\nE.CWE-59:Improper Link Resolution Before File Access ('Link Following')\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint bordage_conduced = 0;\r\n\r\nunion minnewaukan_gemmules \r\n{\r\n char *starchmen_lienteric;\r\n double pseudopolitical_senior;\r\n char *prats_unspleenish;\r\n char hat_kartvel;\r\n int misky_explosimeter;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *incongruously_turnor);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid untampered_coachmaker(union minnewaukan_gemmules capman_nei);\r\nint search(char *str_param,char c_param)\r\n{\r\n if ( *str_param == c_param) {\r\n return 1;\r\n } else if ( *str_param == 0) {\r\n \r\n \r\n return search(&str_param[0],c_param);\r\n } else {\r\n return search(&str_param[1],c_param);\r\n }\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&bordage_conduced,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n#define UNCREATURELY_BOONDOCKER(x) untampered_coachmaker((union minnewaukan_gemmules) x)\r\n\r\nvoid handle_taint(char *incongruously_turnor)\r\n{\r\n union minnewaukan_gemmules grumbled_untreasurable;\r\n ++global_variable;;\r\n if (incongruously_turnor != 0) {;\r\n grumbled_untreasurable . starchmen_lienteric = incongruously_turnor;\r\n\tUNCREATURELY_BOONDOCKER(grumbled_untreasurable);\r\n }\r\n}\r\n\r\nvoid untampered_coachmaker(union minnewaukan_gemmules capman_nei)\r\n{\r\n int found;\r\n char *gisella_marshalsea = 0;\r\n ++global_variable;;\r\n gisella_marshalsea = ((char *)capman_nei . starchmen_lienteric);\r\n \r\n \r\n \r\n found = search(&gisella_marshalsea[1],gisella_marshalsea[0]);\r\n \r\n \r\n \r\n;\r\n if (capman_nei . starchmen_lienteric != 0) \r\n free(((char *)capman_nei . starchmen_lienteric));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-674:Uncontrolled Recursion|D.CWE-834:Excessive Iteration", "cwe": "674"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-671:Lack of Administrator Control over Security\nC.No Vulnerabilities\nD.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nE.CWE-761:Free of Pointer not at Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define M_SOURCE_FIXED_STRING \"Fixed String\" \r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_fixed_string_54bSink(char * data);\r\n\r\nvoid My_char_fixed_string_54()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n \r\n strcpy(data, M_SOURCE_FIXED_STRING);\r\n My_char_fixed_string_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_fixed_string_54bB2GSink(char * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n \r\n strcpy(data, M_SOURCE_FIXED_STRING);\r\n My_char_fixed_string_54bB2GSink(data);\r\n}\r\n\r\nvoid My_char_fixed_string_54()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fixed_string_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fixed_string_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-761:Free of Pointer not at Start of Buffer|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-771:Missing Reference to Active Allocated Resource\nB.No Vulnerabilities\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-1038:Insecure Automated Optimizations\nE.CWE-183:Permissive List of Allowed Inputs\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\ntypedef union\r\n{\r\n int unionFirst;\r\n int unionSecond;\r\n} My_open_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_34()\r\n{\r\n int data;\r\n My_open_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n My_open_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_34()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|A.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-271:Privilege Dropping / Lowering Errors\nB.No Vulnerabilities\nC.CWE-1076:Insufficient Adherence to Expected Conventions\nD.CWE-272:Least Privilege Violation\nE.CWE-94:Improper Control of Generation of Code ('Code Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_RegCreateKey_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyA(\r\n HKEY_LOCAL_MACHINE,\r\n keyName,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyA(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyA(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_RegCreateKey_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_RegCreateKey_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_RegCreateKey_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-272:Least Privilege Violation|A.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-506:Embedded Malicious Code\nC.CWE-1302:Missing Security Identifier\nD.CWE-331:Insufficient Entropy\nE.CWE-510:Trapdoor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_ip_based_logic_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"192.168.30.123\", inet_ntoa(acceptService.sin_addr)) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_ip_based_logic_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_ip_based_logic_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_ip_based_logic_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-510:Trapdoor|B.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-408:Incorrect Behavior Order: Early Amplification\nB.CWE-1390:Weak Authentication\nC.CWE-562:Return of Stack Variable Address\nD.CWE-620:Unverified Password Change\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <lm.h>\r\n#pragma comment(lib, \"netapi32.lib\")\r\n#define USERNAME L\"cwe620testuser\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t newPassword[256];\r\n USER_INFO_1003 myUserInfo;\r\n NET_API_STATUS status;\r\n myUserInfo.usri1003_password = newPassword;\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", myUserInfo.usri1003_password) != 1)\r\n {\r\n myUserInfo.usri1003_password[0] = L'\\0';\r\n }\r\n \r\n status = NetUserSetInfo(NULL, USERNAME, 1003, (LPBYTE)&myUserInfo, NULL);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserSetInfo failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t oldPassword[256];\r\n wchar_t newPassword[256];\r\n NET_API_STATUS status;\r\n printWLine(L\"Enter old password: \");\r\n if (fwscanf(stdin, L\"%255s\", oldPassword) != 1)\r\n {\r\n oldPassword[0] = L'\\0';\r\n }\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", newPassword) != 1)\r\n {\r\n newPassword[0] = L'\\0';\r\n }\r\n \r\n status = NetUserChangePassword(NULL, USERNAME, oldPassword, newPassword);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserChangePassword failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t oldPassword[256];\r\n wchar_t newPassword[256];\r\n NET_API_STATUS status;\r\n printWLine(L\"Enter old password: \");\r\n if (fwscanf(stdin, L\"%255s\", oldPassword) != 1)\r\n {\r\n oldPassword[0] = L'\\0';\r\n }\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", newPassword) != 1)\r\n {\r\n newPassword[0] = L'\\0';\r\n }\r\n \r\n status = NetUserChangePassword(NULL, USERNAME, oldPassword, newPassword);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserChangePassword failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-620:Unverified Password Change|B.CWE-1390:Weak Authentication", "cwe": "620"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-732:Incorrect Permission Assignment for Critical Resource\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-303:Incorrect Implementation of Authentication Algorithm\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fscanf_multiply_01()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n if(data > 0) \r\n {\r\n \r\n int result = data * 2;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n if(data > 0) \r\n {\r\n \r\n int result = data * 2;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n if(data > 0) \r\n {\r\n \r\n if (data < (INT_MAX/2))\r\n {\r\n int result = data * 2;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_fscanf_multiply_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fscanf_multiply_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fscanf_multiply_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|A.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-263:Password Aging with Long Expiration\nB.CWE-296:Improper Following of a Certificate's Chain of Trust\nC.No Vulnerabilities\nD.CWE-787:Out-of-bounds Write\nE.CWE-123:Write-what-where Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_13()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_fgets_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-391:Unchecked Error Condition\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-698:Execution After Redirect (EAR)\nD.No Vulnerabilities\nE.CWE-1321:Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wcstombs_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wcstombs_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wcstombs_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wcstombs_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-391:Unchecked Error Condition|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-190:Integer Overflow or Wraparound\nB.CWE-682:Incorrect Calculation\nC.CWE-593:Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\nD.CWE-435:Improper Interaction Between Multiple Correctly-Behaving Entities\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fgets_postinc_01()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n {\r\n \r\n data++;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n {\r\n \r\n data++;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n \r\n if (data < INT_MAX)\r\n {\r\n data++;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n}\r\n\r\nvoid My_int_fgets_postinc_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fgets_postinc_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fgets_postinc_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\nB.No Vulnerabilities\nC.CWE-36:Absolute Path Traversal\nD.CWE-1097:Persistent Storable Data Element without Associated Comparison Control Element\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_wchar_t_listen_socket_open_34\r\n{\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n unionType myUnion;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n unionType myUnion;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_listen_socket_open_34; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-36:Absolute Path Traversal|E.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-446:UI Discrepancy for Security Feature\nC.CWE-309:Use of Password System for Primary Authentication\nD.CWE-787:Out-of-bounds Write\nE.CWE-123:Write-what-where Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_connect_socket_05()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(staticTrue)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-172:Encoding Error\nC.CWE-311:Missing Encryption of Sensitive Data\nD.CWE-176:Improper Handling of Unicode Encoding\nE.CWE-246:J2EE Bad Practices: Direct Use of Sockets\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_12()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_12()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-176:Improper Handling of Unicode Encoding|B.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-1190:DMA Device Enabled Too Early in Boot Phase\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-691:Insufficient Control Flow Management\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _My_freopen_w32_close_67_structType\r\n{\r\n FILE * structFirst;\r\n} My_freopen_w32_close_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_freopen_w32_close_67bSink(My_freopen_w32_close_67_structType myStruct);\r\n\r\nvoid My_freopen_w32_close_67()\r\n{\r\n FILE * data;\r\n My_freopen_w32_close_67_structType myStruct;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n myStruct.structFirst = data;\r\n My_freopen_w32_close_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_freopen_w32_close_67bB2GSink(My_freopen_w32_close_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n My_freopen_w32_close_67_structType myStruct;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n myStruct.structFirst = data;\r\n My_freopen_w32_close_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_freopen_w32_close_67()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_w32_close_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_w32_close_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-145:Improper Neutralization of Section Delimiters\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nD.No Vulnerabilities\nE.CWE-475:Undefined Behavior for Input to API\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(char));\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(char));\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(char));\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-475:Undefined Behavior for Input to API|B.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-642:External Control of Critical State Data\nB.CWE-573:Improper Following of Specification by Caller\nC.No Vulnerabilities\nD.CWE-475:Undefined Behavior for Input to API\nE.CWE-342:Predictable Exact Value from Previous Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_wchar_t_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-475:Undefined Behavior for Input to API|B.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1052:Excessive Use of Hard-Coded Literals in Initialization\nB.CWE-27:Path Traversal: 'dir/../../filename'\nC.CWE-252:Unchecked Return Value\nD.No Vulnerabilities\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_putchar_16()\r\n{\r\n while(1)\r\n {\r\n \r\n putwchar((wchar_t)L'A');\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n \r\n if (putwchar((wchar_t)L'A') == WEOF)\r\n {\r\n printLine(\"putwchar failed!\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_wchar_t_putchar_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_putchar_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_putchar_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-252:Unchecked Return Value|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-544:Missing Standardized Error Handling Mechanism\nC.CWE-755:Improper Handling of Exceptional Conditions\nD.CWE-325:Missing Cryptographic Step\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptCreateHash_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptCreateHash_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptCreateHash_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptCreateHash_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-325:Missing Cryptographic Step|A.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-48:Path Equivalence: 'file name' (Internal Whitespace)\nC.CWE-693:Protection Mechanism Failure\nD.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\nE.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RC5_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_RC5_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RC5_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RC5_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|C.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-261:Weak Encoding for Password\nB.CWE-282:Improper Ownership Management\nC.CWE-194:Unexpected Sign Extension\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\n#define CHAR_ARRAY_SIZE 8\r\n\r\nnamespace My_fgets_memcpy_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n short data;\r\n short &dataRef = data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = (short)atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n {\r\n short data = dataRef;\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n short &dataRef = data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n {\r\n short data = dataRef;\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fgets_memcpy_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-194:Unexpected Sign Extension|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-576:EJB Bad Practices: Use of Java I/O\nD.No Vulnerabilities\nE.CWE-333:Improper Handling of Insufficient Entropy in TRNG\n", "input": "static void My_int_connect_socket_preinc_12()\r\r\n{\r\r\n int data;\r\r\n /* Initialize data */\r\r\n data = 0;\r\r\n if(globalReturnsTrueOrFalse())\r\r\n {\r\r\n {\r\r\n#ifdef _WIN32\r\r\n WSADATA wsaData;\r\r\n int wsaDataInit = 0;\r\r\n#endif\r\r\n int recvResult;\r\r\n struct sockaddr_in service;\r\r\n SOCKET connectSocket = INVALID_SOCKET;\r\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\r\n do\r\r\n {\r\r\n#ifdef _WIN32\r\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\r\n {\r\r\n break;\r\r\n }\r\r\n wsaDataInit = 1;\r\r\n#endif\r\r\n /* POTENTIAL FLAW: Read data using a connect socket */\r\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\r\n if (connectSocket == INVALID_SOCKET)\r\r\n {\r\r\n break;\r\r\n }\r\r\n memset(&service, 0, sizeof(service));\r\r\n service.sin_family = AF_INET;\r\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\r\n service.sin_port = htons(TCP_PORT);\r\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\r\n {\r\r\n break;\r\r\n }\r\r\n /* Abort on error or the connection was closed, make sure to recv one\r\r\n * less char than is in the recv_buf in order to append a terminator */\r\r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\r\n {\r\r\n break;\r\r\n }\r\r\n /* NUL-terminate the string */\r\r\n inputBuffer[recvResult] = '\\0';\r\r\n /* Convert to int */\r\r\n data = atoi(inputBuffer);\r\r\n }\r\r\n while (0);\r\r\n if (connectSocket != INVALID_SOCKET)\r\r\n {\r\r\n CLOSE_SOCKET(connectSocket);\r\r\n }\r\r\n#ifdef _WIN32\r\r\n if (wsaDataInit)\r\r\n {\r\r\n WSACleanup();\r\r\n }\r\r\n#endif\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n {\r\r\n#ifdef _WIN32\r\r\n WSADATA wsaData;\r\r\n int wsaDataInit = 0;\r\r\n#endif\r\r\n int recvResult;\r\r\n struct sockaddr_in service;\r\r\n SOCKET connectSocket = INVALID_SOCKET;\r\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\r\n do\r\r\n {\r\r\n#ifdef _WIN32\r\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\r\n {\r\r\n break;\r\r\n }\r\r\n wsaDataInit = 1;\r\r\n#endif\r\r\n /* POTENTIAL FLAW: Read data using a connect socket */\r\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\r\n if (connectSocket == INVALID_SOCKET)\r\r\n {\r\r\n break;\r\r\n }\r\r\n memset(&service, 0, sizeof(service));\r\r\n service.sin_family = AF_INET;\r\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\r\n service.sin_port = htons(TCP_PORT);\r\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\r\n {\r\r\n break;\r\r\n }\r\r\n /* Abort on error or the connection was closed, make sure to recv one\r\r\n * less char than is in the recv_buf in order to append a terminator */\r\r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\r\n {\r\r\n break;\r\r\n }\r\r\n /* NUL-terminate the string */\r\r\n inputBuffer[recvResult] = '\\0';\r\r\n /* Convert to int */\r\r\n data = atoi(inputBuffer);\r\r\n }\r\r\n while (0);\r\r\n if (connectSocket != INVALID_SOCKET)\r\r\n {\r\r\n CLOSE_SOCKET(connectSocket);\r\r\n }\r\r\n#ifdef _WIN32\r\r\n if (wsaDataInit)\r\r\n {\r\r\n WSACleanup();\r\r\n }\r\r\n#endif\r\r\n }\r\r\n }\r\r\n if(globalReturnsTrueOrFalse())\r\r\n {\r\r\n /* FIX: Add a check to prevent an overflow from occurring */\r\r\n if (data < INT_MAX)\r\r\n {\r\r\n ++data;\r\r\n int result = data;\r\r\n printIntLine(result);\r\r\n }\r\r\n else\r\r\n {\r\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n /* FIX: Add a check to prevent an overflow from occurring */\r\r\n if (data < INT_MAX)\r\r\n {\r\r\n ++data;\r\r\n int result = data;\r\r\n printIntLine(result);\r\r\n }\r\r\n else\r\r\n {\r\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\r\n }\r\r\n }\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.No Vulnerabilities|D.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-377:Insecure Temporary File\nC.CWE-128:Wrap-around Error\nD.CWE-576:EJB Bad Practices: Use of Java I/O\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_w32GetTempFileName_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n if (GetTempFileNameW(L\".\", L\"m\", 0, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n \r\n if (GetTempFileNameW(L\".\", L\"n\", rand() + 1, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n \r\n if (GetTempFileNameW(L\".\", L\"n\", rand() + 1, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_w32GetTempFileName_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_w32GetTempFileName_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_w32GetTempFileName_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-377:Insecure Temporary File|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-253:Incorrect Check of Function Return Value\nC.CWE-1322:Use of Blocking Code in Single-threaded, Non-blocking Context\nD.CWE-616:Incomplete Identification of Uploaded File Variables (PHP)\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define SRC_STRING L\"string\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_sscanf_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_sscanf_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_sscanf_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_sscanf_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-253:Incorrect Check of Function Return Value|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nC.No Vulnerabilities\nD.CWE-500:Public Static Field Not Marked Final\nE.CWE-710:Improper Adherence to Coding Standards\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_pointer_malloc_use_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n char * * pointer = (char * *)malloc(sizeof(char *));\r\n if (pointer == NULL) {exit(-1);}\r\n char * data = *pointer; \r\n free(pointer);\r\n printLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n char * data;\r\n char * * pointer = (char * *)malloc(sizeof(char *));\r\n if (pointer == NULL) {exit(-1);}\r\n data = \"string\";\r\n *pointer = data; \r\n {\r\n char * data = *pointer;\r\n printLine(data);\r\n }\r\n free(pointer);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_pointer_malloc_use_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_pointer_malloc_use_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_pointer_malloc_use_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-636:Not Failing Securely ('Failing Open')\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.No Vulnerabilities\nD.CWE-773:Missing Reference to Active File Descriptor or Handle\nE.CWE-1332:Improper Handling of Faults that Lead to Instruction Skips\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_fopen_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<FILE *> dataList);\r\n\r\nvoid m()\r\n{\r\n FILE * data;\r\n list<FILE *> dataList;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(list<FILE *> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n list<FILE *> dataList;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fopen_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-35:Path Traversal: '.../...//'\nD.No Vulnerabilities\nE.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nchar * My_w32_char_listen_socket_61bSource(char * data);\r\n\r\nvoid My_w32_char_listen_socket_61()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n data = My_w32_char_listen_socket_61bSource(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nchar * My_w32_char_listen_socket_61bG2BSource(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n data = My_w32_char_listen_socket_61bG2BSource(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_char_listen_socket_61()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_listen_socket_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_listen_socket_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-127:Buffer Under-read\nB.CWE-336:Same Seed in Pseudo-Random Number Generator (PRNG)\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-841:Improper Enforcement of Behavioral Workflow\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE839_negative_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-127:Buffer Under-read|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-124:Buffer Underwrite ('Buffer Underflow')\nC.CWE-1061:Insufficient Encapsulation\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-1190:DMA Device Enabled Too Early in Boot Phase\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_char_memmove_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid mSource(char * &data)\r\n{\r\n {\r\n char * dataBuffer = new char[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL;\r\n mSource(data);\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n memmove(data, source, 100*sizeof(char));\r\n \r\n data[100-1] = '\\0';\r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(char * &data)\r\n{\r\n {\r\n char * dataBuffer = new char[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n data = NULL;\r\n nG2BSource(data);\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n memmove(data, source, 100*sizeof(char));\r\n \r\n data[100-1] = '\\0';\r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_memmove_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-124:Buffer Underwrite ('Buffer Underflow')|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-459:Incomplete Cleanup\nB.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nC.No Vulnerabilities\nD.CWE-164:Improper Neutralization of Internal Special Elements\nE.CWE-1125:Excessive Attack Surface\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_declare_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_declare_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_declare_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_declare_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|A.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1090:Method Containing Access of a Member Element from Another Class\nB.CWE-696:Incorrect Behavior Order\nC.CWE-36:Absolute Path Traversal\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_wchar_t_connect_socket_ofstream_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i;\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n for(i = 0; i < 1; i++)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n for(h = 0; h < 1; h++)\r\n {\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_connect_socket_ofstream_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-36:Absolute Path Traversal|D.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-114:Process Control\nB.CWE-73:External Control of File Name or Path\nC.CWE-1302:Missing Security Identifier\nD.No Vulnerabilities\nE.CWE-1048:Invokable Control Element with Large Number of Outward Calls\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_char_file_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<char *> dataList);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<char *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_file_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-114:Process Control|B.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-283:Unverified Ownership\nD.CWE-253:Incorrect Check of Function Return Value\nE.CWE-1288:Improper Validation of Consistency within Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fwrite_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fwrite_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fwrite_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fwrite_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-253:Incorrect Check of Function Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-416:Use After Free\nB.CWE-309:Use of Password System for Primary Authentication\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-390:Detection of Error Condition Without Action\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_long_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(long * &data);\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n printLongLine(data[0]);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(long * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n printLongLine(data[0]);\r\n \r\n}\r\n\r\n\r\nvoid nB2GSource(long * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_long_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-401:Missing Release of Memory after Effective Lifetime\nC.CWE-444:Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\nD.CWE-202:Exposure of Sensitive Information Through Data Queries\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic wchar_t * mSource(wchar_t * data)\r\n{\r\n {\r\n wchar_t myString[] = L\"myString\";\r\n \r\n data = wcsdup(myString);\r\n \r\n printWLine(data);\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_strdup_wchar_t_42()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n data = mSource(data);\r\n \r\n \r\n ; \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic wchar_t * nG2BSource(wchar_t * data)\r\n{\r\n \r\n data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n \r\n wcscpy(data, L\"a string\");\r\n printWLine(data);\r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n data = nG2BSource(data);\r\n \r\n \r\n ; \r\n}\r\n\r\n\r\nstatic wchar_t * nB2GSource(wchar_t * data)\r\n{\r\n {\r\n wchar_t myString[] = L\"myString\";\r\n \r\n data = wcsdup(myString);\r\n \r\n printWLine(data);\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n data = nB2GSource(data);\r\n \r\n free(data);\r\n}\r\n\r\nvoid My_strdup_wchar_t_42()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_strdup_wchar_t_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_strdup_wchar_t_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-401:Missing Release of Memory after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-602:Client-Side Enforcement of Server-Side Security\nC.CWE-106:Struts: Plug-in Framework not in Use\nD.No Vulnerabilities\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_delete_struct_malloc_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new twoIntsStruct;\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = new twoIntsStruct;\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_struct_malloc_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-762:Mismatched Memory Management Routines|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-770:Allocation of Resources Without Limits or Throttling\nD.CWE-1023:Incomplete Comparison with Missing Factors\nE.CWE-1247:Improper Protection Against Voltage and Clock Glitches\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING \"hello\"\r\n\r\nnamespace My_new_char_fgets_13\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = 20;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_fgets_13; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|C.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-245:J2EE Bad Practices: Direct Management of Connections\nB.CWE-127:Buffer Under-read\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_loop_01\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n {\r\n size_t i;\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n size_t i;\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_loop_01; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-312:Cleartext Storage of Sensitive Information\nC.CWE-489:Active Debug Code\nD.CWE-241:Improper Handling of Unexpected Data Type\nE.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n printLine(getenv(\"PATH\"));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\nvoid My_basic_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable|B.CWE-312:Cleartext Storage of Sensitive Information", "cwe": "526"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.CWE-489:Active Debug Code\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-28:Path Traversal: '..\\filedir'\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_wchar_t_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<wchar_t *> passwordVector);\r\n\r\nvoid m()\r\n{\r\n wchar_t * password;\r\n vector<wchar_t *> passwordVector;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n \r\n wcscpy(password, PASSWORD);\r\n \r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n mSink(passwordVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<wchar_t *> passwordVector);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n vector<wchar_t *> passwordVector;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n \r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n nG2BSink(passwordVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-535:Exposure of Information Through Shell Error Message\nB.CWE-316:Cleartext Storage of Sensitive Information in Memory\nC.CWE-191:Integer Underflow (Wrap or Wraparound)\nD.No Vulnerabilities\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic int mSource(int data)\r\n{\r\n \r\n data = INT_MIN;\r\n return data;\r\n}\r\n\r\nvoid My_int_min_postdec_42()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n data = mSource(data);\r\n {\r\n \r\n data--;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2BSource(int data)\r\n{\r\n \r\n data = -2;\r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n data = nG2BSource(data);\r\n {\r\n \r\n data--;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n\r\nstatic int nB2GSource(int data)\r\n{\r\n \r\n data = INT_MIN;\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n data = nB2GSource(data);\r\n \r\n if (data > INT_MIN)\r\n {\r\n data--;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n}\r\n\r\nvoid My_int_min_postdec_42()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_min_postdec_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_min_postdec_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-191:Integer Underflow (Wrap or Wraparound)|E.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-483:Incorrect Block Delimitation\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-415:Double Free\nE.CWE-1224:Improper Restriction of Write-Once Bit Fields\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_free_struct_81\r\n{\r\n\r\nclass My_malloc_free_struct_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(twoIntsStruct * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_malloc_free_struct_81 : public My_malloc_free_struct_81_base\r\n{\r\npublic:\r\n void action(twoIntsStruct * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_malloc_free_struct_81G2B : public My_malloc_free_struct_81_base\r\n{\r\npublic:\r\n void action(twoIntsStruct * data) const;\r\n};\r\n\r\nclass My_malloc_free_struct_81B2G : public My_malloc_free_struct_81_base\r\n{\r\npublic:\r\n void action(twoIntsStruct * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-415:Double Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-305:Authentication Bypass by Primary Weakness\nB.CWE-686:Function Call With Incorrect Argument Type\nC.CWE-61:UNIX Symbolic Link (Symlink) Following\nD.CWE-359:Exposure of Private Personal Information to an Unauthorized Actor\nE.No Vulnerabilities\n", "input": "ModuleExport size_t RegisterTIFFImage(void)\r\r\n{\r\r\n#define TIFFDescription \"Tagged Image File Format\"\r\r\n\r\r\n char\r\r\n version[MaxTextExtent];\r\r\n\r\r\n MagickInfo\r\r\n *entry;\r\r\n\r\r\n if (tiff_semaphore == (SemaphoreInfo *) NULL)\r\r\n ActivateSemaphoreInfo(&tiff_semaphore);\r\r\n LockSemaphoreInfo(tiff_semaphore);\r\r\n if (instantiate_key == MagickFalse)\r\r\n {\r\r\n if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\r\r\n ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\r\r\n error_handler=TIFFSetErrorHandler(TIFFErrors);\r\r\n warning_handler=TIFFSetWarningHandler(TIFFWarnings);\r\r\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\r\r\n if (tag_extender == (TIFFExtendProc) NULL)\r\r\n tag_extender=TIFFSetTagExtender(TIFFTagExtender);\r\r\n#endif\r\r\n instantiate_key=MagickTrue;\r\r\n }\r\r\n UnlockSemaphoreInfo(tiff_semaphore);\r\r\n *version='\\0';\r\r\n#if defined(TIFF_VERSION)\r\r\n (void) FormatLocaleString(version,MaxTextExtent,\"%d\",TIFF_VERSION);\r\r\n#endif\r\r\n#if defined(MAGICKCORE_TIFF_DELEGATE)\r\r\n {\r\r\n const char\r\r\n *p;\r\r\n\r\r\n register ssize_t\r\r\n i;\r\r\n\r\r\n p=TIFFGetVersion();\r\r\n for (i=0; (i < (MaxTextExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\r\r\n version[i]=(*p++);\r\r\n version[i]='\\0';\r\r\n }\r\r\n#endif\r\r\n\r\r\n entry=SetMagickInfo(\"GROUP4\");\r\r\n#if defined(MAGICKCORE_TIFF_DELEGATE)\r\r\n entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\r\r\n entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\r\r\n#endif\r\r\n entry->raw=MagickTrue;\r\r\n entry->endian_support=MagickTrue;\r\r\n entry->adjoin=MagickFalse;\r\r\n entry->format_type=ImplicitFormatType;\r\r\n entry->seekable_stream=MagickTrue;\r\r\n entry->description=ConstantString(\"Raw CCITT Group4\");\r\r\n entry->mime_type=ConstantString(\"image/tiff\");\r\r\n entry->module=ConstantString(\"TIFF\");\r\r\n (void) RegisterMagickInfo(entry);\r\r\n entry=SetMagickInfo(\"PTIF\");\r\r\n#if defined(MAGICKCORE_TIFF_DELEGATE)\r\r\n entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\r\r\n entry->encoder=(EncodeImageHandler *) WritePTIFImage;\r\r\n#endif\r\r\n entry->endian_support=MagickTrue;\r\r\n entry->seekable_stream=MagickTrue;\r\r\n entry->description=ConstantString(\"Pyramid encoded TIFF\");\r\r\n entry->mime_type=ConstantString(\"image/tiff\");\r\r\n entry->module=ConstantString(\"TIFF\");\r\r\n (void) RegisterMagickInfo(entry);\r\r\n entry=SetMagickInfo(\"TIF\");\r\r\n#if defined(MAGICKCORE_TIFF_DELEGATE)\r\r\n entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\r\r\n entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\r\r\n#endif\r\r\n entry->endian_support=MagickTrue;\r\r\n entry->seekable_stream=MagickTrue;\r\r\n entry->stealth=MagickTrue;\r\r\n entry->description=ConstantString(TIFFDescription);\r\r\n if (*version != '\\0')\r\r\n entry->version=ConstantString(version);\r\r\n entry->mime_type=ConstantString(\"image/tiff\");\r\r\n entry->module=ConstantString(\"TIFF\");\r\r\n (void) RegisterMagickInfo(entry);\r\r\n entry=SetMagickInfo(\"TIFF\");\r\r\n#if defined(MAGICKCORE_TIFF_DELEGATE)\r\r\n entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\r\r\n entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\r\r\n#endif\r\r\n entry->magick=(IsImageFormatHandler *) IsTIFF;\r\r\n entry->endian_support=MagickTrue;\r\r\n entry->seekable_stream=MagickTrue;\r\r\n entry->description=ConstantString(TIFFDescription);\r\r\n if (*version != '\\0')\r\r\n entry->version=ConstantString(version);\r\r\n entry->mime_type=ConstantString(\"image/tiff\");\r\r\n entry->module=ConstantString(\"TIFF\");\r\r\n (void) RegisterMagickInfo(entry);\r\r\n entry=SetMagickInfo(\"TIFF64\");\r\r\n#if defined(TIFF_VERSION_BIG)\r\r\n entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\r\r\n entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\r\r\n#endif\r\r\n entry->adjoin=MagickFalse;\r\r\n entry->endian_support=MagickTrue;\r\r\n entry->seekable_stream=MagickTrue;\r\r\n entry->description=ConstantString(\"Tagged Image File Format (64-bit)\");\r\r\n if (*version != '\\0')\r\r\n entry->version=ConstantString(version);\r\r\n entry->mime_type=ConstantString(\"image/tiff\");\r\r\n entry->module=ConstantString(\"TIFF\");\r\r\n (void) RegisterMagickInfo(entry);\r\r\n return(MagickImageCoderSignature);\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.No Vulnerabilities|E.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-67:Improper Handling of Windows Device Names\nB.CWE-369:Divide By Zero\nC.CWE-682:Incorrect Calculation\nD.CWE-496:Public Data Assigned to Private Array-Typed Field\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fgets_divide_02()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(1)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(1)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(1)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(1)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(1)\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 7;\r\n }\r\n if(1)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(1)\r\n {\r\n \r\n data = 7;\r\n }\r\n if(1)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\nvoid My_int_fgets_divide_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fgets_divide_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fgets_divide_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-369:Divide By Zero|C.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-605:Multiple Binds to the Same Port\nB.No Vulnerabilities\nC.CWE-680:Integer Overflow to Buffer Overflow\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n#ifdef _WIN32\r\n BOOL bOptVal = TRUE;\r\n int bOptLen = sizeof(BOOL);\r\n#else\r\n int bOptVal = 1;\r\n int bOptLen = sizeof(int);\r\n#endif\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-605:Multiple Binds to the Same Port|E.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "605"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-182:Collapse of Data into Unsafe Value\nC.No Vulnerabilities\nD.CWE-1164:Irrelevant Code\nE.CWE-563:Assignment to Variable without Use\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_unused_init_variable_int64_t_82\r\n{\r\n\r\nclass My_unused_init_variable_int64_t_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(int64_t data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_unused_init_variable_int64_t_82 : public My_unused_init_variable_int64_t_82_base\r\n{\r\npublic:\r\n void action(int64_t data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_unused_init_variable_int64_t_82B2G : public My_unused_init_variable_int64_t_82_base\r\n{\r\npublic:\r\n void action(int64_t data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-710:Improper Adherence to Coding Standards\nB.No Vulnerabilities\nC.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nD.CWE-291:Reliance on IP Address for Authentication\nE.CWE-1096:Singleton Class Instance Creation without Proper Locking or Synchronization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double_pointer_alloca_use_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n double * * pointer = (double * *)ALLOCA(sizeof(double *));\r\n double * data = *pointer; \r\n printDoubleLine(*data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n double * data;\r\n double * * pointer = (double * *)ALLOCA(sizeof(double *));\r\n \r\n data = (double *)malloc(sizeof(double));\r\n if (data == NULL) {exit(-1);}\r\n *data = 5.0;\r\n *pointer = data; \r\n {\r\n double * data = *pointer;\r\n printDoubleLine(*data);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n double * data;\r\n double * * pointer = (double * *)ALLOCA(sizeof(double *));\r\n \r\n data = (double *)malloc(sizeof(double));\r\n if (data == NULL) {exit(-1);}\r\n *data = 5.0;\r\n *pointer = data; \r\n {\r\n double * data = *pointer;\r\n printDoubleLine(*data);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double_pointer_alloca_use_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double_pointer_alloca_use_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double_pointer_alloca_use_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|A.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-841:Improper Enforcement of Behavioral Workflow\nB.CWE-1320:Improper Protection for Outbound Error Messages and Alert Signals\nC.CWE-127:Buffer Under-read\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_My_CWE839_fscanf_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.No Vulnerabilities\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer\nE.CWE-511:Logic/Time Bomb\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_15()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n break;\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|A.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-480:Use of Incorrect Operator\nB.CWE-286:Incorrect User Management\nC.CWE-641:Improper Restriction of Names for Files and Other Resources\nD.No Vulnerabilities\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic char* staticStringM = \"Hello\";\r\nstatic char* staticStringN = \"Hello\";\r\n\r\nstatic char * helperM()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringM;\r\n }\r\n}\r\n\r\nstatic char * helperN()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringN;\r\n }\r\n}\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n if(helperM == NULL)\r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if(helperN() == NULL) \r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n if(helperN() == NULL) \r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-480:Use of Incorrect Operator|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "480"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-258:Empty Password in Configuration File\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-770:Allocation of Resources Without Limits or Throttling\nD.No Vulnerabilities\nE.CWE-301:Reflection Attack in an Authentication Protocol\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_rand_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(size_t &data);\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n mSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(size_t &data);\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n nG2BSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n\r\nvoid nB2GSource(size_t &data);\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n nB2GSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_rand_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|C.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-674:Uncontrolled Recursion\nB.CWE-587:Assignment of a Fixed Address to a Pointer\nC.CWE-344:Use of Invariant Value in Dynamically Changing Context\nD.CWE-696:Incorrect Behavior Order\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n char *charPointer = (char*)0x400000;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-587:Assignment of a Fixed Address to a Pointer|C.CWE-344:Use of Invariant Value in Dynamically Changing Context", "cwe": "587"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-404:Improper Resource Shutdown or Release\nB.No Vulnerabilities\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-391:Unchecked Error Condition\nE.CWE-1193:Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_freopen_w32CloseHandle_51bSink(FILE * data);\r\n\r\nvoid My_freopen_w32CloseHandle_51()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n My_freopen_w32CloseHandle_51bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_freopen_w32CloseHandle_51bB2GSink(FILE * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n My_freopen_w32CloseHandle_51bB2GSink(data);\r\n}\r\n\r\nvoid My_freopen_w32CloseHandle_51()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_w32CloseHandle_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_w32CloseHandle_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-404:Improper Resource Shutdown or Release|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nB.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nC.CWE-528:Exposure of Core Dump File to an Unauthorized Control Sphere\nD.No Vulnerabilities\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int64_t_malloc_02()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n \r\n data = (int64_t *)malloc(1*sizeof(int64_t));\r\n if(1)\r\n {\r\n \r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n \r\n data = (int64_t *)malloc(1*sizeof(int64_t));\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n \r\n data = (int64_t *)malloc(1*sizeof(int64_t));\r\n if(1)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int64_t_malloc_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_malloc_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_malloc_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-690:Unchecked Return Value to NULL Pointer Dereference|E.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-413:Improper Resource Locking\nB.CWE-570:Expression is Always False\nC.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nD.No Vulnerabilities\nE.CWE-1121:Excessive McCabe Cyclomatic Complexity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_16()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n while(1)\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n break;\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n while(1)\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n break;\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-591:Sensitive Data Storage in Improperly Locked Memory|A.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-412:Unrestricted Externally Accessible Lock\nB.CWE-667:Improper Locking\nC.CWE-128:Wrap-around Error\nD.No Vulnerabilities\nE.CWE-357:Insufficient UI Warning of Dangerous Operations\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <unistd.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint epiphonemas_hayatake = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int fd;\r\n char *extension = \".lck\";\r\n char *thelockfile;\r\n char *anno_louisianians = 0;\r\n jmp_buf primp_sovkhoz;\r\n int carbolising_tanga;\r\n void **costain_adjument = 0;\r\n void *labyrinthitis_foresweat = 0;\r\n char *biliverdic_myriapodan;;\r\n if (__sync_bool_compare_and_swap(&epiphonemas_hayatake,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n biliverdic_myriapodan = getenv(\"DIFFRACTION_HOMOANISIC\");\r\n if (biliverdic_myriapodan != 0) {;\r\n labyrinthitis_foresweat = ((void *)biliverdic_myriapodan);\r\n costain_adjument = &labyrinthitis_foresweat;\r\n carbolising_tanga = setjmp(primp_sovkhoz);\r\n if (carbolising_tanga == 0) {\r\n longjmp(primp_sovkhoz,1);\r\n }\r\n anno_louisianians = ((char *)((char *)( *costain_adjument)));\r\n \r\n thelockfile = (char *)malloc(strlen(\"/opt//workspace/testData/\") + strlen(anno_louisianians) +\r\n strlen(extension) + 1);\r\n \r\n if (thelockfile) {\r\n \r\n \r\n strcpy(thelockfile, \"/opt//workspace/testData/\");\r\n strcat(thelockfile, anno_louisianians);\r\n strcat(thelockfile, extension);\r\n \r\n \r\n if (access(\"/opt//workspace/testData/\", R_OK && W_OK) == -1) {\r\n printf(\"Error accessing testData directory\\n\");\r\n } else {\r\n printf(\"Grabbing lock file: %s\\n\", thelockfile);\r\n \r\n \r\n \r\n while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\r\n sleep(0);\r\n }\r\n \r\n printf(\"Made it to the critical section\\n\");\r\n if (fd != -1) {\r\n close(fd);\r\n unlink(thelockfile);\r\n }\r\n free (thelockfile);\r\n }\r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-412:Unrestricted Externally Accessible Lock|B.CWE-667:Improper Locking", "cwe": "412"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1043:Data Element Aggregating an Excessively Large Number of Non-Primitive Elements\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.CWE-272:Least Privilege Violation\nE.CWE-210:Self-generated Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_RegOpenKeyEx_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegOpenKeyExW(\r\n HKEY_LOCAL_MACHINE,\r\n keyName,\r\n 0,\r\n KEY_WRITE,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegOpenKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n KEY_WRITE,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_RegOpenKeyEx_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_RegOpenKeyEx_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_RegOpenKeyEx_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-272:Least Privilege Violation|C.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-693:Protection Mechanism Failure\nD.CWE-23:Relative Path Traversal\nE.CWE-266:Incorrect Privilege Assignment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_char_listen_socket_ifstream_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_ifstream_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-23:Relative Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-804:Guessable CAPTCHA\nD.No Vulnerabilities\nE.CWE-587:Assignment of a Fixed Address to a Pointer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CreateFile_close_31()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n {\r\n HANDLE dataCopy = data;\r\n HANDLE data = dataCopy;\r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n \r\n _close((int)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n {\r\n HANDLE dataCopy = data;\r\n HANDLE data = dataCopy;\r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n \r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_close_31()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_close_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_close_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-242:Use of Inherently Dangerous Function\nB.CWE-347:Improper Verification of Cryptographic Signature\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.No Vulnerabilities\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_memmove_02()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(1)\r\n {\r\n \r\n data = RAND32();\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(1)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_rand_memmove_02()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_memmove_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_memmove_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-113:Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-573:Improper Following of Specification by Caller\nE.CWE-325:Missing Cryptographic Step\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptCreateHash_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptCreateHash_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptCreateHash_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptCreateHash_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-325:Missing Cryptographic Step|D.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-172:Encoding Error\nB.CWE-548:Exposure of Information Through Directory Listing\nC.CWE-1058:Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element\nD.CWE-176:Improper Handling of Unicode Encoding\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_08()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_08()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-176:Improper Handling of Unicode Encoding|A.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-307:Improper Restriction of Excessive Authentication Attempts\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nD.CWE-427:Uncontrolled Search Path Element\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_console_65bSink(char * data);\r\n\r\nvoid My_char_console_65()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = My_char_console_65bSink;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (250-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_console_65bG2BSink(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = My_char_console_65bG2BSink;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n \r\n strcat(data, NEW_PATH);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_console_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1288:Improper Validation of Consistency within Input\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.No Vulnerabilities\nD.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\nE.CWE-197:Numeric Truncation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nnamespace My_int_fgets_to_char_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(int &data)\r\n{\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(int &data)\r\n{\r\n \r\n data = CHAR_MAX-5;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_fgets_to_char_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-197:Numeric Truncation Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-940:Improper Verification of Source of a Communication Channel\nB.CWE-1284:Improper Validation of Specified Quantity in Input\nC.CWE-606:Unchecked Input for Loop Condition\nD.No Vulnerabilities\nE.CWE-780:Use of RSA Algorithm without OAEP\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_console_66bSink(wchar_t * dataArray[]);\r\n\r\nvoid My_wchar_t_console_66()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n \r\n dataArray[2] = data;\r\n My_wchar_t_console_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_console_66bG2BSink(wchar_t * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"15\");\r\n dataArray[2] = data;\r\n My_wchar_t_console_66bG2BSink(dataArray);\r\n}\r\n\r\n\r\nvoid My_wchar_t_console_66bB2GSink(wchar_t * dataArray[]);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n dataArray[2] = data;\r\n My_wchar_t_console_66bB2GSink(dataArray);\r\n}\r\n\r\nvoid My_wchar_t_console_66()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_console_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_console_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-606:Unchecked Input for Loop Condition|B.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-357:Insufficient UI Warning of Dangerous Operations\nC.CWE-673:External Influence of Sphere Definition\nD.CWE-426:Untrusted Search Path\nE.CWE-117:Improper Output Neutralization for Logs\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM system\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_system_09()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_char_system_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_system_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_system_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-426:Untrusted Search Path|C.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-170:Improper Null Termination\nB.CWE-394:Unexpected Status Code or Return Value\nC.CWE-77:Improper Neutralization of Special Elements used in a Command ('Command Injection')\nD.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nE.No Vulnerabilities\n", "input": "int http_wait_for_request_body(struct stream *s, struct channel *req, int an_bit)\r\r\n{\r\r\n\tstruct session *sess = s->sess;\r\r\n\tstruct http_txn *txn = s->txn;\r\r\n\tstruct http_msg *msg = &s->txn->req;\r\r\n\r\r\n\t/* We have to parse the HTTP request body to find any required data.\r\r\n\t * \"balance url_param check_post\" should have been the only way to get\r\r\n\t * into this. We were brought here after HTTP header analysis, so all\r\r\n\t * related structures are ready.\r\r\n\t */\r\r\n\r\r\n\tif (msg->msg_state < HTTP_MSG_CHUNK_SIZE) {\r\r\n\t\t/* This is the first call */\r\r\n\t\tif (msg->msg_state < HTTP_MSG_BODY)\r\r\n\t\t\tgoto missing_data;\r\r\n\r\r\n\t\tif (msg->msg_state < HTTP_MSG_100_SENT) {\r\r\n\t\t\t/* If we have HTTP/1.1 and Expect: 100-continue, then we must\r\r\n\t\t\t * send an HTTP/1.1 100 Continue intermediate response.\r\r\n\t\t\t */\r\r\n\t\t\tif (msg->flags & HTTP_MSGF_VER_11) {\r\r\n\t\t\t\tstruct hdr_ctx ctx;\r\r\n\t\t\t\tctx.idx = 0;\r\r\n\t\t\t\t/* Expect is allowed in 1.1, look for it */\r\r\n\t\t\t\tif (http_find_header2(\"Expect\", 6, req->buf->p, &txn->hdr_idx, &ctx) &&\r\r\n\t\t\t\t unlikely(ctx.vlen == 12 && strncasecmp(ctx.line+ctx.val, \"100-continue\", 12) == 0)) {\r\r\n\t\t\t\t\tco_inject(&s->res, http_100_chunk.str, http_100_chunk.len);\r\r\n\t\t\t\t\thttp_remove_header2(&txn->req, &txn->hdr_idx, &ctx);\r\r\n\t\t\t\t}\r\r\n\t\t\t}\r\r\n\t\t\tmsg->msg_state = HTTP_MSG_100_SENT;\r\r\n\t\t}\r\r\n\r\r\n\t\t/* we have msg->sov which points to the first byte of message body.\r\r\n\t\t * req->buf->p still points to the beginning of the message. We\r\r\n\t\t * must save the body in msg->next because it survives buffer\r\r\n\t\t * re-alignments.\r\r\n\t\t */\r\r\n\t\tmsg->next = msg->sov;\r\r\n\r\r\n\t\tif (msg->flags & HTTP_MSGF_TE_CHNK)\r\r\n\t\t\tmsg->msg_state = HTTP_MSG_CHUNK_SIZE;\r\r\n\t\telse\r\r\n\t\t\tmsg->msg_state = HTTP_MSG_DATA;\r\r\n\t}\r\r\n\r\r\n\tif (!(msg->flags & HTTP_MSGF_TE_CHNK)) {\r\r\n\t\t/* We're in content-length mode, we just have to wait for enough data. */\r\r\n\t\tif (http_body_bytes(msg) < msg->body_len)\r\r\n\t\t\tgoto missing_data;\r\r\n\r\r\n\t\t/* OK we have everything we need now */\r\r\n\t\tgoto http_end;\r\r\n\t}\r\r\n\r\r\n\t/* OK here we're parsing a chunked-encoded message */\r\r\n\r\r\n\tif (msg->msg_state == HTTP_MSG_CHUNK_SIZE) {\r\r\n\t\t/* read the chunk size and assign it to ->chunk_len, then\r\r\n\t\t * set ->sov and ->next to point to the body and switch to DATA or\r\r\n\t\t * TRAILERS state.\r\r\n\t\t */\r\r\n\t\tunsigned int chunk;\r\r\n\t\tint ret = h1_parse_chunk_size(req->buf, msg->next, req->buf->i, &chunk);\r\r\n\r\r\n\t\tif (!ret)\r\r\n\t\t\tgoto missing_data;\r\r\n\t\telse if (ret < 0) {\r\r\n\t\t\tmsg->err_pos = req->buf->i + ret;\r\r\n\t\t\tif (msg->err_pos < 0)\r\r\n\t\t\t\tmsg->err_pos += req->buf->size;\r\r\n\t\t\tstream_inc_http_err_ctr(s);\r\r\n\t\t\tgoto return_req;\r\r\n\t\t}\r\r\n\r\r\n\t\tmsg->chunk_len = chunk;\r\r\n\t\tmsg->body_len += chunk;\r\r\n\r\r\n\t\tmsg->sol = ret;\r\r\n\t\tmsg->next += ret;\r\r\n\t\tmsg->msg_state = msg->chunk_len ? HTTP_MSG_DATA : HTTP_MSG_TRAILERS;\r\r\n\t}\r\r\n\r\r\n\t/* Now we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state.\r\r\n\t * We have the first data byte is in msg->sov + msg->sol. We're waiting\r\r\n\t * for at least a whole chunk or the whole content length bytes after\r\r\n\t * msg->sov + msg->sol.\r\r\n\t */\r\r\n\tif (msg->msg_state == HTTP_MSG_TRAILERS)\r\r\n\t\tgoto http_end;\r\r\n\r\r\n\tif (http_body_bytes(msg) >= msg->body_len) /* we have enough bytes now */\r\r\n\t\tgoto http_end;\r\r\n\r\r\n missing_data:\r\r\n\t/* we get here if we need to wait for more data. If the buffer is full,\r\r\n\t * we have the maximum we can expect.\r\r\n\t */\r\r\n\tif (buffer_full(req->buf, global.tune.maxrewrite))\r\r\n\t\tgoto http_end;\r\r\n\r\r\n\tif ((req->flags & CF_READ_TIMEOUT) || tick_is_expired(req->analyse_exp, now_ms)) {\r\r\n\t\ttxn->status = 408;\r\r\n\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\r\r\n\r\r\n\t\tif (!(s->flags & SF_ERR_MASK))\r\r\n\t\t\ts->flags |= SF_ERR_CLITO;\r\r\n\t\tif (!(s->flags & SF_FINST_MASK))\r\r\n\t\t\ts->flags |= SF_FINST_D;\r\r\n\t\tgoto return_err_msg;\r\r\n\t}\r\r\n\r\r\n\t/* we get here if we need to wait for more data */\r\r\n\tif (!(req->flags & (CF_SHUTR | CF_READ_ERROR))) {\r\r\n\t\t/* Not enough data. We'll re-use the http-request\r\r\n\t\t * timeout here. Ideally, we should set the timeout\r\r\n\t\t * relative to the accept() date. We just set the\r\r\n\t\t * request timeout once at the beginning of the\r\r\n\t\t * request.\r\r\n\t\t */\r\r\n\t\tchannel_dont_connect(req);\r\r\n\t\tif (!tick_isset(req->analyse_exp))\r\r\n\t\t\treq->analyse_exp = tick_add_ifset(now_ms, s->be->timeout.httpreq);\r\r\n\t\treturn 0;\r\r\n\t}\r\r\n\r\r\n http_end:\r\r\n\t/* The situation will not evolve, so let's give up on the analysis. */\r\r\n\ts->logs.tv_request = now; /* update the request timer to reflect full request */\r\r\n\treq->analysers &= ~an_bit;\r\r\n\treq->analyse_exp = TICK_ETERNITY;\r\r\n\treturn 1;\r\r\n\r\r\n return_req: /* let's centralize all m requests */\r\r\n\ttxn->req.err_state = txn->req.msg_state;\r\r\n\ttxn->req.msg_state = HTTP_MSG_ERROR;\r\r\n\ttxn->status = 400;\r\r\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\r\r\n\r\r\n\tif (!(s->flags & SF_ERR_MASK))\r\r\n\t\ts->flags |= SF_ERR_PRXCOND;\r\r\n\tif (!(s->flags & SF_FINST_MASK))\r\r\n\t\ts->flags |= SF_FINST_R;\r\r\n\r\r\n return_err_msg:\r\r\n\treq->analysers &= AN_REQ_FLT_END;\r\r\n\tHA_ATOMIC_ADD(&sess->fe->fe_counters.failed_req, 1);\r\r\n\tif (sess->listener->counters)\r\r\n\t\tHA_ATOMIC_ADD(&sess->listener->counters->failed_req, 1);\r\r\n\treturn 0;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.No Vulnerabilities|E.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-99:Improper Control of Resource Identifiers ('Resource Injection')\nB.CWE-665:Improper Initialization\nC.No Vulnerabilities\nD.CWE-326:Inadequate Encryption Strength\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ncat_13()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n {\r\n size_t sourceLen;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n sourceLen = strlen(source);\r\n \r\n strncat(data, source, sourceLen);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n size_t sourceLen;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n sourceLen = strlen(source);\r\n \r\n strncat(data, source, sourceLen);\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n size_t sourceLen;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n sourceLen = strlen(source);\r\n \r\n strncat(data, source, sourceLen);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_ncat_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ncat_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ncat_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-467:Use of sizeof() on a Pointer Type\nB.CWE-131:Incorrect Calculation of Buffer Size\nC.No Vulnerabilities\nD.CWE-106:Struts: Plug-in Framework not in Use\nE.CWE-75:Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * mChar = NULL;\r\n \r\n mChar = (char *)malloc(sizeof(mChar));\r\n if (mChar == NULL) {exit(-1);}\r\n *mChar = 'B';\r\n printHexCharLine(*mChar);\r\n free(mChar);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * nChar = NULL;\r\n \r\n nChar = (char *)malloc(sizeof(*nChar));\r\n if (nChar == NULL) {exit(-1);}\r\n *nChar = 'G';\r\n printHexCharLine(*nChar);\r\n free(nChar);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * nChar = NULL;\r\n \r\n nChar = (char *)malloc(sizeof(*nChar));\r\n if (nChar == NULL) {exit(-1);}\r\n *nChar = 'G';\r\n printHexCharLine(*nChar);\r\n free(nChar);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-467:Use of sizeof() on a Pointer Type|B.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1357:Reliance on Insufficiently Trustworthy Component\nB.CWE-434:Unrestricted Upload of File with Dangerous Type\nC.CWE-628:Function Call with Incorrectly Specified Arguments\nD.No Vulnerabilities\nE.CWE-688:Function Call With Incorrect Variable or Reference as Argument\n", "input": "MSG_PROCESS_RETURN tls_process_certificate_request(SSL *s, PACKET *pkt)\r\r\n{\r\r\n int ret = MSG_PROCESS_ERROR;\r\r\n unsigned int list_len, ctype_num, i, name_len;\r\r\n X509_NAME *xn = NULL;\r\r\n const unsigned char *data;\r\r\n const unsigned char *namestart, *namebytes;\r\r\n STACK_OF(X509_NAME) *ca_sk = NULL;\r\r\n\r\r\n if ((ca_sk = sk_X509_NAME_new(ca_dn_cmp)) == NULL) {\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\r\r\n goto err;\r\r\n }\r\r\n\r\r\n /* get the certificate types */\r\r\n if (!PACKET_get_1(pkt, &ctype_num)\r\r\n || !PACKET_get_bytes(pkt, &data, ctype_num)) {\r\r\n ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\r\r\n goto err;\r\r\n }\r\r\n OPENSSL_free(s->cert->ctypes);\r\r\n s->cert->ctypes = NULL;\r\r\n if (ctype_num > SSL3_CT_NUMBER) {\r\r\n /* If we exceed static buffer copy all to cert structure */\r\r\n s->cert->ctypes = OPENSSL_malloc(ctype_num);\r\r\n if (s->cert->ctypes == NULL) {\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\r\r\n goto err;\r\r\n }\r\r\n memcpy(s->cert->ctypes, data, ctype_num);\r\r\n s->cert->ctype_num = (size_t)ctype_num;\r\r\n ctype_num = SSL3_CT_NUMBER;\r\r\n }\r\r\n for (i = 0; i < ctype_num; i++)\r\r\n s->s3->tmp.ctype[i] = data[i];\r\r\n\r\r\n if (SSL_USE_SIGALGS(s)) {\r\r\n if (!PACKET_get_net_2(pkt, &list_len)\r\r\n || !PACKET_get_bytes(pkt, &data, list_len)) {\r\r\n ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\r\r\n SSL_R_LENGTH_MISMATCH);\r\r\n goto err;\r\r\n }\r\r\n\r\r\n /* Clear certificate digests and validity flags */\r\r\n for (i = 0; i < SSL_PKEY_NUM; i++) {\r\r\n s->s3->tmp.md[i] = NULL;\r\r\n s->s3->tmp.valid_flags[i] = 0;\r\r\n }\r\r\n if ((list_len & 1) || !tls1_save_sigalgs(s, data, list_len)) {\r\r\n ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\r\r\n SSL_R_SIGNATURE_ALGORITHMS_ERROR);\r\r\n goto err;\r\r\n }\r\r\n if (!tls1_process_sigalgs(s)) {\r\r\n ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\r\r\n goto err;\r\r\n }\r\r\n } else {\r\r\n ssl_set_default_md(s);\r\r\n }\r\r\n\r\r\n /* get the CA RDNs */\r\r\n if (!PACKET_get_net_2(pkt, &list_len)\r\r\n || PACKET_remaining(pkt) != list_len) {\r\r\n ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\r\r\n goto err;\r\r\n }\r\r\n\r\r\n while (PACKET_remaining(pkt)) {\r\r\n if (!PACKET_get_net_2(pkt, &name_len)\r\r\n || !PACKET_get_bytes(pkt, &namebytes, name_len)) {\r\r\n ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\r\r\n SSL_R_LENGTH_MISMATCH);\r\r\n goto err;\r\r\n }\r\r\n\r\r\n namestart = namebytes;\r\r\n\r\r\n if ((xn = d2i_X509_NAME(NULL, (const unsigned char **)&namebytes,\r\r\n name_len)) == NULL) {\r\r\n ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_ASN1_LIB);\r\r\n goto err;\r\r\n }\r\r\n\r\r\n if (namebytes != (namestart + name_len)) {\r\r\n ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\r\r\n SSL_R_CA_DN_LENGTH_MISMATCH);\r\r\n goto err;\r\r\n }\r\r\n if (!sk_X509_NAME_push(ca_sk, xn)) {\r\r\n SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\r\r\n goto err;\r\r\n }\r\r\n xn = NULL;\r\r\n }\r\r\n\r\r\n /* we should setup a certificate to return.... */\r\r\n s->s3->tmp.cert_req = 1;\r\r\n s->s3->tmp.ctype_num = ctype_num;\r\r\n sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);\r\r\n s->s3->tmp.ca_names = ca_sk;\r\r\n ca_sk = NULL;\r\r\n\r\r\n ret = MSG_PROCESS_CONTINUE_PROCESSING;\r\r\n goto done;\r\r\n err:\r\r\n ossl_statem_set_error(s);\r\r\n done:\r\r\n X509_NAME_free(xn);\r\r\n sk_X509_NAME_pop_free(ca_sk, X509_NAME_free);\r\r\n return ret;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.No Vulnerabilities|D.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-912:Hidden Functionality\nB.No Vulnerabilities\nC.CWE-506:Embedded Malicious Code\nD.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption\nE.CWE-616:Incomplete Identification of Uploaded File Variables (PHP)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\n#define _SECOND ((INT64)10000000)\r\n#define _MINUTE (60 * _SECOND)\r\n#define _HOUR (60 * _MINUTE)\r\n#define _DAY (24 * _HOUR)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_file_attrib_accessed_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n FILETIME ftAccess;\r\n ULONGLONG qwResult;\r\n HANDLE hFile = INVALID_HANDLE_VALUE;\r\n do\r\n {\r\n hFile = CreateFile(TEXT(\"mFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE, \r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n break;\r\n }\r\n if (!GetFileTime(hFile,\r\n NULL,\r\n &ftAccess,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n qwResult -= 10 * _DAY;\r\n \r\n ftAccess.dwLowDateTime = (DWORD)(qwResult & 0xFFFFFFFF);\r\n ftAccess.dwHighDateTime = (DWORD)(qwResult >> 32);\r\n \r\n SetFileTime(hFile,\r\n (LPFILETIME)NULL,\r\n &ftAccess,\r\n (LPFILETIME)NULL);\r\n }\r\n while (0);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_file_attrib_accessed_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_file_attrib_accessed_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_file_attrib_accessed_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-506:Embedded Malicious Code|A.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-468:Incorrect Pointer Scaling\nB.No Vulnerabilities\nC.CWE-682:Incorrect Calculation\nD.CWE-158:Improper Neutralization of Null Byte or NUL Character\nE.CWE-182:Collapse of Data into Unsafe Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+(2*sizeof(int)));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-468:Incorrect Pointer Scaling|C.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1056:Invokable Control Element with Variadic Parameters\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-763:Release of Invalid Pointer or Reference\nD.No Vulnerabilities\nE.CWE-142:Improper Neutralization of Value Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_int64_t_calloc_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = (int64_t *)calloc(100, sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = (int64_t *)calloc(100, sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = (int64_t *)calloc(100, sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new int64_t[100];\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = new int64_t[100];\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_int64_t_calloc_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-426:Untrusted Search Path\nB.CWE-673:External Influence of Sphere Definition\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.No Vulnerabilities\nE.CWE-163:Improper Neutralization of Multiple Trailing Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM system\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\nnamespace My_char_system_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(char * &data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n mSource(data);\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(char * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_system_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-426:Untrusted Search Path|B.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1047:Modules with Circular Dependencies\nC.CWE-416:Use After Free\nD.CWE-657:Violation of Secure Design Principles\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_new_delete_int64_t_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_int64_t_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-416:Use After Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-229:Improper Handling of Values\nB.CWE-287:Improper Authentication\nC.No Vulnerabilities\nD.CWE-221:Information Loss or Omission\nE.CWE-222:Truncation of Security-relevant Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SIZE 15\r\n#define TRUNCATED_USERNAME_SIZE 4 \r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n char truncatedUsername[TRUNCATED_USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n memcpy(truncatedUsername, username, sizeof(truncatedUsername));\r\n truncatedUsername[TRUNCATED_USERNAME_SIZE] = '\\0';\r\n \r\n if (LogonUserA(\r\n truncatedUsername,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-222:Truncation of Security-relevant Information|D.CWE-221:Information Loss or Omission", "cwe": "222"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-415:Double Free\nB.CWE-834:Excessive Iteration\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-307:Improper Restriction of Excessive Authentication Attempts\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_int64_t_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid mSource(int64_t * &data)\r\n{\r\n data = new int64_t;\r\n \r\n delete data;\r\n}\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(int64_t * &data)\r\n{\r\n data = new int64_t;\r\n \r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nstatic void nB2GSource(int64_t * &data)\r\n{\r\n data = new int64_t;\r\n \r\n delete data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_int64_t_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-415:Double Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1119:Excessive Use of Unconditional Branching\nB.CWE-286:Incorrect User Management\nC.CWE-127:Buffer Under-read\nD.No Vulnerabilities\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_alloca_memmove_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_wchar_t_alloca_memmove_64()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n My_wchar_t_alloca_memmove_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_alloca_memmove_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n My_wchar_t_alloca_memmove_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_wchar_t_alloca_memmove_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_alloca_memmove_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_alloca_memmove_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-383:J2EE Bad Practices: Direct Use of Threads\nC.CWE-153:Improper Neutralization of Substitution Characters\nD.No Vulnerabilities\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2int_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double2int_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2int_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2int_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-681:Incorrect Conversion between Numeric Types|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-696:Incorrect Behavior Order\nB.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nC.CWE-400:Uncontrolled Resource Consumption\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\n#define SENTENCE \"This is the sentence we are printing to the file. \"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_fwrite_54bSink(int count);\r\n\r\nvoid My_connect_socket_fwrite_54()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_fwrite_54bSink(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_fwrite_54bG2BSink(int count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n My_connect_socket_fwrite_54bG2BSink(count);\r\n}\r\n\r\n\r\nvoid My_connect_socket_fwrite_54bB2GSink(int count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_fwrite_54bB2GSink(count);\r\n}\r\n\r\nvoid My_connect_socket_fwrite_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_fwrite_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_fwrite_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-400:Uncontrolled Resource Consumption|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-691:Insufficient Control Flow Management\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-23:Relative Path Traversal\nD.No Vulnerabilities\nE.CWE-447:Unimplemented or Unsupported Feature in UI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_file_ofstream_61\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nchar * mSource(char * data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n data = mSource(data);\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nchar * nG2BSource(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_ofstream_61; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-23:Relative Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-110:Struts: Validator Without Form Field\nB.CWE-390:Detection of Error Condition Without Action\nC.No Vulnerabilities\nD.CWE-261:Weak Encoding for Password\nE.CWE-755:Improper Handling of Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_char_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_char_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_char_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_char_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-390:Detection of Error Condition Without Action|E.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.No Vulnerabilities\nC.CWE-1097:Persistent Storable Data Element without Associated Comparison Control Element\nD.CWE-805:Buffer Access with Incorrect Length Value\nE.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint entropion_cardplayer = 0;\r\nint global_variable;\r\nvoid handle_taint(char *dripps_boylike);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid wahahe_anaxone(int remunerable_westchester,... );\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&entropion_cardplayer,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *dripps_boylike)\r\n{\r\n char *haggling_grasser[42] = {0};\r\n ++global_variable;;\r\n if (dripps_boylike != 0) {;\r\n haggling_grasser[39] = dripps_boylike;\r\n wahahe_anaxone(1,haggling_grasser);\r\n }\r\n}\r\n\r\nvoid wahahe_anaxone(int remunerable_westchester,... )\r\n{\r\n int oc_i = 0;\r\n char * data = 0;\r\n char *redskins_jarnut = 0;\r\n char **disbrain_unhandled = 0;\r\n va_list uncompressible_precinctive;\r\n ++global_variable;;\r\n if (remunerable_westchester > 0) {\r\n __builtin_va_start(uncompressible_precinctive,remunerable_westchester);\r\n disbrain_unhandled = (va_arg(uncompressible_precinctive,char **));\r\n __builtin_va_end(uncompressible_precinctive);\r\n }\r\n redskins_jarnut = ((char *)disbrain_unhandled[39]);\r\n \r\n data = (char*) malloc(8 * sizeof(char));\r\n if (data != NULL) {\r\n \r\n \r\n \r\n \r\n \r\n strncpy(data, redskins_jarnut, strlen(redskins_jarnut) + 1);\r\n for (; oc_i < strlen(data); ++oc_i) {\r\n data[oc_i] = toupper(data[oc_i]);\r\n }\r\n printf(\"%s\\n\", data);\r\n \r\n \r\n free(data);\r\n }\r\n \r\n;\r\n if (disbrain_unhandled[39] != 0) \r\n free(((char *)disbrain_unhandled[39]));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-805:Buffer Access with Incorrect Length Value|E.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer", "cwe": "805"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nB.CWE-575:EJB Bad Practices: Use of AWT Swing\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-1240:Use of a Cryptographic Primitive with a Risky Implementation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_open_no_close_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_open_no_close_83\r\n{\r\npublic:\r\n My_open_no_close_83(int dataCopy);\r\n ~My_open_no_close_83();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_open_no_close_83B2G\r\n{\r\npublic:\r\n My_open_no_close_83B2G(int dataCopy);\r\n ~My_open_no_close_83B2G();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-241:Improper Handling of Unexpected Data Type\nB.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nC.CWE-426:Untrusted Search Path\nD.No Vulnerabilities\nE.CWE-710:Improper Adherence to Coding Standards\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_pointer_new_use_15\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n int * * pointer = new int *;\r\n int * data = *pointer; \r\n delete pointer;\r\n printIntLine(*data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n int * data;\r\n \r\n data = new int;\r\n *data = 5;\r\n int * * pointer = new int *;\r\n *pointer = data; \r\n {\r\n int * data = *pointer;\r\n printIntLine(*data);\r\n }\r\n delete pointer;\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n int * data;\r\n \r\n data = new int;\r\n *data = 5;\r\n int * * pointer = new int *;\r\n *pointer = data; \r\n {\r\n int * data = *pointer;\r\n printIntLine(*data);\r\n }\r\n delete pointer;\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_pointer_new_use_15; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-184:Incomplete List of Disallowed Inputs\nB.CWE-401:Missing Release of Memory after Effective Lifetime\nC.CWE-1111:Incomplete I/O Documentation\nD.CWE-404:Improper Resource Shutdown or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_int_54\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(int * data);\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n data = NULL;\r\n \r\n data = new int;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(int * data);\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n data = NULL;\r\n \r\n int dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n nG2BSink_b(data);\r\n}\r\n\r\n\r\nvoid nB2GSink_b(int * data);\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n data = NULL;\r\n \r\n data = new int;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n nB2GSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_int_54; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-401:Missing Release of Memory after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-834:Excessive Iteration\nC.No Vulnerabilities\nD.CWE-127:Buffer Under-read\nE.CWE-270:Privilege Context Switching Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_char_loop_11()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n {\r\n size_t i;\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n size_t i;\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n size_t i;\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_char_loop_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_char_loop_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_char_loop_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nB.No Vulnerabilities\nC.CWE-20:Improper Input Validation\nD.CWE-1111:Incomplete I/O Documentation\nE.CWE-1334:Unauthorized Error Injection Can Degrade Hardware Redundancy\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint outgoer_defeit = 0;\r\n\r\nunion monolinguist_amphibolitic \r\n{\r\n char *rostrated_missilries;\r\n double outffed_mastiches;\r\n char *fremescent_winnah;\r\n char dendrocolaptine_satisfier;\r\n int leanora_decreers;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nint toupper(int c) {\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int oc_i = 0;\r\n char stack_buffer_64[64];\r\n char *plaudit_scrumpy = 0;\r\n int pestify_goupin;\r\n int musths_beweeps;\r\n union monolinguist_amphibolitic brisked_periosteophyte = {0};\r\n int *overresolute_rectorial = 0;\r\n int duende_curvirostral;\r\n union monolinguist_amphibolitic decurtate_cailly[10] = {0};\r\n union monolinguist_amphibolitic lidded_infanta;\r\n char *innervating_onagraceae;;\r\n if (__sync_bool_compare_and_swap(&outgoer_defeit,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n innervating_onagraceae = getenv(\"UNDEWILY_HINTED\");\r\n if (innervating_onagraceae != 0) {;\r\n lidded_infanta . rostrated_missilries = innervating_onagraceae;\r\n decurtate_cailly[5] = lidded_infanta;\r\n duende_curvirostral = 5;\r\n overresolute_rectorial = &duende_curvirostral;\r\n brisked_periosteophyte = *(decurtate_cailly + *overresolute_rectorial);\r\n musths_beweeps = 5;\r\n while(1 == 1){\r\n musths_beweeps = musths_beweeps * 2;\r\n musths_beweeps = musths_beweeps + 2;\r\n if (musths_beweeps > 1000) {\r\n break; \r\n }\r\n }\r\n pestify_goupin = musths_beweeps;\r\n plaudit_scrumpy = ((char *)brisked_periosteophyte . rostrated_missilries);\r\n \r\n memset(stack_buffer_64,0,64);\r\n \r\n \r\n \r\n \r\n \r\n strcpy(stack_buffer_64,plaudit_scrumpy);\r\n \r\n \r\n \r\n for (; oc_i < 64; ++oc_i) {\r\n stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",stack_buffer_64);\r\n \r\n \r\n \r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')|C.CWE-20:Improper Input Validation", "cwe": "120"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1220:Insufficient Granularity of Access Control\nB.CWE-127:Buffer Under-read\nC.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE839_fgets_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.No Vulnerabilities\nC.CWE-1323:Improper Management of Sensitive Trace Data\nD.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nE.CWE-122:Heap-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_c_My_c_My_c_My_c_CWE805_struct_memmove_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-122:Heap-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-202:Exposure of Sensitive Information Through Data Queries\nB.No Vulnerabilities\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.CWE-160:Improper Neutralization of Leading Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_short_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_short_64()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n My_short_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_short_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n My_short_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_short_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-297:Improper Validation of Certificate with Host Mismatch\nB.CWE-404:Improper Resource Shutdown or Release\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-1098:Data Element containing Pointer Item without Proper Copy Control Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_w32CloseHandle_13()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_w32CloseHandle_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_w32CloseHandle_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_w32CloseHandle_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-221:Information Loss or Omission\nB.CWE-109:Struts: Validator Turned Off\nC.CWE-222:Truncation of Security-relevant Information\nD.No Vulnerabilities\nE.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SIZE 15\r\n#define TRUNCATED_USERNAME_SIZE 4 \r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n char truncatedUsername[TRUNCATED_USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n memcpy(truncatedUsername, username, sizeof(truncatedUsername));\r\n truncatedUsername[TRUNCATED_USERNAME_SIZE] = '\\0';\r\n \r\n if (LogonUserA(\r\n truncatedUsername,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-222:Truncation of Security-relevant Information|A.CWE-221:Information Loss or Omission", "cwe": "222"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1269:Product Released in Non-Release Configuration\nB.No Vulnerabilities\nC.CWE-253:Incorrect Check of Function Return Value\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-32:Path Traversal: '...' (Triple Dot)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fread_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\r\n {\r\n printLine(\"fread failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\r\n {\r\n printLine(\"fread failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fread_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fread_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fread_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-253:Incorrect Check of Function Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-786:Access of Memory Location Before Start of Buffer\nC.CWE-131:Incorrect Calculation of Buffer Size\nD.CWE-124:Buffer Underwrite ('Buffer Underflow')\nE.CWE-625:Permissive Regular Expression\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_wchar_t_loop_12()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n size_t i;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n data[i] = source[i];\r\n }\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n size_t i;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n data[i] = source[i];\r\n }\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_loop_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_loop_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_loop_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-124:Buffer Underwrite ('Buffer Underflow')|B.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-655:Insufficient Psychological Acceptability\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_delete_array_int64_t_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int64_t *> dataVector);\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n vector<int64_t *> dataVector;\r\n \r\n data = NULL;\r\n \r\n data = new int64_t;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<int64_t *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n vector<int64_t *> dataVector;\r\n \r\n data = NULL;\r\n \r\n data = new int64_t[100];\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<int64_t *> dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n vector<int64_t *> dataVector;\r\n \r\n data = NULL;\r\n \r\n data = new int64_t;\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_int64_t_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-180:Incorrect Behavior Order: Validate Before Canonicalize\nC.CWE-309:Use of Password System for Primary Authentication\nD.CWE-391:Unchecked Error Condition\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#include <math.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_sqrt_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n double doubleNumber;\r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_sqrt_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_sqrt_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_sqrt_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-391:Unchecked Error Condition|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nB.No Vulnerabilities\nC.CWE-645:Overly Restrictive Account Lockout Mechanism\nD.CWE-588:Attempt to Access Child of a Non-structure Pointer\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_17()\r\n{\r\n int i;\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = &dataMBuffer;\r\n }\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\nvoid My_struct_17()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-588:Attempt to Access Child of a Non-structure Pointer|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1223:Race Condition for Write-Once Attributes\nC.CWE-510:Trapdoor\nD.CWE-506:Embedded Malicious Code\nE.CWE-793:Only Filtering One Instance of a Special Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_ip_based_logic_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"192.168.30.123\", inet_ntoa(acceptService.sin_addr)) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_ip_based_logic_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_ip_based_logic_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_ip_based_logic_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-510:Trapdoor|D.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.No Vulnerabilities\nC.CWE-110:Struts: Validator Without Form Field\nD.CWE-276:Incorrect Default Permissions\nE.CWE-690:Unchecked Return Value to NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n \r\n strcpy(data, \"Initialize\");\r\n printLine(data);\r\n free(data);\r\n}\r\n\r\nvoid My_char_calloc_41()\r\n{\r\n char * data;\r\n data = NULL; \r\n \r\n data = (char *)calloc(20, sizeof(char));\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void nB2GSink(char * data)\r\n{\r\n \r\n if (data != NULL)\r\n {\r\n strcpy(data, \"Initialize\");\r\n printLine(data);\r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n data = NULL; \r\n \r\n data = (char *)calloc(20, sizeof(char));\r\n nB2GSink(data);\r\n}\r\n\r\nvoid My_char_calloc_41()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_calloc_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_calloc_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-690:Unchecked Return Value to NULL Pointer Dereference|A.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-435:Improper Interaction Between Multiple Correctly-Behaving Entities\nC.CWE-510:Trapdoor\nD.CWE-524:Use of Cache Containing Sensitive Information\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_ip_based_logic_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"192.168.30.123\", inet_ntoa(acceptService.sin_addr)) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n}\r\n\r\nvoid My_ip_based_logic_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_ip_based_logic_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_ip_based_logic_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-510:Trapdoor|E.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-588:Attempt to Access Child of a Non-structure Pointer\nB.CWE-798:Use of Hard-coded Credentials\nC.CWE-704:Incorrect Type Conversion or Cast\nD.No Vulnerabilities\nE.CWE-1262:Improper Access Control for Register Interface\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n goto source;\r\nsource:\r\n \r\n data = &dataMBuffer;\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n goto source;\r\nsource:\r\n \r\n data = &dataNBuffer;\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-588:Attempt to Access Child of a Non-structure Pointer|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1114:Inappropriate Whitespace Style\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-126:Buffer Over-read\nD.No Vulnerabilities\nE.CWE-1122:Excessive Halstead Complexity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_memmove_44\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * data)\r\n{\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n data = NULL;\r\n \r\n data = new wchar_t[50];\r\n wmemset(data, L'A', 50-1); \r\n data[50-1] = L'\\0'; \r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * data)\r\n{\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n data = NULL;\r\n \r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n funcPtr(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_memmove_44; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1062:Parent Class with References to Child Class\nB.CWE-1284:Improper Validation of Specified Quantity in Input\nC.No Vulnerabilities\nD.CWE-755:Improper Handling of Exceptional Conditions\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_char_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printLine(data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fgets_char_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_char_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_char_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-390:Detection of Error Condition Without Action|D.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-673:External Influence of Sphere Definition\nB.CWE-794:Incomplete Filtering of Multiple Instances of Special Elements\nC.CWE-426:Untrusted Search Path\nD.CWE-836:Use of Password Hash Instead of Password for Authentication\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _wpopen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\nnamespace My_wchar_t_popen_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_popen_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-426:Untrusted Search Path|A.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nB.CWE-73:External Control of File Name or Path\nC.No Vulnerabilities\nD.CWE-114:Process Control\nE.CWE-689:Permission Race Condition During Resource Copy\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_console_03()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_console_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_console_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_console_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|B.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-284:Improper Access Control\nC.CWE-1301:Insufficient or Incomplete Data Removal within Hardware Component\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-273:Improper Check for Dropped Privileges\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <rpcdce.h>\r\n# pragma comment(lib, \"rpcrt4\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RpcImpersonateClient_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n RpcImpersonateClient(0);\r\n \r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\nvoid My_w32_RpcImpersonateClient_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RpcImpersonateClient_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RpcImpersonateClient_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-273:Improper Check for Dropped Privileges|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-703:Improper Check or Handling of Exceptional Conditions\nB.CWE-426:Untrusted Search Path\nC.CWE-284:Improper Access Control\nD.CWE-556:ASP.NET Misconfiguration: Use of Identity Impersonation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateWindowStation_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n HWINSTA hWinStation;\r\n wchar_t * wStationName = L\"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationW(\r\n wStationName,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n HWINSTA hWinStation;\r\n wchar_t * wStationName = L\"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationW(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateWindowStation_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateWindowStation_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateWindowStation_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-284:Improper Access Control|D.CWE-556:ASP.NET Misconfiguration: Use of Identity Impersonation", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-286:Incorrect User Management\nB.CWE-126:Buffer Over-read\nC.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\nD.No Vulnerabilities\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_malloc_wchar_t_memmove_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_malloc_wchar_t_memmove_64()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = (wchar_t *)malloc(50*sizeof(wchar_t));\r\n wmemset(data, L'A', 50-1); \r\n data[50-1] = L'\\0'; \r\n My_malloc_wchar_t_memmove_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_malloc_wchar_t_memmove_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n My_malloc_wchar_t_memmove_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_malloc_wchar_t_memmove_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_memmove_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_memmove_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-667:Improper Locking\nB.CWE-832:Unlock of a Resource that is not Locked\nC.CWE-781:Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code\nD.No Vulnerabilities\nE.CWE-560:Use of umask() with chmod-style Argument\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-832:Unlock of a Resource that is not Locked|A.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-153:Improper Neutralization of Substitution Characters\nB.CWE-590:Free of Memory not on the Heap\nC.No Vulnerabilities\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-675:Multiple Operations on Resource in Single-Operation Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_struct_static_53\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(twoIntsStruct * data);\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n {\r\n \r\n static twoIntsStruct dataBuffer;\r\n dataBuffer.intOne = 1;\r\n dataBuffer.intTwo = 1;\r\n data = &dataBuffer;\r\n }\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(twoIntsStruct * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n {\r\n \r\n twoIntsStruct * dataBuffer = new twoIntsStruct;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n nG2BSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_struct_static_53; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-590:Free of Memory not on the Heap|D.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-272:Least Privilege Violation\nB.CWE-820:Missing Synchronization\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.CWE-400:Uncontrolled Resource Consumption\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegCreateUSKey_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKLM) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegCreateUSKey_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegCreateUSKey_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegCreateUSKey_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-272:Least Privilege Violation|C.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1113:Inappropriate Comment Style\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-617:Reachable Assertion\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_listen_socket_22Global = 0;\r\n\r\nint My_listen_socket_22Source(int data);\r\n\r\nvoid My_listen_socket_22()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n My_listen_socket_22Global = 1; \r\n data = My_listen_socket_22Source(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_listen_socket_22G2B1Global = 0;\r\nint My_listen_socket_22G2B2Global = 0;\r\n\r\n\r\nint My_listen_socket_22G2B1Source(int data);\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n My_listen_socket_22G2B1Global = 0; \r\n data = My_listen_socket_22G2B1Source(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nint My_listen_socket_22G2B2Source(int data);\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n My_listen_socket_22G2B2Global = 1; \r\n data = My_listen_socket_22G2B2Source(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_listen_socket_22()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-617:Reachable Assertion|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-771:Missing Reference to Active Allocated Resource\nB.CWE-304:Missing Critical Step in Authentication\nC.No Vulnerabilities\nD.CWE-773:Missing Reference to Active File Descriptor or Handle\nE.CWE-435:Improper Interaction Between Multiple Correctly-Behaving Entities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_03()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(5==5)\r\n {\r\n \r\n data = fopen(\"MSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(5==5)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-773:Missing Reference to Active File Descriptor or Handle|A.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-307:Improper Restriction of Excessive Authentication Attempts\nB.CWE-675:Multiple Operations on Resource in Single-Operation Context\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_freopen_63bSink(FILE * * dataPtr);\r\n\r\nvoid My_freopen_63()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n My_freopen_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_freopen_63bG2BSink(FILE * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n My_freopen_63bG2BSink(&data);\r\n}\r\n\r\n\r\nvoid My_freopen_63bB2GSink(FILE * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n My_freopen_63bB2GSink(&data);\r\n}\r\n\r\nvoid My_freopen_63()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-675:Multiple Operations on Resource in Single-Operation Context|C.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-301:Reflection Attack in an Authentication Protocol\nB.CWE-252:Unchecked Return Value\nC.No Vulnerabilities\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define SRC \"sscanf\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_sscanf_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n sscanf(SRC, \"%99s\\0\", data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (sscanf(SRC, \"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"sscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (sscanf(SRC, \"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"sscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_sscanf_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_sscanf_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_sscanf_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-1102:Reliance on Machine-Dependent Data Representation\nD.CWE-1119:Excessive Use of Unconditional Branching\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE170_wchar_t_memcpy_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-194:Unexpected Sign Extension\nC.No Vulnerabilities\nD.CWE-340:Generation of Predictable Numbers or Identifiers\nE.CWE-512:Spyware\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_rand_memcpy_52bSink(short data);\r\n\r\nvoid My_rand_memcpy_52()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = (short)RAND32();\r\n My_rand_memcpy_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_rand_memcpy_52bG2BSink(short data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n My_rand_memcpy_52bG2BSink(data);\r\n}\r\n\r\nvoid My_rand_memcpy_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_memcpy_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_memcpy_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-194:Unexpected Sign Extension|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-160:Improper Neutralization of Leading Special Elements\nB.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nC.CWE-1255:Comparison Logic is Vulnerable to Power Side-Channel Attacks\nD.No Vulnerabilities\nE.CWE-479:Signal Handler Use of a Non-reentrant Function\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\nstatic void helperM(int sig)\r\n{\r\n \r\n \r\n void *voidPointer = malloc(10);\r\n if (voidPointer == NULL) {exit(-1);}\r\n free(voidPointer);\r\n}\r\n\r\nstatic volatile sig_atomic_t volatileSigAtomic = 0;\r\n\r\nstatic void helperN(int sig)\r\n{\r\n \r\n volatileSigAtomic = sig;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n signal(SIGINT, helperM);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\nvoid My_basic_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-479:Signal Handler Use of a Non-reentrant Function|B.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe", "cwe": "479"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-832:Unlock of a Resource that is not Locked\nB.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nC.No Vulnerabilities\nD.CWE-667:Improper Locking\nE.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-832:Unlock of a Resource that is not Locked|D.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-415:Double Free\nB.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_wchar_t_65\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n \r\n data = NULL;\r\n data = new wchar_t;\r\n \r\n delete data;\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n \r\n data = NULL;\r\n data = new wchar_t;\r\n \r\n funcPtr(data);\r\n}\r\n\r\n\r\nvoid nB2GSink(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nB2GSink;\r\n \r\n data = NULL;\r\n data = new wchar_t;\r\n \r\n delete data;\r\n funcPtr(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_wchar_t_65; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-415:Double Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-370:Missing Check for Certificate Revocation after Initial Check\nC.CWE-415:Double Free\nD.CWE-293:Using Referer Field for Authentication\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_delete_char_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<char *> dataVector);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n \r\n data = NULL;\r\n data = new char;\r\n \r\n delete data;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<char *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n \r\n data = NULL;\r\n data = new char;\r\n \r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<char *> dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n \r\n data = NULL;\r\n data = new char;\r\n \r\n delete data;\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_char_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-415:Double Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-127:Buffer Under-read\nB.CWE-786:Access of Memory Location Before Start of Buffer\nC.CWE-260:Password in Configuration File\nD.CWE-1293:Missing Source Correlation of Multiple Independent Data\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_My_My_My_My_My_My_My_CWE839_connect_socket_81_base\r\n{\r\npublic:\r\n void action(int data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-127:Buffer Under-read|B.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1260:Improper Handling of Overlap Between Protected Memory Ranges\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-1025:Comparison Using Wrong Factors\nD.No Vulnerabilities\nE.CWE-427:Uncontrolled Search Path Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\nstatic char * My_char_listen_socket_45Data;\r\nstatic char * My_char_listen_socket_45G2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n char * data = My_char_listen_socket_45Data;\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_char_listen_socket_45()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_char_listen_socket_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n char * data = My_char_listen_socket_45G2BData;\r\n \r\n PUTENV(data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n \r\n strcat(data, NEW_PATH);\r\n My_char_listen_socket_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid My_char_listen_socket_45()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-788:Access of Memory Location After End of Buffer\nC.No Vulnerabilities\nD.CWE-126:Buffer Over-read\nE.CWE-1070:Serializable Data Element Containing non-Serializable Item Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_declare_loop_54bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_declare_loop_54()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataMBuffer;\r\n My_wchar_t_declare_loop_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_declare_loop_54bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataNBuffer;\r\n My_wchar_t_declare_loop_54bG2BSink(data);\r\n}\r\n\r\nvoid My_wchar_t_declare_loop_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_declare_loop_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_declare_loop_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1044:Architecture with Number of Horizontal Layers Outside of Expected Range\nB.No Vulnerabilities\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_char_13()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_free_char_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_char_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_char_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-341:Predictable from Observable State\nB.CWE-617:Reachable Assertion\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.No Vulnerabilities\nE.CWE-434:Unrestricted Upload of File with Dangerous Type\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_rand_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_rand_64()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n My_rand_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_rand_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n My_rand_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_rand_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-617:Reachable Assertion|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-486:Comparison of Classes by Name\nC.CWE-194:Unexpected Sign Extension\nD.No Vulnerabilities\nE.CWE-261:Weak Encoding for Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nshort My_negative_malloc_68Data;\r\nshort My_negative_malloc_68G2BData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_negative_malloc_68bSink();\r\n\r\nvoid My_negative_malloc_68()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = -1;\r\n My_negative_malloc_68Data = data;\r\n My_negative_malloc_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_negative_malloc_68bG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n My_negative_malloc_68G2BData = data;\r\n My_negative_malloc_68bG2BSink();\r\n}\r\n\r\nvoid My_negative_malloc_68()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_negative_malloc_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_negative_malloc_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-194:Unexpected Sign Extension|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-459:Incomplete Cleanup\nC.CWE-1263:Improper Physical Access Control\nD.CWE-363:Race Condition Enabling Link Following\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_declare_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_declare_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_declare_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_declare_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|B.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.No Vulnerabilities\nC.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nD.CWE-1265:Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\nE.CWE-675:Multiple Operations on Resource in Single-Operation Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_freopen_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, FILE *> dataMap);\r\n\r\nvoid m()\r\n{\r\n FILE * data;\r\n map<int, FILE *> dataMap;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, FILE *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n FILE * data;\r\n map<int, FILE *> dataMap;\r\n data = NULL; \r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, FILE *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n map<int, FILE *> dataMap;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_freopen_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-675:Multiple Operations on Resource in Single-Operation Context|A.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-544:Missing Standardized Error Handling Mechanism\nB.CWE-328:Use of Weak Hash\nC.CWE-14:Compiler Removal of Code to Clear Buffers\nD.CWE-326:Inadequate Encryption Strength\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define MD2_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_MD2_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[MD2_SUM_SIZE], calcHash[MD2_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < MD2_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_MD2, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = MD2_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, MD2_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_MD2_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_MD2_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_MD2_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-328:Use of Weak Hash|D.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-37:Path Traversal: '/absolute/pathname/here'\nB.No Vulnerabilities\nC.CWE-511:Logic/Time Bomb\nD.CWE-173:Improper Handling of Alternate Encoding\nE.CWE-482:Comparing instead of Assigning\n", "input": "PHP_METHOD(PharFileInfo, compress)\r\r\n{\r\r\n\tlong method;\r\r\n\tchar *error;\r\r\n\tPHAR_ENTRY_OBJECT();\r\r\n\r\r\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &method) == FAILURE) {\r\r\n\t\treturn;\r\r\n\t}\r\r\n\r\r\n\tif (entry_obj->ent.entry->is_tar) {\r\r\n\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\"Cannot compress with Gzip compression, not possible with tar-based phar archives\");\r\r\n\t\treturn;\r\r\n\t}\r\r\n\r\r\n\tif (entry_obj->ent.entry->is_dir) {\r\r\n\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC, \\\r\r\n\t\t\t\"Phar entry is a directory, cannot set compression\"); \\\r\r\n\t\treturn;\r\r\n\t}\r\r\n\r\r\n\tif (PHAR_G(readonly) && !entry_obj->ent.entry->phar->is_data) {\r\r\n\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\"Phar is readonly, cannot change compression\");\r\r\n\t\treturn;\r\r\n\t}\r\r\n\r\r\n\tif (entry_obj->ent.entry->is_deleted) {\r\r\n\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\"Cannot compress deleted file\");\r\r\n\t\treturn;\r\r\n\t}\r\r\n\r\r\n\tif (entry_obj->ent.entry->is_persistent) {\r\r\n\t\tphar_archive_data *phar = entry_obj->ent.entry->phar;\r\r\n\r\r\n\t\tif (FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {\r\r\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar->fname);\r\r\n\t\t\treturn;\r\r\n\t\t}\r\r\n\t\t/* re-populate after copy-on-write */\r\r\n\t\tzend_hash_find(&phar->manifest, entry_obj->ent.entry->filename, entry_obj->ent.entry->filename_len, (void **)&entry_obj->ent.entry);\r\r\n\t}\r\r\n\tswitch (method) {\r\r\n\t\tcase PHAR_ENT_COMPRESSED_GZ:\r\r\n\t\t\tif (entry_obj->ent.entry->flags & PHAR_ENT_COMPRESSED_GZ) {\r\r\n\t\t\t\tRETURN_TRUE;\r\r\n\t\t\t}\r\r\n\r\r\n\t\t\tif ((entry_obj->ent.entry->flags & PHAR_ENT_COMPRESSED_BZ2) != 0) {\r\r\n\t\t\t\tif (!PHAR_G(has_bz2)) {\r\r\n\t\t\t\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\t\t\t\"Cannot compress with gzip compression, file is already compressed with bzip2 compression and bz2 extension is not enabled, cannot decompress\");\r\r\n\t\t\t\t\treturn;\r\r\n\t\t\t\t}\r\r\n\r\r\n\t\t\t\t/* decompress this file indirectly */\r\r\n\t\t\t\tif (SUCCESS != phar_open_entry_fp(entry_obj->ent.entry, &error, 1 TSRMLS_CC)) {\r\r\n\t\t\t\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\t\t\t\"Phar error: Cannot decompress bzip2-compressed file \\\"%s\\\" in phar \\\"%s\\\" in order to compress with gzip: %s\", entry_obj->ent.entry->filename, entry_obj->ent.entry->phar->fname, error);\r\r\n\t\t\t\t\tefree(error);\r\r\n\t\t\t\t\treturn;\r\r\n\t\t\t\t}\r\r\n\t\t\t}\r\r\n\r\r\n\t\t\tif (!PHAR_G(has_zlib)) {\r\r\n\t\t\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\t\t\"Cannot compress with gzip compression, zlib extension is not enabled\");\r\r\n\t\t\t\treturn;\r\r\n\t\t\t}\r\r\n\r\r\n\t\t\tentry_obj->ent.entry->old_flags = entry_obj->ent.entry->flags;\r\r\n\t\t\tentry_obj->ent.entry->flags &= ~PHAR_ENT_COMPRESSION_MASK;\r\r\n\t\t\tentry_obj->ent.entry->flags |= PHAR_ENT_COMPRESSED_GZ;\r\r\n\t\t\tbreak;\r\r\n\t\tcase PHAR_ENT_COMPRESSED_BZ2:\r\r\n\t\t\tif (entry_obj->ent.entry->flags & PHAR_ENT_COMPRESSED_BZ2) {\r\r\n\t\t\t\tRETURN_TRUE;\r\r\n\t\t\t}\r\r\n\r\r\n\t\t\tif ((entry_obj->ent.entry->flags & PHAR_ENT_COMPRESSED_GZ) != 0) {\r\r\n\t\t\t\tif (!PHAR_G(has_zlib)) {\r\r\n\t\t\t\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\t\t\t\"Cannot compress with bzip2 compression, file is already compressed with gzip compression and zlib extension is not enabled, cannot decompress\");\r\r\n\t\t\t\t\treturn;\r\r\n\t\t\t\t}\r\r\n\r\r\n\t\t\t\t/* decompress this file indirectly */\r\r\n\t\t\t\tif (SUCCESS != phar_open_entry_fp(entry_obj->ent.entry, &error, 1 TSRMLS_CC)) {\r\r\n\t\t\t\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\t\t\t\"Phar error: Cannot decompress gzip-compressed file \\\"%s\\\" in phar \\\"%s\\\" in order to compress with bzip2: %s\", entry_obj->ent.entry->filename, entry_obj->ent.entry->phar->fname, error);\r\r\n\t\t\t\t\tefree(error);\r\r\n\t\t\t\t\treturn;\r\r\n\t\t\t\t}\r\r\n\t\t\t}\r\r\n\r\r\n\t\t\tif (!PHAR_G(has_bz2)) {\r\r\n\t\t\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC,\r\r\n\t\t\t\t\t\"Cannot compress with bzip2 compression, bz2 extension is not enabled\");\r\r\n\t\t\t\treturn;\r\r\n\t\t\t}\r\r\n\t\t\tentry_obj->ent.entry->old_flags = entry_obj->ent.entry->flags;\r\r\n\t\t\tentry_obj->ent.entry->flags &= ~PHAR_ENT_COMPRESSION_MASK;\r\r\n\t\t\tentry_obj->ent.entry->flags |= PHAR_ENT_COMPRESSED_BZ2;\r\r\n\t\t\tbreak;\r\r\n\t\tdefault:\r\r\n\t\t\tzend_throw_exception_ex(spl_ce_MMethodCallException, 0 TSRMLS_CC, \\\r\r\n\t\t\t\t\"Unknown compression type specified\"); \\\r\r\n\t}\r\r\n\r\r\n\tentry_obj->ent.entry->phar->is_modified = 1;\r\r\n\tentry_obj->ent.entry->is_modified = 1;\r\r\n\tphar_flush(entry_obj->ent.entry->phar, 0, 0, 0, &error TSRMLS_CC);\r\r\n\r\r\n\tif (error) {\r\r\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\r\r\n\t\tefree(error);\r\r\n\t}\r\r\n\r\r\n\tRETURN_TRUE;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.No Vulnerabilities|B.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-328:Use of Weak Hash\nB.CWE-326:Inadequate Encryption Strength\nC.CWE-113:Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\nD.No Vulnerabilities\nE.CWE-454:External Initialization of Trusted Variables or Data Stores\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define MD5_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_MD5_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[MD5_SUM_SIZE], calcHash[MD5_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < MD5_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = MD5_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, MD5_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_MD5_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_MD5_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_MD5_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-328:Use of Weak Hash|B.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-522:Insufficiently Protected Credentials\nB.No Vulnerabilities\nC.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context\nD.CWE-256:Plaintext Storage of a Password\nE.CWE-1043:Data Element Aggregating an Excessively Large Number of Non-Primitive Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_char_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<char *> dataVector);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<char *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<char *> dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-256:Plaintext Storage of a Password|A.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-134:Use of Externally-Controlled Format String\nB.CWE-271:Privilege Dropping / Lowering Errors\nC.CWE-272:Least Privilege Violation\nD.CWE-598:Use of GET Request Method With Sensitive Query Strings\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n TRUE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegOpenUSKey_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegOpenUSKey_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-272:Least Privilege Violation|B.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-773:Missing Reference to Active File Descriptor or Handle\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-479:Signal Handler Use of a Non-reentrant Function\nD.No Vulnerabilities\nE.CWE-1315:Improper Setting of Bus Controlling Capability in Fabric End-point\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_open_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, int> dataMap);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(map<int, int> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_open_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-481:Assigning instead of Comparing\nB.No Vulnerabilities\nC.CWE-480:Use of Incorrect Operator\nD.CWE-472:External Control of Assumed-Immutable Web Parameter\nE.CWE-144:Improper Neutralization of Line Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n int intRand = rand();\r\n \r\n if(intRand = 5)\r\n {\r\n printLine(\"i was 5\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n int intRand = rand();\r\n \r\n if(intRand == 5)\r\n {\r\n printLine(\"i was 5\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n int intRand = rand();\r\n \r\n if(intRand == 5)\r\n {\r\n printLine(\"i was 5\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_basic_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-481:Assigning instead of Comparing|C.CWE-480:Use of Incorrect Operator", "cwe": "481"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-57:Path Equivalence: 'fakedir/../realdir/filename'\nB.CWE-330:Use of Insufficiently Random Values\nC.No Vulnerabilities\nD.CWE-111:Direct Use of Unsafe JNI\nE.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|B.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-364:Signal Handler Race Condition\nC.CWE-912:Hidden Functionality\nD.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"windows.h\"\r\n#pragma comment(lib, \"user32.lib\")\r\n#pragma comment(lib, \"Gdi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_screen_capture_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n \r\n hdcWindow = GetDC(hWnd);\r\n if (hdcWindow == NULL)\r\n {\r\n break;\r\n }\r\n \r\n hdcMemDC = CreateCompatibleDC(hdcWindow);\r\n if (hdcMemDC == NULL)\r\n {\r\n break;\r\n }\r\n \r\n if (GetClientRect(hWnd, &rcClient) == 0)\r\n {\r\n break;\r\n }\r\n \r\n hbmScreen = CreateCompatibleBitmap(hdcWindow, rcClient.right-rcClient.left, rcClient.bottom-rcClient.top);\r\n if (hbmScreen == NULL)\r\n {\r\n break;\r\n }\r\n \r\n selectResult = SelectObject(hdcMemDC,hbmScreen);\r\n if (selectResult == NULL || selectResult == HGDI_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (BitBlt(hdcMemDC,\r\n 0,0,\r\n rcClient.right-rcClient.left, rcClient.bottom-rcClient.top,\r\n hdcWindow,\r\n 0,0,\r\n SRCCOPY) == 0)\r\n {\r\n break;\r\n }\r\n \r\n if (GetObject(hbmScreen,sizeof(BITMAP),&bmpScreen) == 0)\r\n {\r\n break;\r\n }\r\n bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\r\n bmiHeader.biWidth = bmpScreen.bmWidth;\r\n bmiHeader.biHeight = bmpScreen.bmHeight;\r\n bmiHeader.biPlanes = 1;\r\n bmiHeader.biBitCount = 32;\r\n bmiHeader.biCompression = BI_RGB;\r\n bmiHeader.biSizeImage = 0;\r\n bmiHeader.biXPelsPerMeter = 0;\r\n bmiHeader.biYPelsPerMeter = 0;\r\n bmiHeader.biClrUsed = 0;\r\n bmiHeader.biClrImportant = 0;\r\n dwBmpSize = ((bmpScreen.bmWidth * bmiHeader.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight;\r\n \r\n hDIB = GlobalAlloc(GHND,dwBmpSize);\r\n if (hDIB == NULL)\r\n {\r\n break;\r\n }\r\n lpbitmap = (char *)GlobalLock(hDIB);\r\n if (lpbitmap == NULL)\r\n {\r\n break;\r\n }\r\n \r\n if (GetDIBits(hdcWindow, hbmScreen, 0,\r\n (UINT)bmpScreen.bmHeight,\r\n lpbitmap,\r\n (BITMAPINFO *)&bmiHeader, DIB_RGB_COLORS) == 0)\r\n {\r\n break;\r\n }\r\n \r\n hFile = CreateFile(TEXT(\"capture.bmp\"),\r\n GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n break;\r\n }\r\n \r\n dwSizeofDIB = dwBmpSize + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);\r\n \r\n bmfHeader.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER);\r\n \r\n bmfHeader.bfSize = dwSizeofDIB;\r\n \r\n bmfHeader.bfType = 0x4D42; \r\n dwBytesWritten = 0;\r\n \r\n if (WriteFile(hFile, (LPSTR)&bmfHeader, sizeof(BITMAPFILEHEADER), &dwBytesWritten, NULL) == 0)\r\n {\r\n break;\r\n }\r\n if (WriteFile(hFile, (LPSTR)&bmiHeader, sizeof(BITMAPINFOHEADER), &dwBytesWritten, NULL) == 0)\r\n {\r\n break;\r\n }\r\n if (WriteFile(hFile, (LPSTR)lpbitmap, dwBmpSize, &dwBytesWritten, NULL) == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n \r\n if (hDIB != NULL)\r\n {\r\n GlobalUnlock(hDIB);\r\n GlobalFree(hDIB);\r\n }\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n \r\n if (hbmScreen != NULL)\r\n {\r\n DeleteObject(hbmScreen);\r\n }\r\n if (hdcMemDC != NULL)\r\n {\r\n DeleteObject(hdcMemDC);\r\n }\r\n if (hdcWindow != NULL)\r\n {\r\n ReleaseDC(hWnd,hdcWindow);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_screen_capture_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-506:Embedded Malicious Code|C.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-122:Heap-based Buffer Overflow\nC.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nD.CWE-787:Out-of-bounds Write\nE.CWE-508:Non-Replicating Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_c_src_char_cat_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n data = (char *)malloc(100*sizeof(char));\r\n \r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, char *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n data = (char *)malloc(100*sizeof(char));\r\n \r\n memset(data, 'A', 50-1); \r\n data[50-1] = '\\0'; \r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_c_src_char_cat_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-122:Heap-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.CWE-173:Improper Handling of Alternate Encoding\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.No Vulnerabilities\nE.CWE-124:Buffer Underwrite ('Buffer Underflow')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_11()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|A.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-1268:Policy Privileges are not Assigned Consistently Between Control and Data Agents\nC.No Vulnerabilities\nD.CWE-301:Reflection Attack in an Authentication Protocol\nE.CWE-253:Incorrect Check of Function Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_fwrite_16()\r\n{\r\n while(1)\r\n {\r\n \r\n if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n \r\n if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_wchar_t_fwrite_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_fwrite_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_fwrite_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-253:Incorrect Check of Function Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-687:Function Call With Incorrectly Specified Argument Value\nC.CWE-185:Incorrect Regular Expression\nD.CWE-459:Incomplete Cleanup\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_alloca_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_alloca_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_alloca_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_alloca_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|D.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-643:Improper Neutralization of Data within XPath Expressions ('XPath Injection')\nB.CWE-667:Improper Locking\nC.CWE-662:Improper Synchronization\nD.CWE-1326:Missing Immutable Root of Trust in Hardware\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_basic_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-667:Improper Locking|C.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-15:External Control of System or Configuration Setting\nB.No Vulnerabilities\nC.CWE-482:Comparing instead of Assigning\nD.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nE.CWE-710:Improper Adherence to Coding Standards\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_malloc_use_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char * pointer = (char *)malloc(sizeof(char));\r\n if (pointer == NULL) {exit(-1);}\r\n char data = *pointer; \r\n free(pointer);\r\n printHexCharLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char data;\r\n char * pointer = (char *)malloc(sizeof(char));\r\n if (pointer == NULL) {exit(-1);}\r\n data = 5;\r\n *pointer = data; \r\n {\r\n char data = *pointer;\r\n printHexCharLine(data);\r\n }\r\n free(pointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char data;\r\n char * pointer = (char *)malloc(sizeof(char));\r\n if (pointer == NULL) {exit(-1);}\r\n data = 5;\r\n *pointer = data; \r\n {\r\n char data = *pointer;\r\n printHexCharLine(data);\r\n }\r\n free(pointer);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char data;\r\n char * pointer = (char *)malloc(sizeof(char));\r\n if (pointer == NULL) {exit(-1);}\r\n data = 5;\r\n *pointer = data; \r\n {\r\n char data = *pointer;\r\n printHexCharLine(data);\r\n }\r\n free(pointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_malloc_use_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_malloc_use_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_malloc_use_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-202:Exposure of Sensitive Information Through Data Queries\nB.CWE-161:Improper Neutralization of Multiple Leading Special Elements\nC.CWE-1055:Multiple Inheritance from Concrete Classes\nD.No Vulnerabilities\nE.CWE-589:Call to Non-ubiquitous API\n", "input": "generate_std (RSA_secret_key *sk, unsigned int nbits, unsigned long use_e,\r\r\n int transient_key)\r\r\n{\r\r\n gcry_mpi_t p, q; /* the two primes */\r\r\n gcry_mpi_t d; /* the private key */\r\r\n gcry_mpi_t u;\r\r\n gcry_mpi_t t1, t2;\r\r\n gcry_mpi_t n; /* the public key */\r\r\n gcry_mpi_t e; /* the exponent */\r\r\n gcry_mpi_t phi; /* helper: (p-1)(q-1) */\r\r\n gcry_mpi_t g;\r\r\n gcry_mpi_t f;\r\r\n gcry_random_level_t random_level;\r\r\n\r\r\n if (fips_mode ())\r\r\n {\r\r\n if (nbits < 1024)\r\r\n return GPG_ERR_INV_VALUE;\r\r\n if (transient_key)\r\r\n return GPG_ERR_INV_VALUE;\r\r\n }\r\r\n\r\r\n /* The random quality depends on the transient_key flag. */\r\r\n random_level = transient_key ? GCRY_STRONG_RANDOM : GCRY_VERY_STRONG_RANDOM;\r\r\n\r\r\n /* Make sure that nbits is even so that we generate p, q of equal size. */\r\r\n if ( (nbits&1) )\r\r\n nbits++;\r\r\n\r\r\n if (use_e == 1) /* Alias for a secure value */\r\r\n use_e = 65537; /* as demanded by Sphinx. */\r\r\n\r\r\n /* Public exponent:\r\r\n In general we use 41 as this is quite fast and more secure than the\r\r\n commonly used 17. Benchmarking the RSA verify function\r\r\n with a 1024 bit key yields (2001-11-08):\r\r\n e=17 0.54 ms\r\r\n e=41 0.75 ms\r\r\n e=257 0.95 ms\r\r\n e=65537 1.80 ms\r\r\n */\r\r\n e = mpi_alloc( (32+BITS_PER_MPI_LIMB-1)/BITS_PER_MPI_LIMB );\r\r\n if (!use_e)\r\r\n mpi_set_ui (e, 41); /* This is a reasonable secure and fast value */\r\r\n else\r\r\n {\r\r\n use_e |= 1; /* make sure this is odd */\r\r\n mpi_set_ui (e, use_e);\r\r\n }\r\r\n\r\r\n n = mpi_new (nbits);\r\r\n\r\r\n p = q = NULL;\r\r\n do\r\r\n {\r\r\n /* select two (very secret) primes */\r\r\n if (p)\r\r\n _gcry_mpi_release (p);\r\r\n if (q)\r\r\n _gcry_mpi_release (q);\r\r\n if (use_e)\r\r\n { /* Do an extra test to ensure that the given exponent is\r\r\n suitable. */\r\r\n p = _gcry_generate_secret_prime (nbits/2, random_level,\r\r\n check_exponent, e);\r\r\n q = _gcry_generate_secret_prime (nbits/2, random_level,\r\r\n check_exponent, e);\r\r\n }\r\r\n else\r\r\n { /* We check the exponent later. */\r\r\n p = _gcry_generate_secret_prime (nbits/2, random_level, NULL, NULL);\r\r\n q = _gcry_generate_secret_prime (nbits/2, random_level, NULL, NULL);\r\r\n }\r\r\n if (mpi_cmp (p, q) > 0 ) /* p shall be smaller than q (for calc of u)*/\r\r\n mpi_swap(p,q);\r\r\n /* calculate the modulus */\r\r\n mpi_mul( n, p, q );\r\r\n }\r\r\n while ( mpi_get_nbits(n) != nbits );\r\r\n\r\r\n /* calculate Euler totient: phi = (p-1)(q-1) */\r\r\n t1 = mpi_alloc_secure( mpi_get_nlimbs(p) );\r\r\n t2 = mpi_alloc_secure( mpi_get_nlimbs(p) );\r\r\n phi = mpi_snew ( nbits );\r\r\n g\t= mpi_snew ( nbits );\r\r\n f\t= mpi_snew ( nbits );\r\r\n mpi_sub_ui( t1, p, 1 );\r\r\n mpi_sub_ui( t2, q, 1 );\r\r\n mpi_mul( phi, t1, t2 );\r\r\n mpi_gcd (g, t1, t2);\r\r\n mpi_fdiv_q(f, phi, g);\r\r\n\r\r\n while (!mpi_gcd(t1, e, phi)) /* (while gcd is not 1) */\r\r\n {\r\r\n if (use_e)\r\r\n BUG (); /* The prime generator already made sure that we\r\r\n never can get to here. */\r\r\n mpi_add_ui (e, e, 2);\r\r\n }\r\r\n\r\r\n /* calculate the secret key d = e^-1 mod phi */\r\r\n d = mpi_snew ( nbits );\r\r\n mpi_invm (d, e, f );\r\r\n /* calculate the inverse of p and q (used for chinese remainder theorem)*/\r\r\n u = mpi_snew ( nbits );\r\r\n mpi_invm(u, p, q );\r\r\n\r\r\n if( DBG_CIPHER )\r\r\n {\r\r\n log_mpidump(\" p= \", p );\r\r\n log_mpidump(\" q= \", q );\r\r\n log_mpidump(\"phi= \", phi );\r\r\n log_mpidump(\" g= \", g );\r\r\n log_mpidump(\" f= \", f );\r\r\n log_mpidump(\" n= \", n );\r\r\n log_mpidump(\" e= \", e );\r\r\n log_mpidump(\" d= \", d );\r\r\n log_mpidump(\" u= \", u );\r\r\n }\r\r\n\r\r\n _gcry_mpi_release (t1);\r\r\n _gcry_mpi_release (t2);\r\r\n _gcry_mpi_release (phi);\r\r\n _gcry_mpi_release (f);\r\r\n _gcry_mpi_release (g);\r\r\n\r\r\n sk->n = n;\r\r\n sk->e = e;\r\r\n sk->p = p;\r\r\n sk->q = q;\r\r\n sk->d = d;\r\r\n sk->u = u;\r\r\n\r\r\n /* Now we can test our keys. */\r\r\n if (test_keys (sk, nbits - 64))\r\r\n {\r\r\n _gcry_mpi_release (sk->n); sk->n = NULL;\r\r\n _gcry_mpi_release (sk->e); sk->e = NULL;\r\r\n _gcry_mpi_release (sk->p); sk->p = NULL;\r\r\n _gcry_mpi_release (sk->q); sk->q = NULL;\r\r\n _gcry_mpi_release (sk->d); sk->d = NULL;\r\r\n _gcry_mpi_release (sk->u); sk->u = NULL;\r\r\n fips_signal_error (\"self-test after key generation failed\");\r\r\n return GPG_ERR_SELFTEST_FAILED;\r\r\n }\r\r\n\r\r\n return 0;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.No Vulnerabilities|D.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-693:Protection Mechanism Failure\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-400:Uncontrolled Resource Consumption\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define SENTENCE \"This is the sentence we are printing to the file. \"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_rand_fwrite_61bSource(int count);\r\n\r\nvoid My_rand_fwrite_61()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n count = My_rand_fwrite_61bSource(count);\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\r\n {\r\n exit(1);\r\n }\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_rand_fwrite_61bG2BSource(int count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n count = My_rand_fwrite_61bG2BSource(count);\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\r\n {\r\n exit(1);\r\n }\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n\r\nint My_rand_fwrite_61bB2GSource(int count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n count = My_rand_fwrite_61bB2GSource(count);\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_rand_fwrite_61()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_fwrite_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_fwrite_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-400:Uncontrolled Resource Consumption|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-506:Embedded Malicious Code\nC.CWE-1294:Insecure Security Identifier Mechanism\nD.CWE-795:Only Filtering Special Elements at a Specified Location\nE.CWE-510:Trapdoor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_ip_based_logic_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"192.168.30.123\", inet_ntoa(acceptService.sin_addr)) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_ip_based_logic_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_ip_based_logic_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_ip_based_logic_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-510:Trapdoor|B.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-129:Improper Validation of Array Index\nB.CWE-73:External Control of File Name or Path\nC.CWE-114:Process Control\nD.No Vulnerabilities\nE.CWE-117:Improper Output Neutralization for Logs\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_connect_socket_12()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_connect_socket_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_connect_socket_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_connect_socket_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|B.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-197:Numeric Truncation Error\nB.CWE-476:NULL Pointer Dereference\nC.CWE-339:Small Seed Space in PRNG\nD.No Vulnerabilities\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_rand_to_char_52bSink(int data);\r\n\r\nvoid My_int_rand_to_char_52()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n My_int_rand_to_char_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_rand_to_char_52bG2BSink(int data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = CHAR_MAX-5;\r\n My_int_rand_to_char_52bG2BSink(data);\r\n}\r\n\r\nvoid My_int_rand_to_char_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_rand_to_char_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_rand_to_char_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-197:Numeric Truncation Error|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-271:Privilege Dropping / Lowering Errors\nB.CWE-272:Least Privilege Violation\nC.No Vulnerabilities\nD.CWE-1278:Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\nE.CWE-1284:Improper Validation of Specified Quantity in Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_SHRegCreateUSKey_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKLM) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_SHRegCreateUSKey_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_SHRegCreateUSKey_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_SHRegCreateUSKey_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-272:Least Privilege Violation|A.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-641:Improper Restriction of Names for Files and Other Resources\nC.No Vulnerabilities\nD.CWE-682:Incorrect Calculation\nE.CWE-51:Path Equivalence: '/multiple//internal/slash'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_fgets_divide_54bSink(int data);\r\n\r\nvoid My_int_fgets_divide_54()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n My_int_fgets_divide_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_fgets_divide_54bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n My_int_fgets_divide_54bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_int_fgets_divide_54bB2GSink(int data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n My_int_fgets_divide_54bB2GSink(data);\r\n}\r\n\r\nvoid My_int_fgets_divide_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fgets_divide_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fgets_divide_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|D.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nC.No Vulnerabilities\nD.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nE.CWE-311:Missing Encryption of Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifdef _WIN32\r\n#define ACCESS _access\r\n#define W_OK 02\r\n#else\r\n#define ACCESS access\r\n#endif\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_access_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (ACCESS(filename, W_OK) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_access_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_access_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_access_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|B.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-798:Use of Hard-coded Credentials\nC.CWE-1257:Improper Access Control Applied to Mirrored or Aliased Memory Regions\nD.CWE-415:Double Free\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_wchar_t_15\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n data = new wchar_t;\r\n \r\n delete data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n delete data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n data = new wchar_t;\r\n \r\n delete data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n \r\n ; \r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n data = new wchar_t;\r\n \r\n delete data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n data = new wchar_t;\r\n \r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n delete data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n data = new wchar_t;\r\n \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n delete data;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_wchar_t_15; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-415:Double Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nB.No Vulnerabilities\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.CWE-763:Release of Invalid Pointer or Reference\nE.CWE-1038:Insecure Automated Optimizations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_listen_socket_14()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(globalFive==5)\r\n {\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_listen_socket_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|D.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.CWE-1054:Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-1093:Excessively Complex Data Representation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_09\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(data->intOne);\r\n delete data;\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(data->intOne);\r\n delete data;\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n TwoIntsClass * tmpData = new TwoIntsClass;\r\n tmpData->intOne = 0;\r\n tmpData->intTwo = 0;\r\n \r\n data = tmpData;\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n TwoIntsClass * tmpData = new TwoIntsClass;\r\n tmpData->intOne = 0;\r\n tmpData->intTwo = 0;\r\n \r\n data = tmpData;\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_09; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-476:NULL Pointer Dereference|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-475:Undefined Behavior for Input to API\nB.CWE-473:PHP External Variable Modification\nC.CWE-573:Improper Following of Specification by Caller\nD.No Vulnerabilities\nE.CWE-262:Not Using Password Aging\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(char));\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(char));\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(char));\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-475:Undefined Behavior for Input to API|C.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-798:Use of Hard-coded Credentials\nC.CWE-1336:Improper Neutralization of Special Elements Used in a Template Engine\nD.CWE-259:Use of Hard-coded Password\nE.CWE-689:Permission Race Condition During Resource Copy\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_w32_wchar_t_81\r\n{\r\n\r\nclass My_w32_wchar_t_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * password) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_wchar_t_81 : public My_w32_wchar_t_81_base\r\n{\r\npublic:\r\n void action(wchar_t * password) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_wchar_t_81G2B : public My_w32_wchar_t_81_base\r\n{\r\npublic:\r\n void action(wchar_t * password) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-259:Use of Hard-coded Password|B.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1023:Incomplete Comparison with Missing Factors\nB.CWE-478:Missing Default Case in Multiple Condition Expression\nC.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\nD.CWE-313:Cleartext Storage in a File or on Disk\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n default:\r\n return;\r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n default:\r\n return;\r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-478:Missing Default Case in Multiple Condition Expression|A.CWE-1023:Incomplete Comparison with Missing Factors", "cwe": "478"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nB.No Vulnerabilities\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-41:Improper Resolution of Path Equivalence\nE.CWE-406:Insufficient Control of Network Message Volume (Network Amplification)\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint gigamaree_leucite = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid schapping_sesterce(int leitao_wyvern,char **tabic_fideicommissor);\r\nvoid burned_canonise(int dereistic_metasoma,char **hierogrammatist_bedsheets);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int apaturia_willingest = 7;\r\n char **eleroy_unpraying = 0;\r\n char **pressurizers_distinctionless = 0;\r\n int bristly_dowie = 89;\r\n char *undivorceable_uglifiers;;\r\n if (__sync_bool_compare_and_swap(&gigamaree_leucite,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&undivorceable_uglifiers,\"2474\",bristly_dowie);\r\n if (undivorceable_uglifiers != 0) {;\r\n eleroy_unpraying = &undivorceable_uglifiers;\r\n pressurizers_distinctionless = eleroy_unpraying + 5;\r\n schapping_sesterce(apaturia_willingest,pressurizers_distinctionless);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid schapping_sesterce(int leitao_wyvern,char **tabic_fideicommissor)\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n int is_valid = 1;\r\n int i = 0;\r\n char cmd_str[1000] = {0};\r\n char *imboscata_gozell = 0;\r\n ++global_variable;\r\n leitao_wyvern--;\r\n if (leitao_wyvern > 0) {\r\n burned_canonise(leitao_wyvern,tabic_fideicommissor);\r\n return ;\r\n }\r\n imboscata_gozell = ((char *)( *(tabic_fideicommissor - 5)));\r\n \r\n \r\n\r\n snprintf(cmd_str, 1000, \"vim -s \" \"/opt//workspace/testData/\" \"vim_scripts/hello.vim %s\", imboscata_gozell);\r\n \r\n for (; i < strlen(imboscata_gozell); ++i) {\r\n if (imboscata_gozell[i] == ';') {\r\n if (i == 0 || imboscata_gozell[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n if (imboscata_gozell[i] == '|') {\r\n if (i == 0 || imboscata_gozell[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n if (imboscata_gozell[i] == '|') {\r\n if (i == 0 || imboscata_gozell[i - 1] != '|') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n if (imboscata_gozell[i] == '&') {\r\n if (i == 0 || imboscata_gozell[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n if (imboscata_gozell[i] == '&') {\r\n if (i == 0 || imboscata_gozell[i - 1] != '&') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n \r\n if (is_valid == 1) {\r\n \r\n\r\n fpipe = popen(cmd_str, \"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if ( *(tabic_fideicommissor - 5) != 0) \r\n free(((char *)( *(tabic_fideicommissor - 5))));\r\nclose_printf_context();\r\n}\r\n\r\nvoid burned_canonise(int dereistic_metasoma,char **hierogrammatist_bedsheets)\r\n{\r\n ++global_variable;\r\n schapping_sesterce(dereistic_metasoma,hierogrammatist_bedsheets);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "88"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.CWE-299:Improper Check for Certificate Revocation\nC.CWE-172:Encoding Error\nD.CWE-390:Detection of Error Condition Without Action\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_char_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_char_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_char_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_char_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-637:Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')\nB.CWE-510:Trapdoor\nC.CWE-665:Improper Initialization\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} My_wchar_t_cat_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_cat_34()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_cat_34_unionType myUnion;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_cat_34_unionType myUnion;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = L'\\0'; \r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_cat_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_cat_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_cat_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-773:Missing Reference to Active File Descriptor or Handle\nC.CWE-564:SQL Injection: Hibernate\nD.CWE-771:Missing Reference to Active Allocated Resource\nE.CWE-339:Small Seed Space in PRNG\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic FILE * mSource(FILE * data)\r\n{\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n return data;\r\n}\r\n\r\nvoid My_fopen_42()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n data = mSource(data);\r\n \r\n data = fopen(\"MSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic FILE * nB2GSource(FILE * data)\r\n{\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n return data;\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n data = nB2GSource(data);\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n}\r\n\r\nvoid My_fopen_42()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-773:Missing Reference to Active File Descriptor or Handle|D.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-908:Use of Uninitialized Resource\nC.CWE-325:Missing Cryptographic Step\nD.CWE-1073:Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses\nE.CWE-573:Improper Following of Specification by Caller\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptHashData_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_CryptHashData_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptHashData_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptHashData_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-325:Missing Cryptographic Step|E.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-250:Execution with Unnecessary Privileges\nB.CWE-141:Improper Neutralization of Parameter/Argument Delimiters\nC.CWE-1262:Improper Access Control for Register Interface\nD.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nE.No Vulnerabilities\n", "input": " tt_face_load_sbit( TT_Face face,\r\r\n FT_Stream stream )\r\r\n {\r\r\n FT_Error error;\r\r\n FT_ULong table_size;\r\r\n\r\r\n\r\r\n face->sbit_table = NULL;\r\r\n face->sbit_table_size = 0;\r\r\n face->sbit_table_type = TT_SBIT_TABLE_TYPE_NONE;\r\r\n face->sbit_num_strikes = 0;\r\r\n\r\r\n error = face->goto_table( face, TTAG_CBLC, stream, &table_size );\r\r\n if ( !error )\r\r\n face->sbit_table_type = TT_SBIT_TABLE_TYPE_CBLC;\r\r\n else\r\r\n {\r\r\n error = face->goto_table( face, TTAG_EBLC, stream, &table_size );\r\r\n if ( error )\r\r\n error = face->goto_table( face, TTAG_bloc, stream, &table_size );\r\r\n if ( !error )\r\r\n face->sbit_table_type = TT_SBIT_TABLE_TYPE_EBLC;\r\r\n }\r\r\n\r\r\n if ( error )\r\r\n {\r\r\n error = face->goto_table( face, TTAG_sbix, stream, &table_size );\r\r\n if ( !error )\r\r\n face->sbit_table_type = TT_SBIT_TABLE_TYPE_SBIX;\r\r\n }\r\r\n if ( error )\r\r\n goto Exit;\r\r\n\r\r\n if ( table_size < 8 )\r\r\n {\r\r\n FT_ERROR(( \"tt_face_load_sbit_strikes: table too short\\n\" ));\r\r\n error = FT_THROW( Invalid_File_Format );\r\r\n goto Exit;\r\r\n }\r\r\n\r\r\n switch ( (FT_UInt)face->sbit_table_type )\r\r\n {\r\r\n case TT_SBIT_TABLE_TYPE_EBLC:\r\r\n case TT_SBIT_TABLE_TYPE_CBLC:\r\r\n {\r\r\n FT_Byte* p;\r\r\n FT_Fixed version;\r\r\n FT_ULong num_strikes;\r\r\n FT_UInt count;\r\r\n\r\r\n\r\r\n if ( FT_FRAME_EXTRACT( table_size, face->sbit_table ) )\r\r\n goto Exit;\r\r\n\r\r\n face->sbit_table_size = table_size;\r\r\n\r\r\n p = face->sbit_table;\r\r\n\r\r\n version = FT_NEXT_ULONG( p );\r\r\n num_strikes = FT_NEXT_ULONG( p );\r\r\n\r\r\n if ( ( version & 0xFFFF0000UL ) != 0x00020000UL )\r\r\n {\r\r\n error = FT_THROW( Unknown_File_Format );\r\r\n goto Exit;\r\r\n }\r\r\n\r\r\n if ( num_strikes >= 0x10000UL )\r\r\n {\r\r\n error = FT_THROW( Invalid_File_Format );\r\r\n goto Exit;\r\r\n }\r\r\n\r\r\n /*\r\r\n * Count the number of strikes available in the table. We are a bit\r\r\n * paranoid there and don't trust the data.\r\r\n */\r\r\n count = (FT_UInt)num_strikes;\r\r\n if ( 8 + 48UL * count > table_size )\r\r\n count = (FT_UInt)( ( table_size - 8 ) / 48 );\r\r\n\r\r\n face->sbit_num_strikes = count;\r\r\n }\r\r\n break;\r\r\n\r\r\n case TT_SBIT_TABLE_TYPE_SBIX:\r\r\n {\r\r\n FT_UShort version;\r\r\n FT_UShort flags;\r\r\n FT_ULong num_strikes;\r\r\n FT_UInt count;\r\r\n\r\r\n\r\r\n if ( FT_FRAME_ENTER( 8 ) )\r\r\n goto Exit;\r\r\n\r\r\n version = FT_GET_USHORT();\r\r\n flags = FT_GET_USHORT();\r\r\n num_strikes = FT_GET_ULONG();\r\r\n\r\r\n FT_FRAME_EXIT();\r\r\n\r\r\n if ( version < 1 )\r\r\n {\r\r\n error = FT_THROW( Unknown_File_Format );\r\r\n goto Exit;\r\r\n }\r\r\n\r\r\n /* Bit 0 must always be `1'. */\r\r\n /* Bit 1 controls the overlay of bitmaps with outlines. */\r\r\n /* All other bits should be zero. */\r\r\n if ( !( flags == 1 || flags == 3 ) ||\r\r\n num_strikes >= 0x10000UL )\r\r\n {\r\r\n error = FT_THROW( Invalid_File_Format );\r\r\n goto Exit;\r\r\n }\r\r\n\r\r\n /* we currently don't support bit 1; however, it is better to */\r\r\n /* draw at least something... */\r\r\n if ( flags == 3 )\r\r\n FT_TRACE1(( \"tt_face_load_sbit_strikes:\"\r\r\n \" sbix overlay not supported yet\\n\"\r\r\n \" \"\r\r\n \" expect m rendering results\\n\" ));\r\r\n\r\r\n /*\r\r\n * Count the number of strikes available in the table. We are a bit\r\r\n * paranoid there and don't trust the data.\r\r\n */\r\r\n count = (FT_UInt)num_strikes;\r\r\n if ( 8 + 4UL * count > table_size )\r\r\n count = (FT_UInt)( ( table_size - 8 ) / 4 );\r\r\n\r\r\n if ( FT_STREAM_SEEK( FT_STREAM_POS() - 8 ) )\r\r\n goto Exit;\r\r\n\r\r\n face->sbit_table_size = 8 + count * 4;\r\r\n if ( FT_FRAME_EXTRACT( face->sbit_table_size, face->sbit_table ) )\r\r\n goto Exit;\r\r\n\r\r\n face->sbit_num_strikes = count;\r\r\n }\r\r\n break;\r\r\n\r\r\n default:\r\r\n error = FT_THROW( Unknown_File_Format );\r\r\n break;\r\r\n }\r\r\n\r\r\n if ( !error )\r\r\n FT_TRACE3(( \"sbit_num_strikes: %u\\n\", face->sbit_num_strikes ));\r\r\n\r\r\n return FT_Err_Ok;\r\r\n\r\r\n Exit:\r\r\n if ( error )\r\r\n {\r\r\n if ( face->sbit_table )\r\r\n FT_FRAME_RELEASE( face->sbit_table );\r\r\n face->sbit_table_size = 0;\r\r\n face->sbit_table_type = TT_SBIT_TABLE_TYPE_NONE;\r\r\n }\r\r\n\r\r\n return error;\r\r\n }\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.No Vulnerabilities|E.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-142:Improper Neutralization of Value Delimiters\nC.No Vulnerabilities\nD.CWE-789:Memory Allocation with Excessive Size Value\nE.CWE-187:Partial String Comparison\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_connect_socket_54\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(size_t data);\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(size_t data);\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n nG2BSink_b(data);\r\n}\r\n\r\n\r\nvoid nB2GSink_b(size_t data);\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n nB2GSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_connect_socket_54; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-789:Memory Allocation with Excessive Size Value|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nB.No Vulnerabilities\nC.CWE-491:Public cloneable() Method Without Final ('Object Hijack')\nD.CWE-575:EJB Bad Practices: Use of AWT Swing\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <process.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_listen_socket_w32spawnl_09()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n \r\n _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n \r\n \r\n _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n \r\n \r\n _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid My_wchar_t_listen_socket_w32spawnl_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_listen_socket_w32spawnl_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_listen_socket_w32spawnl_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-125:Out-of-bounds Read\nB.CWE-648:Incorrect Use of Privileged APIs\nC.CWE-1023:Incomplete Comparison with Missing Factors\nD.No Vulnerabilities\nE.CWE-478:Missing Default Case in Multiple Condition Expression\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n default:\r\n return;\r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n default:\r\n return;\r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-478:Missing Default Case in Multiple Condition Expression|C.CWE-1023:Incomplete Comparison with Missing Factors", "cwe": "478"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nB.CWE-1395:Dependency on Vulnerable Third-Party Component\nC.CWE-272:Least Privilege Violation\nD.CWE-271:Privilege Dropping / Lowering Errors\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_RegCreateKey_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyW(\r\n HKEY_LOCAL_MACHINE,\r\n keyName,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_RegCreateKey_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_RegCreateKey_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_RegCreateKey_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-272:Least Privilege Violation|D.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-95:Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nB.CWE-483:Incorrect Block Delimitation\nC.CWE-599:Missing Validation of OpenSSL Certificate\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_semicolon_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0);\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_semicolon_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_semicolon_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_semicolon_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-483:Incorrect Block Delimitation|D.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "483"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-486:Comparison of Classes by Name\nB.No Vulnerabilities\nC.CWE-682:Incorrect Calculation\nD.CWE-369:Divide By Zero\nE.CWE-820:Missing Synchronization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_fgets_modulo_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(int &data);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n \r\n printIntLine(100 % data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(int &data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n \r\n printIntLine(100 % data);\r\n}\r\n\r\n\r\nvoid nB2GSource(int &data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nB2GSource(data);\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 % data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_fgets_modulo_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-369:Divide By Zero|C.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-135:Incorrect Calculation of Multi-Byte String Length\nB.CWE-187:Partial String Comparison\nC.CWE-457:Use of Uninitialized Variable\nD.CWE-665:Improper Initialization\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_int_array_partial_init_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(int * * dataPtr);\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n data = new int[10];\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i] = i;\r\n }\r\n }\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(int * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n data = new int[10];\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = i;\r\n }\r\n }\r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(int * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n data = new int[10];\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i] = i;\r\n }\r\n }\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_int_array_partial_init_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-457:Use of Uninitialized Variable|D.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-804:Guessable CAPTCHA\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nD.No Vulnerabilities\nE.CWE-773:Missing Reference to Active File Descriptor or Handle\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32CreateFile_65bSink(HANDLE data);\r\n\r\nvoid My_w32CreateFile_65()\r\n{\r\n HANDLE data;\r\n \r\n void (*funcPtr) (HANDLE) = My_w32CreateFile_65bSink;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32CreateFile_65bB2GSink(HANDLE data);\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n void (*funcPtr) (HANDLE) = My_w32CreateFile_65bB2GSink;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_w32CreateFile_65()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-459:Incomplete Cleanup\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-510:Trapdoor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _wunlink\r\n#define FOPEN _wfopen\r\n#define MKTEMP _wmktemp\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#define FOPEN fopen\r\n#define MKTEMP mktemp\r\n#endif\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"mXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-459:Incomplete Cleanup|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "459"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-391:Unchecked Error Condition\nB.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nC.CWE-459:Incomplete Cleanup\nD.CWE-110:Struts: Validator Without Form Field\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_declare_01()\r\n{\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_declare_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_declare_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_declare_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|C.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.No Vulnerabilities\nC.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nD.CWE-175:Improper Handling of Mixed Encoding\nE.CWE-112:Missing XML Validation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_12()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_short_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-391:Unchecked Error Condition\nD.No Vulnerabilities\nE.CWE-544:Missing Standardized Error Handling Mechanism\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(list<int> &data);\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n mSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(list<int> &data);\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n nG2BSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\n\r\nvoid nB2GSource(list<int> &data);\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n nB2GSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-672:Operation on a Resource after Expiration or Release|A.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-651:Exposure of WSDL File Containing Sensitive Information\nB.CWE-393:Return of Wrong Status Code\nC.CWE-319:Cleartext Transmission of Sensitive Information\nD.No Vulnerabilities\nE.CWE-311:Missing Encryption of Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_64bSink(void * passwordVoidPtr);\r\n\r\nvoid My_w32_wchar_t_listen_socket_64()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_wchar_t_listen_socket_64bSink(&password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_64bG2BSink(void * passwordVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n My_w32_wchar_t_listen_socket_64bG2BSink(&password);\r\n}\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_64bB2GSink(void * passwordVoidPtr);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_wchar_t_listen_socket_64bB2GSink(&password);\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_64()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-319:Cleartext Transmission of Sensitive Information|E.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-454:External Initialization of Trusted Variables or Data Stores\nB.CWE-710:Improper Adherence to Coding Standards\nC.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)\nD.No Vulnerabilities\nE.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_pointer_malloc_use_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));\r\n if (pointer == NULL) {exit(-1);}\r\n twoIntsStruct * data = *pointer; \r\n free(pointer);\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n twoIntsStruct * data;\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));\r\n if (pointer == NULL) {exit(-1);}\r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n free(pointer);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n twoIntsStruct * data;\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));\r\n if (pointer == NULL) {exit(-1);}\r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n free(pointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_pointer_malloc_use_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_pointer_malloc_use_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_pointer_malloc_use_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|B.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.No Vulnerabilities\nC.CWE-1304:Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\nD.CWE-1327:Binding to an Unrestricted IP Address\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_listen_socket_multiply_65bSink(int data);\r\n\r\nvoid My_int_listen_socket_multiply_65()\r\n{\r\n int data;\r\n \r\n void (*funcPtr) (int) = My_int_listen_socket_multiply_65bSink;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_listen_socket_multiply_65bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = My_int_listen_socket_multiply_65bG2BSink;\r\n \r\n data = 0;\r\n \r\n data = -2;\r\n funcPtr(data);\r\n}\r\n\r\n\r\nvoid My_int_listen_socket_multiply_65bB2GSink(int data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = My_int_listen_socket_multiply_65bB2GSink;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_int_listen_socket_multiply_65()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_listen_socket_multiply_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_listen_socket_multiply_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|E.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-67:Improper Handling of Windows Device Names\nC.CWE-319:Cleartext Transmission of Sensitive Information\nD.CWE-311:Missing Encryption of Sensitive Data\nE.CWE-130:Improper Handling of Length Parameter Inconsistency\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\nnamespace My_w32_wchar_t_connect_socket_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * password;\r\n wchar_t * &passwordRef = password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n closesocket(connectSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n {\r\n wchar_t * password = passwordRef;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t * &passwordRef = password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n {\r\n wchar_t * password = passwordRef;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * password;\r\n wchar_t * &passwordRef = password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n closesocket(connectSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n {\r\n wchar_t * password = passwordRef;\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_connect_socket_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-319:Cleartext Transmission of Sensitive Information|D.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-602:Client-Side Enforcement of Server-Side Security\nC.CWE-253:Incorrect Check of Function Return Value\nD.CWE-426:Untrusted Search Path\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_fscanf_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\r\n {\r\n printLine(\"fwscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"fwscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"fwscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_fscanf_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_fscanf_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_fscanf_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-253:Incorrect Check of Function Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-602:Client-Side Enforcement of Server-Side Security\nB.No Vulnerabilities\nC.CWE-563:Assignment to Variable without Use\nD.CWE-1164:Irrelevant Code\nE.CWE-328:Use of Weak Hash\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_value_char_15()\r\n{\r\n char data;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 'C';\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n data = 'Z';\r\n printHexCharLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char data;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 'C';\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n printHexCharLine(data);\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char data;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 'C';\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n printHexCharLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char data;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = 'C';\r\n printHexCharLine(data);\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n data = 'Z';\r\n printHexCharLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char data;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 'C';\r\n printHexCharLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n data = 'Z';\r\n printHexCharLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_unused_value_char_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_value_char_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_value_char_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-757:Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\nB.CWE-415:Double Free\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_long_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new long[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new long[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new long[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new long[100];\r\n \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new long[100];\r\n \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_long_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-415:Double Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-248:Uncaught Exception\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-123:Write-what-where Condition\nE.CWE-507:Trojan Horse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_connect_socket_03()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(5==5)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-123:Write-what-where Condition|C.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-343:Predictable Value Range from Previous Values\nB.No Vulnerabilities\nC.CWE-191:Integer Underflow (Wrap or Wraparound)\nD.CWE-682:Incorrect Calculation\nE.CWE-1060:Excessive Number of Inefficient Server-Side Data Accesses\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_min_predec_02()\r\n{\r\n short data;\r\n data = 0;\r\n if(1)\r\n {\r\n \r\n data = SHRT_MIN;\r\n }\r\n if(1)\r\n {\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n short data;\r\n data = 0;\r\n if(1)\r\n {\r\n \r\n data = SHRT_MIN;\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n short data;\r\n data = 0;\r\n if(1)\r\n {\r\n \r\n data = SHRT_MIN;\r\n }\r\n if(1)\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n data = 0;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(1)\r\n {\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n data = 0;\r\n if(1)\r\n {\r\n \r\n data = -2;\r\n }\r\n if(1)\r\n {\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_min_predec_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_min_predec_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_min_predec_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-191:Integer Underflow (Wrap or Wraparound)|D.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-783:Operator Precedence Logic Error\nB.No Vulnerabilities\nC.CWE-294:Authentication Bypass by Capture-replay\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.CWE-36:Absolute Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_wchar_t_console_open_65\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n funcPtr(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_console_open_65; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-36:Absolute Path Traversal|D.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1056:Invokable Control Element with Variadic Parameters\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-126:Buffer Over-read\nD.CWE-295:Improper Certificate Validation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_My_My_My_My_My_My_My_My_My_CWE129_fgets_84B2G();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.No Vulnerabilities\nC.CWE-479:Signal Handler Use of a Non-reentrant Function\nD.CWE-1104:Use of Unmaintained Third Party Components\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_class_calloc_45\r\n{\r\n\r\nstatic TwoIntsClass * mData;\r\nstatic TwoIntsClass * nG2BData;\r\nstatic TwoIntsClass * nB2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n TwoIntsClass * data = mData;\r\n \r\n delete [] data;\r\n}\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = (TwoIntsClass *)calloc(100, sizeof(TwoIntsClass));\r\n if (data == NULL) {exit(-1);}\r\n mData = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n TwoIntsClass * data = nG2BData;\r\n \r\n delete [] data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass[100];\r\n nG2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n TwoIntsClass * data = nB2GData;\r\n \r\n free(data);\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = (TwoIntsClass *)calloc(100, sizeof(TwoIntsClass));\r\n if (data == NULL) {exit(-1);}\r\n nB2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_class_calloc_45; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-733:Compiler Optimization Removal or Modification of Security-critical Code\nB.CWE-328:Use of Weak Hash\nC.CWE-127:Buffer Under-read\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(int data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n int buffer[10] = { 0 };\r\n \r\n if (data < 10)\r\n {\r\n printIntLine(buffer[data]);\r\n }\r\n else\r\n {\r\n printLine(\"ERROR: Array index is too big.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_My_My_My_CWE839_connect_socket_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-777:Regular Expression without Anchors\nB.No Vulnerabilities\nC.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nD.CWE-794:Incomplete Filtering of Multiple Instances of Special Elements\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32CreateFile_no_close_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<HANDLE> dataList);\r\n\r\nvoid m()\r\n{\r\n HANDLE data;\r\n list<HANDLE> dataList;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(list<HANDLE> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n list<HANDLE> dataList;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32CreateFile_no_close_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1078:Inappropriate Source Code Style or Formatting\nB.CWE-73:External Control of File Name or Path\nC.CWE-546:Suspicious Comment\nD.CWE-788:Access of Memory Location After End of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_HACK_10()\r\n{\r\n if(globalTrue)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_HACK_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_HACK_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_HACK_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-546:Suspicious Comment|A.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-134:Use of Externally-Controlled Format String\nB.No Vulnerabilities\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-1332:Improper Handling of Faults that Lead to Instruction Skips\nE.CWE-1099:Inconsistent Naming Conventions for Identifiers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define SNPRINTF _snwprintf\r\n#else\r\n#define SNPRINTF snprintf\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_file_snprintf_53bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_file_snprintf_53()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n My_wchar_t_file_snprintf_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_file_snprintf_53bG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"fixedstringtest\");\r\n My_wchar_t_file_snprintf_53bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_wchar_t_file_snprintf_53bB2GSink(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n My_wchar_t_file_snprintf_53bB2GSink(data);\r\n}\r\n\r\nvoid My_wchar_t_file_snprintf_53()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_file_snprintf_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_file_snprintf_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-134:Use of Externally-Controlled Format String|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-284:Improper Access Control\nC.CWE-619:Dangling Database Cursor ('Cursor Injection')\nD.CWE-316:Cleartext Storage of Sensitive Information in Memory\nE.CWE-326:Inadequate Encryption Strength\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n#define BUFSIZE 1024\r\n#define PIPE_NAME \"\\\\\\\\.\\\\pipe\\\\TestPipe\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateNamedPipe_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE | PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE | PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateNamedPipe_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateNamedPipe_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateNamedPipe_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-284:Improper Access Control|C.CWE-619:Dangling Database Cursor ('Cursor Injection')", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-135:Incorrect Calculation of Multi-Byte String Length\nB.CWE-323:Reusing a Nonce, Key Pair in Encryption\nC.No Vulnerabilities\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-415:Double Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_struct_42\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic twoIntsStruct * mSource(twoIntsStruct * data)\r\n{\r\n data = new twoIntsStruct;\r\n \r\n delete data;\r\n return data;\r\n}\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n data = mSource(data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic twoIntsStruct * nG2BSource(twoIntsStruct * data)\r\n{\r\n data = new twoIntsStruct;\r\n \r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n data = nG2BSource(data);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nstatic twoIntsStruct * nB2GSource(twoIntsStruct * data)\r\n{\r\n data = new twoIntsStruct;\r\n \r\n delete data;\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n data = nB2GSource(data);\r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_struct_42; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-415:Double Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nB.CWE-506:Embedded Malicious Code\nC.CWE-511:Logic/Time Bomb\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CompareFileTime_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CompareFileTime_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CompareFileTime_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CompareFileTime_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|B.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-99:Improper Control of Resource Identifiers ('Resource Injection')\nC.CWE-650:Trusting HTTP Permission Methods on the Server Side\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CreateFile_no_close_11()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalReturnsTrue())\r\n {\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_no_close_11()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_no_close_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_no_close_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)\nD.CWE-404:Improper Resource Shutdown or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_w32CloseHandle_02()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(1)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(1)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_w32CloseHandle_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_w32CloseHandle_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_w32CloseHandle_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-1083:Data Access from Outside Expected Data Manager Component\nC.No Vulnerabilities\nD.CWE-252:Unchecked Return Value\nE.CWE-369:Divide By Zero\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32ImpersonateSelf_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ImpersonateSelf(SecurityImpersonation);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (!ImpersonateSelf(SecurityImpersonation))\r\n {\r\n exit(1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n if (!ImpersonateSelf(SecurityImpersonation))\r\n {\r\n exit(1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32ImpersonateSelf_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32ImpersonateSelf_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32ImpersonateSelf_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-252:Unchecked Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-434:Unrestricted Upload of File with Dangerous Type\nB.No Vulnerabilities\nC.CWE-6:J2EE Misconfiguration: Insufficient Session-ID Length\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-680:Integer Overflow to Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_fixed_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = INT_MAX / 2 + 2; \r\n \r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = 20;\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_fixed_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-680:Integer Overflow to Buffer Overflow|D.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-138:Improper Neutralization of Special Elements\nC.CWE-224:Obscured Security-relevant Information by Alternate Name\nD.CWE-696:Incorrect Behavior Order\nE.CWE-464:Addition of Data Structure Sentinel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_02()\r\n{\r\n char data;\r\n data = ' ';\r\n if(1)\r\n {\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char data;\r\n data = ' ';\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 'a';\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char data;\r\n data = ' ';\r\n if(1)\r\n {\r\n \r\n data = 'a';\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\nvoid My_basic_02()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-464:Addition of Data Structure Sentinel|B.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-436:Interpretation Conflict\nC.CWE-667:Improper Locking\nD.CWE-912:Hidden Functionality\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\n#define _SECOND ((INT64)10000000)\r\n#define _MINUTE (60 * _SECOND)\r\n#define _HOUR (60 * _MINUTE)\r\n#define _DAY (24 * _HOUR)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_file_attrib_created_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n FILETIME ftCreate;\r\n ULONGLONG qwResult;\r\n HANDLE hFile = INVALID_HANDLE_VALUE;\r\n do\r\n {\r\n hFile = CreateFile(TEXT(\"mFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE, \r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n break;\r\n }\r\n if (GetFileTime(hFile,\r\n &ftCreate,\r\n NULL,\r\n NULL) == 0)\r\n {\r\n break;\r\n }\r\n \r\n qwResult -= 10 * _DAY;\r\n \r\n ftCreate.dwLowDateTime = (DWORD)(qwResult & 0xFFFFFFFF);\r\n ftCreate.dwHighDateTime = (DWORD)(qwResult >> 32);\r\n \r\n SetFileTime(hFile,\r\n &ftCreate,\r\n (LPFILETIME)NULL,\r\n (LPFILETIME)NULL);\r\n }\r\n while (0);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_file_attrib_created_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_file_attrib_created_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_file_attrib_created_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-506:Embedded Malicious Code|D.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-447:Unimplemented or Unsupported Feature in UI\nB.CWE-763:Release of Invalid Pointer or Reference\nC.CWE-1339:Insufficient Precision or Accuracy of a Real Number\nD.CWE-761:Free of Pointer not at Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_wchar_t_environment_22Global = 0;\r\n\r\nvoid My_wchar_t_environment_22Sink(wchar_t * data);\r\n\r\nvoid My_wchar_t_environment_22()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n My_wchar_t_environment_22Global = 1; \r\n My_wchar_t_environment_22Sink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_wchar_t_environment_22B2G1Global = 0;\r\nint My_wchar_t_environment_22B2G2Global = 0;\r\n\r\n\r\nvoid My_wchar_t_environment_22B2G1Sink(wchar_t * data);\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n My_wchar_t_environment_22B2G1Global = 0; \r\n My_wchar_t_environment_22B2G1Sink(data);\r\n}\r\n\r\n\r\nvoid My_wchar_t_environment_22B2G2Sink(wchar_t * data);\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n My_wchar_t_environment_22B2G2Global = 1; \r\n My_wchar_t_environment_22B2G2Sink(data);\r\n}\r\n\r\nvoid My_wchar_t_environment_22()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_environment_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_environment_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-761:Free of Pointer not at Start of Buffer|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-377:Insecure Temporary File\nB.CWE-163:Improper Neutralization of Multiple Trailing Special Elements\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-85:Doubled Character XSS Manipulations\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define TEMPNAM tempnam\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TEMPNAM tempnam\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_tempnam_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_tempnam_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_tempnam_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_tempnam_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-377:Insecure Temporary File|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-270:Privilege Context Switching Error\nB.CWE-639:Authorization Bypass Through User-Controlled Key\nC.CWE-73:External Control of File Name or Path\nD.CWE-114:Process Control\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\nnamespace My_w32_wchar_t_connect_socket_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_connect_socket_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.CWE-114:Process Control\nC.CWE-652:Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')\nD.CWE-85:Doubled Character XSS Manipulations\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nnamespace My_w32_wchar_t_listen_socket_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_listen_socket_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-114:Process Control|A.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-319:Cleartext Transmission of Sensitive Information\nB.CWE-787:Out-of-bounds Write\nC.No Vulnerabilities\nD.CWE-364:Signal Handler Race Condition\nE.CWE-123:Write-what-where Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_connect_socket_11()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-123:Write-what-where Condition|B.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-267:Privilege Defined With Unsafe Actions\nC.CWE-509:Replicating Malicious Code (Virus or Worm)\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_short_63bSink(void * * dataPtr);\r\n\r\nvoid My_short_63()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n My_short_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_short_63bG2BSink(void * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n My_short_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_short_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nC.CWE-400:Uncontrolled Resource Consumption\nD.No Vulnerabilities\nE.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int count)\r\n{\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_for_loop_41()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n mSink(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(int count)\r\n{\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n nG2BSink(count);\r\n}\r\n\r\n\r\nstatic void nB2GSink(int count)\r\n{\r\n {\r\n size_t i = 0;\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n nB2GSink(count);\r\n}\r\n\r\nvoid My_fgets_for_loop_41()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_for_loop_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_for_loop_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-400:Uncontrolled Resource Consumption|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-514:Covert Channel\nC.CWE-190:Integer Overflow or Wraparound\nD.No Vulnerabilities\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _My_int64_t_fscanf_multiply_67_structType\r\n{\r\n int64_t structFirst;\r\n} My_int64_t_fscanf_multiply_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int64_t_fscanf_multiply_67bSink(My_int64_t_fscanf_multiply_67_structType myStruct);\r\n\r\nvoid My_int64_t_fscanf_multiply_67()\r\n{\r\n int64_t data;\r\n My_int64_t_fscanf_multiply_67_structType myStruct;\r\n data = 0LL;\r\n \r\n fscanf (stdin, \"%lld\", &data);\r\n myStruct.structFirst = data;\r\n My_int64_t_fscanf_multiply_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int64_t_fscanf_multiply_67bG2BSink(My_int64_t_fscanf_multiply_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t data;\r\n My_int64_t_fscanf_multiply_67_structType myStruct;\r\n data = 0LL;\r\n \r\n data = 2;\r\n myStruct.structFirst = data;\r\n My_int64_t_fscanf_multiply_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_int64_t_fscanf_multiply_67bB2GSink(My_int64_t_fscanf_multiply_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t data;\r\n My_int64_t_fscanf_multiply_67_structType myStruct;\r\n data = 0LL;\r\n \r\n fscanf (stdin, \"%lld\", &data);\r\n myStruct.structFirst = data;\r\n My_int64_t_fscanf_multiply_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_int64_t_fscanf_multiply_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_fscanf_multiply_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_fscanf_multiply_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|E.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-404:Improper Resource Shutdown or Release\nB.CWE-191:Integer Underflow (Wrap or Wraparound)\nC.No Vulnerabilities\nD.CWE-401:Missing Release of Memory after Effective Lifetime\nE.CWE-467:Use of sizeof() on a Pointer Type\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_malloc_04()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = (char *)ALLOCA(100*sizeof(char));\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = (char *)ALLOCA(100*sizeof(char));\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid My_char_malloc_04()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_malloc_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_malloc_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-401:Missing Release of Memory after Effective Lifetime|A.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-669:Incorrect Resource Transfer Between Spheres\nB.CWE-682:Incorrect Calculation\nC.No Vulnerabilities\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-912:Hidden Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int64_t_rand_sub_52bSink(int64_t data);\r\n\r\nvoid My_int64_t_rand_sub_52()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n data = (int64_t)RAND64();\r\n My_int64_t_rand_sub_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int64_t_rand_sub_52bG2BSink(int64_t data);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n data = -2;\r\n My_int64_t_rand_sub_52bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_int64_t_rand_sub_52bB2GSink(int64_t data);\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n data = (int64_t)RAND64();\r\n My_int64_t_rand_sub_52bB2GSink(data);\r\n}\r\n\r\nvoid My_int64_t_rand_sub_52()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_rand_sub_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_rand_sub_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|B.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-675:Multiple Operations on Resource in Single-Operation Context\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-1188:Initialization of a Resource with an Insecure Default\nD.No Vulnerabilities\nE.CWE-153:Improper Neutralization of Substitution Characters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n# define OPEN _open\r\n# define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n# define OPEN open\r\n# define CLOSE close\r\n#endif\r\n\r\ntypedef struct _My_open_67_structType\r\n{\r\n int structFirst;\r\n} My_open_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_open_67bSink(My_open_67_structType myStruct);\r\n\r\nvoid My_open_67()\r\n{\r\n int data;\r\n My_open_67_structType myStruct;\r\n data = -1; \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n CLOSE(data);\r\n myStruct.structFirst = data;\r\n My_open_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_open_67bG2BSink(My_open_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_open_67_structType myStruct;\r\n data = -1; \r\n \r\n data = OPEN(\"NSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n myStruct.structFirst = data;\r\n My_open_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_open_67bB2GSink(My_open_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n My_open_67_structType myStruct;\r\n data = -1; \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n CLOSE(data);\r\n myStruct.structFirst = data;\r\n My_open_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_open_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-675:Multiple Operations on Resource in Single-Operation Context|B.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-665:Improper Initialization\nC.CWE-435:Improper Interaction Between Multiple Correctly-Behaving Entities\nD.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * data)\r\n{\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_cat_44()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * data)\r\n{\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = L'\\0'; \r\n funcPtr(data);\r\n}\r\n\r\nvoid My_wchar_t_cat_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_cat_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_cat_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-363:Race Condition Enabling Link Following\nB.No Vulnerabilities\nC.CWE-590:Free of Memory not on the Heap\nD.CWE-270:Privilege Context Switching Error\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_array_struct_alloca_09\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i].intOne = 1;\r\n dataBuffer[i].intTwo = 1;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printStructLine(&data[0]);\r\n \r\n delete [] data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n twoIntsStruct * dataBuffer = new twoIntsStruct[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i].intOne = 1;\r\n dataBuffer[i].intTwo = 1;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printStructLine(&data[0]);\r\n \r\n delete [] data;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n twoIntsStruct * dataBuffer = new twoIntsStruct[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i].intOne = 1;\r\n dataBuffer[i].intTwo = 1;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printStructLine(&data[0]);\r\n \r\n delete [] data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_struct_alloca_09; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-590:Free of Memory not on the Heap|E.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nB.No Vulnerabilities\nC.CWE-1327:Binding to an Unrestricted IP Address\nD.CWE-364:Signal Handler Race Condition\nE.CWE-1023:Incomplete Comparison with Missing Factors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\ntypedef struct _structSigAtomic\r\n{\r\n sig_atomic_t val;\r\n} structSigAtomic;\r\n\r\nstructSigAtomic *My_basic_04StructSigAtomicM = NULL;\r\nstructSigAtomic *My_basic_04StructSigAtomicN = NULL;\r\n\r\nstatic void helperM(int sig)\r\n{\r\n if (My_basic_04StructSigAtomicM != NULL)\r\n {\r\n My_basic_04StructSigAtomicM->val = 2;\r\n }\r\n}\r\n\r\nstatic void helperN(int sig)\r\n{\r\n if (My_basic_04StructSigAtomicN != NULL)\r\n {\r\n My_basic_04StructSigAtomicN->val = 2;\r\n }\r\n}\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_04StructSigAtomicM != NULL)\r\n {\r\n free(My_basic_04StructSigAtomicM);\r\n My_basic_04StructSigAtomicM = NULL;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_04StructSigAtomicM = gStructSigAtomic;\r\n My_basic_04StructSigAtomicM->val = 1;\r\n \r\n signal(SIGINT, helperM);\r\n \r\n if (My_basic_04StructSigAtomicM != NULL)\r\n {\r\n free(My_basic_04StructSigAtomicM);\r\n My_basic_04StructSigAtomicM = NULL;\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_04StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_04StructSigAtomicN);\r\n My_basic_04StructSigAtomicN = 0;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_04StructSigAtomicN = gStructSigAtomic;\r\n My_basic_04StructSigAtomicN->val = 1;\r\n \r\n signal(SIGINT, helperN);\r\n \r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_04StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_04StructSigAtomicN);\r\n My_basic_04StructSigAtomicN = NULL;\r\n }\r\n signal(SIGINT, helperN);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_04StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_04StructSigAtomicN);\r\n My_basic_04StructSigAtomicN = 0;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_04StructSigAtomicN = gStructSigAtomic;\r\n My_basic_04StructSigAtomicN->val = 1;\r\n \r\n signal(SIGINT, helperN);\r\n \r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_04StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_04StructSigAtomicN);\r\n My_basic_04StructSigAtomicN = NULL;\r\n }\r\n signal(SIGINT, helperN);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-364:Signal Handler Race Condition|A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "364"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\nD.CWE-261:Weak Encoding for Password\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_char_console_ofstream_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_console_ofstream_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-36:Absolute Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-280:Improper Handling of Insufficient Permissions or Privileges \nB.CWE-682:Incorrect Calculation\nC.CWE-514:Covert Channel\nD.CWE-469:Use of Pointer Subtraction to Determine Size\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SOURCE_STRING L\"abc/opqrstu\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t string1[] = SOURCE_STRING;\r\n wchar_t string2[] = SOURCE_STRING;\r\n wchar_t * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = wcschr(string1, L'/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string2);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t string1[] = SOURCE_STRING;\r\n wchar_t * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = wcschr(string1, L'/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t string1[] = SOURCE_STRING;\r\n wchar_t * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = wcschr(string1, L'/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-469:Use of Pointer Subtraction to Determine Size|B.CWE-682:Incorrect Calculation", "cwe": "469"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-939:Improper Authorization in Handler for Custom URL Scheme\nB.No Vulnerabilities\nC.CWE-1127:Compilation with Insufficient Warnings or Errors\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\nHANDLE My_w32CreateFile_no_close_68DataForMSink;\r\n\r\nHANDLE My_w32CreateFile_no_close_68DataForNSink;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32CreateFile_no_close_68bSink();\r\n\r\nvoid My_w32CreateFile_no_close_68()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n My_w32CreateFile_no_close_68DataForMSink = data;\r\n My_w32CreateFile_no_close_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32CreateFile_no_close_68bB2GSink();\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n My_w32CreateFile_no_close_68DataForNSink = data;\r\n My_w32CreateFile_no_close_68bB2GSink();\r\n}\r\n\r\nvoid My_w32CreateFile_no_close_68()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_no_close_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_no_close_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-1320:Improper Protection for Outbound Error Messages and Alert Signals\nC.CWE-476:NULL Pointer Dereference\nD.CWE-386:Symbolic Name not Mapping to Correct Object\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_10()\r\n{\r\n wchar_t * data;\r\n if(globalTrue)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n printWcharLine(data[0]);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n if(globalTrue)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printWcharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n if(globalTrue)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printWcharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = L\"N\";\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n printWcharLine(data[0]);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n if(globalTrue)\r\n {\r\n \r\n data = L\"N\";\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n printWcharLine(data[0]);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-705:Incorrect Control Flow Scoping\nB.CWE-396:Declaration of Catch for Generic Exception\nC.CWE-1339:Insufficient Precision or Accuracy of a Real Number\nD.No Vulnerabilities\nE.CWE-419:Unprotected Primary Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_exception_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(staticTrue)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-396:Declaration of Catch for Generic Exception|A.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-221:Information Loss or Omission\nB.CWE-223:Omission of Security-relevant Information\nC.CWE-777:Regular Expression without Anchors\nD.CWE-1224:Improper Restriction of Write-Once Bit Fields\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SZ 15\r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login\\n\");\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login by %s\\n\", username);\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login by %s\\n\", username);\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-223:Omission of Security-relevant Information|A.CWE-221:Information Loss or Omission", "cwe": "223"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-627:Dynamic Variable Evaluation\nD.CWE-36:Absolute Path Traversal\nE.CWE-14:Compiler Removal of Code to Clear Buffers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_console_ifstream_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_console_ifstream_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-36:Absolute Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-675:Multiple Operations on Resource in Single-Operation Context\nB.CWE-620:Unverified Password Change\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-1389:Incorrect Parsing of Numbers with Different Radices\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n# define OPEN _open\r\n# define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n# define OPEN open\r\n# define CLOSE close\r\n#endif\r\n\r\ntypedef union\r\n{\r\n int unionFirst;\r\n int unionSecond;\r\n} My_open_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_34()\r\n{\r\n int data;\r\n My_open_34_unionType myUnion;\r\n data = -1; \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n CLOSE(data);\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n CLOSE(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_open_34_unionType myUnion;\r\n data = -1; \r\n \r\n data = OPEN(\"NSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n CLOSE(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n My_open_34_unionType myUnion;\r\n data = -1; \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n CLOSE(data);\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid My_open_34()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-675:Multiple Operations on Resource in Single-Operation Context|C.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-82:Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\nB.CWE-1112:Incomplete Documentation of Program Execution\nC.No Vulnerabilities\nD.CWE-280:Improper Handling of Insufficient Permissions or Privileges \nE.CWE-140:Improper Neutralization of Delimiters\n", "input": "static void await_references(H264Context *h)\r\r\n{\r\r\n const int mb_xy = h->mb_xy;\r\r\n const int mb_type = h->cur_pic.mb_type[mb_xy];\r\r\n int refs[2][48];\r\r\n int nrefs[2] = { 0 };\r\r\n int ref, list;\r\r\n\r\r\n memset(refs, -1, sizeof(refs));\r\r\n\r\r\n if (IS_16X16(mb_type)) {\r\r\n get_lowest_part_y(h, refs, 0, 16, 0,\r\r\n IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\r\r\n } else if (IS_16X8(mb_type)) {\r\r\n get_lowest_part_y(h, refs, 0, 8, 0,\r\r\n IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\r\r\n get_lowest_part_y(h, refs, 8, 8, 8,\r\r\n IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);\r\r\n } else if (IS_8X16(mb_type)) {\r\r\n get_lowest_part_y(h, refs, 0, 16, 0,\r\r\n IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\r\r\n get_lowest_part_y(h, refs, 4, 16, 0,\r\r\n IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);\r\r\n } else {\r\r\n int i;\r\r\n\r\r\n av_assert2(IS_8X8(mb_type));\r\r\n\r\r\n for (i = 0; i < 4; i++) {\r\r\n const int sub_mb_type = h->sub_mb_type[i];\r\r\n const int n = 4 * i;\r\r\n int y_offset = (i & 2) << 2;\r\r\n\r\r\n if (IS_SUB_8X8(sub_mb_type)) {\r\r\n get_lowest_part_y(h, refs, n, 8, y_offset,\r\r\n IS_DIR(sub_mb_type, 0, 0),\r\r\n IS_DIR(sub_mb_type, 0, 1),\r\r\n nrefs);\r\r\n } else if (IS_SUB_8X4(sub_mb_type)) {\r\r\n get_lowest_part_y(h, refs, n, 4, y_offset,\r\r\n IS_DIR(sub_mb_type, 0, 0),\r\r\n IS_DIR(sub_mb_type, 0, 1),\r\r\n nrefs);\r\r\n get_lowest_part_y(h, refs, n + 2, 4, y_offset + 4,\r\r\n IS_DIR(sub_mb_type, 0, 0),\r\r\n IS_DIR(sub_mb_type, 0, 1),\r\r\n nrefs);\r\r\n } else if (IS_SUB_4X8(sub_mb_type)) {\r\r\n get_lowest_part_y(h, refs, n, 8, y_offset,\r\r\n IS_DIR(sub_mb_type, 0, 0),\r\r\n IS_DIR(sub_mb_type, 0, 1),\r\r\n nrefs);\r\r\n get_lowest_part_y(h, refs, n + 1, 8, y_offset,\r\r\n IS_DIR(sub_mb_type, 0, 0),\r\r\n IS_DIR(sub_mb_type, 0, 1),\r\r\n nrefs);\r\r\n } else {\r\r\n int j;\r\r\n av_assert2(IS_SUB_4X4(sub_mb_type));\r\r\n for (j = 0; j < 4; j++) {\r\r\n int sub_y_offset = y_offset + 2 * (j & 2);\r\r\n get_lowest_part_y(h, refs, n + j, 4, sub_y_offset,\r\r\n IS_DIR(sub_mb_type, 0, 0),\r\r\n IS_DIR(sub_mb_type, 0, 1),\r\r\n nrefs);\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n for (list = h->list_count - 1; list >= 0; list--)\r\r\n for (ref = 0; ref < 48 && nrefs[list]; ref++) {\r\r\n int row = refs[list][ref];\r\r\n if (row >= 0) {\r\r\n Picture *ref_pic = &h->ref_list[list][ref];\r\r\n int ref_field = ref_pic->reference - 1;\r\r\n int ref_field_picture = ref_pic->field_picture;\r\r\n int pic_height = 16 * h->mb_height >> ref_field_picture;\r\r\n\r\r\n row <<= MB_MBAFF(h);\r\r\n nrefs[list]--;\r\r\n\r\r\n if (!FIELD_PICTURE(h) && ref_field_picture) { // frame referencing two fields\r\r\n ff_thread_await_progress(&ref_pic->tf,\r\r\n FFMIN((row >> 1) - !(row & 1),\r\r\n pic_height - 1),\r\r\n 1);\r\r\n ff_thread_await_progress(&ref_pic->tf,\r\r\n FFMIN((row >> 1), pic_height - 1),\r\r\n 0);\r\r\n } else if (FIELD_PICTURE(h) && !ref_field_picture) { // field referencing one field of a frame\r\r\n ff_thread_await_progress(&ref_pic->tf,\r\r\n FFMIN(row * 2 + ref_field,\r\r\n pic_height - 1),\r\r\n 0);\r\r\n } else if (FIELD_PICTURE(h)) {\r\r\n ff_thread_await_progress(&ref_pic->tf,\r\r\n FFMIN(row, pic_height - 1),\r\r\n ref_field);\r\r\n } else {\r\r\n ff_thread_await_progress(&ref_pic->tf,\r\r\n FFMIN(row, pic_height - 1),\r\r\n 0);\r\r\n }\r\r\n }\r\r\n }\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.No Vulnerabilities|C.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1106:Insufficient Use of Symbolic Constants\nB.CWE-400:Uncontrolled Resource Consumption\nC.CWE-794:Incomplete Filtering of Multiple Instances of Special Elements\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define SENTENCE \"This is the sentence we are printing to the file. \"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_fwrite_15()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n count = RAND32();\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\r\n {\r\n exit(1);\r\n }\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n count = RAND32();\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n count = RAND32();\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n count = 20;\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\r\n {\r\n exit(1);\r\n }\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n count = 20;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n size_t i = 0;\r\n FILE *pFile = NULL;\r\n const char *filename = \"output.txt\";\r\n pFile = fopen(filename, \"w+\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\r\n {\r\n exit(1);\r\n }\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_rand_fwrite_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_fwrite_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_fwrite_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1191:On-Chip Debug and Test Interface With Improper Access Control\nB.No Vulnerabilities\nC.CWE-807:Reliance on Untrusted Inputs in a Security Decision\nD.CWE-413:Improper Resource Locking\nE.CWE-591:Sensitive Data Storage in Improperly Locked Memory\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_64bSink(void * passwordVoidPtr);\r\n\r\nvoid My_w32_char_64()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_64bSink(&password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_64bG2BSink(void * passwordVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_64bG2BSink(&password);\r\n}\r\n\r\nvoid My_w32_char_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-591:Sensitive Data Storage in Improperly Locked Memory|D.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-271:Privilege Dropping / Lowering Errors\nB.CWE-146:Improper Neutralization of Expression/Command Delimiters\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-272:Least Privilege Violation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_RegOpenKeyEx_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegOpenKeyExW(\r\n HKEY_LOCAL_MACHINE,\r\n keyName,\r\n 0,\r\n KEY_WRITE,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegOpenKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n KEY_WRITE,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegOpenKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n KEY_WRITE,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_RegOpenKeyEx_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_RegOpenKeyEx_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_RegOpenKeyEx_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-272:Least Privilege Violation|A.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-375:Returning a Mutable Object to an Untrusted Caller\nB.No Vulnerabilities\nC.CWE-172:Encoding Error\nD.CWE-759:Use of a One-Way Hash without a Salt\nE.CWE-176:Improper Handling of Unicode Encoding\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_63bSink(wchar_t * * dataPtr);\r\n\r\nvoid My_w32_63()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n My_w32_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_63bG2BSink(wchar_t * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n My_w32_63bG2BSink(&data);\r\n}\r\n\r\n\r\nvoid My_w32_63bB2GSink(wchar_t * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n My_w32_63bB2GSink(&data);\r\n}\r\n\r\nvoid My_w32_63()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-176:Improper Handling of Unicode Encoding|C.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-566:Authorization Bypass Through User-Controlled SQL Primary Key\nB.CWE-20:Improper Input Validation\nC.No Vulnerabilities\nD.CWE-294:Authentication Bypass by Capture-replay\nE.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint incogitance_nonaffinities = 0;\r\nint global_variable;\r\n\r\nunion desc_pretrying \r\n{\r\n char *antaranga_vanquishable;\r\n double glairier_thiazole;\r\n char *upridge_paraterminal;\r\n char foremasts_orangeness;\r\n int cutovers_aquitaine;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid inferiors_absorptiometer(int grossification_emergently,union desc_pretrying phosphoresce_polyphonies);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\nstruct struct {\r\n int (* before)(int);\r\n char buffer[64];\r\n int (* after)(int);\r\n};\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int squareflipper_bondless = 7;\r\n union desc_pretrying unbarricadoed_bretelle = {0};\r\n int *heterochromic_jacobitely = 0;\r\n int misteacher_faso;\r\n union desc_pretrying bediapers_collochemistry[10] = {0};\r\n union desc_pretrying tachypnoeic_prorata;\r\n int reposition_elephantoid = 596;\r\n char *russomania_unorderable;;\r\n if (__sync_bool_compare_and_swap(&incogitance_nonaffinities,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&russomania_unorderable,\"9420\",reposition_elephantoid);\r\n if (russomania_unorderable != 0) {;\r\n tachypnoeic_prorata . antaranga_vanquishable = russomania_unorderable;\r\n bediapers_collochemistry[5] = tachypnoeic_prorata;\r\n misteacher_faso = 5;\r\n heterochromic_jacobitely = &misteacher_faso;\r\n unbarricadoed_bretelle = *(bediapers_collochemistry + *heterochromic_jacobitely);\r\n inferiors_absorptiometer(squareflipper_bondless,unbarricadoed_bretelle);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid inferiors_absorptiometer(int grossification_emergently,union desc_pretrying phosphoresce_polyphonies)\r\n{\r\n \r\n int i = 0;\r\n int opt_var;\r\n struct struct* data = NULL;\r\n char *milkshop_domdaniel = 0;\r\n ++global_variable;\r\n grossification_emergently--;\r\n if (grossification_emergently > 0) {\r\n inferiors_absorptiometer(grossification_emergently,phosphoresce_polyphonies);\r\n return ;\r\n }\r\n milkshop_domdaniel = ((char *)phosphoresce_polyphonies . antaranga_vanquishable);\r\n \r\n data = (struct struct*) malloc(sizeof(struct struct));\r\n if (data != NULL) {\r\n data->before = toupper;\r\n memset(data->buffer,0,64);\r\n data->after = toupper;\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n strcpy(data->buffer, milkshop_domdaniel);\r\n \r\n \r\n opt_var = strlen( data->buffer);\r\n for (; i < opt_var; ++i) {\r\n data->buffer[i] = toupper(data->buffer[i]);\r\n printf(\"%c\",data->after(data->buffer[i]));\r\n }\r\n \r\n \r\n printf(\"\\n\");\r\n free(data);\r\n \r\n }\r\n;\r\n if (phosphoresce_polyphonies . antaranga_vanquishable != 0) \r\n free(((char *)phosphoresce_polyphonies . antaranga_vanquishable));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')|B.CWE-20:Improper Input Validation", "cwe": "120"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-328:Use of Weak Hash\nC.CWE-1044:Architecture with Number of Horizontal Layers Outside of Expected Range\nD.CWE-530:Exposure of Backup File to an Unauthorized Control Sphere\nE.CWE-326:Inadequate Encryption Strength\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define SHA1_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_SHA1_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA1_SUM_SIZE], calcHash[SHA1_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA1_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA1_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA1_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_SHA1_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_SHA1_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_SHA1_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-328:Use of Weak Hash|E.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.CWE-114:Process Control\nC.No Vulnerabilities\nD.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nE.CWE-293:Using Referer Field for Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_file_66bSink(char * dataArray[]);\r\n\r\nvoid My_w32_char_file_66()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n dataArray[2] = data;\r\n My_w32_char_file_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_file_66bG2BSink(char * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n dataArray[2] = data;\r\n My_w32_char_file_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_w32_char_file_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_file_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_file_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-114:Process Control|A.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-663:Use of a Non-reentrant Function in a Concurrent Context\nB.No Vulnerabilities\nC.CWE-502:Deserialization of Untrusted Data\nD.CWE-1070:Serializable Data Element Containing non-Serializable Item Elements\nE.CWE-1174:ASP.NET Misconfiguration: Improper Model Validation\n", "input": "expand_case_fold_string(Node* node, regex_t* reg, int state)\r\r\n{\r\r\n int r, n, len, alt_num;\r\r\n int fold_len;\r\r\n int prev_is_ambig, prev_is, is, is_in_look_behind;\r\r\n UChar *start, *end, *p;\r\r\n UChar* foldp;\r\r\n Node *top_root, *root, *snode, *prev_node;\r\r\n OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\r\r\n UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\r\r\n StrNode* sn;\r\r\n\r\r\n if (NODE_STRING_IS_AMBIG(node)) return 0;\r\r\n\r\r\n sn = STR_(node);\r\r\n\r\r\n start = sn->s;\r\r\n end = sn->end;\r\r\n if (start >= end) return 0;\r\r\n\r\r\n is_in_look_behind = (state & IN_LOOK_BEHIND) != 0;\r\r\n\r\r\n r = 0;\r\r\n top_root = root = prev_node = snode = NULL_NODE;\r\r\n alt_num = 1;\r\r\n p = start;\r\r\n while (p < end) {\r\r\n n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag,\r\r\n p, end, items);\r\r\n if (n < 0) {\r\r\n r = n;\r\r\n goto err;\r\r\n }\r\r\n\r\r\n len = enclen(reg->enc, p);\r\r\n is = is_case_fold_items_for_search(reg->enc, len, n, items);\r\r\n\r\r\n if (is_in_look_behind ||\r\r\n (IS_NOT_NULL(snode) ||\r\r\n (is\r\r\n /* expand single char case: ex. /(?i:a)/ */\r\r\n && !(p == start && p + len >= end)))) {\r\r\n if (IS_NULL(snode)) {\r\r\n if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\r\r\n top_root = root = onig_node_list_add(NULL_NODE, prev_node);\r\r\n if (IS_NULL(root)) {\r\r\n onig_node_free(prev_node);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n\r\r\n prev_node = snode = onig_node_new_str(NULL, NULL);\r\r\n if (IS_NULL(snode)) goto mem_err;\r\r\n if (IS_NOT_NULL(root)) {\r\r\n if (IS_NULL(onig_node_list_add(root, snode))) {\r\r\n onig_node_free(snode);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n\r\r\n prev_is_ambig = -1; /* -1: new */\r\r\n prev_is = 0; /* escape compiler warning */\r\r\n }\r\r\n else {\r\r\n prev_is_ambig = NODE_STRING_IS_AMBIG(snode);\r\r\n prev_is = NODE_STRING_IS_N_AMBIG(snode);\r\r\n }\r\r\n\r\r\n if (n != 0) {\r\r\n foldp = p;\r\r\n fold_len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag,\r\r\n &foldp, end, buf);\r\r\n foldp = buf;\r\r\n }\r\r\n else {\r\r\n foldp = p; fold_len = len;\r\r\n }\r\r\n\r\r\n if ((prev_is_ambig == 0 && n != 0) ||\r\r\n (prev_is_ambig > 0 && (n == 0 || prev_is != is))) {\r\r\n if (IS_NULL(root) /* && IS_NOT_NULL(prev_node) */) {\r\r\n top_root = root = onig_node_list_add(NULL_NODE, prev_node);\r\r\n if (IS_NULL(root)) {\r\r\n onig_node_free(prev_node);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n\r\r\n prev_node = snode = onig_node_new_str(foldp, foldp + fold_len);\r\r\n if (IS_NULL(snode)) goto mem_err;\r\r\n if (IS_NULL(onig_node_list_add(root, snode))) {\r\r\n onig_node_free(snode);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n else {\r\r\n r = onig_node_str_cat(snode, foldp, foldp + fold_len);\r\r\n if (r != 0) goto err;\r\r\n }\r\r\n\r\r\n if (n != 0) NODE_STRING_SET_AMBIG(snode);\r\r\n if (is != 0) NODE_STRING_SET_N_AMBIG(snode);\r\r\n }\r\r\n else {\r\r\n alt_num *= (n + 1);\r\r\n if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;\r\r\n\r\r\n if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\r\r\n top_root = root = onig_node_list_add(NULL_NODE, prev_node);\r\r\n if (IS_NULL(root)) {\r\r\n onig_node_free(prev_node);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n\r\r\n r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);\r\r\n if (r < 0) goto mem_err;\r\r\n if (r == 1) {\r\r\n if (IS_NULL(root)) {\r\r\n top_root = prev_node;\r\r\n }\r\r\n else {\r\r\n if (IS_NULL(onig_node_list_add(root, prev_node))) {\r\r\n onig_node_free(prev_node);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n\r\r\n root = NODE_CAR(prev_node);\r\r\n }\r\r\n else { /* r == 0 */\r\r\n if (IS_NOT_NULL(root)) {\r\r\n if (IS_NULL(onig_node_list_add(root, prev_node))) {\r\r\n onig_node_free(prev_node);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n snode = NULL_NODE;\r\r\n }\r\r\n\r\r\n p += len;\r\r\n }\r\r\n\r\r\n if (p < end) {\r\r\n Node *srem;\r\r\n\r\r\n r = expand_case_fold_make_rem_string(&srem, p, end, reg);\r\r\n if (r != 0) goto mem_err;\r\r\n\r\r\n if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {\r\r\n top_root = root = onig_node_list_add(NULL_NODE, prev_node);\r\r\n if (IS_NULL(root)) {\r\r\n onig_node_free(srem);\r\r\n onig_node_free(prev_node);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n\r\r\n if (IS_NULL(root)) {\r\r\n prev_node = srem;\r\r\n }\r\r\n else {\r\r\n if (IS_NULL(onig_node_list_add(root, srem))) {\r\r\n onig_node_free(srem);\r\r\n goto mem_err;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n /* ending */\r\r\n top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);\r\r\n swap_node(node, top_root);\r\r\n onig_node_free(top_root);\r\r\n return 0;\r\r\n\r\r\n mem_err:\r\r\n r = ONIGERR_MEMORY;\r\r\n\r\r\n err:\r\r\n onig_node_free(top_root);\r\r\n return r;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.No Vulnerabilities|B.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-134:Use of Externally-Controlled Format String\nC.No Vulnerabilities\nD.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nE.CWE-288:Authentication Bypass Using an Alternate Path or Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_wchar_t_listen_socket_vfprintf_81\r\n{\r\n\r\nclass My_wchar_t_listen_socket_vfprintf_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_wchar_t_listen_socket_vfprintf_81 : public My_wchar_t_listen_socket_vfprintf_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_wchar_t_listen_socket_vfprintf_81G2B : public My_wchar_t_listen_socket_vfprintf_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\nclass My_wchar_t_listen_socket_vfprintf_81B2G : public My_wchar_t_listen_socket_vfprintf_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-134:Use of Externally-Controlled Format String|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-603:Use of Client-Side Authentication\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.No Vulnerabilities\nD.CWE-134:Use of Externally-Controlled Format String\nE.CWE-301:Reflection Attack in an Authentication Protocol\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_char_file_w32_vsnprintf_81\r\n{\r\n\r\nclass My_char_file_w32_vsnprintf_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(char * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_char_file_w32_vsnprintf_81 : public My_char_file_w32_vsnprintf_81_base\r\n{\r\npublic:\r\n void action(char * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_char_file_w32_vsnprintf_81G2B : public My_char_file_w32_vsnprintf_81_base\r\n{\r\npublic:\r\n void action(char * data) const;\r\n};\r\n\r\nclass My_char_file_w32_vsnprintf_81B2G : public My_char_file_w32_vsnprintf_81_base\r\n{\r\npublic:\r\n void action(char * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-134:Use of Externally-Controlled Format String|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-1390:Weak Authentication\nD.CWE-665:Improper Initialization\nE.CWE-353:Missing Support for Integrity Check\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_ncat_15()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data[0] = L'\\0'; \r\n break;\r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data[0] = L'\\0'; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_ncat_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_ncat_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_ncat_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-665:Improper Initialization|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-459:Incomplete Cleanup\nB.CWE-99:Improper Control of Resource Identifiers ('Resource Injection')\nC.CWE-439:Behavioral Change in New Version or Environment\nD.No Vulnerabilities\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_declare_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_declare_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_declare_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_declare_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|A.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-261:Weak Encoding for Password\nB.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nC.No Vulnerabilities\nD.CWE-692:Incomplete Denylist to Cross-Site Scripting\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_accept_listen_bind_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_accept_listen_bind_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_accept_listen_bind_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_accept_listen_bind_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-666:Operation on Resource in Wrong Phase of Lifetime|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-450:Multiple Interpretations of UI Input\nB.CWE-401:Missing Release of Memory after Effective Lifetime\nC.No Vulnerabilities\nD.CWE-135:Incorrect Calculation of Multi-Byte String Length\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_int_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = new int;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n }\r\n else\r\n {\r\n \r\n int dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = new int;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n }\r\n else\r\n {\r\n \r\n data = new int;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n delete data;\r\n }\r\n else\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n int dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n }\r\n else\r\n {\r\n \r\n int dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = 5;\r\n printIntLine(*data);\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_int_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-401:Missing Release of Memory after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nB.CWE-605:Multiple Binds to the Same Port\nC.CWE-134:Use of Externally-Controlled Format String\nD.CWE-668:Exposure of Resource to Wrong Sphere\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include <stdarg.h>\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mVaSinkB(wchar_t * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vfwprintf(stdout, data, args);\r\n va_end(args);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_vfprintf_18()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n goto sink;\r\nsink:\r\n mVaSinkB(data, data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void nB2GVaSinkG(wchar_t * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vfwprintf(stdout, L\"%s\", args);\r\n va_end(args);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n goto sink;\r\nsink:\r\n nB2GVaSinkG(data, data);\r\n}\r\n\r\nstatic void nG2BVaSinkB(wchar_t * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vfwprintf(stdout, data, args);\r\n va_end(args);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n \r\n wcscpy(data, L\"fixedstringtest\");\r\n goto sink;\r\nsink:\r\n nG2BVaSinkB(data, data);\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_vfprintf_18()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_vfprintf_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_vfprintf_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-134:Use of Externally-Controlled Format String|D.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-311:Missing Encryption of Sensitive Data\nB.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\nC.CWE-233:Improper Handling of Parameters\nD.CWE-319:Cleartext Transmission of Sensitive Information\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_listen_socket_65bSink(char * password);\r\n\r\nvoid My_w32_char_listen_socket_65()\r\n{\r\n char * password;\r\n \r\n void (*funcPtr) (char *) = My_w32_char_listen_socket_65bSink;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n \r\n funcPtr(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_listen_socket_65bG2BSink(char * password);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n void (*funcPtr) (char *) = My_w32_char_listen_socket_65bG2BSink;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n \r\n strcpy(password, \"Password1234!\");\r\n funcPtr(password);\r\n}\r\n\r\n\r\nvoid My_w32_char_listen_socket_65bB2GSink(char * password);\r\n\r\nstatic void nB2G()\r\n{\r\n char * password;\r\n void (*funcPtr) (char *) = My_w32_char_listen_socket_65bB2GSink;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n funcPtr(password);\r\n}\r\n\r\nvoid My_w32_char_listen_socket_65()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_listen_socket_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_listen_socket_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-319:Cleartext Transmission of Sensitive Information|A.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1078:Inappropriate Source Code Style or Formatting\nB.CWE-546:Suspicious Comment\nC.CWE-779:Logging of Excessive Data\nD.CWE-520:.NET Misconfiguration: Use of Impersonation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_FIXME_10()\r\n{\r\n if(globalTrue)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_FIXME_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_FIXME_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_FIXME_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-546:Suspicious Comment|A.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-194:Unexpected Sign Extension\nB.No Vulnerabilities\nC.CWE-925:Improper Verification of Intent by Broadcast Receiver\nD.CWE-166:Improper Handling of Missing Special Element\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fscanf_strncpy_82\r\n{\r\n\r\nclass My_fscanf_strncpy_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(short data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fscanf_strncpy_82 : public My_fscanf_strncpy_82_base\r\n{\r\npublic:\r\n void action(short data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fscanf_strncpy_82G2B : public My_fscanf_strncpy_82_base\r\n{\r\npublic:\r\n void action(short data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-194:Unexpected Sign Extension|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-510:Trapdoor\nC.CWE-691:Insufficient Control Flow Management\nD.CWE-645:Overly Restrictive Account Lockout Mechanism\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_listen_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(30000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_listen_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|E.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-510:Trapdoor\nB.No Vulnerabilities\nC.CWE-506:Embedded Malicious Code\nD.CWE-565:Reliance on Cookies without Validation and Integrity Checking\nE.CWE-114:Process Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_connection_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(80);\r\n \r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_connection_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-510:Trapdoor|C.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nC.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nD.CWE-1318:Missing Support for Security Features in On-chip Fabrics or Buses\nE.CWE-155:Improper Neutralization of Wildcards or Matching Symbols\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_realloc_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(wchar_t));\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_realloc_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_realloc_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_realloc_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|C.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nB.CWE-1231:Improper Prevention of Lock Bit Modification\nC.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nD.No Vulnerabilities\nE.CWE-196:Unsigned to Signed Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifdef _WIN32\r\n#define ACCESS _access\r\n#define W_OK 02\r\n#else\r\n#define ACCESS access\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_access_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (ACCESS(filename, W_OK) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_access_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_access_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_access_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-788:Access of Memory Location After End of Buffer\nD.No Vulnerabilities\nE.CWE-1101:Reliance on Runtime Component in Generated Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int data)\r\n{\r\n {\r\n int buffer[10] = { 0 };\r\n \r\n if (data >= 0)\r\n {\r\n printIntLine(buffer[data]);\r\n }\r\n else\r\n {\r\n printLine(\"ERROR: Array index is negative\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_My_My_My_CWE129_fscanf_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|C.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-178:Improper Handling of Case Sensitivity\nB.CWE-682:Incorrect Calculation\nC.No Vulnerabilities\nD.CWE-1118:Insufficient Documentation of Error Handling Techniques\nE.CWE-190:Integer Overflow or Wraparound\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_fscanf_add_05()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticTrue)\r\n {\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n short result = data + 1;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticTrue)\r\n {\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n }\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data < SHRT_MAX)\r\n {\r\n short result = data + 1;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticTrue)\r\n {\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n if (data < SHRT_MAX)\r\n {\r\n short result = data + 1;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 2;\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n short result = data + 1;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticTrue)\r\n {\r\n \r\n data = 2;\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n short result = data + 1;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_fscanf_add_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_fscanf_add_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_fscanf_add_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-94:Improper Control of Generation of Code ('Code Injection')\nB.CWE-358:Improperly Implemented Security Check for Standard\nC.CWE-259:Use of Hard-coded Password\nD.No Vulnerabilities\nE.CWE-798:Use of Hard-coded Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_06()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n strcpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-259:Use of Hard-coded Password|E.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-377:Insecure Temporary File\nB.CWE-657:Violation of Secure Design Principles\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.No Vulnerabilities\nE.CWE-652:Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_w32GetTempFileName_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n if (GetTempFileNameW(L\".\", L\"m\", 0, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n \r\n if (GetTempFileNameW(L\".\", L\"n\", rand() + 1, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n \r\n if (GetTempFileNameW(L\".\", L\"n\", rand() + 1, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_w32GetTempFileName_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_w32GetTempFileName_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_w32GetTempFileName_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-377:Insecure Temporary File|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-506:Embedded Malicious Code\nC.CWE-1251:Mirrored Regions with Different Values\nD.CWE-510:Trapdoor\nE.CWE-698:Execution After Redirect (EAR)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <ws2tcpip.h>\r\n#else\r\n#include <netdb.h>\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_hostname_based_logic_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char hostname[NI_MAXHOST];\r\n char servInfo[NI_MAXSERV];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n if (getnameinfo((struct sockaddr *)&acceptService,\r\n sizeof(struct sockaddr),\r\n hostname,\r\n NI_MAXHOST, servInfo, NI_MAXSERV, NI_NUMERICSERV) != 0)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"admin.google.com\", hostname) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_hostname_based_logic_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_hostname_based_logic_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_hostname_based_logic_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-510:Trapdoor|B.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-27:Path Traversal: 'dir/../../filename'\nB.CWE-190:Integer Overflow or Wraparound\nC.CWE-680:Integer Overflow to Buffer Overflow\nD.CWE-326:Inadequate Encryption Strength\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_rand_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int> dataVector);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<int> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = 20;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_rand_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-680:Integer Overflow to Buffer Overflow|B.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-176:Improper Handling of Unicode Encoding\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-263:Password Aging with Long Expiration\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <float.h>\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2float_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printFloatLine((float)doubleNumber);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > FLT_MAX || doubleNumber < FLT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as a float\");\r\n }\r\n else\r\n {\r\n printFloatLine((float)doubleNumber);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > FLT_MAX || doubleNumber < FLT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as a float\");\r\n }\r\n else\r\n {\r\n printFloatLine((float)doubleNumber);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_double2float_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2float_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2float_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-681:Incorrect Conversion between Numeric Types|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1100:Insufficient Isolation of System-Dependent Functions\nB.CWE-13:ASP.NET Misconfiguration: Password in Configuration File\nC.No Vulnerabilities\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.CWE-366:Race Condition within a Thread\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#define N_ITERS 1000000\r\n\r\nstatic stdThreadLock gNLock = NULL;\r\n\r\nstatic void helperM(void *args)\r\n{\r\n int *pIntArgs = (int*)args;\r\n int i;\r\n \r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n *pIntArgs = *pIntArgs + 1;\r\n }\r\n}\r\n\r\nstatic void helperN(void *args)\r\n{\r\n int *pIntArgs = (int *)args;\r\n int i;\r\n \r\n stdThreadLockAcquire(gNLock);\r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n *pIntArgs = *pIntArgs + 1;\r\n }\r\n stdThreadLockRelease(gNLock);\r\n}\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_byref_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n int valMSink;\r\n valMSink = 0;\r\n if (!stdThreadCreate(helperM, (void*)&valMSink, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperM, (void*)&valMSink, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n printIntLine(valMSink);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n int valNSink;\r\n valNSink = 0;\r\n if (!stdThreadLockCreate(&gNLock))\r\n {\r\n return;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n stdThreadLockDestroy(gNLock);\r\n printIntLine(valNSink);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n int valNSink;\r\n valNSink = 0;\r\n if (!stdThreadLockCreate(&gNLock))\r\n {\r\n return;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n stdThreadLockDestroy(gNLock);\r\n printIntLine(valNSink);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_byref_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_byref_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_byref_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-366:Race Condition within a Thread|D.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "366"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.CWE-1394:Use of Default Cryptographic Key\nC.No Vulnerabilities\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-916:Use of Password Hash With Insufficient Computational Effort\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nint My_listen_socket_68Data;\r\nint My_listen_socket_68G2BData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_listen_socket_68bSink();\r\n\r\nvoid My_listen_socket_68()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_listen_socket_68Data = data;\r\n My_listen_socket_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_listen_socket_68bG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n My_listen_socket_68G2BData = data;\r\n My_listen_socket_68bG2BSink();\r\n}\r\n\r\nvoid My_listen_socket_68()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-617:Reachable Assertion|D.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-767:Access to Critical Private Variable via Public Method\nE.CWE-483:Incorrect Block Delimitation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(int data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n \r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_listen_socket_add_21()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(int data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data < INT_MAX)\r\n {\r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(int data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n if (data < INT_MAX)\r\n {\r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(int data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n {\r\n \r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_int_listen_socket_add_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_listen_socket_add_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_listen_socket_add_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1258:Exposure of Sensitive System Information Due to Uncleared Debug Information\nB.No Vulnerabilities\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-1253:Incorrect Selection of Fuse Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_05()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(staticTrue)\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|D.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-79:Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nB.CWE-73:External Control of File Name or Path\nC.CWE-114:Process Control\nD.No Vulnerabilities\nE.CWE-1055:Multiple Inheritance from Concrete Classes\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_environment_03()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_environment_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_environment_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_environment_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|B.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1302:Missing Security Identifier\nC.CWE-665:Improper Initialization\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-508:Non-Replicating Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_ncat_05()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n ; \r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_ncat_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_ncat_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_ncat_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nB.CWE-205:Observable Behavioral Discrepancy\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_file_15()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (256-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_file_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_file_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_file_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-394:Unexpected Status Code or Return Value\nC.CWE-1022:Use of Web Link to Untrusted Target with window.opener Access\nD.CWE-126:Buffer Over-read\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_alloca_memcpy_16()\r\n{\r\n char * data;\r\n char * dataMBuffer = (char *)ALLOCA(50*sizeof(char));\r\n char * dataNBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n while(1)\r\n {\r\n \r\n data = dataMBuffer;\r\n break;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataMBuffer = (char *)ALLOCA(50*sizeof(char));\r\n char * dataNBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n while(1)\r\n {\r\n \r\n data = dataNBuffer;\r\n break;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_char_alloca_memcpy_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_alloca_memcpy_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_alloca_memcpy_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-570:Expression is Always False\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-144:Improper Neutralization of Line Delimiters\nE.CWE-590:Free of Memory not on the Heap\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_int64_t_declare_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(int64_t * * dataPtr);\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n {\r\n \r\n int64_t dataBuffer;\r\n dataBuffer = 5LL;\r\n data = &dataBuffer;\r\n }\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(int64_t * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n {\r\n \r\n int64_t * dataBuffer = new int64_t;\r\n *dataBuffer = 5LL;\r\n data = dataBuffer;\r\n }\r\n nG2BSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_int64_t_declare_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-480:Use of Incorrect Operator\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.No Vulnerabilities\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-321:Use of Hard-coded Cryptographic Key\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_65bSink(char * cryptoKey);\r\n\r\nvoid My_w32_char_65()\r\n{\r\n char * cryptoKey;\r\n \r\n void (*funcPtr) (char *) = My_w32_char_65bSink;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n \r\n funcPtr(cryptoKey);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_65bG2BSink(char * cryptoKey);\r\n\r\nstatic void nG2B()\r\n{\r\n char * cryptoKey;\r\n void (*funcPtr) (char *) = My_w32_char_65bG2BSink;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n funcPtr(cryptoKey);\r\n}\r\n\r\nvoid My_w32_char_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-321:Use of Hard-coded Cryptographic Key|D.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-138:Improper Neutralization of Special Elements\nC.CWE-464:Addition of Data Structure Sentinel\nD.CWE-683:Function Call With Incorrect Order of Arguments\nE.CWE-1088:Synchronous Access of Remote Resource without Timeout\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_32()\r\n{\r\n char data;\r\n char *dataPtr1 = &data;\r\n char *dataPtr2 = &data;\r\n data = ' ';\r\n {\r\n char data = *dataPtr1;\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n char data = *dataPtr2;\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n char *dataPtr1 = &data;\r\n char *dataPtr2 = &data;\r\n data = ' ';\r\n {\r\n char data = *dataPtr1;\r\n \r\n data = 'a';\r\n *dataPtr1 = data;\r\n }\r\n {\r\n char data = *dataPtr2;\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_32()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-464:Addition of Data Structure Sentinel|B.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-806:Buffer Access Using Size of Source Buffer\nB.CWE-793:Only Filtering One Instance of a Special Element\nC.CWE-475:Undefined Behavior for Input to API\nD.CWE-573:Improper Following of Specification by Caller\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-475:Undefined Behavior for Input to API|D.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-546:Suspicious Comment\nB.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nC.CWE-413:Improper Resource Locking\nD.CWE-804:Guessable CAPTCHA\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_13()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-591:Sensitive Data Storage in Improperly Locked Memory|C.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-111:Direct Use of Unsafe JNI\nB.CWE-1111:Incomplete I/O Documentation\nC.CWE-789:Memory Allocation with Excessive Size Value\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING \"hello\"\r\n\r\nnamespace My_new_char_fgets_41\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(size_t data)\r\n{\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(size_t data)\r\n{\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(size_t data)\r\n{\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n nB2GSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_fgets_41; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-789:Memory Allocation with Excessive Size Value|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.CWE-580:clone() Method Without super.clone()\nC.CWE-788:Access of Memory Location After End of Buffer\nD.CWE-483:Incorrect Block Delimitation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_wchar_t_memmove_14()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(globalFive==5)\r\n {\r\n \r\n data = (wchar_t *)malloc(50*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 50-1); \r\n data[50-1] = L'\\0'; \r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(globalFive==5)\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_memmove_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_memmove_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_memmove_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|C.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.No Vulnerabilities\nC.CWE-546:Suspicious Comment\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-42:Path Equivalence: 'filename.' (Trailing Dot)\n", "input": "\r\n\r\n\r\n#include <inttypes.h>\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int64_t_fscanf_postdec_06()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n data--;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n }\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data > LLONG_MIN)\r\n {\r\n data--;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n if (data > LLONG_MIN)\r\n {\r\n data--;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n data--;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = -2;\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n data--;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int64_t_fscanf_postdec_06()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_fscanf_postdec_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_fscanf_postdec_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|A.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-581:Object Model Violation: Just One of Equals and Hashcode Defined\nB.CWE-73:External Control of File Name or Path\nC.No Vulnerabilities\nD.CWE-695:Use of Low-Level Functionality\nE.CWE-114:Process Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_listen_socket_10()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_listen_socket_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_listen_socket_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_listen_socket_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-114:Process Control|B.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-416:Use After Free\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-344:Use of Invariant Value in Dynamically Changing Context\nD.No Vulnerabilities\nE.CWE-686:Function Call With Incorrect Argument Type\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_char_01()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n \r\n printLine(data);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n \r\n printLine(data);\r\n \r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\nvoid My_malloc_free_char_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_char_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_char_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-416:Use After Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-344:Use of Invariant Value in Dynamically Changing Context\nB.CWE-587:Assignment of a Fixed Address to a Pointer\nC.No Vulnerabilities\nD.CWE-1254:Incorrect Comparison Logic Granularity\nE.CWE-477:Use of Obsolete Function\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n \r\n char *charPointer = (char*)0x400000;\r\n printHexCharLine(*charPointer);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_basic_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-587:Assignment of a Fixed Address to a Pointer|A.CWE-344:Use of Invariant Value in Dynamically Changing Context", "cwe": "587"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-127:Buffer Under-read\nB.No Vulnerabilities\nC.CWE-7:J2EE Misconfiguration: Missing Custom Error Page\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-578:EJB Bad Practices: Use of Class Loader\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic int My_My_My_My_My_My_My_My_My_My_My_My_My_CWE839_negative_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)\nC.CWE-1039:Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\nD.No Vulnerabilities\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fscanf_18()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n goto source;\r\nsource:\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n goto source;\r\nsource:\r\n \r\n data = ASSERT_VALUE+1;\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fscanf_18()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-617:Reachable Assertion|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-234:Failure to Handle Missing Parameter\nB.No Vulnerabilities\nC.CWE-459:Incomplete Cleanup\nD.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nE.CWE-167:Improper Handling of Additional Special Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_alloca_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_alloca_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_alloca_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_alloca_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|C.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-131:Incorrect Calculation of Buffer Size\nB.CWE-1292:Incorrect Conversion of Security Identifiers\nC.CWE-467:Use of sizeof() on a Pointer Type\nD.No Vulnerabilities\nE.CWE-395:Use of NullPointerException Catch to Detect NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int * mInt = NULL;\r\n \r\n mInt = (int *)malloc(sizeof(mInt));\r\n if (mInt == NULL) {exit(-1);}\r\n *mInt = 5;\r\n printIntLine(*mInt);\r\n free(mInt);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int * nInt = NULL;\r\n \r\n nInt = (int *)malloc(sizeof(*nInt));\r\n if (nInt == NULL) {exit(-1);}\r\n *nInt = 6;\r\n printIntLine(*nInt);\r\n free(nInt);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int * nInt = NULL;\r\n \r\n nInt = (int *)malloc(sizeof(*nInt));\r\n if (nInt == NULL) {exit(-1);}\r\n *nInt = 6;\r\n printIntLine(*nInt);\r\n free(nInt);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-467:Use of sizeof() on a Pointer Type|A.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-606:Unchecked Input for Loop Condition\nB.CWE-531:Inclusion of Sensitive Information in Test Code\nC.CWE-540:Inclusion of Sensitive Information in Source Code\nD.CWE-1284:Improper Validation of Specified Quantity in Input\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} My_wchar_t_file_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_file_34()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_file_34_unionType myUnion;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_file_34_unionType myUnion;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"15\");\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_file_34_unionType myUnion;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_file_34()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_file_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_file_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-606:Unchecked Input for Loop Condition|D.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-213:Exposure of Sensitive Information Due to Incompatible Policies\nB.CWE-573:Improper Following of Specification by Caller\nC.No Vulnerabilities\nD.CWE-480:Use of Incorrect Operator\nE.CWE-325:Missing Cryptographic Step\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptHashData_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptHashData_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptHashData_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptHashData_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-325:Missing Cryptographic Step|B.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-87:Improper Neutralization of Alternate XSS Syntax\nC.CWE-256:Plaintext Storage of a Password\nD.CWE-1021:Improper Restriction of Rendered UI Layers or Frames\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_char_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, char *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, char *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|E.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1266:Improper Scrubbing of Sensitive Data from Decommissioned Device\nB.No Vulnerabilities\nC.CWE-476:NULL Pointer Dereference\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-1292:Incorrect Conversion of Security Identifiers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_deref_after_check_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n \r\n int *intPointer = NULL;\r\n if (intPointer == NULL)\r\n {\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int *intPointer = NULL;\r\n if (intPointer == NULL)\r\n {\r\n printLine(\"pointer is NULL\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n \r\n int *intPointer = NULL;\r\n if (intPointer == NULL)\r\n {\r\n printLine(\"pointer is NULL\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_deref_after_check_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_deref_after_check_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_deref_after_check_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-682:Incorrect Calculation\nC.CWE-73:External Control of File Name or Path\nD.CWE-431:Missing Handler\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\ntypedef struct _My_int_connect_socket_sub_67_structType\r\n{\r\n int structFirst;\r\n} My_int_connect_socket_sub_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_connect_socket_sub_67bSink(My_int_connect_socket_sub_67_structType myStruct);\r\n\r\nvoid My_int_connect_socket_sub_67()\r\n{\r\n int data;\r\n My_int_connect_socket_sub_67_structType myStruct;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_sub_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_connect_socket_sub_67bG2BSink(My_int_connect_socket_sub_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_int_connect_socket_sub_67_structType myStruct;\r\n \r\n data = 0;\r\n \r\n data = -2;\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_sub_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_int_connect_socket_sub_67bB2GSink(My_int_connect_socket_sub_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n My_int_connect_socket_sub_67_structType myStruct;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_sub_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_int_connect_socket_sub_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_sub_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_sub_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|B.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1284:Improper Validation of Specified Quantity in Input\nB.CWE-606:Unchecked Input for Loop Condition\nC.No Vulnerabilities\nD.CWE-763:Release of Invalid Pointer or Reference\nE.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_console_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"15\");\r\n funcPtr(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(char * data)\r\n{\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nB2GSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_console_44()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-606:Unchecked Input for Loop Condition|A.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.No Vulnerabilities\nC.CWE-425:Direct Request ('Forced Browsing')\nD.CWE-675:Multiple Operations on Resource in Single-Operation Context\nE.CWE-144:Improper Neutralization of Line Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_freopen_81\r\n{\r\n\r\nclass My_freopen_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(FILE * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_freopen_81 : public My_freopen_81_base\r\n{\r\npublic:\r\n void action(FILE * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_freopen_81G2B : public My_freopen_81_base\r\n{\r\npublic:\r\n void action(FILE * data) const;\r\n};\r\n\r\nclass My_freopen_81B2G : public My_freopen_81_base\r\n{\r\npublic:\r\n void action(FILE * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-675:Multiple Operations on Resource in Single-Operation Context|A.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-430:Deployment of Wrong Handler\nC.CWE-1063:Creation of Class Instance within a Static Code Block\nD.CWE-391:Unchecked Error Condition\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#include <math.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_sqrt_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n double doubleNumber;\r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_sqrt_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_sqrt_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_sqrt_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-391:Unchecked Error Condition|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-364:Signal Handler Race Condition\nB.No Vulnerabilities\nC.CWE-476:NULL Pointer Dereference\nD.CWE-644:Improper Neutralization of HTTP Headers for Scripting Syntax\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_10()\r\n{\r\n char * data;\r\n if(globalTrue)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n printHexCharLine(data[0]);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n if(globalTrue)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printHexCharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n if(globalTrue)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printHexCharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = \"N\";\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n printHexCharLine(data[0]);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n if(globalTrue)\r\n {\r\n \r\n data = \"N\";\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n printHexCharLine(data[0]);\r\n }\r\n}\r\n\r\nvoid My_char_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-201:Insertion of Sensitive Information Into Sent Data\nB.CWE-1078:Inappropriate Source Code Style or Formatting\nC.No Vulnerabilities\nD.CWE-706:Use of Incorrectly-Resolved Name or Reference\nE.CWE-546:Suspicious Comment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_BUG_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_BUG_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_BUG_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_BUG_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-546:Suspicious Comment|B.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-535:Exposure of Information Through Shell Error Message\nB.CWE-211:Externally-Generated Error Message Containing Sensitive Information\nC.CWE-791:Incomplete Filtering of Special Elements\nD.CWE-1269:Product Released in Non-Release Configuration\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-535:Exposure of Information Through Shell Error Message|B.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.No Vulnerabilities\nC.CWE-104:Struts: Form Bean Does Not Extend Validation Class\nD.CWE-590:Free of Memory not on the Heap\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_free_wchar_t_alloca_14()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n }\r\n printWLine(data);\r\n \r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n }\r\n printWLine(data);\r\n \r\n free(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n }\r\n printWLine(data);\r\n \r\n free(data);\r\n}\r\n\r\nvoid My_free_wchar_t_alloca_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_free_wchar_t_alloca_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_free_wchar_t_alloca_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|E.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-705:Incorrect Control Flow Scoping\nC.CWE-396:Declaration of Catch for Generic Exception\nD.CWE-577:EJB Bad Practices: Use of Sockets\nE.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_exception_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-396:Declaration of Catch for Generic Exception|B.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-115:Misinterpretation of Input\nC.CWE-351:Insufficient Type Distinction\nD.CWE-259:Use of Hard-coded Password\nE.CWE-798:Use of Hard-coded Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\nnamespace My_w32_wchar_t_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(wchar_t * &password)\r\n{\r\n \r\n wcscpy(password, PASSWORD);\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n mSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(wchar_t * &password)\r\n{\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n nG2BSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-259:Use of Hard-coded Password|E.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-303:Incorrect Implementation of Authentication Algorithm\nC.No Vulnerabilities\nD.CWE-400:Uncontrolled Resource Consumption\nE.CWE-1247:Improper Protection Against Voltage and Clock Glitches\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\nstatic int My_fgets_sleep_45Data;\r\nstatic int My_fgets_sleep_45G2BData;\r\nstatic int My_fgets_sleep_45B2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n int count = My_fgets_sleep_45Data;\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n}\r\n\r\nvoid My_fgets_sleep_45()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n My_fgets_sleep_45Data = count;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n int count = My_fgets_sleep_45G2BData;\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n My_fgets_sleep_45G2BData = count;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n int count = My_fgets_sleep_45B2GData;\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n My_fgets_sleep_45B2GData = count;\r\n nB2GSink();\r\n}\r\n\r\nvoid My_fgets_sleep_45()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_sleep_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_sleep_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-400:Uncontrolled Resource Consumption|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-1123:Excessive Use of Self-Modifying Code\nD.CWE-1125:Excessive Attack Surface\nE.CWE-427:Uncontrolled Search Path Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_char_listen_socket_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n \r\n PUTENV(data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n \r\n strcat(data, NEW_PATH);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_listen_socket_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-507:Trojan Horse\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-590:Free of Memory not on the Heap\nE.CWE-657:Violation of Secure Design Principles\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_int_static_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i;\r\n int * data;\r\n data = NULL; \r\n for(i = 0; i < 1; i++)\r\n {\r\n {\r\n \r\n static int dataBuffer;\r\n dataBuffer = 5;\r\n data = &dataBuffer;\r\n }\r\n }\r\n printIntLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n int * data;\r\n data = NULL; \r\n for(h = 0; h < 1; h++)\r\n {\r\n {\r\n \r\n int * dataBuffer = new int;\r\n *dataBuffer = 5;\r\n data = dataBuffer;\r\n }\r\n }\r\n printIntLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_int_static_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-926:Improper Export of Android Application Components\nC.No Vulnerabilities\nD.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_CWE129_large_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-390:Detection of Error Condition Without Action\nB.No Vulnerabilities\nC.CWE-755:Improper Handling of Exceptional Conditions\nD.CWE-462:Duplicate Key in Associative List (Alist)\nE.CWE-1177:Use of Prohibited Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-390:Detection of Error Condition Without Action|C.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-1322:Use of Blocking Code in Single-threaded, Non-blocking Context\nC.CWE-588:Attempt to Access Child of a Non-structure Pointer\nD.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_14\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(globalFive==5)\r\n {\r\n \r\n data = &dataMBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(globalFive==5)\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_14; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-588:Attempt to Access Child of a Non-structure Pointer|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-123:Write-what-where Condition\nB.CWE-787:Out-of-bounds Write\nC.No Vulnerabilities\nD.CWE-593:Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\nE.CWE-271:Privilege Dropping / Lowering Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\nnamespace My_connect_socket_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_connect_socket_84\r\n{\r\npublic:\r\n My_connect_socket_84(mStruct dataCopy);\r\n ~My_connect_socket_84();\r\n\r\nprivate:\r\n mStruct data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_connect_socket_84G2B\r\n{\r\npublic:\r\n My_connect_socket_84G2B(mStruct dataCopy);\r\n ~My_connect_socket_84G2B();\r\n\r\nprivate:\r\n mStruct data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-123:Write-what-where Condition|B.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-459:Incomplete Cleanup\nB.CWE-341:Predictable from Observable State\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-464:Addition of Data Structure Sentinel\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <unistd.h> \r\nint eyeground_melanization = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid unmixable_unsuspectful(char *const baun_limulid);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int antiliberalness_bacterial = 0;\r\n char *creasier_surgeons = 0;\r\n char *unhairy_corvinas;;\r\n if (__sync_bool_compare_and_swap(&eyeground_melanization,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n unhairy_corvinas = getenv(\"RESPIRATORED_TRERONINAE\");\r\n if (unhairy_corvinas != 0) {;\r\n antiliberalness_bacterial = ((int )(strlen(unhairy_corvinas)));\r\n creasier_surgeons = ((char *)(malloc(antiliberalness_bacterial + 1)));\r\n if (creasier_surgeons == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(creasier_surgeons,0,antiliberalness_bacterial + 1);\r\n memcpy(creasier_surgeons,unhairy_corvinas,antiliberalness_bacterial);\r\n unmixable_unsuspectful(creasier_surgeons);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid unmixable_unsuspectful(char *const baun_limulid)\r\n{\r\n int random_data;\r\n char fill_buff[50000];\r\n char file_path[50][31];\r\n int filedes;\r\n int count = 0;\r\n int taint_num;\r\n int ss_i = 0;\r\n char *staggered_demihaque = 0;\r\n ++global_variable;;\r\n staggered_demihaque = ((char *)((char *)baun_limulid));\r\n \r\n random_data = open(\"/dev/urandom\",0);\r\n read(random_data,fill_buff,49999U);\r\n close(random_data);\r\n fill_buff[49999] = '\\0';\r\n taint_num = atoi(staggered_demihaque);\r\n if (taint_num < 0) {\r\n taint_num = 0;\r\n }\r\n \r\n for (ss_i = 0; ss_i < taint_num; ++ss_i) {\r\n ++count;\r\n strncpy(file_path[ss_i % 50],\"/tmp/data_459-XXXXXX\",31);\r\n filedes = mkstemp(file_path[ss_i % 50]);\r\n write(filedes,fill_buff,sizeof(fill_buff));\r\n close(filedes);\r\n }\r\n \r\n \r\n for (ss_i = 0; ss_i < 50; ++ss_i){\r\n \r\n if (count == ss_i) {\r\n break;\r\n }\r\n \r\n unlink(file_path[ss_i]);\r\n }\r\n \r\n \r\n \r\n;\r\n if (((char *)baun_limulid) != 0) \r\n free(((char *)((char *)baun_limulid)));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-459:Incomplete Cleanup|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "459"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-562:Return of Stack Variable Address\nC.CWE-480:Use of Incorrect Operator\nD.CWE-797:Only Filtering Special Elements at an Absolute Position\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic char* staticStringM = \"Hello\";\r\nstatic char* staticStringN = \"Hello\";\r\n\r\nstatic char * helperM()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringM;\r\n }\r\n}\r\n\r\nstatic char * helperN()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringN;\r\n }\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n if(helperM == NULL)\r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if(helperN() == NULL) \r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n if(helperN() == NULL) \r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-480:Use of Incorrect Operator|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "480"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-413:Improper Resource Locking\nB.CWE-319:Cleartext Transmission of Sensitive Information\nC.CWE-252:Unchecked Return Value\nD.No Vulnerabilities\nE.CWE-591:Sensitive Data Storage in Improperly Locked Memory\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_41Sink(char * password)\r\n{\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_char_41()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_41Sink(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nvoid My_w32_char_41G2BSink(char * password)\r\n{\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_41G2BSink(password);\r\n}\r\n\r\nvoid My_w32_char_41()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-591:Sensitive Data Storage in Improperly Locked Memory|A.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-476:NULL Pointer Dereference\nC.CWE-1253:Incorrect Selection of Fuse Values\nD.CWE-823:Use of Out-of-range Pointer Offset\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint squatinidae_tweed = 0;\r\n\r\nunion regioide_incumberment \r\n{\r\n char *maronian_algesia;\r\n double finitive_uncompassionate;\r\n char *warman_kakidrosis;\r\n char calamines_terranean;\r\n int tritanoptic_upspeak;\r\n}\r\n;\r\nint global_variable;\r\nvoid fleckiness_amalle(union regioide_incumberment *nonconstruable_ecofreak);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid corycavidine_angular(void (*paquito_holstein)(union regioide_incumberment *));\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&squatinidae_tweed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n corycavidine_angular(fleckiness_amalle);\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid fleckiness_amalle(union regioide_incumberment *nonconstruable_ecofreak)\r\n{\r\n union regioide_incumberment particularizer_alvelos;\r\n char *claibornian_sheilah;\r\n ++global_variable;;\r\n setup_printf_context();\r\n claibornian_sheilah = getenv(\"EXULTED_EXOPLASM\");\r\n if (claibornian_sheilah != 0) {;\r\n particularizer_alvelos . maronian_algesia = claibornian_sheilah;\r\n *nonconstruable_ecofreak = particularizer_alvelos;\r\n }\r\n}\r\n\r\nvoid corycavidine_angular(void (*paquito_holstein)(union regioide_incumberment *))\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *colporrhaphy_convertable = 0;\r\n union regioide_incumberment monaca_preacheress = {0};\r\n long intervener_tufts[10];\r\n union regioide_incumberment pterichthys_polygenes[10] = {0};\r\n ++global_variable;\r\n union regioide_incumberment mesena_hoodwinking = {0};\r\n paquito_holstein(&mesena_hoodwinking);\r\n if (mesena_hoodwinking . maronian_algesia != 0) {;\r\n pterichthys_polygenes[5] = mesena_hoodwinking;\r\n intervener_tufts[1] = 5;\r\n monaca_preacheress = *(pterichthys_polygenes + intervener_tufts[1]);\r\n colporrhaphy_convertable = ((char *)monaca_preacheress . maronian_algesia);\r\n \r\n buffer_value = atoi(colporrhaphy_convertable);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-476:NULL Pointer Dereference|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-413:Improper Resource Locking\nB.CWE-234:Failure to Handle Missing Parameter\nC.No Vulnerabilities\nD.CWE-1041:Use of Redundant Code\nE.CWE-591:Sensitive Data Storage in Improperly Locked Memory\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\nnamespace My_w32_wchar_t_82\r\n{\r\n\r\nclass My_w32_wchar_t_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * password) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_wchar_t_82 : public My_w32_wchar_t_82_base\r\n{\r\npublic:\r\n void action(wchar_t * password);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_wchar_t_82G2B : public My_w32_wchar_t_82_base\r\n{\r\npublic:\r\n void action(wchar_t * password);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-591:Sensitive Data Storage in Improperly Locked Memory|A.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.No Vulnerabilities\nC.CWE-436:Interpretation Conflict\nD.CWE-1260:Improper Handling of Overlap Between Protected Memory Ranges\nE.CWE-415:Double Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_char_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new char[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new char[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new char[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new char[100];\r\n \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new char[100];\r\n \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_char_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-415:Double Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\nC.CWE-667:Improper Locking\nD.CWE-662:Improper Synchronization\nE.CWE-109:Struts: Validator Turned Off\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-667:Improper Locking|D.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-622:Improper Validation of Function Hook Arguments\nC.CWE-9:J2EE Misconfiguration: Weak Access Permissions for EJB Methods\nD.CWE-789:Memory Allocation with Excessive Size Value\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_listen_socket_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = 20;\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_listen_socket_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-789:Memory Allocation with Excessive Size Value|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-568:finalize() Method Without super.finalize()\nD.CWE-252:Unchecked Return Value\nE.CWE-583:finalize() Method Declared Public\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define SRC L\"sscanf\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_sscanf_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n swscanf(SRC, L\"%99s\\0\", data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_wchar_t_sscanf_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_sscanf_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_sscanf_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-252:Unchecked Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-1233:Security-Sensitive Hardware Controls with Missing Lock Bit Protection\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_fread_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\r\n {\r\n printLine(\"fread failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\r\n {\r\n printLine(\"fread failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_fread_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_fread_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_fread_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-252:Unchecked Return Value|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.No Vulnerabilities\nC.CWE-1318:Missing Support for Security Features in On-chip Fabrics or Buses\nD.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\nE.CWE-197:Numeric Truncation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_large_to_char_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int data;\r\n int &dataRef = data;\r\n \r\n data = -1;\r\n \r\n data = SHRT_MAX + 5;\r\n {\r\n int data = dataRef;\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n int &dataRef = data;\r\n \r\n data = -1;\r\n \r\n data = CHAR_MAX-5;\r\n {\r\n int data = dataRef;\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_large_to_char_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-197:Numeric Truncation Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-238:Improper Handling of Incomplete Structural Elements\nC.CWE-588:Attempt to Access Child of a Non-structure Pointer\nD.CWE-704:Incorrect Type Conversion or Cast\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_64\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(void * dataVoidPtr);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n nG2BSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_64; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-588:Attempt to Access Child of a Non-structure Pointer|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-511:Logic/Time Bomb\nB.CWE-1320:Improper Protection for Outbound Error Messages and Alert Signals\nC.CWE-506:Embedded Malicious Code\nD.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <time.h>\r\n\r\n#define TIME_CHECK ((time_t)1199163600) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_time_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_time_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_time_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_time_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-511:Logic/Time Bomb|C.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-253:Incorrect Check of Function Return Value\nD.No Vulnerabilities\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_scanf_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (scanf(\"%99s\\0\", data) == 0)\r\n {\r\n printLine(\"scanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (scanf(\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"scanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (scanf(\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"scanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_scanf_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_scanf_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_scanf_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-253:Incorrect Check of Function Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-686:Function Call With Incorrect Argument Type\nB.CWE-15:External Control of System or Configuration Setting\nC.CWE-642:External Control of Critical State Data\nD.No Vulnerabilities\nE.CWE-644:Improper Neutralization of HTTP Headers for Scripting Syntax\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_02()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_02()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-15:External Control of System or Configuration Setting|C.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-261:Weak Encoding for Password\nB.CWE-124:Buffer Underwrite ('Buffer Underflow')\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-1192:System-on-Chip (SoC) Using Components without Unique, Immutable Identifiers\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE839_listen_socket_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-124:Buffer Underwrite ('Buffer Underflow')|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-601:URL Redirection to Untrusted Site ('Open Redirect')\nB.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nC.No Vulnerabilities\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_unsigned_int_rand_predec_54bSink(unsigned int data);\r\n\r\nvoid My_unsigned_int_rand_predec_54()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n \r\n data = (unsigned int)RAND32();\r\n My_unsigned_int_rand_predec_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_unsigned_int_rand_predec_54bG2BSink(unsigned int data);\r\n\r\nstatic void nG2B()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n \r\n data = -2;\r\n My_unsigned_int_rand_predec_54bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_unsigned_int_rand_predec_54bB2GSink(unsigned int data);\r\n\r\nstatic void nB2G()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n \r\n data = (unsigned int)RAND32();\r\n My_unsigned_int_rand_predec_54bB2GSink(data);\r\n}\r\n\r\nvoid My_unsigned_int_rand_predec_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unsigned_int_rand_predec_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unsigned_int_rand_predec_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|E.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-824:Access of Uninitialized Pointer\nB.CWE-344:Use of Invariant Value in Dynamically Changing Context\nC.CWE-587:Assignment of a Fixed Address to a Pointer\nD.CWE-624:Executable Regular Expression Error\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n \r\n char *charPointer = (char*)0x400000;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-587:Assignment of a Fixed Address to a Pointer|B.CWE-344:Use of Invariant Value in Dynamically Changing Context", "cwe": "587"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-648:Incorrect Use of Privileged APIs\nB.CWE-141:Improper Neutralization of Parameter/Argument Delimiters\nC.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nD.CWE-188:Reliance on Data/Memory Layout\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_union_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n union\r\n {\r\n struct\r\n {\r\n char charFirst, charSecond, charThird, charFourth;\r\n } structChars;\r\n long longNumber;\r\n } unionStructLong;\r\n unionStructLong.longNumber = 0x10203040;\r\n \r\n unionStructLong.structChars.charFourth |= 0x80; \r\n printIntLine(unionStructLong.longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_union_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_union_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_union_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-188:Reliance on Data/Memory Layout|C.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-912:Hidden Functionality\nC.CWE-506:Embedded Malicious Code\nD.CWE-1269:Product Released in Non-Release Configuration\nE.CWE-366:Race Condition within a Thread\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_aes_encrypted_payload_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n BYTE payload[20] = {0xfb, 0x50, 0xe5, 0x8d, 0xc5, 0x4b, 0xdd, 0xe0, 0x26, 0x2b, 0x98, 0x49, 0x73, 0xfb, 0x4c, 0xf6};\r\n DWORD payloadLen = strlen((char *)payload);\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)payload, &payloadLen))\r\n {\r\n break;\r\n }\r\n \r\n payload[payloadLen] = '\\0';\r\n if(system((char*)payload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char * payload = \"calc.exe\";\r\n if(system(payload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n char * payload = \"calc.exe\";\r\n if(system(payload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_aes_encrypted_payload_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_aes_encrypted_payload_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_aes_encrypted_payload_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-506:Embedded Malicious Code|B.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nD.CWE-352:Cross-Site Request Forgery (CSRF)\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int data)\r\n{\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_rand_memcpy_44()\r\n{\r\n int data;\r\n \r\n void (*funcPtr) (int) = mSink;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(int data)\r\n{\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = nG2BSink;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_rand_memcpy_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_memcpy_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_memcpy_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-760:Use of a One-Way Hash with a Predictable Salt\nB.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\nC.No Vulnerabilities\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.CWE-36:Absolute Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_environment_ifstream_61\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nchar * mSource(char * data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n data = mSource(data);\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nchar * nG2BSource(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_ifstream_61; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-36:Absolute Path Traversal|D.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-468:Incorrect Pointer Scaling\nD.CWE-694:Use of Multiple Resources with Duplicate Identifier\nE.CWE-1321:Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ptr_to_int_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+2));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ptr_to_int_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ptr_to_int_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ptr_to_int_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-468:Incorrect Pointer Scaling|B.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1299:Missing Protection Mechanism for Alternate Hardware Interface\nB.CWE-222:Truncation of Security-relevant Information\nC.CWE-221:Information Loss or Omission\nD.No Vulnerabilities\nE.CWE-917:Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SIZE 15\r\n#define TRUNCATED_USERNAME_SIZE 4 \r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n char truncatedUsername[TRUNCATED_USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n memcpy(truncatedUsername, username, sizeof(truncatedUsername));\r\n truncatedUsername[TRUNCATED_USERNAME_SIZE] = '\\0';\r\n \r\n if (LogonUserA(\r\n truncatedUsername,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-222:Truncation of Security-relevant Information|C.CWE-221:Information Loss or Omission", "cwe": "222"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-188:Reliance on Data/Memory Layout\nC.CWE-565:Reliance on Cookies without Validation and Integrity Checking\nD.CWE-910:Use of Expired File Descriptor\nE.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_modify_local_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n char *charPtr;\r\n structCharInt.charFirst = 1;\r\n charPtr = &structCharInt.charFirst;\r\n \r\n *(int*)(charPtr + sizeof(int)) = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\nvoid My_modify_local_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_modify_local_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_modify_local_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-188:Reliance on Data/Memory Layout|E.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-704:Incorrect Type Conversion or Cast\nC.CWE-309:Use of Password System for Primary Authentication\nD.No Vulnerabilities\nE.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <float.h>\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2float_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printFloatLine((float)doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > FLT_MAX || doubleNumber < FLT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as a float\");\r\n }\r\n else\r\n {\r\n printFloatLine((float)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > FLT_MAX || doubleNumber < FLT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as a float\");\r\n }\r\n else\r\n {\r\n printFloatLine((float)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double2float_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2float_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2float_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-681:Incorrect Conversion between Numeric Types|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-280:Improper Handling of Insufficient Permissions or Privileges \nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-195:Signed to Unsigned Conversion Error\nD.CWE-656:Reliance on Security Through Obscurity\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_fscanf_memcpy_22Global = 0;\r\n\r\nint My_fscanf_memcpy_22Source(int data);\r\n\r\nvoid My_fscanf_memcpy_22()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n My_fscanf_memcpy_22Global = 1; \r\n data = My_fscanf_memcpy_22Source(data);\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_fscanf_memcpy_22G2B1Global = 0;\r\nint My_fscanf_memcpy_22G2B2Global = 0;\r\n\r\n\r\nint My_fscanf_memcpy_22G2B1Source(int data);\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n My_fscanf_memcpy_22G2B1Global = 0; \r\n data = My_fscanf_memcpy_22G2B1Source(data);\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nint My_fscanf_memcpy_22G2B2Source(int data);\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n My_fscanf_memcpy_22G2B2Global = 1; \r\n data = My_fscanf_memcpy_22G2B2Source(data);\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_fscanf_memcpy_22()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_memcpy_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_memcpy_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-124:Buffer Underwrite ('Buffer Underflow')\nB.CWE-1083:Data Access from Outside Expected Data Manager Component\nC.No Vulnerabilities\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-589:Call to Non-ubiquitous API\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcpy(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_alloca_cpy_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcpy(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_alloca_cpy_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_alloca_cpy_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_alloca_cpy_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-124:Buffer Underwrite ('Buffer Underflow')|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.CWE-585:Empty Synchronized Block\nC.CWE-595:Comparison of Object References Instead of Object Contents\nD.No Vulnerabilities\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_class_declare_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * *dataPtr1 = &data;\r\n TwoIntsClass * *dataPtr2 = &data;\r\n data = NULL; \r\n {\r\n TwoIntsClass * data = *dataPtr1;\r\n {\r\n \r\n TwoIntsClass dataBuffer;\r\n dataBuffer.intOne = 1;\r\n dataBuffer.intTwo = 1;\r\n data = &dataBuffer;\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n TwoIntsClass * data = *dataPtr2;\r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * *dataPtr1 = &data;\r\n TwoIntsClass * *dataPtr2 = &data;\r\n data = NULL; \r\n {\r\n TwoIntsClass * data = *dataPtr1;\r\n {\r\n \r\n TwoIntsClass * dataBuffer = new TwoIntsClass;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n TwoIntsClass * data = *dataPtr2;\r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_class_declare_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-590:Free of Memory not on the Heap|E.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-124:Buffer Underwrite ('Buffer Underflow')\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-1074:Class with Excessively Deep Inheritance\nE.CWE-419:Unprotected Primary Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_loop_13\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n {\r\n size_t i;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n data[i] = source[i];\r\n }\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n size_t i;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n data[i] = source[i];\r\n }\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n size_t i;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n data[i] = source[i];\r\n }\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_loop_13; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-124:Buffer Underwrite ('Buffer Underflow')|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-771:Missing Reference to Active Allocated Resource\nB.No Vulnerabilities\nC.CWE-487:Reliance on Package-level Scope\nD.CWE-311:Missing Encryption of Sensitive Data\nE.CWE-319:Cleartext Transmission of Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_w32_char_connect_socket_22Global = 0;\r\n\r\nvoid My_w32_char_connect_socket_22Sink(char * password);\r\n\r\nvoid My_w32_char_connect_socket_22()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n closesocket(connectSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_char_connect_socket_22Global = 1; \r\n My_w32_char_connect_socket_22Sink(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_w32_char_connect_socket_22B2G1Global = 0;\r\nint My_w32_char_connect_socket_22B2G2Global = 0;\r\nint My_w32_char_connect_socket_22G2BGlobal = 0;\r\n\r\n\r\nvoid My_w32_char_connect_socket_22B2G1Sink(char * password);\r\n\r\nstatic void nB2G1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n closesocket(connectSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_char_connect_socket_22B2G1Global = 0; \r\n My_w32_char_connect_socket_22B2G1Sink(password);\r\n}\r\n\r\n\r\nvoid My_w32_char_connect_socket_22B2G2Sink(char * password);\r\n\r\nstatic void nB2G2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n closesocket(connectSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_char_connect_socket_22B2G2Global = 1; \r\n My_w32_char_connect_socket_22B2G2Sink(password);\r\n}\r\n\r\n\r\nvoid My_w32_char_connect_socket_22G2BSink(char * password);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_connect_socket_22G2BGlobal = 1; \r\n My_w32_char_connect_socket_22G2BSink(password);\r\n}\r\n\r\nvoid My_w32_char_connect_socket_22()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_connect_socket_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_connect_socket_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-319:Cleartext Transmission of Sensitive Information|D.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-200:Exposure of Sensitive Information to an Unauthorized Actor\nB.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.CWE-546:Suspicious Comment\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_BUG_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_BUG_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_BUG_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_BUG_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-546:Suspicious Comment|C.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-272:Least Privilege Violation\nB.CWE-113:Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\nC.No Vulnerabilities\nD.CWE-791:Incomplete Filtering of Special Elements\nE.CWE-271:Privilege Dropping / Lowering Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateProcess_01()\r\n{\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n \r\n if( !CreateProcessW(NULL,\r\n L\"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n 0,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcess failed\");\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcess successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n \r\n if( !CreateProcessW(NULL,\r\n L\"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n 0,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printf( \"CreateProcess failed (%d).\\n\", GetLastError() );\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcess successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateProcess_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateProcess_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateProcess_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-272:Least Privilege Violation|E.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.CWE-363:Race Condition Enabling Link Following\nC.CWE-114:Process Control\nD.No Vulnerabilities\nE.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_console_53bSink(wchar_t * data);\r\n\r\nvoid My_w32_wchar_t_console_53()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n My_w32_wchar_t_console_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_console_53bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n My_w32_wchar_t_console_53bG2BSink(data);\r\n}\r\n\r\nvoid My_w32_wchar_t_console_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_console_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_console_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|A.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-190:Integer Overflow or Wraparound\nB.CWE-680:Integer Overflow to Buffer Overflow\nC.No Vulnerabilities\nD.CWE-203:Observable Discrepancy\nE.CWE-474:Use of Function with Inconsistent Implementations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nnamespace My_malloc_fgets_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(int &data)\r\n{\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(int &data)\r\n{\r\n \r\n data = 20;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_fgets_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-680:Integer Overflow to Buffer Overflow|A.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-121:Stack-based Buffer Overflow\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-684:Incorrect Provision of Specified Functionality\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_dest_wchar_t_alloca_cpy_01()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n \r\n data = dataMBuffer;\r\n data[0] = L'\\0'; \r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscpy(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n \r\n data = dataNBuffer;\r\n data[0] = L'\\0'; \r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscpy(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_dest_wchar_t_alloca_cpy_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_dest_wchar_t_alloca_cpy_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_dest_wchar_t_alloca_cpy_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-121:Stack-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-652:Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-340:Generation of Predictable Numbers or Identifiers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_w32_char_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_char_84\r\n{\r\npublic:\r\n My_w32_char_84(char * cryptoKeyCopy);\r\n ~My_w32_char_84();\r\n\r\nprivate:\r\n char * cryptoKey;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_char_84G2B\r\n{\r\npublic:\r\n My_w32_char_84G2B(char * cryptoKeyCopy);\r\n ~My_w32_char_84G2B();\r\n\r\nprivate:\r\n char * cryptoKey;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|D.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-512:Spyware\nB.CWE-606:Unchecked Input for Loop Condition\nC.CWE-273:Improper Check for Dropped Privileges\nD.No Vulnerabilities\nE.CWE-1284:Improper Validation of Specified Quantity in Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_connect_socket_07()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"15\");\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n \r\n wcscpy(data, L\"15\");\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_07()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-606:Unchecked Input for Loop Condition|E.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1339:Insufficient Precision or Accuracy of a Real Number\nB.CWE-403:Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')\nC.CWE-511:Logic/Time Bomb\nD.No Vulnerabilities\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <time.h>\r\n\r\n#define TIME_CHECK ((time_t)1199163600) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_time_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_time_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_time_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_time_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|E.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-269:Improper Privilege Management\nC.CWE-1077:Floating Point Comparison with Incorrect Operator\nD.CWE-787:Out-of-bounds Write\nE.CWE-123:Write-what-where Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_connect_socket_02()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(1)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_02()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.No Vulnerabilities\nC.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int64_t_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_int64_t_64()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n My_int64_t_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int64_t_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n {\r\n int64_t tmpData = 5LL;\r\n data = &tmpData;\r\n }\r\n My_int64_t_64bG2BSink(&data);\r\n}\r\n\r\n\r\nvoid My_int64_t_64bB2GSink(void * dataVoidPtr);\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n My_int64_t_64bB2GSink(&data);\r\n}\r\n\r\nvoid My_int64_t_64()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-476:NULL Pointer Dereference|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.No Vulnerabilities\nC.CWE-675:Multiple Operations on Resource in Single-Operation Context\nD.CWE-75:Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)\nE.CWE-129:Improper Validation of Array Index\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fopen_82\r\n{\r\n\r\nclass My_fopen_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(FILE * data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fopen_82 : public My_fopen_82_base\r\n{\r\npublic:\r\n void action(FILE * data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fopen_82G2B : public My_fopen_82_base\r\n{\r\npublic:\r\n void action(FILE * data);\r\n};\r\n\r\nclass My_fopen_82B2G : public My_fopen_82_base\r\n{\r\npublic:\r\n void action(FILE * data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-675:Multiple Operations on Resource in Single-Operation Context|A.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1025:Comparison Using Wrong Factors\nC.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nD.CWE-27:Path Traversal: 'dir/../../filename'\nE.CWE-188:Reliance on Data/Memory Layout\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_modify_local_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n char *charPtr;\r\n structCharInt.charFirst = 1;\r\n charPtr = &structCharInt.charFirst;\r\n \r\n *(int*)(charPtr + sizeof(int)) = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\nvoid My_modify_local_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_modify_local_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_modify_local_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-188:Reliance on Data/Memory Layout|C.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-307:Improper Restriction of Excessive Authentication Attempts\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nD.CWE-511:Logic/Time Bomb\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_file_53bSink(char * data);\r\n\r\nvoid My_w32_char_file_53()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (256-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n My_w32_char_file_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_file_53bG2BSink(char * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n My_w32_char_file_53bG2BSink(data);\r\n}\r\n\r\nvoid My_w32_char_file_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_file_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_file_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-421:Race Condition During Access to Alternate Channel\nC.CWE-588:Attempt to Access Child of a Non-structure Pointer\nD.CWE-162:Improper Neutralization of Trailing Special Elements\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_class_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(staticFive==5)\r\n {\r\n \r\n data = &dataMBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(staticFive==5)\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-588:Attempt to Access Child of a Non-structure Pointer|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-293:Using Referer Field for Authentication\nB.CWE-1302:Missing Security Identifier\nC.CWE-23:Relative Path Traversal\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FOPEN fopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\nchar * My_char_file_fopen_68Data;\r\nchar * My_char_file_fopen_68G2BData;\r\n\r\nnamespace My_char_file_fopen_68\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink();\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n My_char_file_fopen_68Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n \r\n strcat(data, \"file.txt\");\r\n My_char_file_fopen_68G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_fopen_68; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-23:Relative Path Traversal|D.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-328:Use of Weak Hash\nC.No Vulnerabilities\nD.CWE-589:Call to Non-ubiquitous API\nE.CWE-617:Reachable Assertion\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nnamespace My_fgets_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int data;\r\n int &dataRef = data;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n {\r\n int data = dataRef;\r\n \r\n assert(data > ASSERT_VALUE);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n int &dataRef = data;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n {\r\n int data = dataRef;\r\n \r\n assert(data > ASSERT_VALUE);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fgets_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-617:Reachable Assertion|A.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-510:Trapdoor\nC.CWE-330:Use of Insufficiently Random Values\nD.CWE-506:Embedded Malicious Code\nE.CWE-43:Path Equivalence: 'filename....' (Multiple Trailing Dot)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_listen_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(30000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_listen_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|D.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-600:Uncaught Exception in Servlet \nC.No Vulnerabilities\nD.CWE-1319:Improper Protection against Electromagnetic Fault Injection (EM-FI)\nE.CWE-122:Heap-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING L\"AAAAAAAAAA\"\r\n\r\nnamespace My_cpp_My_cpp_CWE193_wchar_t_ncpy_52; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-122:Heap-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-469:Use of Pointer Subtraction to Determine Size\nC.CWE-497:Exposure of Sensitive System Information to an Unauthorized Control Sphere\nD.CWE-56:Path Equivalence: 'filedir*' (Wildcard)\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SOURCE_STRING \"abc/opqrstu\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char string2[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string2);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-469:Use of Pointer Subtraction to Determine Size|E.CWE-682:Incorrect Calculation", "cwe": "469"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-834:Excessive Iteration\nC.CWE-416:Use After Free\nD.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_new_delete_char_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printHexCharLine(*data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printHexCharLine(*data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printHexCharLine(*data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_char_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-416:Use After Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.No Vulnerabilities\nC.CWE-126:Buffer Over-read\nD.CWE-1391:Use of Weak Credentials\nE.CWE-707:Improper Neutralization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} My_wchar_t_declare_memmove_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_declare_memmove_34()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_declare_memmove_34_unionType myUnion;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataMBuffer;\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_declare_memmove_34_unionType myUnion;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataNBuffer;\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_declare_memmove_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_declare_memmove_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_declare_memmove_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-79:Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nC.CWE-1322:Use of Blocking Code in Single-threaded, Non-blocking Context\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_w32CloseHandle_02()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(1)\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(1)\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_w32CloseHandle_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_w32CloseHandle_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_w32CloseHandle_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nC.No Vulnerabilities\nD.CWE-1082:Class Instance Self Destruction Control Element\nE.CWE-104:Struts: Form Bean Does Not Extend Validation Class\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n goto source;\r\nsource:\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n goto sink;\r\nsink:\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n goto source;\r\nsource:\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n goto sink;\r\nsink:\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n goto source;\r\nsource:\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n goto sink;\r\nsink:\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-672:Operation on a Resource after Expiration or Release|B.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1122:Excessive Halstead Complexity\nC.CWE-123:Write-what-where Condition\nD.CWE-757:Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\nmStruct My_fgets_68Data;\r\nmStruct My_fgets_68G2BData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fgets_68bSink();\r\n\r\nvoid My_fgets_68()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n My_fgets_68Data = data;\r\n My_fgets_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fgets_68bG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n My_fgets_68G2BData = data;\r\n My_fgets_68bG2BSink();\r\n}\r\n\r\nvoid My_fgets_68()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-123:Write-what-where Condition|E.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-787:Out-of-bounds Write\nC.CWE-437:Incomplete Model of Endpoint Features\nD.CWE-698:Execution After Redirect (EAR)\nE.CWE-121:Stack-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define SNPRINTF _snprintf\r\n#else\r\n#define SNPRINTF snprintf\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE805_char_declare_snprintf_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-121:Stack-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-599:Missing Validation of OpenSSL Certificate\nD.CWE-1164:Irrelevant Code\nE.CWE-400:Uncontrolled Resource Consumption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_sleep_18()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n goto source;\r\nsource:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n goto source;\r\nsource:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n goto source;\r\nsource:\r\n \r\n count = 20;\r\n goto sink;\r\nsink:\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n}\r\n\r\nvoid My_fgets_sleep_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_sleep_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_sleep_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-400:Uncontrolled Resource Consumption|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nC.No Vulnerabilities\nD.CWE-475:Undefined Behavior for Input to API\nE.CWE-484:Omitted Break Statement in Switch\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-475:Undefined Behavior for Input to API|A.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-304:Missing Critical Step in Authentication\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-1269:Product Released in Non-Release Configuration\nD.No Vulnerabilities\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_int64_t_18()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n goto source;\r\nsource:\r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n free(data);\r\n goto sink;\r\nsink:\r\n \r\n printLongLongLine(data[0]);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n goto source;\r\nsource:\r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n free(data);\r\n goto sink;\r\nsink:\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n goto source;\r\nsource:\r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n goto sink;\r\nsink:\r\n \r\n printLongLongLine(data[0]);\r\n \r\n}\r\n\r\nvoid My_malloc_free_int64_t_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_int64_t_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_int64_t_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-425:Direct Request ('Forced Browsing')\nB.CWE-413:Improper Resource Locking\nC.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nD.CWE-77:Improper Neutralization of Special Elements used in a Command ('Command Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_01()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-591:Sensitive Data Storage in Improperly Locked Memory|B.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-208:Observable Timing Discrepancy\nB.CWE-682:Incorrect Calculation\nC.CWE-1253:Incorrect Selection of Fuse Values\nD.CWE-369:Divide By Zero\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_fgets_modulo_81\r\n{\r\n\r\nclass My_int_fgets_modulo_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(int data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_int_fgets_modulo_81 : public My_int_fgets_modulo_81_base\r\n{\r\npublic:\r\n void action(int data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_int_fgets_modulo_81G2B : public My_int_fgets_modulo_81_base\r\n{\r\npublic:\r\n void action(int data) const;\r\n};\r\n\r\nclass My_int_fgets_modulo_81B2G : public My_int_fgets_modulo_81_base\r\n{\r\npublic:\r\n void action(int data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-369:Divide By Zero|B.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-401:Missing Release of Memory after Effective Lifetime\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-1024:Comparison of Incompatible Types\nE.CWE-710:Improper Adherence to Coding Standards\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_twoIntsStruct_malloc_17()\r\n{\r\n int i,j;\r\n twoIntsStruct * data;\r\n data = NULL;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine(&data[0]);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int i,k;\r\n twoIntsStruct * data;\r\n data = NULL;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine(&data[0]);\r\n }\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h,j;\r\n twoIntsStruct * data;\r\n data = NULL;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine(&data[0]);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid My_twoIntsStruct_malloc_17()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_twoIntsStruct_malloc_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_twoIntsStruct_malloc_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-401:Missing Release of Memory after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-913:Improper Control of Dynamically-Managed Code Resources\nC.CWE-912:Hidden Functionality\nD.No Vulnerabilities\nE.CWE-36:Absolute Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_aes_encrypted_payload_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n BYTE payload[20] = {0xfb, 0x50, 0xe5, 0x8d, 0xc5, 0x4b, 0xdd, 0xe0, 0x26, 0x2b, 0x98, 0x49, 0x73, 0xfb, 0x4c, 0xf6};\r\n DWORD payloadLen = strlen((char *)payload);\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)payload, &payloadLen))\r\n {\r\n break;\r\n }\r\n \r\n payload[payloadLen] = '\\0';\r\n if(system((char*)payload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char * payload = \"calc.exe\";\r\n if(system(payload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n char * payload = \"calc.exe\";\r\n if(system(payload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_aes_encrypted_payload_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_aes_encrypted_payload_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_aes_encrypted_payload_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-506:Embedded Malicious Code|C.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-564:SQL Injection: Hibernate\nB.CWE-163:Improper Neutralization of Multiple Trailing Special Elements\nC.No Vulnerabilities\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<list<int> > dataVector);\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n vector<list<int> > dataVector;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<list<int> > dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n vector<list<int> > dataVector;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<list<int> > dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n vector<list<int> > dataVector;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-672:Operation on a Resource after Expiration or Release|E.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-427:Uncontrolled Search Path Element\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-109:Struts: Validator Turned Off\nD.CWE-198:Use of Incorrect Byte Ordering\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_environment_08()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 250-dataLen-1);\r\n }\r\n }\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n strcat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_char_environment_08()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-77:Improper Neutralization of Special Elements used in a Command ('Command Injection')\nB.No Vulnerabilities\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-36:Absolute Path Traversal\nE.CWE-1116:Inaccurate Comments\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FOPEN fopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\nnamespace My_char_file_fopen_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_fopen_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-36:Absolute Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nB.CWE-145:Improper Neutralization of Section Delimiters\nC.CWE-1191:On-Chip Debug and Test Interface With Improper Access Control\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_stat_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n struct STAT statBuffer;\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (STAT(filename, &statBuffer) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_stat_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_stat_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_stat_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|D.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-221:Information Loss or Omission\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-222:Truncation of Security-relevant Information\nE.CWE-597:Use of Wrong Operator in String Comparison\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SIZE 15\r\n#define TRUNCATED_USERNAME_SIZE 4 \r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_01()\r\n{\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n char truncatedUsername[TRUNCATED_USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n memcpy(truncatedUsername, username, sizeof(truncatedUsername));\r\n truncatedUsername[TRUNCATED_USERNAME_SIZE] = '\\0';\r\n \r\n if (LogonUserA(\r\n truncatedUsername,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-222:Truncation of Security-relevant Information|B.CWE-221:Information Loss or Omission", "cwe": "222"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-680:Integer Overflow to Buffer Overflow\nB.CWE-306:Missing Authentication for Critical Function\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-1293:Missing Source Correlation of Multiple Independent Data\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_fixed_17()\r\n{\r\n int i;\r\n int data;\r\n \r\n data = -1;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = INT_MAX / 2 + 2; \r\n \r\n }\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n int data;\r\n \r\n data = -1;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\nvoid My_malloc_fixed_17()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_fixed_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_fixed_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-680:Integer Overflow to Buffer Overflow|C.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nB.CWE-1230:Exposure of Sensitive Information Through Metadata\nC.No Vulnerabilities\nD.CWE-222:Truncation of Security-relevant Information\nE.CWE-221:Information Loss or Omission\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SIZE 15\r\n#define TRUNCATED_USERNAME_SIZE 4 \r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n char truncatedUsername[TRUNCATED_USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n memcpy(truncatedUsername, username, sizeof(truncatedUsername));\r\n truncatedUsername[TRUNCATED_USERNAME_SIZE] = '\\0';\r\n \r\n if (LogonUserA(\r\n truncatedUsername,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-222:Truncation of Security-relevant Information|E.CWE-221:Information Loss or Omission", "cwe": "222"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-372:Incomplete Internal State Distinction\nE.CWE-224:Obscured Security-relevant Information by Alternate Name\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_wchar_t_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<wchar_t *> dataVector);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n vector<wchar_t *> dataVector;\r\n \r\n data = NULL;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<wchar_t *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n vector<wchar_t *> dataVector;\r\n \r\n data = L\"N\";\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<wchar_t *> dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n vector<wchar_t *> dataVector;\r\n \r\n data = NULL;\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-756:Missing Custom Error Page\nC.No Vulnerabilities\nD.CWE-665:Improper Initialization\nE.CWE-468:Incorrect Pointer Scaling\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_cat_31()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n {\r\n char * dataCopy = data;\r\n char * data = dataCopy;\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = '\\0'; \r\n {\r\n char * dataCopy = data;\r\n char * data = dataCopy;\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_cat_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_cat_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_cat_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-665:Improper Initialization|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-692:Incomplete Denylist to Cross-Site Scripting\nB.No Vulnerabilities\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-124:Buffer Underwrite ('Buffer Underflow')\nE.CWE-285:Improper Authorization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_wchar_t_loop_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<wchar_t *> dataList);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<wchar_t *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_loop_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-124:Buffer Underwrite ('Buffer Underflow')|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-426:Untrusted Search Path\nC.CWE-50:Path Equivalence: '//multiple/leading/slash'\nD.CWE-282:Improper Ownership Management\nE.CWE-673:External Influence of Sphere Definition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM system\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_char_system_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_system_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_system_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_system_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-426:Untrusted Search Path|E.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1024:Comparison of Incompatible Types\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.No Vulnerabilities\nD.CWE-520:.NET Misconfiguration: Use of Impersonation\nE.CWE-427:Uncontrolled Search Path Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH L\"%SystemRoot%\\\\system32\"\r\n#define PUTENV _wputenv\r\n#else\r\n#define NEW_PATH L\"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_connect_socket_66bSink(wchar_t * dataArray[]);\r\n\r\nvoid My_wchar_t_connect_socket_66()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataArray[2] = data;\r\n My_wchar_t_connect_socket_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_connect_socket_66bG2BSink(wchar_t * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, NEW_PATH);\r\n dataArray[2] = data;\r\n My_wchar_t_connect_socket_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-804:Guessable CAPTCHA\nB.CWE-787:Out-of-bounds Write\nC.CWE-650:Trusting HTTP Permission Methods on the Server Side\nD.No Vulnerabilities\nE.CWE-121:Stack-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING \"AAAAAAAAAA\"\r\n\r\ntypedef struct _My_My_My_My_My_My_My_My_My_My_My_My_My_My_CWE193_char_declare_memmove_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-121:Stack-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-190:Integer Overflow or Wraparound\nC.CWE-682:Incorrect Calculation\nD.CWE-565:Reliance on Cookies without Validation and Integrity Checking\nE.CWE-1066:Missing Serialization Control Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_rand_add_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(int &data);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n mSource(data);\r\n {\r\n \r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(int &data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n nG2BSource(data);\r\n {\r\n \r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n\r\nvoid nB2GSource(int &data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n nB2GSource(data);\r\n \r\n if (data < INT_MAX)\r\n {\r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_rand_add_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-190:Integer Overflow or Wraparound|C.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-51:Path Equivalence: '/multiple//internal/slash'\nD.CWE-430:Deployment of Wrong Handler\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <process.h>\r\n#define EXECLP _execlp\r\n#else \r\n#define EXECLP execlp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_environment_execlp_16()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n break;\r\n }\r\n \r\n \r\n EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n break;\r\n }\r\n \r\n \r\n EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid My_char_environment_execlp_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_execlp_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_execlp_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-606:Unchecked Input for Loop Condition\nB.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nC.CWE-1102:Reliance on Machine-Dependent Data Representation\nD.No Vulnerabilities\nE.CWE-413:Improper Resource Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_18()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n goto source;\r\nsource:\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n goto source;\r\nsource:\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_char_18()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-591:Sensitive Data Storage in Improperly Locked Memory|E.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-1056:Invokable Control Element with Variadic Parameters\nC.CWE-23:Relative Path Traversal\nD.CWE-1242:Inclusion of Undocumented Features or Chicken Bits\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH L\"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH L\"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifdef _WIN32\r\n#define FOPEN _wfopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\nnamespace My_wchar_t_listen_socket_fopen_67\r\n{\r\n\r\ntypedef struct _structType\r\n{\r\n wchar_t * structFirst;\r\n} structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(structType myStruct);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n structType myStruct;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n mSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n structType myStruct;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"file.txt\");\r\n myStruct.structFirst = data;\r\n nG2BSink(myStruct);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_listen_socket_fopen_67; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-23:Relative Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-179:Incorrect Behavior Order: Early Validation\nD.CWE-563:Assignment to Variable without Use\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_bind_accept_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_bind_accept_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_bind_accept_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_bind_accept_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-187:Partial String Comparison\nB.No Vulnerabilities\nC.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nD.CWE-130:Improper Handling of Length Parameter Inconsistency\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CreateFile_no_close_04()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_no_close_04()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_no_close_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_no_close_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-617:Reachable Assertion\nC.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nD.CWE-671:Lack of Administrator Control over Security\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\nnamespace My_rand_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(int &data)\r\n{\r\n \r\n data = RAND32();\r\n}\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(int &data)\r\n{\r\n \r\n data = ASSERT_VALUE+1;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_rand_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-617:Reachable Assertion|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-272:Least Privilege Violation\nB.CWE-606:Unchecked Input for Loop Condition\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.No Vulnerabilities\nE.CWE-129:Improper Validation of Array Index\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateProcess_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n \r\n if( !CreateProcessW(NULL,\r\n L\"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n 0,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcess failed\");\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcess successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n \r\n if( !CreateProcessW(NULL,\r\n L\"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n 0,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printf( \"CreateProcess failed (%d).\\n\", GetLastError() );\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcess successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n \r\n if( !CreateProcessW(NULL,\r\n L\"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n 0,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printf( \"CreateProcess failed (%d).\\n\", GetLastError() );\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcess successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateProcess_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateProcess_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateProcess_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-272:Least Privilege Violation|C.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-187:Partial String Comparison\nB.CWE-763:Release of Invalid Pointer or Reference\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.No Vulnerabilities\nE.CWE-628:Function Call with Incorrectly Specified Arguments\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_listen_socket_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(map<int, char *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-656:Reliance on Security Through Obscurity\nC.CWE-123:Write-what-where Condition\nD.CWE-787:Out-of-bounds Write\nE.CWE-480:Use of Incorrect Operator\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_13()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_listen_socket_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-468:Incorrect Pointer Scaling\nB.CWE-682:Incorrect Calculation\nC.No Vulnerabilities\nD.CWE-455:Non-exit on Failed Initialization\nE.CWE-300:Channel Accessible by Non-Endpoint\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ptr_to_int_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+2));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ptr_to_int_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ptr_to_int_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ptr_to_int_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-468:Incorrect Pointer Scaling|B.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-675:Multiple Operations on Resource in Single-Operation Context\nB.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nC.CWE-1338:Improper Protections Against Hardware Overheating\nD.No Vulnerabilities\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_realloc_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(wchar_t));\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_realloc_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_realloc_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_realloc_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-486:Comparison of Classes by Name\nC.CWE-152:Improper Neutralization of Macro Symbols\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define RENAME rename\r\n#else\r\n#define RENAME rename\r\n#endif\r\n\r\n#define OLD_M_FILE_NAME \"oldmfilename.txt\"\r\n#define OLD_N_FILE_NAME \"oldnfilename.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_rename_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n RENAME(OLD_M_FILE_NAME, \"newmfilename.txt\");\r\n }\r\n else\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, \"newnfilename.txt\") != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, \"newnfilename.txt\") != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n else\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, \"newnfilename.txt\") != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_rename_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_rename_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_rename_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-134:Use of Externally-Controlled Format String\nC.CWE-252:Unchecked Return Value\nD.No Vulnerabilities\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include <stdarg.h>\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\nnamespace My_char_listen_socket_vfprintf_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mVaSink(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vfprintf(stdout, data, args);\r\n va_end(args);\r\n }\r\n}\r\n\r\nstatic void mSource(char * &data)\r\n{\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n mSource(data);\r\n mVaSink(data, data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BVaSink(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vfprintf(stdout, data, args);\r\n va_end(args);\r\n }\r\n}\r\n\r\nstatic void nG2BSource(char * &data)\r\n{\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n nG2BVaSink(data, data);\r\n}\r\n\r\n\r\nstatic void nB2GVaSink(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vfprintf(stdout, \"%s\", args);\r\n va_end(args);\r\n }\r\n}\r\n\r\nstatic void nB2GSource(char * &data)\r\n{\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n nB2GSource(data);\r\n nB2GVaSink(data, data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_vfprintf_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-134:Use of Externally-Controlled Format String|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1103:Use of Platform-Dependent Third Party Components\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-455:Non-exit on Failed Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_w32_close_15()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(6)\r\n {\r\n case 6:\r\n if (data != NULL)\r\n {\r\n \r\n _close((int)data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(6)\r\n {\r\n case 6:\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fopen_w32_close_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_w32_close_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_w32_close_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-862:Missing Authorization\nB.CWE-323:Reusing a Nonce, Key Pair in Encryption\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.No Vulnerabilities\nE.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_char_connect_socket_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_w32_char_connect_socket_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_connect_socket_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_connect_socket_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-771:Missing Reference to Active Allocated Resource\nB.CWE-563:Assignment to Variable without Use\nC.No Vulnerabilities\nD.CWE-773:Missing Reference to Active File Descriptor or Handle\nE.CWE-231:Improper Handling of Extra Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_open_63bSink(int * dataPtr);\r\n\r\nvoid My_open_63()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n My_open_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_open_63bB2GSink(int * data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n My_open_63bB2GSink(&data);\r\n}\r\n\r\nvoid My_open_63()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-773:Missing Reference to Active File Descriptor or Handle|A.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-321:Use of Hard-coded Cryptographic Key\nB.No Vulnerabilities\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-784:Reliance on Cookies without Validation and Integrity Checking in a Security Decision\nE.CWE-311:Missing Encryption of Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * cryptoKey)\r\n{\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_44()\r\n{\r\n wchar_t * cryptoKey;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n \r\n funcPtr(cryptoKey);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * cryptoKey)\r\n{\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * cryptoKey;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n funcPtr(cryptoKey);\r\n}\r\n\r\nvoid My_w32_wchar_t_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-321:Use of Hard-coded Cryptographic Key|C.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-588:Attempt to Access Child of a Non-structure Pointer\nC.CWE-170:Improper Null Termination\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-112:Missing XML Validation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n void * *dataPtr1 = &data;\r\n void * *dataPtr2 = &data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n {\r\n void * data = *dataPtr1;\r\n \r\n data = &dataMBuffer;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n void * data = *dataPtr2;\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n void * *dataPtr1 = &data;\r\n void * *dataPtr2 = &data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n {\r\n void * data = *dataPtr1;\r\n \r\n data = &dataNBuffer;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n void * data = *dataPtr2;\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-588:Attempt to Access Child of a Non-structure Pointer|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-779:Logging of Excessive Data\nC.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nD.CWE-330:Use of Insufficiently Random Values\nE.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifdef _WIN32\r\n#define ACCESS _access\r\n#define W_OK 02\r\n#else\r\n#define ACCESS access\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_access_01()\r\n{\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (ACCESS(filename, W_OK) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_access_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_access_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_access_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|E.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-224:Obscured Security-relevant Information by Alternate Name\nC.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\nD.No Vulnerabilities\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <process.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_listen_socket_w32_spawnv_53bSink(char * data);\r\n\r\nvoid My_char_listen_socket_w32_spawnv_53()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_char_listen_socket_w32_spawnv_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_listen_socket_w32_spawnv_53bG2BSink(char * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n \r\n strcat(data, \"*.*\");\r\n My_char_listen_socket_w32_spawnv_53bG2BSink(data);\r\n}\r\n\r\nvoid My_char_listen_socket_w32_spawnv_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_w32_spawnv_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_w32_spawnv_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-190:Integer Overflow or Wraparound\nC.CWE-733:Compiler Optimization Removal or Modification of Security-critical Code\nD.CWE-682:Incorrect Calculation\nE.CWE-279:Incorrect Execution-Assigned Permissions\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint circumambages_cartmaker = 0;\r\nint global_variable;\r\n#define ROTARIANIZE_OVERRIPELY(x) hegumen_outpipe((char **) x)\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid hegumen_outpipe(char **surveillant_undunged);\r\nint 190_global_var = 0;\r\n\r\nunsigned int avdevice_version()\r\n{\r\n char **chiropractors_unwetted = 0;\r\n char **sympathizing_akeldama = 0;\r\n char *sedimetric_pyramidic[53] = {0};\r\n char *leckrone_lotis;;\r\n if (__sync_bool_compare_and_swap(&circumambages_cartmaker,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&leckrone_lotis,\"CONGLOMERATIC_DOUANES\");\r\n if (leckrone_lotis != 0) {;\r\n sedimetric_pyramidic[8] = leckrone_lotis;\r\n chiropractors_unwetted = sedimetric_pyramidic;\r\n sympathizing_akeldama = chiropractors_unwetted + 5;\r\n\tROTARIANIZE_OVERRIPELY(sympathizing_akeldama);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid hegumen_outpipe(char **surveillant_undunged)\r\n{\r\n int tainted_int = 0;\r\n int output_counter = 0;\r\n char *josephinite_withercraft = 0;\r\n ++global_variable;;\r\n josephinite_withercraft = ((char *)(surveillant_undunged - 5)[8]);\r\n \r\n tainted_int = atoi(josephinite_withercraft);\r\n if (tainted_int > 0) {\r\n \r\n\r\n tainted_int = tainted_int * tainted_int;\r\n \r\n \r\n \r\n while (tainted_int != 0) {\r\n\r\n if (tainted_int != INT_MIN) {\r\n tainted_int--;\r\n }\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n ++190_global_var;\r\n if (190_global_var >= INT_MAX) {\r\n 190_global_var = 0;\r\n }\r\n }\r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\n if ((surveillant_undunged - 5)[8] != 0) \r\n free(((char *)(surveillant_undunged - 5)[8]));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-190:Integer Overflow or Wraparound|D.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.No Vulnerabilities\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-302:Authentication Bypass by Assumed-Immutable Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_open_w32CloseHandle_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int> dataVector);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(vector<int> dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_open_w32CloseHandle_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-273:Improper Check for Dropped Privileges\nB.CWE-1096:Singleton Class Instance Creation without Proper Locking or Synchronization\nC.CWE-697:Incorrect Comparison\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#define BUFSIZE 1024\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n ImpersonateNamedPipeClient(hPipe);\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateNamedPipeClient_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateNamedPipeClient_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-273:Improper Check for Dropped Privileges|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-346:Origin Validation Error\nB.No Vulnerabilities\nC.CWE-476:NULL Pointer Dereference\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-941:Incorrectly Specified Destination in a Communication Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_null_check_after_deref_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n if (intPointer != NULL)\r\n {\r\n *intPointer = 10;\r\n }\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n *intPointer = 10;\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n *intPointer = 10;\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_null_check_after_deref_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_null_check_after_deref_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_null_check_after_deref_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-176:Improper Handling of Unicode Encoding\nB.CWE-618:Exposed Unsafe ActiveX Method\nC.CWE-778:Insufficient Logging\nD.CWE-172:Encoding Error\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * data)\r\n{\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n}\r\n\r\nvoid My_w32_44()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * data)\r\n{\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n funcPtr(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(wchar_t * data)\r\n{\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nB2GSink;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_w32_44()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-176:Improper Handling of Unicode Encoding|D.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1270:Generation of Incorrect Security Tokens\nC.CWE-467:Use of sizeof() on a Pointer Type\nD.CWE-131:Incorrect Calculation of Buffer Size\nE.CWE-707:Improper Neutralization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_01()\r\n{\r\n {\r\n int * mInt = NULL;\r\n \r\n mInt = (int *)malloc(sizeof(mInt));\r\n if (mInt == NULL) {exit(-1);}\r\n *mInt = 5;\r\n printIntLine(*mInt);\r\n free(mInt);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n int * nInt = NULL;\r\n \r\n nInt = (int *)malloc(sizeof(*nInt));\r\n if (nInt == NULL) {exit(-1);}\r\n *nInt = 6;\r\n printIntLine(*nInt);\r\n free(nInt);\r\n }\r\n}\r\n\r\nvoid My_int_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-467:Use of sizeof() on a Pointer Type|D.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-416:Use After Free\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-1283:Mutable Attestation or Measurement Reporting Data\nE.CWE-263:Password Aging with Long Expiration\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic char * helperM(char * aString)\r\n{\r\n size_t i = 0;\r\n size_t j;\r\n char * reversedString = NULL;\r\n if (aString != NULL)\r\n {\r\n i = strlen(aString);\r\n reversedString = (char *) malloc(i+1);\r\n if (reversedString == NULL) {exit(-1);}\r\n for (j = 0; j < i; j++)\r\n {\r\n reversedString[j] = aString[i-j-1];\r\n }\r\n reversedString[i] = '\\0';\r\n \r\n free(reversedString);\r\n return reversedString;\r\n }\r\n else\r\n {\r\n return NULL;\r\n }\r\n}\r\n\r\nstatic char * helperN(char * aString)\r\n{\r\n size_t i = 0;\r\n size_t j;\r\n char * reversedString = NULL;\r\n if (aString != NULL)\r\n {\r\n i = strlen(aString);\r\n reversedString = (char *) malloc(i+1);\r\n if (reversedString == NULL) {exit(-1);}\r\n for (j = 0; j < i; j++)\r\n {\r\n reversedString[j] = aString[i-j-1];\r\n }\r\n reversedString[i] = '\\0';\r\n \r\n return reversedString;\r\n }\r\n else\r\n {\r\n return NULL;\r\n }\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_return_freed_ptr_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n \r\n char * reversedString = helperM(\"MSink\");\r\n printLine(reversedString);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n \r\n char * reversedString = helperN(\"NSink\");\r\n printLine(reversedString);\r\n \r\n }\r\n}\r\n\r\nvoid My_return_freed_ptr_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_return_freed_ptr_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_return_freed_ptr_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-325:Missing Cryptographic Step\nB.CWE-573:Improper Following of Specification by Caller\nC.No Vulnerabilities\nD.CWE-341:Predictable from Observable State\nE.CWE-426:Untrusted Search Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptDeriveKey_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptDeriveKey_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptDeriveKey_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptDeriveKey_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-325:Missing Cryptographic Step|B.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.CWE-152:Improper Neutralization of Macro Symbols\nC.CWE-1060:Excessive Number of Inefficient Server-Side Data Accesses\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fscanf_sleep_51bSink(int count);\r\n\r\nvoid My_fscanf_sleep_51()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n My_fscanf_sleep_51bSink(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fscanf_sleep_51bG2BSink(int count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n My_fscanf_sleep_51bG2BSink(count);\r\n}\r\n\r\n\r\nvoid My_fscanf_sleep_51bB2GSink(int count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n My_fscanf_sleep_51bB2GSink(count);\r\n}\r\n\r\nvoid My_fscanf_sleep_51()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_sleep_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_sleep_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1235:Incorrect Use of Autoboxing and Unboxing for Performance Critical Operations\nC.CWE-912:Hidden Functionality\nD.CWE-32:Path Traversal: '...' (Triple Dot)\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_base64_encoded_payload_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n char * encodedPayload = \"Y2FsYy5leGU=\";\r\n BYTE * decodedPayload = NULL;\r\n DWORD requiredLength;\r\n do\r\n {\r\n \r\n if (!CryptStringToBinaryA(encodedPayload,\r\n strlen(encodedPayload),\r\n CRYPT_STRING_BASE64,\r\n NULL,\r\n &requiredLength,\r\n NULL,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n decodedPayload = (BYTE*) malloc(requiredLength + 1);\r\n if (decodedPayload == NULL)\r\n {\r\n break;\r\n }\r\n \r\n if (!CryptStringToBinaryA(encodedPayload,\r\n strlen(encodedPayload),\r\n CRYPT_STRING_BASE64,\r\n decodedPayload,\r\n &requiredLength,\r\n NULL,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n decodedPayload[requiredLength] = '\\0';\r\n if (system((char*)decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n free(decodedPayload);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char * decodedPayload = \"calc.exe\";\r\n if (system(decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n char * decodedPayload = \"calc.exe\";\r\n if (system(decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_base64_encoded_payload_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_base64_encoded_payload_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_base64_encoded_payload_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-506:Embedded Malicious Code|C.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.CWE-824:Access of Uninitialized Pointer\nC.CWE-284:Improper Access Control\nD.No Vulnerabilities\nE.CWE-143:Improper Neutralization of Record Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_RegCreateKeyEx_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_ALL_ACCESS,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_RegCreateKeyEx_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_RegCreateKeyEx_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_RegCreateKeyEx_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-284:Improper Access Control|A.CWE-476:NULL Pointer Dereference", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-636:Not Failing Securely ('Failing Open')\nB.No Vulnerabilities\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-1063:Creation of Class Instance within a Static Code Block\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint readl_firework = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid ambitionless_trigemini(int lowland_unpropagable,char **antiphilosophy_nonsyntactical);\r\nvoid unbrutalised_nopalry(int licentiousness_segs,char **nondefeasibness_cogitability);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int preadjourn_klutzy = 7;\r\n char **boomtown_nackenheimer = 0;\r\n char **audiovisuals_sulpharsenious = 0;\r\n char *falsifiable_nearabouts;;\r\n if (__sync_bool_compare_and_swap(&readl_firework,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&falsifiable_nearabouts,\"SIEUR_INFLUENCE\");\r\n if (falsifiable_nearabouts != 0) {;\r\n boomtown_nackenheimer = &falsifiable_nearabouts;\r\n audiovisuals_sulpharsenious = boomtown_nackenheimer + 5;\r\n ambitionless_trigemini(preadjourn_klutzy,audiovisuals_sulpharsenious);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid ambitionless_trigemini(int lowland_unpropagable,char **antiphilosophy_nonsyntactical)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *isobornyl_sigfried = 0;\r\n ++global_variable;\r\n lowland_unpropagable--;\r\n if (lowland_unpropagable > 0) {\r\n unbrutalised_nopalry(lowland_unpropagable,antiphilosophy_nonsyntactical);\r\n return ;\r\n }\r\n isobornyl_sigfried = ((char *)( *(antiphilosophy_nonsyntactical - 5)));\r\n \r\n if (strlen(isobornyl_sigfried) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n snprintf(command_buffer, 1000, \"%s%s\",command_str,isobornyl_sigfried);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if ( *(antiphilosophy_nonsyntactical - 5) != 0) \r\n free(((char *)( *(antiphilosophy_nonsyntactical - 5))));\r\nclose_printf_context();\r\n}\r\n\r\nvoid unbrutalised_nopalry(int licentiousness_segs,char **nondefeasibness_cogitability)\r\n{\r\n ++global_variable;\r\n ambitionless_trigemini(licentiousness_segs,nondefeasibness_cogitability);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1078:Inappropriate Source Code Style or Formatting\nB.No Vulnerabilities\nC.CWE-564:SQL Injection: Hibernate\nD.CWE-546:Suspicious Comment\nE.CWE-354:Improper Validation of Integrity Check Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_BUG_01()\r\n{\r\n \r\n \r\n printLine(\"Hello\");\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n \r\n printLine(\"Hello\");\r\n}\r\n\r\nvoid My_BUG_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_BUG_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_BUG_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-546:Suspicious Comment|A.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.No Vulnerabilities\nC.CWE-922:Insecure Storage of Sensitive Information\nD.CWE-259:Use of Hard-coded Password\nE.CWE-1059:Insufficient Technical Documentation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\nnamespace My_w32_wchar_t_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &password);\r\n\r\nvoid m()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n mSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &password);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n nG2BSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-259:Use of Hard-coded Password|A.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-123:Write-what-where Condition\nC.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nD.CWE-544:Missing Standardized Error Handling Mechanism\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_16()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n while(1)\r\n {\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n break;\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n while(1)\r\n {\r\n \r\n ; \r\n break;\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_fgets_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|A.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-65:Windows Hard Link\nB.CWE-93:Improper Neutralization of CRLF Sequences ('CRLF Injection')\nC.No Vulnerabilities\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.CWE-546:Suspicious Comment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_TODO_05()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_TODO_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_TODO_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_TODO_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nB.CWE-682:Incorrect Calculation\nC.No Vulnerabilities\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-343:Predictable Value Range from Previous Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fgets_add_32()\r\n{\r\n int data;\r\n int *dataPtr1 = &data;\r\n int *dataPtr2 = &data;\r\n \r\n data = 0;\r\n {\r\n int data = *dataPtr1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int data = *dataPtr2;\r\n {\r\n \r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n int *dataPtr1 = &data;\r\n int *dataPtr2 = &data;\r\n \r\n data = 0;\r\n {\r\n int data = *dataPtr1;\r\n \r\n data = 2;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int data = *dataPtr2;\r\n {\r\n \r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n int *dataPtr1 = &data;\r\n int *dataPtr2 = &data;\r\n \r\n data = 0;\r\n {\r\n int data = *dataPtr1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int data = *dataPtr2;\r\n \r\n if (data < INT_MAX)\r\n {\r\n int result = data + 1;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_fgets_add_32()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fgets_add_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fgets_add_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-131:Incorrect Calculation of Buffer Size\nC.CWE-483:Incorrect Block Delimitation\nD.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_semicolon_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0);\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_semicolon_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_semicolon_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_semicolon_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-483:Incorrect Block Delimitation|A.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "483"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-710:Improper Adherence to Coding Standards\nB.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nC.No Vulnerabilities\nD.CWE-293:Using Referer Field for Authentication\nE.CWE-1039:Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_new_use_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n TwoIntsClass * pointer = new TwoIntsClass;\r\n TwoIntsClass data = *pointer; \r\n delete pointer;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n TwoIntsClass data;\r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n TwoIntsClass * pointer = new TwoIntsClass;\r\n *pointer = data; \r\n {\r\n TwoIntsClass data = *pointer;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n delete pointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_new_use_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|A.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.No Vulnerabilities\nC.CWE-114:Process Control\nD.CWE-838:Inappropriate Encoding for Output Context\nE.CWE-603:Use of Client-Side Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_console_09()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_console_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_console_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_console_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|A.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nB.CWE-122:Heap-based Buffer Overflow\nC.CWE-294:Authentication Bypass by Capture-replay\nD.No Vulnerabilities\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING \"AAAAAAAAAA\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_c_My_c_My_c_My_c_CWE193_char_loop_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-122:Heap-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.No Vulnerabilities\nC.CWE-1074:Class with Excessively Deep Inheritance\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-26:Path Traversal: '/dir/../filename'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fputc_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n fputc((int)'A', stdout);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n if (fputc((int)'A', stdout) == EOF)\r\n {\r\n printLine(\"fputc failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fputc_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fputc_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fputc_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-182:Collapse of Data into Unsafe Value\nB.CWE-198:Use of Incorrect Byte Ordering\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-704:Incorrect Type Conversion or Cast\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2int_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double2int_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2int_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2int_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-681:Incorrect Conversion between Numeric Types|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-253:Incorrect Check of Function Return Value\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-495:Private Data Structure Returned From A Public Method\nE.CWE-821:Incorrect Synchronization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define REMOVE _wremove\r\n#else\r\n#define REMOVE remove\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_remove_18()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n if (REMOVE(L\"removemem.txt\") == 0)\r\n {\r\n printLine(\"remove failed!\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n if (REMOVE(L\"removemen.txt\") != 0)\r\n {\r\n printLine(\"remove failed!\");\r\n }\r\n}\r\n\r\nvoid My_wchar_t_remove_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_remove_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_remove_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-253:Incorrect Check of Function Return Value|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-697:Incorrect Comparison\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-437:Incomplete Model of Endpoint Features\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CreateFile_close_10()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalTrue)\r\n {\r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n \r\n _close((int)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n \r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalTrue)\r\n {\r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n \r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_close_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_close_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_close_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-404:Improper Resource Shutdown or Release|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1024:Comparison of Incompatible Types\nB.CWE-541:Inclusion of Sensitive Information in an Include File\nC.No Vulnerabilities\nD.CWE-628:Function Call with Incorrectly Specified Arguments\nE.CWE-688:Function Call With Incorrect Variable or Reference as Argument\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 100\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%s\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-688:Function Call With Incorrect Variable or Reference as Argument|D.CWE-628:Function Call with Incorrectly Specified Arguments", "cwe": "688"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-245:J2EE Bad Practices: Direct Management of Connections\nB.No Vulnerabilities\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-23:Relative Path Traversal\nE.CWE-644:Improper Neutralization of HTTP Headers for Scripting Syntax\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_char_console_ifstream_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_console_ifstream_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-23:Relative Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-467:Use of sizeof() on a Pointer Type\nB.No Vulnerabilities\nC.CWE-194:Unexpected Sign Extension\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#define CHAR_ARRAY_SIZE 8\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_strncpy_31()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n int tempInt;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n \r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n tempInt = atoi(inputBuffer);\r\n if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\r\n {\r\n data = -1;\r\n }\r\n else\r\n {\r\n data = tempInt;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n {\r\n short dataCopy = data;\r\n short data = dataCopy;\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n {\r\n short dataCopy = data;\r\n short data = dataCopy;\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_socket_strncpy_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_strncpy_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_strncpy_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-194:Unexpected Sign Extension|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-182:Collapse of Data into Unsafe Value\nC.No Vulnerabilities\nD.CWE-590:Free of Memory not on the Heap\nE.CWE-128:Wrap-around Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_array_int_static_54\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(int * data);\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n data = NULL; \r\n {\r\n \r\n static int dataBuffer[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(int * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n data = NULL; \r\n {\r\n \r\n int * dataBuffer = new int[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n nG2BSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_int_static_54; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|A.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-174:Double Decoding of the Same Data\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nD.No Vulnerabilities\nE.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_environment_15()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 256-dataLen-1);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_char_environment_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_environment_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_environment_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-1284:Improper Validation of Specified Quantity in Input\nD.CWE-1220:Insufficient Granularity of Access Control\nE.CWE-196:Unsigned to Signed Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n unsigned intUnsigned;\r\n int intSigned;\r\n intUnsigned = rand();\r\n if (rand() % 2 == 0)\r\n {\r\n intUnsigned = UINT_MAX - intUnsigned;\r\n }\r\n \r\n intSigned = intUnsigned;\r\n printIntLine(intSigned);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n unsigned intUnsigned;\r\n int intSigned;\r\n intUnsigned = rand();\r\n if (rand() % 2 == 0)\r\n {\r\n intUnsigned = UINT_MAX - intUnsigned;\r\n }\r\n \r\n if (intUnsigned > INT_MAX)\r\n {\r\n exit(1);\r\n }\r\n intSigned = intUnsigned;\r\n printIntLine(intSigned);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n unsigned intUnsigned;\r\n int intSigned;\r\n intUnsigned = rand();\r\n if (rand() % 2 == 0)\r\n {\r\n intUnsigned = UINT_MAX - intUnsigned;\r\n }\r\n \r\n if (intUnsigned > INT_MAX)\r\n {\r\n exit(1);\r\n }\r\n intSigned = intUnsigned;\r\n printIntLine(intSigned);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-196:Unsigned to Signed Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "196"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-804:Guessable CAPTCHA\nE.CWE-9:J2EE Misconfiguration: Weak Access Permissions for EJB Methods\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#include <process.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_console_w32_spawnlp_03()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n \r\n \r\n _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n }\r\n \r\n \r\n _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n }\r\n \r\n \r\n _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid My_char_console_w32_spawnlp_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_w32_spawnlp_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_w32_spawnlp_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1290:Incorrect Decoding of Security Identifiers \nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-926:Improper Export of Android Application Components\nE.CWE-134:Use of Externally-Controlled Format String\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} My_wchar_t_environment_printf_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_environment_printf_34()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_environment_printf_34_unionType myUnion;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n \r\n wprintf(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_environment_printf_34_unionType myUnion;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"fixedstringtest\");\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n \r\n wprintf(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_environment_printf_34_unionType myUnion;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n \r\n wprintf(L\"%s\\n\", data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_environment_printf_34()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_environment_printf_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_environment_printf_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-134:Use of Externally-Controlled Format String|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-761:Free of Pointer not at Start of Buffer\nB.CWE-1312:Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-168:Improper Handling of Inconsistent Special Elements\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\n\r\nchar * My_char_listen_socket_61bSource(char * data);\r\n\r\nvoid My_char_listen_socket_61()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n data = My_char_listen_socket_61bSource(data);\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nchar * My_char_listen_socket_61bB2GSource(char * data);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n data = My_char_listen_socket_61bB2GSource(data);\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_char_listen_socket_61()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-761:Free of Pointer not at Start of Buffer|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-650:Trusting HTTP Permission Methods on the Server Side\nB.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-195:Signed to Unsigned Conversion Error\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fgets_strncpy_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fgets_strncpy_83\r\n{\r\npublic:\r\n My_fgets_strncpy_83(int dataCopy);\r\n ~My_fgets_strncpy_83();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fgets_strncpy_83G2B\r\n{\r\npublic:\r\n My_fgets_strncpy_83G2B(int dataCopy);\r\n ~My_fgets_strncpy_83G2B();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-195:Signed to Unsigned Conversion Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-394:Unexpected Status Code or Return Value\nE.CWE-617:Reachable Assertion\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fscanf_07()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive==5)\r\n {\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive==5)\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fscanf_07()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-617:Reachable Assertion|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-1125:Excessive Attack Surface\nC.No Vulnerabilities\nD.CWE-358:Improperly Implemented Security Check for Standard\nE.CWE-190:Integer Overflow or Wraparound\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nchar My_char_max_add_61bSource(char data);\r\n\r\nvoid My_char_max_add_61()\r\n{\r\n char data;\r\n data = ' ';\r\n data = My_char_max_add_61bSource(data);\r\n {\r\n \r\n char result = data + 1;\r\n printHexCharLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nchar My_char_max_add_61bG2BSource(char data);\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n data = ' ';\r\n data = My_char_max_add_61bG2BSource(data);\r\n {\r\n \r\n char result = data + 1;\r\n printHexCharLine(result);\r\n }\r\n}\r\n\r\n\r\nchar My_char_max_add_61bB2GSource(char data);\r\n\r\nstatic void nB2G()\r\n{\r\n char data;\r\n data = ' ';\r\n data = My_char_max_add_61bB2GSource(data);\r\n \r\n if (data < CHAR_MAX)\r\n {\r\n char result = data + 1;\r\n printHexCharLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n}\r\n\r\nvoid My_char_max_add_61()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_max_add_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_max_add_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-190:Integer Overflow or Wraparound|A.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-131:Incorrect Calculation of Buffer Size\nC.CWE-128:Wrap-around Error\nD.CWE-127:Buffer Under-read\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n size_t i;\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_char_alloca_loop_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n size_t i;\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_alloca_loop_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_alloca_loop_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_alloca_loop_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-127:Buffer Under-read|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-710:Improper Adherence to Coding Standards\nB.CWE-760:Use of a One-Way Hash with a Predictable Salt\nC.CWE-122:Heap-based Buffer Overflow\nD.CWE-787:Out-of-bounds Write\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_My_My_My_My_My_My_My_My_My_CWE135_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-122:Heap-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1293:Missing Source Correlation of Multiple Independent Data\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.CWE-1039:Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_53\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(list<int> data);\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(list<int> data);\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n nG2BSink_b(data);\r\n}\r\n\r\n\r\nvoid nB2GSink_b(list<int> data);\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n nB2GSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_53; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-672:Operation on a Resource after Expiration or Release|C.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1124:Excessively Deep Nesting\nB.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nC.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nD.CWE-1114:Inappropriate Whitespace Style\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_stat_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n struct STAT statBuffer;\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (STAT(filename, &statBuffer) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_stat_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_stat_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_stat_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|C.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\nC.No Vulnerabilities\nD.CWE-328:Use of Weak Hash\nE.CWE-284:Improper Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define MD5_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_MD5_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[MD5_SUM_SIZE], calcHash[MD5_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < MD5_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = MD5_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, MD5_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_MD5_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_MD5_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_MD5_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-328:Use of Weak Hash|A.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nC.CWE-330:Use of Insufficiently Random Values\nD.CWE-662:Improper Synchronization\nE.CWE-304:Missing Critical Step in Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|C.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-584:Return Inside Finally Block\nD.CWE-195:Signed to Unsigned Conversion Error\nE.CWE-510:Trapdoor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_memmove_52bSink(int data);\r\n\r\nvoid My_connect_socket_memmove_52()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_memmove_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_memmove_52bG2BSink(int data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n My_connect_socket_memmove_52bG2BSink(data);\r\n}\r\n\r\nvoid My_connect_socket_memmove_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_memmove_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_memmove_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-325:Missing Cryptographic Step\nB.CWE-332:Insufficient Entropy in PRNG\nC.CWE-457:Use of Uninitialized Variable\nD.CWE-665:Improper Initialization\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_array_alloca_no_init_01()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));\r\n \r\n ; \r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));\r\n \r\n ; \r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_array_alloca_no_init_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_array_alloca_no_init_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_array_alloca_no_init_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-457:Use of Uninitialized Variable|D.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-191:Integer Underflow (Wrap or Wraparound)\nD.CWE-682:Incorrect Calculation\nE.CWE-1232:Improper Lock Behavior After Power State Transition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_char_min_sub_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_char_min_sub_83\r\n{\r\npublic:\r\n My_char_min_sub_83(char dataCopy);\r\n ~My_char_min_sub_83();\r\n\r\nprivate:\r\n char data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_char_min_sub_83G2B\r\n{\r\npublic:\r\n My_char_min_sub_83G2B(char dataCopy);\r\n ~My_char_min_sub_83G2B();\r\n\r\nprivate:\r\n char data;\r\n};\r\n\r\nclass My_char_min_sub_83B2G\r\n{\r\npublic:\r\n My_char_min_sub_83B2G(char dataCopy);\r\n ~My_char_min_sub_83B2G();\r\n\r\nprivate:\r\n char data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-191:Integer Underflow (Wrap or Wraparound)|D.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-755:Improper Handling of Exceptional Conditions\nC.CWE-772:Missing Release of Resource after Effective Lifetime\nD.CWE-497:Exposure of Sensitive System Information to an Unauthorized Control Sphere\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_empty_catch_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"Range specified was invalid\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n try\r\n {\r\n string stringHello = \"hello\";\r\n string stringSubstring = stringHello.substr(rand(), rand());\r\n printLine(stringSubstring.c_str());\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"Range specified was invalid\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_empty_catch_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-390:Detection of Error Condition Without Action|B.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-913:Improper Control of Dynamically-Managed Code Resources\nB.No Vulnerabilities\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-259:Use of Hard-coded Password\nE.CWE-230:Improper Handling of Missing Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_66bSink(wchar_t * passwordArray[]);\r\n\r\nvoid My_w32_wchar_t_66()\r\n{\r\n wchar_t * password;\r\n wchar_t * passwordArray[5];\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n \r\n wcscpy(password, PASSWORD);\r\n \r\n passwordArray[2] = password;\r\n My_w32_wchar_t_66bSink(passwordArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_66bG2BSink(wchar_t * passwordArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t * passwordArray[5];\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n passwordArray[2] = password;\r\n My_w32_wchar_t_66bG2BSink(passwordArray);\r\n}\r\n\r\nvoid My_w32_wchar_t_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-547:Use of Hard-coded, Security-relevant Constants\nD.CWE-326:Inadequate Encryption Strength\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_memmove_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n mSource(data);\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n nG2BSource(data);\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_memmove_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-654:Reliance on a Single Factor in a Security Decision\nB.CWE-704:Incorrect Type Conversion or Cast\nC.No Vulnerabilities\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_01()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_short_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.CWE-208:Observable Timing Discrepancy\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-617:Reachable Assertion\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_63bSink(char * * passwordPtr);\r\n\r\nvoid My_w32_char_63()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n \r\n strcpy(password, PASSWORD);\r\n My_w32_char_63bSink(&password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_63bG2BSink(char * * password);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n My_w32_char_63bG2BSink(&password);\r\n}\r\n\r\nvoid My_w32_char_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1113:Inappropriate Comment Style\nB.CWE-464:Addition of Data Structure Sentinel\nC.CWE-446:UI Discrepancy for Security Feature\nD.No Vulnerabilities\nE.CWE-138:Improper Neutralization of Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_basic_51bSink(char data);\r\n\r\nvoid My_basic_51()\r\n{\r\n char data;\r\n data = ' ';\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n My_basic_51bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_basic_51bG2BSink(char data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n data = ' ';\r\n \r\n data = 'a';\r\n My_basic_51bG2BSink(data);\r\n}\r\n\r\nvoid My_basic_51()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-464:Addition of Data Structure Sentinel|E.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-511:Logic/Time Bomb\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nD.No Vulnerabilities\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _My_fopen_no_close_67_structType\r\n{\r\n FILE * structFirst;\r\n} My_fopen_no_close_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fopen_no_close_67bSink(My_fopen_no_close_67_structType myStruct);\r\n\r\nvoid My_fopen_no_close_67()\r\n{\r\n FILE * data;\r\n My_fopen_no_close_67_structType myStruct;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n myStruct.structFirst = data;\r\n My_fopen_no_close_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fopen_no_close_67bB2GSink(My_fopen_no_close_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n My_fopen_no_close_67_structType myStruct;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n myStruct.structFirst = data;\r\n My_fopen_no_close_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_fopen_no_close_67()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_no_close_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_no_close_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-81:Improper Neutralization of Script in an Error Message Web Page\nB.CWE-508:Non-Replicating Malicious Code\nC.CWE-673:External Influence of Sphere Definition\nD.CWE-426:Untrusted Search Path\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _wpopen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_popen_12()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n wcscpy(data, M_OS_COMMAND);\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n }\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n }\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_popen_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_popen_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_popen_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-426:Untrusted Search Path|C.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-315:Cleartext Storage of Sensitive Information in a Cookie\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_53bSink(wchar_t * cryptoKey);\r\n\r\nvoid My_w32_wchar_t_53()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n My_w32_wchar_t_53bSink(cryptoKey);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_53bG2BSink(wchar_t * cryptoKey);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n My_w32_wchar_t_53bG2BSink(cryptoKey);\r\n}\r\n\r\nvoid My_w32_wchar_t_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|D.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-253:Incorrect Check of Function Return Value\nB.No Vulnerabilities\nC.CWE-114:Process Control\nD.CWE-73:External Control of File Name or Path\nE.CWE-1259:Improper Restriction of Security Token Assignment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_relativePath_63bSink(char * * dataPtr);\r\n\r\nvoid My_w32_char_relativePath_63()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"winsrv.dll\");\r\n My_w32_char_relativePath_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_relativePath_63bG2BSink(char * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n My_w32_char_relativePath_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_w32_char_relativePath_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_relativePath_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_relativePath_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|D.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-444:Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-34:Path Traversal: '....//'\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <process.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_listen_socket_w32spawnl_01()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n \r\n _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n \r\n strcat(data, \"*.*\");\r\n \r\n \r\n _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid My_char_listen_socket_w32spawnl_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_w32spawnl_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_w32spawnl_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-127:Buffer Under-read\nC.CWE-1076:Insufficient Adherence to Expected Conventions\nD.CWE-183:Permissive List of Allowed Inputs\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_char_ncpy_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_malloc_char_ncpy_83\r\n{\r\npublic:\r\n My_malloc_char_ncpy_83(char * dataCopy);\r\n ~My_malloc_char_ncpy_83();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_malloc_char_ncpy_83G2B\r\n{\r\npublic:\r\n My_malloc_char_ncpy_83G2B(char * dataCopy);\r\n ~My_malloc_char_ncpy_83G2B();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-616:Incomplete Identification of Uploaded File Variables (PHP)\nB.CWE-122:Heap-based Buffer Overflow\nC.CWE-787:Out-of-bounds Write\nD.CWE-1280:Access Control Check Implemented After Asset is Accessed\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_cpp_src_char_cat_41\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid mSink(char * data)\r\n{\r\n {\r\n char dest[50] = \"\";\r\n \r\n strcat(dest, data);\r\n printLine(data);\r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = new char[100];\r\n \r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nvoid nG2BSink(char * data)\r\n{\r\n {\r\n char dest[50] = \"\";\r\n \r\n strcat(dest, data);\r\n printLine(data);\r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n data = new char[100];\r\n \r\n memset(data, 'A', 50-1); \r\n data[50-1] = '\\0'; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_cpp_src_char_cat_41; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-122:Heap-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-173:Improper Handling of Alternate Encoding\nC.CWE-195:Signed to Unsigned Conversion Error\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-295:Improper Certificate Validation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_strncpy_10()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n \r\n data = RAND32();\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_rand_strncpy_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_strncpy_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_strncpy_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-195:Signed to Unsigned Conversion Error|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1102:Reliance on Machine-Dependent Data Representation\nC.CWE-124:Buffer Underwrite ('Buffer Underflow')\nD.CWE-597:Use of Wrong Operator in String Comparison\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(int data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n int i;\r\n int buffer[10] = { 0 };\r\n \r\n if (data < 10)\r\n {\r\n buffer[data] = 1;\r\n \r\n for(i = 0; i < 10; i++)\r\n {\r\n printIntLine(buffer[i]);\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"ERROR: Array index is negative.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_My_My_My_CWE839_negative_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-124:Buffer Underwrite ('Buffer Underflow')|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-122:Heap-based Buffer Overflow\nB.No Vulnerabilities\nC.CWE-576:EJB Bad Practices: Use of Java I/O\nD.CWE-274:Improper Handling of Insufficient Privileges\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_cpp_My_cpp_CWE129_rand_21; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-122:Heap-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-197:Numeric Truncation Error\nB.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_fscanf_06()\r\n{\r\n short data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n }\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\nvoid My_short_fscanf_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_fscanf_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_fscanf_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-197:Numeric Truncation Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-642:External Control of Critical State Data\nB.CWE-15:External Control of System or Configuration Setting\nC.CWE-258:Empty Password in Configuration File\nD.No Vulnerabilities\nE.CWE-1395:Dependency on Vulnerable Third-Party Component\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic char * mSource(char * data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_w32_21()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n mStatic = 1; \r\n data = mSource(data);\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic char * nG2B1Source(char * data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic char * nG2B2Source(char * data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-15:External Control of System or Configuration Setting|A.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nB.CWE-522:Insufficiently Protected Credentials\nC.No Vulnerabilities\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-397:Declaration of Throws for Generic Exception\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std; \r\n\r\nnamespace My_throw_exception_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalTrue)\r\n {\r\n \r\n throw exception();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_throw_exception_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-397:Declaration of Throws for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "397"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-404:Improper Resource Shutdown or Release\nB.CWE-104:Struts: Form Bean Does Not Extend Validation Class\nC.No Vulnerabilities\nD.CWE-586:Explicit Call to Finalize()\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_char_64\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(void * dataVoidPtr);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL;\r\n \r\n data = new char;\r\n \r\n *data = 'A';\r\n printHexCharLine(*data);\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n data = NULL;\r\n \r\n char dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = 'A';\r\n printHexCharLine(*data);\r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(void * dataVoidPtr);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n data = NULL;\r\n \r\n data = new char;\r\n \r\n *data = 'A';\r\n printHexCharLine(*data);\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_64; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|A.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-391:Unchecked Error Condition\nB.CWE-662:Improper Synchronization\nC.CWE-446:UI Discrepancy for Security Feature\nD.CWE-667:Improper Locking\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-667:Improper Locking|B.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.No Vulnerabilities\nC.CWE-511:Logic/Time Bomb\nD.CWE-146:Improper Neutralization of Expression/Command Delimiters\nE.CWE-145:Improper Neutralization of Section Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <time.h>\r\n\r\n#define TIME_CHECK ((time_t)1199163600) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_time_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_time_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_time_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_time_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|A.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1173:Improper Use of Validation Framework\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-1302:Missing Security Identifier\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_freopen_w32CloseHandle_08()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n if(staticReturnsTrue())\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n if(staticReturnsTrue())\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_freopen_w32CloseHandle_08()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_w32CloseHandle_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_w32CloseHandle_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-564:SQL Injection: Hibernate\nB.No Vulnerabilities\nC.CWE-667:Improper Locking\nD.CWE-1119:Excessive Use of Unconditional Branching\nE.CWE-662:Improper Synchronization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-667:Improper Locking|E.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.No Vulnerabilities\nC.CWE-73:External Control of File Name or Path\nD.CWE-114:Process Control\nE.CWE-1055:Multiple Inheritance from Concrete Classes\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_console_09()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_console_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_console_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_console_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-121:Stack-based Buffer Overflow\nB.CWE-259:Use of Hard-coded Password\nC.CWE-1121:Excessive McCabe Cyclomatic Complexity\nD.CWE-787:Out-of-bounds Write\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_My_My_My_My_My_My_CWE806_char_declare_memcpy_84G2B();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-121:Stack-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1326:Missing Immutable Root of Trust in Hardware\nB.No Vulnerabilities\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.CWE-105:Struts: Form Field Without Validator\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_wchar_t_file_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, wchar_t *> dataMap);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n map<int, wchar_t *> dataMap;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(map<int, wchar_t *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n map<int, wchar_t *> dataMap;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_file_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-588:Attempt to Access Child of a Non-structure Pointer\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-437:Incomplete Model of Endpoint Features\nE.CWE-756:Missing Custom Error Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_51\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(void * data);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(void * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n nG2BSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_51; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-588:Attempt to Access Child of a Non-structure Pointer|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-401:Missing Release of Memory after Effective Lifetime\nB.CWE-404:Improper Resource Shutdown or Release\nC.No Vulnerabilities\nD.CWE-140:Improper Neutralization of Delimiters\nE.CWE-585:Empty Synchronized Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_calloc_15()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n free(data);\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n free(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_wchar_t_calloc_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_calloc_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_calloc_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-401:Missing Release of Memory after Effective Lifetime|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-618:Exposed Unsafe ActiveX Method\nC.CWE-124:Buffer Underwrite ('Buffer Underflow')\nD.No Vulnerabilities\nE.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int data)\r\n{\r\n {\r\n int i;\r\n int buffer[10] = { 0 };\r\n \r\n if (data < 10)\r\n {\r\n buffer[data] = 1;\r\n \r\n for(i = 0; i < 10; i++)\r\n {\r\n printIntLine(buffer[i]);\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"ERROR: Array index is negative.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_My_My_My_CWE839_negative_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-124:Buffer Underwrite ('Buffer Underflow')|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-253:Incorrect Check of Function Return Value\nB.CWE-416:Use After Free\nC.CWE-777:Regular Expression without Anchors\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_wchar_t_17()\r\n{\r\n int i,j;\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n for(i = 0; i < 1; i++)\r\n {\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n free(data);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int i,k;\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n for(i = 0; i < 1; i++)\r\n {\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n free(data);\r\n }\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h,j;\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n for(h = 0; h < 1; h++)\r\n {\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_free_wchar_t_17()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_wchar_t_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_wchar_t_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-415:Double Free\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.No Vulnerabilities\nD.CWE-431:Missing Handler\nE.CWE-478:Missing Default Case in Multiple Condition Expression\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_class_66\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(TwoIntsClass * dataArray[]);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n delete [] data;\r\n \r\n dataArray[2] = data;\r\n mSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(TwoIntsClass * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n dataArray[2] = data;\r\n nG2BSink(dataArray);\r\n}\r\n\r\n\r\nvoid nB2GSink(TwoIntsClass * dataArray[]);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n delete [] data;\r\n dataArray[2] = data;\r\n nB2GSink(dataArray);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_class_66; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-415:Double Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.No Vulnerabilities\nD.CWE-195:Signed to Unsigned Conversion Error\nE.CWE-302:Authentication Bypass by Assumed-Immutable Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_strncpy_31()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_strncpy_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_strncpy_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_strncpy_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nB.CWE-331:Insufficient Entropy\nC.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nD.No Vulnerabilities\nE.CWE-1124:Excessively Deep Nesting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_free_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_free_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_free_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_free_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|C.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-299:Improper Check for Certificate Revocation\nB.CWE-761:Free of Pointer not at Start of Buffer\nC.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nD.CWE-763:Release of Invalid Pointer or Reference\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_char_environment_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_char_environment_83\r\n{\r\npublic:\r\n My_char_environment_83(char * dataCopy);\r\n ~My_char_environment_83();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_char_environment_83B2G\r\n{\r\npublic:\r\n My_char_environment_83B2G(char * dataCopy);\r\n ~My_char_environment_83B2G();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-761:Free of Pointer not at Start of Buffer|D.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.No Vulnerabilities\nC.CWE-427:Uncontrolled Search Path Element\nD.CWE-1174:ASP.NET Misconfiguration: Improper Model Validation\nE.CWE-1304:Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_connect_socket_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, char *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n \r\n strcat(data, NEW_PATH);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_connect_socket_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-427:Uncontrolled Search Path Element|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-282:Improper Ownership Management\nB.No Vulnerabilities\nC.CWE-662:Improper Synchronization\nD.CWE-667:Improper Locking\nE.CWE-113:Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_basic_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-667:Improper Locking|C.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-770:Allocation of Resources Without Limits or Throttling\nD.CWE-152:Improper Neutralization of Macro Symbols\nE.CWE-476:NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(wchar_t * data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n \r\n printWcharLine(data[0]);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_21()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(wchar_t * data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printWcharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(wchar_t * data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printWcharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(wchar_t * data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n \r\n \r\n printWcharLine(data[0]);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = L\"N\";\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_wchar_t_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-180:Incorrect Behavior Order: Validate Before Canonicalize\nB.CWE-351:Insufficient Type Distinction\nC.No Vulnerabilities\nD.CWE-391:Unchecked Error Condition\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_strtol_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n long longNumber;\r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n printf(\"%li\\n\", longNumber);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_strtol_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_strtol_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_strtol_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-391:Unchecked Error Condition|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-1326:Missing Immutable Root of Trust in Hardware\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_w32_char_listen_socket_81\r\n{\r\n\r\nclass My_w32_char_listen_socket_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(char * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_char_listen_socket_81 : public My_w32_char_listen_socket_81_base\r\n{\r\npublic:\r\n void action(char * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_char_listen_socket_81G2B : public My_w32_char_listen_socket_81_base\r\n{\r\npublic:\r\n void action(char * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1177:Use of Prohibited Code\nB.CWE-242:Use of Inherently Dangerous Function\nC.No Vulnerabilities\nD.CWE-457:Use of Uninitialized Variable\nE.CWE-31:Path Traversal: 'dir\\..\\..\\filename'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 10\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n \r\n result = gets(dest);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n result = fgets(dest, DEST_SIZE, stdin);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n result = fgets(dest, DEST_SIZE, stdin);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-242:Use of Inherently Dangerous Function|A.CWE-1177:Use of Prohibited Code", "cwe": "242"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-708:Incorrect Ownership Assignment\nB.CWE-787:Out-of-bounds Write\nC.CWE-807:Reliance on Untrusted Inputs in a Security Decision\nD.No Vulnerabilities\nE.CWE-122:Heap-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_CWE805_char_ncpy_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-122:Heap-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-15:External Control of System or Configuration Setting\nB.CWE-1284:Improper Validation of Specified Quantity in Input\nC.No Vulnerabilities\nD.CWE-1384:Improper Handling of Physical or Environmental Conditions\nE.CWE-642:External Control of Critical State Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_w32_22Global = 0;\r\n\r\nchar * My_w32_22Source(char * data);\r\n\r\nvoid My_w32_22()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n My_w32_22Global = 1; \r\n data = My_w32_22Source(data);\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_w32_22G2B1Global = 0;\r\nint My_w32_22G2B2Global = 0;\r\n\r\n\r\nchar * My_w32_22G2B1Source(char * data);\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n My_w32_22G2B1Global = 0; \r\n data = My_w32_22G2B1Source(data);\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nchar * My_w32_22G2B2Source(char * data);\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n My_w32_22G2B2Global = 1; \r\n data = My_w32_22G2B2Source(data);\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_22()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-15:External Control of System or Configuration Setting|E.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-599:Missing Validation of OpenSSL Certificate\nD.CWE-638:Not Using Complete Mediation\nE.CWE-665:Improper Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_ncat_53bSink(char * data);\r\n\r\nvoid My_char_ncat_53()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n My_char_ncat_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_ncat_53bG2BSink(char * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = '\\0'; \r\n My_char_ncat_53bG2BSink(data);\r\n}\r\n\r\nvoid My_char_ncat_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ncat_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ncat_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-665:Improper Initialization|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-469:Use of Pointer Subtraction to Determine Size\nC.CWE-151:Improper Neutralization of Comment Delimiters\nD.No Vulnerabilities\nE.CWE-178:Improper Handling of Case Sensitivity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SOURCE_STRING \"abc/opqrstu\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char string2[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string2);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-469:Use of Pointer Subtraction to Determine Size|A.CWE-682:Incorrect Calculation", "cwe": "469"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.No Vulnerabilities\nC.CWE-682:Incorrect Calculation\nD.CWE-67:Improper Handling of Windows Device Names\nE.CWE-807:Reliance on Untrusted Inputs in a Security Decision\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_rand_predec_07()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticFive==5)\r\n {\r\n \r\n data = (short)RAND32();\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticFive==5)\r\n {\r\n \r\n data = (short)RAND32();\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticFive==5)\r\n {\r\n \r\n data = (short)RAND32();\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n data = 0;\r\n if(staticFive==5)\r\n {\r\n \r\n data = -2;\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_rand_predec_07()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_rand_predec_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_rand_predec_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|C.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-58:Path Equivalence: Windows 8.3 Filename\nB.No Vulnerabilities\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.CWE-546:Suspicious Comment\nE.CWE-624:Executable Regular Expression Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_BUG_18()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n \r\n printLine(\"Hello\");\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n printLine(\"Hello\");\r\n}\r\n\r\nvoid My_BUG_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_BUG_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_BUG_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-546:Suspicious Comment|C.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nC.CWE-782:Exposed IOCTL with Insufficient Access Control\nD.CWE-15:External Control of System or Configuration Setting\nE.CWE-642:External Control of Critical State Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_15()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n strcpy(data, \"hostname\");\r\n break;\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n strcpy(data, \"hostname\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-15:External Control of System or Configuration Setting|E.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1220:Insufficient Granularity of Access Control\nB.CWE-704:Incorrect Type Conversion or Cast\nC.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nD.No Vulnerabilities\nE.CWE-834:Excessive Iteration\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_15()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n break;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_char_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-1236:Improper Neutralization of Formula Elements in a CSV File\nC.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nD.No Vulnerabilities\nE.CWE-271:Privilege Dropping / Lowering Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nint * My_int_realloc_68DataForMSink;\r\n\r\nint * My_int_realloc_68DataForNSink;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_realloc_68bSink();\r\n\r\nvoid My_int_realloc_68()\r\n{\r\n int * data;\r\n data = NULL; \r\n \r\n data = (int *)realloc(data, 1*sizeof(int));\r\n My_int_realloc_68DataForMSink = data;\r\n My_int_realloc_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_realloc_68bB2GSink();\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n data = NULL; \r\n \r\n data = (int *)realloc(data, 1*sizeof(int));\r\n My_int_realloc_68DataForNSink = data;\r\n My_int_realloc_68bB2GSink();\r\n}\r\n\r\nvoid My_int_realloc_68()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_realloc_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_realloc_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-690:Unchecked Return Value to NULL Pointer Dereference|A.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-510:Trapdoor\nC.CWE-357:Insufficient UI Warning of Dangerous Operations\nD.CWE-506:Embedded Malicious Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_ip_based_logic_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"192.168.30.123\", inet_ntoa(acceptService.sin_addr)) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_ip_based_logic_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_ip_based_logic_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_ip_based_logic_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|D.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-331:Insufficient Entropy\nB.CWE-1294:Insecure Security Identifier Mechanism\nC.CWE-506:Embedded Malicious Code\nD.CWE-511:Logic/Time Bomb\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define NUM_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_03()\r\n{\r\n if(5==5)\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_rand_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-511:Logic/Time Bomb|C.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-154:Improper Neutralization of Variable Name Delimiters\nB.CWE-344:Use of Invariant Value in Dynamically Changing Context\nC.No Vulnerabilities\nD.CWE-595:Comparison of Object References Instead of Object Contents\nE.CWE-587:Assignment of a Fixed Address to a Pointer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n \r\n char *charPointer = (char*)0x400000;\r\n printHexCharLine(*charPointer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n}\r\n\r\nvoid My_basic_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-587:Assignment of a Fixed Address to a Pointer|B.CWE-344:Use of Invariant Value in Dynamically Changing Context", "cwe": "587"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1299:Missing Protection Mechanism for Alternate Hardware Interface\nB.CWE-822:Untrusted Pointer Dereference\nC.CWE-1331:Improper Isolation of Shared Resources in Network On Chip (NoC)\nD.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint revenants_incorporator = 0;\r\n\r\nstruct malingerers_quasiperiodic \r\n{\r\n char *scramble_minimising;\r\n double discinoid_jenequen;\r\n char *bleck_limnobiological;\r\n char sillers_admired;\r\n int chorographical_squashberry;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *gonococcal_berdyayev);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\ntypedef int (*fct_ptr)(const char *, const char *);\r\nfct_ptr switch_func(char *param)\r\n{\r\n \r\n int var_len = 0;\r\n fct_ptr fct_ptr_addr = (fct_ptr )0;\r\n var_len = strlen(param) % 3;\r\n if (var_len == 0) {\r\n return strcmp;\r\n }\r\n else if (var_len == 1) {\r\n return strcoll;\r\n }\r\n else {\r\n sscanf(param,\"%p\",&fct_ptr_addr);\r\n return fct_ptr_addr;\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&revenants_incorporator,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *gonococcal_berdyayev)\r\n{\r\n int cmp_flag = 0;\r\n char *patella_whoremonger = 0;\r\n struct malingerers_quasiperiodic *rheumiest_sooky = {0};\r\n struct malingerers_quasiperiodic *prote_recelebrated = {0};\r\n struct malingerers_quasiperiodic aggregated_eliquation;\r\n ++global_variable;;\r\n if (gonococcal_berdyayev != 0) {;\r\n aggregated_eliquation . scramble_minimising = ((char *)gonococcal_berdyayev);\r\n rheumiest_sooky = &aggregated_eliquation;\r\n prote_recelebrated = rheumiest_sooky + 5;\r\n patella_whoremonger = ((char *)( *(prote_recelebrated - 5)) . scramble_minimising);\r\n \r\n \r\n \r\n fct_ptr fp;\r\n const char *rand_word = \"criticisms_metallide\";\r\n fp = switch_func(patella_whoremonger);\r\n \r\n \r\n \r\n \r\n cmp_flag = ( *fp)(rand_word,patella_whoremonger);\r\n \r\n if (cmp_flag == 0)\r\n printf(\"strings are equal\\n\");\r\n else\r\n printf(\"strings are not equal\\n\");\r\n \r\n;\r\n if (( *(prote_recelebrated - 5)) . scramble_minimising != 0) \r\n free(((char *)( *(prote_recelebrated - 5)) . scramble_minimising));\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-822:Untrusted Pointer Dereference|D.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer", "cwe": "822"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-588:Attempt to Access Child of a Non-structure Pointer\nC.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nD.CWE-605:Multiple Binds to the Same Port\nE.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_stat_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char filename[100] = \"\";\r\n struct STAT statBuffer;\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (STAT(filename, &statBuffer) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_stat_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_stat_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_stat_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|C.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nB.No Vulnerabilities\nC.CWE-173:Improper Handling of Alternate Encoding\nD.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nE.CWE-413:Improper Resource Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\ntypedef union\r\n{\r\n char * unionFirst;\r\n char * unionSecond;\r\n} My_w32_char_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_34()\r\n{\r\n char * password;\r\n My_w32_char_34_unionType myUnion;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n myUnion.unionFirst = password;\r\n {\r\n char * password = myUnion.unionSecond;\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n My_w32_char_34_unionType myUnion;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n myUnion.unionFirst = password;\r\n {\r\n char * password = myUnion.unionSecond;\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-591:Sensitive Data Storage in Improperly Locked Memory|E.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.No Vulnerabilities\nC.CWE-84:Improper Neutralization of Encoded URI Schemes in a Web Page\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.CWE-370:Missing Check for Certificate Revocation after Initial Check\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_char_connect_socket_ofstream_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_connect_socket_ofstream_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-36:Absolute Path Traversal|D.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.No Vulnerabilities\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-1056:Invokable Control Element with Variadic Parameters\nE.CWE-242:Use of Inherently Dangerous Function\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(int count)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_connect_socket_for_loop_21()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n mStatic = 1; \r\n mSink(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(int count)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n nB2G1Static = 0; \r\n nB2G1Sink(count);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(int count)\r\n{\r\n if(nB2G2Static)\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n nB2G2Static = 1; \r\n nB2G2Sink(count);\r\n}\r\n\r\n\r\nstatic void nG2BSink(int count)\r\n{\r\n if(nG2BStatic)\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n nG2BStatic = 1; \r\n nG2BSink(count);\r\n}\r\n\r\nvoid My_connect_socket_for_loop_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_for_loop_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_for_loop_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-400:Uncontrolled Resource Consumption|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-783:Operator Precedence Logic Error\nB.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.No Vulnerabilities\nE.CWE-654:Reliance on a Single Factor in a Security Decision\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#include <process.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_console_w32_spawnvp_13()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n _wspawnvp(_P_WAIT, COMMAND_INT, args);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n _wspawnvp(_P_WAIT, COMMAND_INT, args);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n _wspawnvp(_P_WAIT, COMMAND_INT, args);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_console_w32_spawnvp_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_console_w32_spawnvp_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_console_w32_spawnvp_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\nC.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nD.No Vulnerabilities\nE.CWE-686:Function Call With Incorrect Argument Type\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_10()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_short_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\nC.No Vulnerabilities\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-170:Improper Null Termination\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_class_calloc_67\r\n{\r\n\r\ntypedef struct _structType\r\n{\r\n TwoIntsClass * structFirst;\r\n} structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(structType myStruct);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n structType myStruct;\r\n \r\n data = NULL;\r\n \r\n data = (TwoIntsClass *)calloc(100, sizeof(TwoIntsClass));\r\n myStruct.structFirst = data;\r\n mSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n structType myStruct;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass[100];\r\n myStruct.structFirst = data;\r\n nG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid nB2GSink(structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n structType myStruct;\r\n \r\n data = NULL;\r\n \r\n data = (TwoIntsClass *)calloc(100, sizeof(TwoIntsClass));\r\n myStruct.structFirst = data;\r\n nB2GSink(myStruct);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_class_calloc_67; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1078:Inappropriate Source Code Style or Formatting\nB.No Vulnerabilities\nC.CWE-454:External Initialization of Trusted Variables or Data Stores\nD.CWE-546:Suspicious Comment\nE.CWE-1280:Access Control Check Implemented After Asset is Accessed\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_FIXME_18()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n \r\n printLine(\"Hello\");\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n printLine(\"Hello\");\r\n}\r\n\r\nvoid My_FIXME_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_FIXME_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_FIXME_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-546:Suspicious Comment|A.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-426:Untrusted Search Path\nB.CWE-464:Addition of Data Structure Sentinel\nC.CWE-462:Duplicate Key in Associative List (Alist)\nD.No Vulnerabilities\nE.CWE-673:External Influence of Sphere Definition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _wpopen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic wchar_t * mSource(wchar_t * data)\r\n{\r\n \r\n wcscpy(data, M_OS_COMMAND);\r\n return data;\r\n}\r\n\r\nvoid My_wchar_t_popen_42()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = mSource(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic wchar_t * nG2BSource(wchar_t * data)\r\n{\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n return data;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_popen_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_popen_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_popen_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-426:Untrusted Search Path|E.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1110:Incomplete Design Documentation\nC.CWE-126:Buffer Over-read\nD.CWE-788:Access of Memory Location After End of Buffer\nE.CWE-1039:Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE170_wchar_t_loop_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-126:Buffer Over-read|D.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-804:Guessable CAPTCHA\nC.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\nD.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nE.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n\r\n#pragma comment(lib, \"shlwapi\")\r\n\r\n#define M_PATH_SIZE (MAX_PATH / 2) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char path[M_PATH_SIZE];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(M_PATH_SIZE, path);\r\n if (length == 0 || length >= M_PATH_SIZE) \r\n {\r\n exit(1);\r\n }\r\n \r\n \r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printSizeTLine(strlen(path));\r\n printIntLine(M_PATH_SIZE);\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer|D.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cwe": "785"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.No Vulnerabilities\nC.CWE-427:Uncontrolled Search Path Element\nD.CWE-257:Storing Passwords in a Recoverable Format\nE.CWE-599:Missing Validation of OpenSSL Certificate\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH L\"%SystemRoot%\\\\system32\"\r\n#define PUTENV _wputenv\r\n#else\r\n#define NEW_PATH L\"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_file_13()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (250-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(250-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n wcscat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_wchar_t_file_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_file_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_file_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-427:Uncontrolled Search Path Element|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-457:Use of Uninitialized Variable\nB.No Vulnerabilities\nC.CWE-665:Improper Initialization\nD.CWE-1112:Incomplete Documentation of Program Execution\nE.CWE-289:Authentication Bypass by Alternate Name\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_new_double_array_partial_init_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n double * data;\r\n data = new double[10];\r\n if(staticTrue)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n double * data;\r\n data = new double[10];\r\n if(staticTrue)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n double * data;\r\n data = new double[10];\r\n if(staticTrue)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n double * data;\r\n data = new double[10];\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n double * data;\r\n data = new double[10];\r\n if(staticTrue)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_double_array_partial_init_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-457:Use of Uninitialized Variable|C.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-507:Trojan Horse\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-401:Missing Release of Memory after Effective Lifetime\nD.CWE-1252:CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_new_struct_twoIntsStruct_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n struct _twoIntsStruct * data;\r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n \r\n data = new struct _twoIntsStruct;\r\n \r\n data->intOne = 0;\r\n data->intTwo = 0;\r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n struct _twoIntsStruct * data;\r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n \r\n data = new struct _twoIntsStruct;\r\n \r\n data->intOne = 0;\r\n data->intTwo = 0;\r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n struct _twoIntsStruct * data;\r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n \r\n data = new struct _twoIntsStruct;\r\n \r\n data->intOne = 0;\r\n data->intTwo = 0;\r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n struct _twoIntsStruct * data;\r\n data = NULL;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n struct _twoIntsStruct dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n data->intOne = 0;\r\n data->intTwo = 0;\r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n struct _twoIntsStruct * data;\r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n \r\n struct _twoIntsStruct dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n data->intOne = 0;\r\n data->intTwo = 0;\r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_struct_twoIntsStruct_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-401:Missing Release of Memory after Effective Lifetime|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-282:Improper Ownership Management\nC.CWE-1247:Improper Protection Against Voltage and Clock Glitches\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-415:Double Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int * data)\r\n{\r\n \r\n free(data);\r\n}\r\n\r\nvoid My_malloc_free_int_41()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(int * data)\r\n{\r\n \r\n free(data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n \r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(int * data)\r\n{\r\n \r\n \r\n ; \r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n nB2GSink(data);\r\n}\r\n\r\nvoid My_malloc_free_int_41()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_int_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_int_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-415:Double Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-397:Declaration of Throws for Generic Exception\nB.CWE-164:Improper Neutralization of Internal Special Elements\nC.No Vulnerabilities\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-285:Improper Authorization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std; \r\n\r\nnamespace My_throw_exception_03\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(5==5)\r\n {\r\n \r\n throw exception();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_throw_exception_03; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-397:Declaration of Throws for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "397"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-588:Attempt to Access Child of a Non-structure Pointer\nB.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nC.CWE-704:Incorrect Type Conversion or Cast\nD.No Vulnerabilities\nE.CWE-1323:Improper Management of Sensitive Trace Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_struct_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_struct_64()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n My_struct_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_struct_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n My_struct_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_struct_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-588:Attempt to Access Child of a Non-structure Pointer|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-311:Missing Encryption of Sensitive Data\nB.No Vulnerabilities\nC.CWE-319:Cleartext Transmission of Sensitive Information\nD.CWE-1304:Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_listen_socket_18()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n goto source;\r\nsource:\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n goto source;\r\nsource:\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n goto source;\r\nsource:\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n goto sink;\r\nsink:\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-319:Cleartext Transmission of Sensitive Information|A.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.No Vulnerabilities\nC.CWE-788:Access of Memory Location After End of Buffer\nD.CWE-685:Function Call With Incorrect Number of Arguments\nE.CWE-692:Incomplete Denylist to Cross-Site Scripting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\ntypedef struct _My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_CWE129_connect_socket_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|C.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.No Vulnerabilities\nC.CWE-698:Execution After Redirect (EAR)\nD.CWE-789:Memory Allocation with Excessive Size Value\nE.CWE-93:Improper Neutralization of CRLF Sequences ('CRLF Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\ntypedef struct _My_malloc_wchar_t_fgets_67_structType\r\n{\r\n size_t structFirst;\r\n} My_malloc_wchar_t_fgets_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_malloc_wchar_t_fgets_67bSink(My_malloc_wchar_t_fgets_67_structType myStruct);\r\n\r\nvoid My_malloc_wchar_t_fgets_67()\r\n{\r\n size_t data;\r\n My_malloc_wchar_t_fgets_67_structType myStruct;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n myStruct.structFirst = data;\r\n My_malloc_wchar_t_fgets_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_malloc_wchar_t_fgets_67bG2BSink(My_malloc_wchar_t_fgets_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n My_malloc_wchar_t_fgets_67_structType myStruct;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n myStruct.structFirst = data;\r\n My_malloc_wchar_t_fgets_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_malloc_wchar_t_fgets_67bB2GSink(My_malloc_wchar_t_fgets_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n My_malloc_wchar_t_fgets_67_structType myStruct;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n myStruct.structFirst = data;\r\n My_malloc_wchar_t_fgets_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_malloc_wchar_t_fgets_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_fgets_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_fgets_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-789:Memory Allocation with Excessive Size Value|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-675:Multiple Operations on Resource in Single-Operation Context\nC.CWE-143:Improper Neutralization of Record Delimiters\nD.CWE-573:Improper Following of Specification by Caller\nE.CWE-472:External Control of Assumed-Immutable Web Parameter\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_freopen_66bSink(FILE * dataArray[]);\r\n\r\nvoid My_freopen_66()\r\n{\r\n FILE * data;\r\n FILE * dataArray[5];\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n \r\n dataArray[2] = data;\r\n My_freopen_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_freopen_66bG2BSink(FILE * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n FILE * data;\r\n FILE * dataArray[5];\r\n data = NULL; \r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n dataArray[2] = data;\r\n My_freopen_66bG2BSink(dataArray);\r\n}\r\n\r\n\r\nvoid My_freopen_66bB2GSink(FILE * dataArray[]);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n FILE * dataArray[5];\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n dataArray[2] = data;\r\n My_freopen_66bB2GSink(dataArray);\r\n}\r\n\r\nvoid My_freopen_66()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-675:Multiple Operations on Resource in Single-Operation Context|D.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-395:Use of NullPointerException Catch to Detect NULL Pointer Dereference\nB.CWE-462:Duplicate Key in Associative List (Alist)\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-400:Uncontrolled Resource Consumption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_sleep_03()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5==5)\r\n {\r\n \r\n count = RAND32();\r\n }\r\n if(5==5)\r\n {\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5==5)\r\n {\r\n \r\n count = RAND32();\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5==5)\r\n {\r\n \r\n count = RAND32();\r\n }\r\n if(5==5)\r\n {\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n count = 20;\r\n }\r\n if(5==5)\r\n {\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5==5)\r\n {\r\n \r\n count = 20;\r\n }\r\n if(5==5)\r\n {\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n }\r\n}\r\n\r\nvoid My_rand_sleep_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_sleep_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_sleep_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-400:Uncontrolled Resource Consumption|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-15:External Control of System or Configuration Setting\nB.CWE-241:Improper Handling of Unexpected Data Type\nC.CWE-642:External Control of Critical State Data\nD.No Vulnerabilities\nE.CWE-554:ASP.NET Misconfiguration: Not Using Input Validation Framework\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_w32_64()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"hostname\");\r\n My_w32_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_w32_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-15:External Control of System or Configuration Setting|C.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1053:Missing Documentation for Design\nB.CWE-665:Improper Initialization\nC.No Vulnerabilities\nD.CWE-1125:Excessive Attack Surface\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_cat_05()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n ; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_cat_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_cat_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_cat_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1079:Parent Class without Virtual Destructor Method\nB.CWE-252:Unchecked Return Value\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-143:Improper Neutralization of Record Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_fputs_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n fputws(L\"string\", stdout);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (fputws(L\"string\", stdout) == WEOF)\r\n {\r\n printLine(\"fputws failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n if (fputws(L\"string\", stdout) == WEOF)\r\n {\r\n printLine(\"fputws failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_fputs_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_fputs_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_fputs_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1296:Incorrect Chaining or Granularity of Debug Components\nB.CWE-124:Buffer Underwrite ('Buffer Underflow')\nC.CWE-777:Regular Expression without Anchors\nD.No Vulnerabilities\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nchar * My_char_declare_loop_68Data;\r\nchar * My_char_declare_loop_68G2BData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_declare_loop_68bSink();\r\n\r\nvoid My_char_declare_loop_68()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n My_char_declare_loop_68Data = data;\r\n My_char_declare_loop_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_declare_loop_68bG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n My_char_declare_loop_68G2BData = data;\r\n My_char_declare_loop_68bG2BSink();\r\n}\r\n\r\nvoid My_char_declare_loop_68()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_loop_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_loop_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-124:Buffer Underwrite ('Buffer Underflow')|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-232:Improper Handling of Undefined Values\nC.CWE-710:Improper Adherence to Coding Standards\nD.No Vulnerabilities\nE.CWE-444:Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double_pointer_alloca_use_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n double * * pointer = (double * *)ALLOCA(sizeof(double *));\r\n double * data = *pointer; \r\n printDoubleLine(*data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n double * data;\r\n double * * pointer = (double * *)ALLOCA(sizeof(double *));\r\n \r\n data = (double *)malloc(sizeof(double));\r\n if (data == NULL) {exit(-1);}\r\n *data = 5.0;\r\n *pointer = data; \r\n {\r\n double * data = *pointer;\r\n printDoubleLine(*data);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double_pointer_alloca_use_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double_pointer_alloca_use_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double_pointer_alloca_use_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-1265:Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\nC.CWE-128:Wrap-around Error\nD.No Vulnerabilities\nE.CWE-789:Memory Allocation with Excessive Size Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING \"hello\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_char_fgets_04()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = (char *)malloc(data*sizeof(char));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (char *)malloc(data*sizeof(char));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (char *)malloc(data*sizeof(char));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = (char *)malloc(data*sizeof(char));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 20;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = (char *)malloc(data*sizeof(char));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_malloc_char_fgets_04()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_char_fgets_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_char_fgets_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-789:Memory Allocation with Excessive Size Value|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-191:Integer Underflow (Wrap or Wraparound)\nD.CWE-611:Improper Restriction of XML External Entity Reference\nE.CWE-1059:Insufficient Technical Documentation\n", "input": "\r\n\r\n\r\n#include <inttypes.h>\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int64_t_fscanf_sub_32()\r\n{\r\n int64_t data;\r\n int64_t *dataPtr1 = &data;\r\n int64_t *dataPtr2 = &data;\r\n data = 0LL;\r\n {\r\n int64_t data = *dataPtr1;\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int64_t data = *dataPtr2;\r\n {\r\n \r\n int64_t result = data - 1;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t data;\r\n int64_t *dataPtr1 = &data;\r\n int64_t *dataPtr2 = &data;\r\n data = 0LL;\r\n {\r\n int64_t data = *dataPtr1;\r\n \r\n data = -2;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int64_t data = *dataPtr2;\r\n {\r\n \r\n int64_t result = data - 1;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t data;\r\n int64_t *dataPtr1 = &data;\r\n int64_t *dataPtr2 = &data;\r\n data = 0LL;\r\n {\r\n int64_t data = *dataPtr1;\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int64_t data = *dataPtr2;\r\n \r\n if (data > LLONG_MIN)\r\n {\r\n int64_t result = data - 1;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform subtraction.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_int64_t_fscanf_sub_32()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_fscanf_sub_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_fscanf_sub_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-191:Integer Underflow (Wrap or Wraparound)|B.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-150:Improper Neutralization of Escape, Meta, or Control Sequences\nB.CWE-396:Declaration of Catch for Generic Exception\nC.CWE-705:Incorrect Control Flow Scoping\nD.CWE-352:Cross-Site Request Forgery (CSRF)\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_dotdotdot_09\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (...)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_dotdotdot_09; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-396:Declaration of Catch for Generic Exception|C.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-391:Unchecked Error Condition\nB.CWE-15:External Control of System or Configuration Setting\nC.No Vulnerabilities\nD.CWE-642:External Control of Critical State Data\nE.CWE-1328:Security Version Number Mutable to Older Versions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_09()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-15:External Control of System or Configuration Setting|D.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-391:Unchecked Error Condition\nB.CWE-1063:Creation of Class Instance within a Static Code Block\nC.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wcstombs_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wcstombs_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wcstombs_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wcstombs_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-391:Unchecked Error Condition|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-1240:Use of a Cryptographic Primitive with a Risky Implementation\nD.No Vulnerabilities\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_int_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n goto source;\r\nsource:\r\n data = new int[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n delete [] data;\r\n goto sink;\r\nsink:\r\n \r\n printIntLine(data[0]);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n goto source;\r\nsource:\r\n data = new int[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n delete [] data;\r\n goto sink;\r\nsink:\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n goto source;\r\nsource:\r\n data = new int[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n goto sink;\r\nsink:\r\n \r\n printIntLine(data[0]);\r\n \r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_int_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-457:Use of Uninitialized Variable\nB.CWE-636:Not Failing Securely ('Failing Open')\nC.No Vulnerabilities\nD.CWE-665:Improper Initialization\nE.CWE-648:Incorrect Use of Privileged APIs\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_array_declare_no_init_02()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(1)\r\n {\r\n \r\n ; \r\n }\r\n if(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(1)\r\n {\r\n \r\n ; \r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(1)\r\n {\r\n \r\n ; \r\n }\r\n if(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n }\r\n if(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n }\r\n if(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_array_declare_no_init_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_array_declare_no_init_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_array_declare_no_init_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-457:Use of Uninitialized Variable|D.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1109:Use of Same Variable for Multiple Purposes\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-1075:Unconditional Control Flow Transfer outside of Switch Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_w32CloseHandle_07()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticFive==5)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticFive==5)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_w32CloseHandle_07()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_w32CloseHandle_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_w32CloseHandle_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-113:Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\nB.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nC.CWE-749:Exposed Dangerous Method or Function\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_51\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<int> data);\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<int> data);\r\nvoid nB2GSink(list<int> data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n nB2GSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_51; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-672:Operation on a Resource after Expiration or Release|B.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-354:Improper Validation of Integrity Check Value\nB.CWE-416:Use After Free\nC.No Vulnerabilities\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-187:Partial String Comparison\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_char_64\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(void * dataVoidPtr);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = new char;\r\n *data = 'A';\r\n \r\n delete data;\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = new char;\r\n *data = 'A';\r\n \r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(void * dataVoidPtr);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = new char;\r\n *data = 'A';\r\n \r\n delete data;\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_char_64; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-434:Unrestricted Upload of File with Dangerous Type\nD.CWE-834:Excessive Iteration\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic wchar_t * mSource(wchar_t * data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (256-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_w32_wchar_t_file_21()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n mStatic = 1; \r\n data = mSource(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic wchar_t * nG2B1Source(wchar_t * data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic wchar_t * nG2B2Source(wchar_t * data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_file_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_file_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_file_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-804:Guessable CAPTCHA\nC.No Vulnerabilities\nD.CWE-448:Obsolete Feature in UI\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nusing namespace std;\r\n\r\nnamespace My_fgets_strncpy_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, int> dataMap);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, int> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fgets_strncpy_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-427:Uncontrolled Search Path Element\nB.CWE-1048:Invokable Control Element with Large Number of Outward Calls\nC.No Vulnerabilities\nD.CWE-158:Improper Neutralization of Null Byte or NUL Character\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH L\"%SystemRoot%\\\\system32\"\r\n#define PUTENV _wputenv\r\n#else\r\n#define NEW_PATH L\"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_listen_socket_08()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n wcscat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_wchar_t_listen_socket_08()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_listen_socket_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_listen_socket_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-427:Uncontrolled Search Path Element|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1260:Improper Handling of Overlap Between Protected Memory Ranges\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-153:Improper Neutralization of Substitution Characters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_int64_t_realloc_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_delete_int64_t_realloc_83\r\n{\r\npublic:\r\n My_delete_int64_t_realloc_83(int64_t * dataCopy);\r\n ~My_delete_int64_t_realloc_83();\r\n\r\nprivate:\r\n int64_t * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_delete_int64_t_realloc_83G2B\r\n{\r\npublic:\r\n My_delete_int64_t_realloc_83G2B(int64_t * dataCopy);\r\n ~My_delete_int64_t_realloc_83G2B();\r\n\r\nprivate:\r\n int64_t * data;\r\n};\r\n\r\nclass My_delete_int64_t_realloc_83B2G\r\n{\r\npublic:\r\n My_delete_int64_t_realloc_83B2G(int64_t * dataCopy);\r\n ~My_delete_int64_t_realloc_83B2G();\r\n\r\nprivate:\r\n int64_t * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-1191:On-Chip Debug and Test Interface With Improper Access Control\nC.No Vulnerabilities\nD.CWE-617:Reachable Assertion\nE.CWE-1317:Improper Access Control in Fabric Bridge\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\nusing namespace std;\r\n\r\nnamespace My_rand_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int> dataVector);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<int> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_rand_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-617:Reachable Assertion|A.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-912:Hidden Functionality\nC.CWE-126:Buffer Over-read\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_declare_memmove_18()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n goto source;\r\nsource:\r\n \r\n data = dataMBuffer;\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n goto source;\r\nsource:\r\n \r\n data = dataNBuffer;\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_declare_memmove_18()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_declare_memmove_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_declare_memmove_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-792:Incomplete Filtering of One or More Instances of Special Elements\nB.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-23:Relative Path Traversal\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifdef _WIN32\r\n#define FOPEN fopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_char_connect_socket_fopen_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_connect_socket_fopen_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-23:Relative Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-780:Use of RSA Algorithm without OAEP\nB.CWE-1056:Invokable Control Element with Variadic Parameters\nC.No Vulnerabilities\nD.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nE.CWE-40:Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"String to be encrypted\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-780:Use of RSA Algorithm without OAEP|D.CWE-327:Use of a Broken or Risky Cryptographic Algorithm", "cwe": "780"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-761:Free of Pointer not at Start of Buffer\nB.No Vulnerabilities\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-104:Struts: Form Bean Does Not Extend Validation Class\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define M_SOURCE_FIXED_STRING \"Fixed String\" \r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\nvoid My_char_fixed_string_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n \r\n strcpy(data, M_SOURCE_FIXED_STRING);\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2GSink(char * data)\r\n{\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nB2GSink;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n \r\n strcpy(data, M_SOURCE_FIXED_STRING);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_fixed_string_44()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fixed_string_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fixed_string_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-761:Free of Pointer not at Start of Buffer|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-341:Predictable from Observable State\nC.No Vulnerabilities\nD.CWE-682:Incorrect Calculation\nE.CWE-642:External Control of Critical State Data\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint paraders_nonsubstitutive = 0;\r\nint global_variable;\r\n\r\nunion cinchonia_contriturate \r\n{\r\n char *vagrance_scutch;\r\n double wodeleie_visually;\r\n char *isobathic_mirly;\r\n char pamprodactylism_hole;\r\n int beetlike_singhal;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid ramean_androdynamous(int moonish_instantiate,union cinchonia_contriturate *unscarred_apreynte);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int desmotropic_pseudocarcinoid = 7;\r\n union cinchonia_contriturate *endodontically_pliability = {0};\r\n union cinchonia_contriturate novendial_equimolar;\r\n int myoneuralgia_prepuces = 5;\r\n char *urethrovesical_concaptive;;\r\n if (__sync_bool_compare_and_swap(&paraders_nonsubstitutive,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&urethrovesical_concaptive,\"1993\",myoneuralgia_prepuces);\r\n if (urethrovesical_concaptive != 0) {;\r\n novendial_equimolar . vagrance_scutch = urethrovesical_concaptive;\r\n endodontically_pliability = &novendial_equimolar;\r\n ramean_androdynamous(desmotropic_pseudocarcinoid,endodontically_pliability);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid ramean_androdynamous(int moonish_instantiate,union cinchonia_contriturate *unscarred_apreynte)\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *itabuna_anchusins = 0;\r\n ++global_variable;\r\n moonish_instantiate--;\r\n if (moonish_instantiate > 0) {\r\n ramean_androdynamous(moonish_instantiate,unscarred_apreynte);\r\n return ;\r\n }\r\n itabuna_anchusins = ((char *)( *unscarred_apreynte) . vagrance_scutch);\r\n \r\n input = atoi(itabuna_anchusins);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\n if (( *unscarred_apreynte) . vagrance_scutch != 0) \r\n free(((char *)( *unscarred_apreynte) . vagrance_scutch));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|D.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1392:Use of Default Credentials\nB.CWE-185:Incorrect Regular Expression\nC.CWE-821:Incorrect Synchronization\nD.No Vulnerabilities\nE.CWE-284:Improper Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n#include <shlwapi.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_SHRegCreateUSKey_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_ALL_ACCESS,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_SHRegCreateUSKey_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_SHRegCreateUSKey_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_SHRegCreateUSKey_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-284:Improper Access Control|B.CWE-185:Incorrect Regular Expression", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-768:Incorrect Short Circuit Evaluation\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.No Vulnerabilities\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.CWE-391:Unchecked Error Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING \"hello\"\r\n\r\nnamespace My_new_char_fscanf_14\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalFive==5)\r\n {\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalFive==5)\r\n {\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n }\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalFive==5)\r\n {\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(globalFive==5)\r\n {\r\n \r\n data = 20;\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_fscanf_14; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-426:Untrusted Search Path\nB.CWE-393:Return of Wrong Status Code\nC.CWE-1252:CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\nD.CWE-673:External Influence of Sphere Definition\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\nnamespace My_wchar_t_popen_81\r\n{\r\n\r\nclass My_wchar_t_popen_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_wchar_t_popen_81 : public My_wchar_t_popen_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_wchar_t_popen_81G2B : public My_wchar_t_popen_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-426:Untrusted Search Path|D.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-231:Improper Handling of Extra Values\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-448:Obsolete Feature in UI\nD.CWE-377:Insecure Temporary File\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define MKTEMP _wmktemp\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#endif\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_mktemp_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_mktemp_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_mktemp_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_mktemp_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-377:Insecure Temporary File|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-832:Unlock of a Resource that is not Locked\nB.CWE-667:Improper Locking\nC.No Vulnerabilities\nD.CWE-1087:Class with Virtual Method without a Virtual Destructor\nE.CWE-351:Insufficient Type Distinction\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-832:Unlock of a Resource that is not Locked|B.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-553:Command Shell in Externally Accessible Directory\nC.No Vulnerabilities\nD.CWE-912:Hidden Functionality\nE.CWE-210:Self-generated Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_file_attrib_modified_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n FILETIME ftModified;\r\n ULONGLONG qwResult;\r\n HANDLE hFile = INVALID_HANDLE_VALUE;\r\n do\r\n {\r\n hFile = CreateFile(TEXT(\"mFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE, \r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n break;\r\n }\r\n if (GetFileTime(hFile,\r\n NULL,\r\n NULL,\r\n &ftModified) == 0)\r\n {\r\n break;\r\n }\r\n \r\n qwResult -= 10 * _DAY;\r\n \r\n ftModified.dwLowDateTime = (DWORD)(qwResult & 0xFFFFFFFF);\r\n ftModified.dwHighDateTime = (DWORD)(qwResult >> 32);\r\n \r\n SetFileTime(hFile,\r\n (LPFILETIME)NULL,\r\n (LPFILETIME)NULL,\r\n &ftModified);\r\n }\r\n while (0);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_file_attrib_modified_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_file_attrib_modified_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_file_attrib_modified_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-506:Embedded Malicious Code|D.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-481:Assigning instead of Comparing\nB.CWE-480:Use of Incorrect Operator\nC.No Vulnerabilities\nD.CWE-511:Logic/Time Bomb\nE.CWE-492:Use of Inner Class Containing Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int intRand = rand();\r\n \r\n if(intRand = 5)\r\n {\r\n printLine(\"i was 5\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intRand = rand();\r\n \r\n if(intRand == 5)\r\n {\r\n printLine(\"i was 5\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int intRand = rand();\r\n \r\n if(intRand == 5)\r\n {\r\n printLine(\"i was 5\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-481:Assigning instead of Comparing|B.CWE-480:Use of Incorrect Operator", "cwe": "481"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-134:Use of Externally-Controlled Format String\nD.CWE-698:Execution After Redirect (EAR)\nE.CWE-708:Incorrect Ownership Assignment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_console_printf_54bSink(char * data);\r\n\r\nvoid My_char_console_printf_54()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n My_char_console_printf_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_console_printf_54bG2BSink(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n My_char_console_printf_54bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_char_console_printf_54bB2GSink(char * data);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n My_char_console_printf_54bB2GSink(data);\r\n}\r\n\r\nvoid My_char_console_printf_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_printf_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_printf_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-134:Use of Externally-Controlled Format String|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nC.CWE-1239:Improper Zeroization of Hardware Register\nD.CWE-771:Missing Reference to Active Allocated Resource\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_file_31()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (256-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n {\r\n wchar_t * dataCopy = data;\r\n wchar_t * data = dataCopy;\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n {\r\n wchar_t * dataCopy = data;\r\n wchar_t * data = dataCopy;\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_file_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_file_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_file_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-761:Free of Pointer not at Start of Buffer\nB.No Vulnerabilities\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-75:Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)\nE.CWE-148:Improper Neutralization of Input Leaders\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_wchar_t_file_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<wchar_t *> dataList);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(list<wchar_t *> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_file_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-761:Free of Pointer not at Start of Buffer|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-612:Improper Authorization of Index Containing Sensitive Information\nE.CWE-708:Incorrect Ownership Assignment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_environment_ifstream_02\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_ifstream_02; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-23:Relative Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.No Vulnerabilities\nC.CWE-122:Heap-based Buffer Overflow\nD.CWE-511:Logic/Time Bomb\nE.CWE-135:Incorrect Calculation of Multi-Byte String Length\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_cpp_My_cpp_CWE805_char_memcpy_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-122:Heap-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.No Vulnerabilities\nC.CWE-420:Unprotected Alternate Channel\nD.CWE-570:Expression is Always False\nE.CWE-121:Stack-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define SNPRINTF _snwprintf\r\n#else\r\n#define SNPRINTF swprintf\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_My_My_My_My_CWE806_wchar_t_alloca_snprintf_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-121:Stack-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-392:Missing Report of Error Condition\nB.CWE-916:Use of Password Hash With Insufficient Computational Effort\nC.CWE-1284:Improper Validation of Specified Quantity in Input\nD.No Vulnerabilities\nE.CWE-606:Unchecked Input for Loop Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_environment_53bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_environment_53()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n My_wchar_t_environment_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_environment_53bG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"15\");\r\n My_wchar_t_environment_53bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_wchar_t_environment_53bB2GSink(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n My_wchar_t_environment_53bB2GSink(data);\r\n}\r\n\r\nvoid My_wchar_t_environment_53()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_environment_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_environment_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-606:Unchecked Input for Loop Condition|C.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-325:Missing Cryptographic Step\nC.CWE-195:Signed to Unsigned Conversion Error\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-50:Path Equivalence: '//multiple/leading/slash'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _My_rand_malloc_67_structType\r\n{\r\n int structFirst;\r\n} My_rand_malloc_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_rand_malloc_67bSink(My_rand_malloc_67_structType myStruct);\r\n\r\nvoid My_rand_malloc_67()\r\n{\r\n int data;\r\n My_rand_malloc_67_structType myStruct;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n myStruct.structFirst = data;\r\n My_rand_malloc_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_rand_malloc_67bG2BSink(My_rand_malloc_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_rand_malloc_67_structType myStruct;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n myStruct.structFirst = data;\r\n My_rand_malloc_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_rand_malloc_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_malloc_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_malloc_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-195:Signed to Unsigned Conversion Error|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-662:Improper Synchronization\nB.CWE-486:Comparison of Classes by Name\nC.CWE-153:Improper Neutralization of Substitution Characters\nD.CWE-667:Improper Locking\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-667:Improper Locking|A.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-123:Write-what-where Condition\nC.No Vulnerabilities\nD.CWE-1224:Improper Restriction of Write-Once Bit Fields\nE.CWE-520:.NET Misconfiguration: Use of Impersonation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(mStruct data)\r\n{\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_44()\r\n{\r\n mStruct data;\r\n \r\n void (*funcPtr) (mStruct) = mSink;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(mStruct data)\r\n{\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n void (*funcPtr) (mStruct) = nG2BSink;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n funcPtr(data);\r\n}\r\n\r\nvoid My_connect_socket_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|A.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.No Vulnerabilities\nC.CWE-149:Improper Neutralization of Quoting Syntax\nD.CWE-467:Use of sizeof() on a Pointer Type\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<int> * dataPtr);\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<int> * data);\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<int> * data);\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-672:Operation on a Resource after Expiration or Release|E.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-780:Use of RSA Algorithm without OAEP\nB.CWE-291:Reliance on IP Address for Authentication\nC.No Vulnerabilities\nD.CWE-64:Windows Shortcut Following (.LNK)\nE.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"String to be encrypted\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-780:Use of RSA Algorithm without OAEP|E.CWE-327:Use of a Broken or Risky Cryptographic Algorithm", "cwe": "780"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1188:Initialization of a Resource with an Insecure Default\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-188:Reliance on Data/Memory Layout\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#include <process.h>\r\n#define EXECVP _execvp\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic char * mSource(char * data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_char_console_w32_execvp_21()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n mStatic = 1; \r\n data = mSource(data);\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic char * nG2B1Source(char * data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\n\r\nstatic char * nG2B2Source(char * data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\nvoid My_char_console_w32_execvp_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_w32_execvp_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_w32_execvp_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1050:Excessive Platform Resource Consumption within a Loop\nC.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nD.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nE.CWE-605:Multiple Binds to the Same Port\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n#ifdef _WIN32\r\n BOOL bOptVal = TRUE;\r\n int bOptLen = sizeof(BOOL);\r\n#else\r\n int bOptVal = 1;\r\n int bOptLen = sizeof(int);\r\n#endif\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-605:Multiple Binds to the Same Port|D.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "605"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.No Vulnerabilities\nC.CWE-1086:Class with Excessive Number of Child Classes\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_listen_socket_sleep_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_listen_socket_sleep_83\r\n{\r\npublic:\r\n My_listen_socket_sleep_83(int countCopy);\r\n ~My_listen_socket_sleep_83();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_listen_socket_sleep_83G2B\r\n{\r\npublic:\r\n My_listen_socket_sleep_83G2B(int countCopy);\r\n ~My_listen_socket_sleep_83G2B();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\nclass My_listen_socket_sleep_83B2G\r\n{\r\npublic:\r\n My_listen_socket_sleep_83B2G(int countCopy);\r\n ~My_listen_socket_sleep_83B2G();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-150:Improper Neutralization of Escape, Meta, or Control Sequences\nB.CWE-73:External Control of File Name or Path\nC.No Vulnerabilities\nD.CWE-334:Small Space of Random Values\nE.CWE-114:Process Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\n#ifndef OMITM\r\n\r\n\r\nchar * My_w32_char_connect_socket_61bSource(char * data);\r\n\r\nvoid My_w32_char_connect_socket_61()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n data = My_w32_char_connect_socket_61bSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nchar * My_w32_char_connect_socket_61bG2BSource(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n data = My_w32_char_connect_socket_61bG2BSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_connect_socket_61()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_connect_socket_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_connect_socket_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-114:Process Control|B.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-610:Externally Controlled Reference to a Resource in Another Sphere\nC.CWE-341:Predictable from Observable State\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-259:Use of Hard-coded Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_66bSink(char * passwordArray[]);\r\n\r\nvoid My_w32_char_66()\r\n{\r\n char * password;\r\n char * passwordArray[5];\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n \r\n strcpy(password, PASSWORD);\r\n \r\n passwordArray[2] = password;\r\n My_w32_char_66bSink(passwordArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_66bG2BSink(char * passwordArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n char * passwordArray[5];\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n passwordArray[2] = password;\r\n My_w32_char_66bG2BSink(passwordArray);\r\n}\r\n\r\nvoid My_w32_char_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-259:Use of Hard-coded Password|D.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-69:Improper Handling of Windows ::DATA Alternate Data Stream\nB.No Vulnerabilities\nC.CWE-469:Use of Pointer Subtraction to Determine Size\nD.CWE-76:Improper Neutralization of Equivalent Special Elements\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SOURCE_STRING \"abc/opqrstu\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char string2[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string2);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-469:Use of Pointer Subtraction to Determine Size|E.CWE-682:Incorrect Calculation", "cwe": "469"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.CWE-248:Uncaught Exception\nC.No Vulnerabilities\nD.CWE-1279:Cryptographic Operations are run Before Supporting Units are Ready\nE.CWE-321:Use of Hard-coded Cryptographic Key\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_14()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalFive==5)\r\n {\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalFive==5)\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-321:Use of Hard-coded Cryptographic Key|A.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1285:Improper Validation of Specified Index, Position, or Offset in Input\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-111:Direct Use of Unsafe JNI\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_struct_realloc_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_delete_struct_realloc_84\r\n{\r\npublic:\r\n My_delete_struct_realloc_84(twoIntsStruct * dataCopy);\r\n ~My_delete_struct_realloc_84();\r\n\r\nprivate:\r\n twoIntsStruct * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_delete_struct_realloc_84G2B\r\n{\r\npublic:\r\n My_delete_struct_realloc_84G2B(twoIntsStruct * dataCopy);\r\n ~My_delete_struct_realloc_84G2B();\r\n\r\nprivate:\r\n twoIntsStruct * data;\r\n};\r\n\r\nclass My_delete_struct_realloc_84B2G\r\n{\r\npublic:\r\n My_delete_struct_realloc_84B2G(twoIntsStruct * dataCopy);\r\n ~My_delete_struct_realloc_84B2G();\r\n\r\nprivate:\r\n twoIntsStruct * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1103:Use of Platform-Dependent Third Party Components\nB.CWE-1220:Insufficient Granularity of Access Control\nC.No Vulnerabilities\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.CWE-789:Memory Allocation with Excessive Size Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic size_t mSource(size_t data)\r\n{\r\n \r\n data = rand();\r\n return data;\r\n}\r\n\r\nvoid My_malloc_wchar_t_rand_42()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n data = mSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic size_t nG2BSource(size_t data)\r\n{\r\n \r\n data = 20;\r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n data = nG2BSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic size_t nB2GSource(size_t data)\r\n{\r\n \r\n data = rand();\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n data = nB2GSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_rand_42()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_rand_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_rand_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-789:Memory Allocation with Excessive Size Value|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-733:Compiler Optimization Removal or Modification of Security-critical Code\nB.CWE-284:Improper Access Control\nC.No Vulnerabilities\nD.CWE-1258:Exposure of Sensitive System Information Due to Uncleared Debug Information\nE.CWE-1220:Insufficient Granularity of Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n#define BUFSIZE 1024\r\n#define PIPE_NAME L\"\\\\\\\\.\\\\pipe\\\\TestPipe\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateNamedPipe_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n HANDLE hPipe;\r\n wchar_t * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeW(\r\n pipeName,\r\n PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n HANDLE hPipe;\r\n wchar_t * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeW(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE | PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateNamedPipe_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateNamedPipe_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateNamedPipe_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-284:Improper Access Control|E.CWE-1220:Insufficient Granularity of Access Control", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-705:Incorrect Control Flow Scoping\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.CWE-1341:Multiple Releases of Same Resource or Handle\nD.CWE-252:Unchecked Return Value\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_calloc_02()\r\n{\r\n char * data;\r\n data = NULL; \r\n \r\n data = (char *)calloc(20, sizeof(char));\r\n if(1)\r\n {\r\n \r\n strcpy(data, \"Initialize\");\r\n printLine(data);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = NULL; \r\n \r\n data = (char *)calloc(20, sizeof(char));\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n strcpy(data, \"Initialize\");\r\n printLine(data);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = NULL; \r\n \r\n data = (char *)calloc(20, sizeof(char));\r\n if(1)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n strcpy(data, \"Initialize\");\r\n printLine(data);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_calloc_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_calloc_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_calloc_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-690:Unchecked Return Value to NULL Pointer Dereference|D.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-472:External Control of Assumed-Immutable Web Parameter\nB.CWE-342:Predictable Exact Value from Previous Values\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-480:Use of Incorrect Operator\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic char* staticStringM = \"Hello\";\r\nstatic char* staticStringN = \"Hello\";\r\n\r\nstatic char * helperM()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringM;\r\n }\r\n}\r\n\r\nstatic char * helperN()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringN;\r\n }\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n if(helperM == NULL)\r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n if(helperN() == NULL) \r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-480:Use of Incorrect Operator|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "480"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1188:Initialization of a Resource with an Insecure Default\nB.CWE-703:Improper Check or Handling of Exceptional Conditions\nC.CWE-563:Assignment to Variable without Use\nD.No Vulnerabilities\nE.CWE-1164:Irrelevant Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_value_int_04()\r\n{\r\n int data;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 5;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 10;\r\n printIntLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 5;\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printIntLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 5;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 5;\r\n printIntLine(data);\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 10;\r\n printIntLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 5;\r\n printIntLine(data);\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 10;\r\n printIntLine(data);\r\n }\r\n}\r\n\r\nvoid My_unused_value_int_04()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_value_int_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_value_int_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-563:Assignment to Variable without Use|E.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-793:Only Filtering One Instance of a Special Element\nB.CWE-1043:Data Element Aggregating an Excessively Large Number of Non-Primitive Elements\nC.CWE-763:Release of Invalid Pointer or Reference\nD.No Vulnerabilities\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_wchar_t_calloc_02\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(1)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(1)\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new wchar_t[100];\r\n }\r\n if(1)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n \r\n data = new wchar_t[100];\r\n }\r\n if(1)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_wchar_t_calloc_02; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-234:Failure to Handle Missing Parameter\nB.CWE-1338:Improper Protections Against Hardware Overheating\nC.CWE-771:Missing Reference to Active Allocated Resource\nD.CWE-773:Missing Reference to Active File Descriptor or Handle\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_open_53bSink(int data);\r\n\r\nvoid My_open_53()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n My_open_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_open_53bB2GSink(int data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n My_open_53bB2GSink(data);\r\n}\r\n\r\nvoid My_open_53()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-773:Missing Reference to Active File Descriptor or Handle|C.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nC.CWE-698:Execution After Redirect (EAR)\nD.No Vulnerabilities\nE.CWE-1125:Excessive Attack Surface\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_18()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n goto source;\r\nsource:\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n goto source;\r\nsource:\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_short_18()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nB.CWE-1272:Sensitive Information Uncleared Before Debug/Power State Transition\nC.No Vulnerabilities\nD.CWE-693:Protection Mechanism Failure\nE.CWE-548:Exposure of Information Through Directory Listing\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_DES_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_DES_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_DES_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_DES_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|D.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-510:Trapdoor\nC.CWE-787:Out-of-bounds Write\nD.CWE-296:Improper Following of a Certificate's Chain of Trust\nE.CWE-123:Write-what-where Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_04()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_fgets_04()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-123:Write-what-where Condition|C.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1313:Hardware Allows Activation of Test or Debug Logic at Runtime\nB.CWE-523:Unprotected Transport of Credentials\nC.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nD.No Vulnerabilities\nE.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_free_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_free_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_free_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_free_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|C.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-482:Comparing instead of Assigning\nB.CWE-462:Duplicate Key in Associative List (Alist)\nC.CWE-480:Use of Incorrect Operator\nD.No Vulnerabilities\nE.CWE-408:Incorrect Behavior Order: Early Amplification\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n int intMSink = 0;\r\n \r\n printIntLine(intMSink);\r\n \r\n intMSink == 5;\r\n printIntLine(intMSink);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intNSink = 0;\r\n \r\n printIntLine(intNSink);\r\n \r\n intNSink = 5;\r\n printIntLine(intNSink);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n int intNSink = 0;\r\n \r\n printIntLine(intNSink);\r\n \r\n intNSink = 5;\r\n printIntLine(intNSink);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-482:Comparing instead of Assigning|C.CWE-480:Use of Incorrect Operator", "cwe": "482"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-772:Missing Release of Resource after Effective Lifetime\nB.CWE-798:Use of Hard-coded Credentials\nC.CWE-607:Public Static Final Field References Mutable Object\nD.CWE-321:Use of Hard-coded Cryptographic Key\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\nchar * My_w32_char_68Data;\r\nchar * My_w32_char_68G2BData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_68bSink();\r\n\r\nvoid My_w32_char_68()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n My_w32_char_68Data = cryptoKey;\r\n My_w32_char_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_68bG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n My_w32_char_68G2BData = cryptoKey;\r\n My_w32_char_68bG2BSink();\r\n}\r\n\r\nvoid My_w32_char_68()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-321:Use of Hard-coded Cryptographic Key|B.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-841:Improper Enforcement of Behavioral Workflow\nB.No Vulnerabilities\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-23:Relative Path Traversal\nE.CWE-476:NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_listen_socket_ifstream_14\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(globalFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(globalFive==5)\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_ifstream_14; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-23:Relative Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-328:Use of Weak Hash\nB.No Vulnerabilities\nC.CWE-605:Multiple Binds to the Same Port\nD.CWE-560:Use of umask() with chmod-style Argument\nE.CWE-326:Inadequate Encryption Strength\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define MD2_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_MD2_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[MD2_SUM_SIZE], calcHash[MD2_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < MD2_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_MD2, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = MD2_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, MD2_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_MD2_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_MD2_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_MD2_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-328:Use of Weak Hash|E.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nD.CWE-252:Unchecked Return Value\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#include <windows.h>\r\n#define BUFSIZE 1024\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_w32CreateMutex_01()\r\n{\r\n {\r\n HANDLE hMutex = NULL;\r\n hMutex = CreateMutexA(NULL, FALSE, NULL);\r\n \r\n \r\n CloseHandle(hMutex);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n HANDLE hMutex = NULL;\r\n hMutex = CreateMutexA(NULL, FALSE, NULL);\r\n \r\n if (hMutex == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n CloseHandle(hMutex);\r\n }\r\n}\r\n\r\nvoid My_char_w32CreateMutex_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_w32CreateMutex_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_w32CreateMutex_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-252:Unchecked Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nB.No Vulnerabilities\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-272:Least Privilege Violation\nE.CWE-377:Insecure Temporary File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define MKTEMP mktemp\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_mktemp_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char * filename;\r\n char tmpl[] = \"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_mktemp_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_mktemp_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_mktemp_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-377:Insecure Temporary File|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1078:Inappropriate Source Code Style or Formatting\nB.No Vulnerabilities\nC.CWE-546:Suspicious Comment\nD.CWE-219:Storage of File with Sensitive Data Under Web Root\nE.CWE-833:Deadlock\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_LATER_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_LATER_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_LATER_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_LATER_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-546:Suspicious Comment|A.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-335:Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\nD.CWE-1393:Use of Default Password\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_free_int_51\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(int * data);\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n \r\n data = new int;\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(int * data);\r\nvoid nB2GSink(int * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n \r\n data = (int *)malloc(100*sizeof(int));\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n \r\n data = new int;\r\n nB2GSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_free_int_51; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-457:Use of Uninitialized Variable\nB.CWE-237:Improper Handling of Structural Elements\nC.No Vulnerabilities\nD.CWE-617:Reachable Assertion\nE.CWE-665:Improper Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_04()\r\n{\r\n int data;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 5;\r\n printIntLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 5;\r\n printIntLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 5;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 5;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data);\r\n }\r\n}\r\n\r\nvoid My_int_04()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-457:Use of Uninitialized Variable|E.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.CWE-73:External Control of File Name or Path\nC.No Vulnerabilities\nD.CWE-138:Improper Neutralization of Special Elements\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fopen_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-825:Expired Pointer Dereference\nB.CWE-107:Struts: Unused Validation Form\nC.CWE-256:Plaintext Storage of a Password\nD.CWE-522:Insufficiently Protected Credentials\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nwchar_t * My_w32_wchar_t_61bSource(wchar_t * data);\r\n\r\nvoid My_w32_wchar_t_61()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = My_w32_wchar_t_61bSource(data);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nwchar_t * My_w32_wchar_t_61bG2BSource(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = My_w32_wchar_t_61bG2BSource(data);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nwchar_t * My_w32_wchar_t_61bB2GSource(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = My_w32_wchar_t_61bB2GSource(data);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_61()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|D.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.CWE-259:Use of Hard-coded Password\nC.CWE-43:Path Equivalence: 'filename....' (Multiple Trailing Dot)\nD.No Vulnerabilities\nE.CWE-1042:Static Member Data Element outside of a Singleton Class Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\nnamespace My_w32_wchar_t_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * password;\r\n wchar_t * &passwordRef = password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n \r\n wcscpy(password, PASSWORD);\r\n {\r\n wchar_t * password = passwordRef;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t * &passwordRef = password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n {\r\n wchar_t * password = passwordRef;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-259:Use of Hard-coded Password|A.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)\nC.CWE-469:Use of Pointer Subtraction to Determine Size\nD.CWE-682:Incorrect Calculation\nE.CWE-1331:Improper Isolation of Shared Resources in Network On Chip (NoC)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SOURCE_STRING \"abc/opqrstu\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char string2[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string2);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-469:Use of Pointer Subtraction to Determine Size|D.CWE-682:Incorrect Calculation", "cwe": "469"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-190:Integer Overflow or Wraparound\nC.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nD.No Vulnerabilities\nE.CWE-612:Improper Authorization of Index Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_max_postinc_03()\r\n{\r\n short data;\r\n data = 0;\r\n if(5==5)\r\n {\r\n \r\n data = SHRT_MAX;\r\n }\r\n if(5==5)\r\n {\r\n {\r\n \r\n data++;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n short data;\r\n data = 0;\r\n if(5==5)\r\n {\r\n \r\n data = SHRT_MAX;\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data < SHRT_MAX)\r\n {\r\n data++;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n short data;\r\n data = 0;\r\n if(5==5)\r\n {\r\n \r\n data = SHRT_MAX;\r\n }\r\n if(5==5)\r\n {\r\n \r\n if (data < SHRT_MAX)\r\n {\r\n data++;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n data = 0;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 2;\r\n }\r\n if(5==5)\r\n {\r\n {\r\n \r\n data++;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n data = 0;\r\n if(5==5)\r\n {\r\n \r\n data = 2;\r\n }\r\n if(5==5)\r\n {\r\n {\r\n \r\n data++;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_max_postinc_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_max_postinc_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_max_postinc_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-190:Integer Overflow or Wraparound|A.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-1062:Parent Class with References to Child Class\nC.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nD.CWE-271:Privilege Dropping / Lowering Errors\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_short_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, void *> dataMap);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n map<int, void *> dataMap;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, void *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n map<int, void *> dataMap;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_short_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1093:Excessively Complex Data Representation\nB.No Vulnerabilities\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-771:Missing Reference to Active Allocated Resource\nE.CWE-173:Improper Handling of Alternate Encoding\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32CreateFile_52bSink(HANDLE data);\r\n\r\nvoid My_w32CreateFile_52()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n My_w32CreateFile_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32CreateFile_52bB2GSink(HANDLE data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n My_w32CreateFile_52bB2GSink(data);\r\n}\r\n\r\nvoid My_w32CreateFile_52()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|D.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.CWE-916:Use of Password Hash With Insufficient Computational Effort\nC.No Vulnerabilities\nD.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nE.CWE-1329:Reliance on Component That is Not Updateable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_realloc_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(char));\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_realloc_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_realloc_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_realloc_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-175:Improper Handling of Mixed Encoding\nD.CWE-404:Improper Resource Shutdown or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_w32CloseHandle_01()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (data != -1)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n}\r\n\r\nvoid My_open_w32CloseHandle_01()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_w32CloseHandle_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_w32CloseHandle_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-131:Incorrect Calculation of Buffer Size\nB.No Vulnerabilities\nC.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-400:Uncontrolled Resource Consumption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\nnamespace My_fgets_sleep_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(int &count);\r\n\r\nvoid m()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n mSource(count);\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(int &count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n nG2BSource(count);\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n}\r\n\r\n\r\nvoid nB2GSource(int &count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n nB2GSource(count);\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fgets_sleep_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-309:Use of Password System for Primary Authentication\nB.CWE-665:Improper Initialization\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-791:Incomplete Filtering of Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ncat_31()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n {\r\n char * dataCopy = data;\r\n char * data = dataCopy;\r\n {\r\n size_t sourceLen;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n sourceLen = strlen(source);\r\n \r\n strncat(data, source, sourceLen);\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = '\\0'; \r\n {\r\n char * dataCopy = data;\r\n char * data = dataCopy;\r\n {\r\n size_t sourceLen;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n sourceLen = strlen(source);\r\n \r\n strncat(data, source, sourceLen);\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ncat_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ncat_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ncat_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-710:Improper Adherence to Coding Standards\nC.CWE-639:Authorization Bypass Through User-Controlled Key\nD.CWE-297:Improper Validation of Certificate with Host Mismatch\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_double_pointer_new_use_09\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n double * * pointer = new double *;\r\n double * data = *pointer; \r\n delete pointer;\r\n printDoubleLine(*data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n double * data;\r\n \r\n data = new double;\r\n *data = 5.0;\r\n double * * pointer = new double *;\r\n *pointer = data; \r\n {\r\n double * data = *pointer;\r\n printDoubleLine(*data);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n double * data;\r\n \r\n data = new double;\r\n *data = 5.0;\r\n double * * pointer = new double *;\r\n *pointer = data; \r\n {\r\n double * data = *pointer;\r\n printDoubleLine(*data);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_double_pointer_new_use_09; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|B.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-692:Incomplete Denylist to Cross-Site Scripting\nC.CWE-416:Use After Free\nD.CWE-1314:Missing Write Protection for Parametric Data Values\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_new_delete_array_class_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n printIntLine(data[0].intOne);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n }\r\n if(staticTrue)\r\n {\r\n \r\n printIntLine(data[0].intOne);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n }\r\n if(staticTrue)\r\n {\r\n \r\n printIntLine(data[0].intOne);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_class_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-416:Use After Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-761:Free of Pointer not at Start of Buffer\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-1093:Excessively Complex Data Representation\nE.CWE-1092:Use of Same Invokable Control Element in Multiple Architectural Layers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\ntypedef struct _My_char_connect_socket_67_structType\r\n{\r\n char * structFirst;\r\n} My_char_connect_socket_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_connect_socket_67bSink(My_char_connect_socket_67_structType myStruct);\r\n\r\nvoid My_char_connect_socket_67()\r\n{\r\n char * data;\r\n My_char_connect_socket_67_structType myStruct;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_char_connect_socket_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_connect_socket_67bB2GSink(My_char_connect_socket_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n My_char_connect_socket_67_structType myStruct;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_char_connect_socket_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_char_connect_socket_67()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-761:Free of Pointer not at Start of Buffer|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-124:Buffer Underwrite ('Buffer Underflow')\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-253:Incorrect Check of Function Return Value\nE.CWE-460:Improper Cleanup on Thrown Exception\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define RENAME _wrename\r\n#else\r\n#define RENAME rename\r\n#endif\r\n\r\n#define OLD_M_FILE_NAME L\"oldmfilename.txt\"\r\n#define OLD_N_FILE_NAME L\"oldnfilename.txt\"\r\n#define NEW_M_FILE_NAME L\"newmfilename.txt\"\r\n#define NEW_N_FILE_NAME L\"newnfilename.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_rename_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n if (RENAME(OLD_M_FILE_NAME, NEW_M_FILE_NAME) == 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, NEW_N_FILE_NAME) != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, NEW_N_FILE_NAME) != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_rename_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_rename_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_rename_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-253:Incorrect Check of Function Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nB.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nC.CWE-1091:Use of Object without Invoking Destructor Method\nD.No Vulnerabilities\nE.CWE-544:Missing Standardized Error Handling Mechanism\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifdef _WIN32\r\n#define ACCESS _access\r\n#define W_OK 02\r\n#else\r\n#define ACCESS access\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_access_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (ACCESS(filename, W_OK) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_access_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_access_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_access_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|B.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-7:J2EE Misconfiguration: Missing Custom Error Page\nB.CWE-710:Improper Adherence to Coding Standards\nC.CWE-838:Inappropriate Encoding for Output Context\nD.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_struct_pointer_new_use_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n twoIntsStruct * * pointer = new twoIntsStruct *;\r\n twoIntsStruct * data = *pointer; \r\n delete pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n twoIntsStruct * data;\r\n \r\n data = new twoIntsStruct;\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n twoIntsStruct * * pointer = new twoIntsStruct *;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n twoIntsStruct * data;\r\n \r\n data = new twoIntsStruct;\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n twoIntsStruct * * pointer = new twoIntsStruct *;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n else\r\n {\r\n {\r\n twoIntsStruct * data;\r\n \r\n data = new twoIntsStruct;\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n twoIntsStruct * * pointer = new twoIntsStruct *;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_struct_pointer_new_use_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|B.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1114:Inappropriate Whitespace Style\nB.No Vulnerabilities\nC.CWE-705:Incorrect Control Flow Scoping\nD.CWE-1277:Firmware Not Updateable\nE.CWE-396:Declaration of Catch for Generic Exception\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_dotdotdot_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (...)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_dotdotdot_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-396:Declaration of Catch for Generic Exception|C.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.No Vulnerabilities\nC.CWE-788:Access of Memory Location After End of Buffer\nD.CWE-393:Return of Wrong Status Code\nE.CWE-733:Compiler Optimization Removal or Modification of Security-critical Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_char_memcpy_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i;\r\n char * data;\r\n data = NULL;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = new char[50];\r\n memset(data, 'A', 50-1); \r\n data[50-1] = '\\0'; \r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n char * data;\r\n data = NULL;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = new char[100];\r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_memcpy_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|C.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-20:Improper Input Validation\nC.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nD.CWE-626:Null Byte Interaction Error (Poison Null Byte)\nE.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_free_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_free_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_free_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_free_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|C.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-662:Improper Synchronization\nB.CWE-1317:Improper Access Control in Fabric Bridge\nC.No Vulnerabilities\nD.CWE-671:Lack of Administrator Control over Security\nE.CWE-667:Improper Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_01()\r\n{\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n}\r\n\r\nvoid My_basic_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-667:Improper Locking|A.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-404:Improper Resource Shutdown or Release\nB.CWE-353:Missing Support for Integrity Check\nC.No Vulnerabilities\nD.CWE-306:Missing Authentication for Critical Function\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_w32CloseHandle_05()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticTrue)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticTrue)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_w32CloseHandle_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_w32CloseHandle_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_w32CloseHandle_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-404:Improper Resource Shutdown or Release|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-122:Heap-based Buffer Overflow\nC.CWE-273:Improper Check for Dropped Privileges\nD.No Vulnerabilities\nE.CWE-344:Use of Invariant Value in Dynamically Changing Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING \"AAAAAAAAAA\"\r\n\r\nnamespace My_cpp_My_cpp_CWE193_char_loop_53; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-122:Heap-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-628:Function Call with Incorrectly Specified Arguments\nB.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nC.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\nD.No Vulnerabilities\nE.CWE-43:Path Equivalence: 'filename....' (Multiple Trailing Dot)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 100\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%s\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-688:Function Call With Incorrect Variable or Reference as Argument|A.CWE-628:Function Call with Incorrectly Specified Arguments", "cwe": "688"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-676:Use of Potentially Dangerous Function\nB.No Vulnerabilities\nC.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nD.CWE-215:Insertion of Sensitive Information Into Debugging Code\nE.CWE-1177:Use of Prohibited Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#define CHAR_BUFFER_SIZE 10\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_basic_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char charBuffer[CHAR_BUFFER_SIZE];\r\n \r\n \r\n cin >> charBuffer;\r\n charBuffer[CHAR_BUFFER_SIZE-1] = '\\0';\r\n printLine(charBuffer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char charBuffer[CHAR_BUFFER_SIZE];\r\n \r\n cin.width(CHAR_BUFFER_SIZE);\r\n cin >> charBuffer;\r\n charBuffer[CHAR_BUFFER_SIZE-1] = '\\0';\r\n printLine(charBuffer);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char charBuffer[CHAR_BUFFER_SIZE];\r\n \r\n cin.width(CHAR_BUFFER_SIZE);\r\n cin >> charBuffer;\r\n charBuffer[CHAR_BUFFER_SIZE-1] = '\\0';\r\n printLine(charBuffer);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_basic_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-676:Use of Potentially Dangerous Function|E.CWE-1177:Use of Prohibited Code", "cwe": "676"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-535:Exposure of Information Through Shell Error Message\nB.CWE-352:Cross-Site Request Forgery (CSRF)\nC.CWE-258:Empty Password in Configuration File\nD.CWE-211:Externally-Generated Error Message Containing Sensitive Information\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-535:Exposure of Information Through Shell Error Message|D.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1074:Class with Excessively Deep Inheritance\nB.No Vulnerabilities\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-1235:Incorrect Use of Autoboxing and Unboxing for Performance Critical Operations\nE.CWE-798:Use of Hard-coded Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\nnamespace My_w32_wchar_t_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &cryptoKey);\r\n\r\nvoid m()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n mSource(cryptoKey);\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &cryptoKey);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n nG2BSource(cryptoKey);\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|E.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-211:Externally-Generated Error Message Containing Sensitive Information\nB.CWE-768:Incorrect Short Circuit Evaluation\nC.CWE-382:J2EE Bad Practices: Use of System.exit()\nD.No Vulnerabilities\nE.CWE-535:Exposure of Information Through Shell Error Message\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-535:Exposure of Information Through Shell Error Message|A.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nB.CWE-580:clone() Method Without super.clone()\nC.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nD.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_free_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_free_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_free_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_free_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|C.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-479:Signal Handler Use of a Non-reentrant Function\nB.No Vulnerabilities\nC.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nD.CWE-1341:Multiple Releases of Same Resource or Handle\nE.CWE-147:Improper Neutralization of Input Terminators\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\nstatic void helperM(int sig)\r\n{\r\n \r\n \r\n void *voidPointer = malloc(10);\r\n if (voidPointer == NULL) {exit(-1);}\r\n free(voidPointer);\r\n}\r\n\r\nstatic volatile sig_atomic_t volatileSigAtomic = 0;\r\n\r\nstatic void helperN(int sig)\r\n{\r\n \r\n volatileSigAtomic = sig;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n signal(SIGINT, helperM);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n signal(SIGINT, helperN);\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n signal(SIGINT, helperN);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_basic_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-479:Signal Handler Use of a Non-reentrant Function|C.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe", "cwe": "479"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-467:Use of sizeof() on a Pointer Type\nB.CWE-295:Improper Certificate Validation\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_accept_bind_listen_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_accept_bind_listen_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_accept_bind_listen_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_accept_bind_listen_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-666:Operation on Resource in Wrong Phase of Lifetime|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-195:Signed to Unsigned Conversion Error\nC.CWE-1064:Invokable Control Element with Signature Containing an Excessive Number of Parameters\nD.No Vulnerabilities\nE.CWE-455:Non-exit on Failed Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_listen_socket_memmove_54bSink(int data);\r\n\r\nvoid My_listen_socket_memmove_54()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_listen_socket_memmove_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_listen_socket_memmove_54bG2BSink(int data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n My_listen_socket_memmove_54bG2BSink(data);\r\n}\r\n\r\nvoid My_listen_socket_memmove_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_memmove_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_memmove_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-195:Signed to Unsigned Conversion Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.No Vulnerabilities\nC.CWE-1193:Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\nD.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nE.CWE-671:Lack of Administrator Control over Security\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_realloc_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(char));\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_realloc_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_realloc_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_realloc_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1072:Data Resource Access without Use of Connection Pooling\nB.CWE-272:Least Privilege Violation\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.No Vulnerabilities\nE.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_SHRegOpenUSKey_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n TRUE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_SHRegOpenUSKey_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_SHRegOpenUSKey_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_SHRegOpenUSKey_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-272:Least Privilege Violation|C.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-267:Privilege Defined With Unsafe Actions\nB.CWE-675:Multiple Operations on Resource in Single-Operation Context\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-539:Use of Persistent Cookies Containing Sensitive Information\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n# define OPEN _open\r\n# define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n# define OPEN open\r\n# define CLOSE close\r\n#endif\r\n\r\nnamespace My_open_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_open_84\r\n{\r\npublic:\r\n My_open_84(int dataCopy);\r\n ~My_open_84();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_open_84G2B\r\n{\r\npublic:\r\n My_open_84G2B(int dataCopy);\r\n ~My_open_84G2B();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\nclass My_open_84B2G\r\n{\r\npublic:\r\n My_open_84B2G(int dataCopy);\r\n ~My_open_84B2G();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-675:Multiple Operations on Resource in Single-Operation Context|C.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-221:Information Loss or Omission\nB.No Vulnerabilities\nC.CWE-510:Trapdoor\nD.CWE-222:Truncation of Security-relevant Information\nE.CWE-690:Unchecked Return Value to NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SIZE 15\r\n#define TRUNCATED_USERNAME_SIZE 4 \r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n char truncatedUsername[TRUNCATED_USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n memcpy(truncatedUsername, username, sizeof(truncatedUsername));\r\n truncatedUsername[TRUNCATED_USERNAME_SIZE] = '\\0';\r\n \r\n if (LogonUserA(\r\n truncatedUsername,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-222:Truncation of Security-relevant Information|A.CWE-221:Information Loss or Omission", "cwe": "222"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-195:Signed to Unsigned Conversion Error\nB.CWE-186:Overly Restrictive Regular Expression\nC.No Vulnerabilities\nD.CWE-455:Non-exit on Failed Initialization\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fscanf_strncpy_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fscanf_strncpy_84\r\n{\r\npublic:\r\n My_fscanf_strncpy_84(int dataCopy);\r\n ~My_fscanf_strncpy_84();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fscanf_strncpy_84G2B\r\n{\r\npublic:\r\n My_fscanf_strncpy_84G2B(int dataCopy);\r\n ~My_fscanf_strncpy_84G2B();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-195:Signed to Unsigned Conversion Error|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-797:Only Filtering Special Elements at an Absolute Position\nC.No Vulnerabilities\nD.CWE-280:Improper Handling of Insufficient Permissions or Privileges \nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n list<int> *dataPtr1 = &data;\r\n list<int> *dataPtr2 = &data;\r\n {\r\n list<int> data = *dataPtr1;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n *dataPtr1 = data;\r\n }\r\n {\r\n list<int> data = *dataPtr2;\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n list<int> *dataPtr1 = &data;\r\n list<int> *dataPtr2 = &data;\r\n {\r\n list<int> data = *dataPtr1;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n *dataPtr1 = data;\r\n }\r\n {\r\n list<int> data = *dataPtr2;\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n list<int> *dataPtr1 = &data;\r\n list<int> *dataPtr2 = &data;\r\n {\r\n list<int> data = *dataPtr1;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n *dataPtr1 = data;\r\n }\r\n {\r\n list<int> data = *dataPtr2;\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-672:Operation on a Resource after Expiration or Release|E.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-121:Stack-based Buffer Overflow\nB.CWE-284:Improper Access Control\nC.CWE-787:Out-of-bounds Write\nD.CWE-444:Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic char * mSource(char * data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n }\r\n return data;\r\n}\r\n\r\nvoid My_My_My_My_CWE806_char_alloca_ncat_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-121:Stack-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1044:Architecture with Number of Horizontal Layers Outside of Expected Range\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-358:Improperly Implemented Security Check for Standard\nD.No Vulnerabilities\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_free_int64_t_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(int64_t * &data);\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(int64_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n free(data);\r\n}\r\n\r\n\r\nvoid nB2GSource(int64_t * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n delete data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_free_int64_t_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nB.CWE-773:Missing Reference to Active File Descriptor or Handle\nC.CWE-1193:Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\nD.No Vulnerabilities\nE.CWE-771:Missing Reference to Active Allocated Resource\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_31()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_31()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-773:Missing Reference to Active File Descriptor or Handle|E.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-359:Exposure of Private Personal Information to an Unauthorized Actor\nB.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\nC.CWE-546:Suspicious Comment\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_HACK_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_HACK_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_HACK_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_HACK_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.No Vulnerabilities\nC.CWE-1299:Missing Protection Mechanism for Alternate Hardware Interface\nD.CWE-124:Buffer Underwrite ('Buffer Underflow')\nE.CWE-1078:Inappropriate Source Code Style or Formatting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_memmove_82\r\n{\r\n\r\nclass My_new_wchar_t_memmove_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_wchar_t_memmove_82 : public My_new_wchar_t_memmove_82_base\r\n{\r\npublic:\r\n void action(wchar_t * data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_wchar_t_memmove_82G2B : public My_new_wchar_t_memmove_82_base\r\n{\r\npublic:\r\n void action(wchar_t * data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-124:Buffer Underwrite ('Buffer Underflow')|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-305:Authentication Bypass by Primary Weakness\nC.CWE-608:Struts: Non-private Field in ActionForm Class\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <process.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_connect_socket_w32spawnl_06()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n \r\n _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n }\r\n \r\n \r\n _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n }\r\n \r\n \r\n _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid My_char_connect_socket_w32spawnl_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_w32spawnl_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_w32spawnl_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-484:Omitted Break Statement in Switch\nB.CWE-506:Embedded Malicious Code\nC.CWE-262:Not Using Password Aging\nD.No Vulnerabilities\nE.CWE-912:Hidden Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define FILENAME \"conf.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_file_transfer_listen_socket_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char contents[65536]; \r\n FILE * pFile;\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(contents, (int)(65535), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n contents[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, contents, strlen(contents), 0) != strlen(contents))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_file_transfer_listen_socket_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-506:Embedded Malicious Code|E.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-493:Critical Public Variable Without Final Modifier\nB.CWE-484:Omitted Break Statement in Switch\nC.No Vulnerabilities\nD.CWE-514:Covert Channel\nE.CWE-710:Improper Adherence to Coding Standards\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n break;\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n break;\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-484:Omitted Break Statement in Switch|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "484"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-211:Externally-Generated Error Message Containing Sensitive Information\nB.CWE-708:Incorrect Ownership Assignment\nC.CWE-1293:Missing Source Correlation of Multiple Independent Data\nD.No Vulnerabilities\nE.CWE-535:Exposure of Information Through Shell Error Message\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-535:Exposure of Information Through Shell Error Message|A.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-188:Reliance on Data/Memory Layout\nB.CWE-479:Signal Handler Use of a Non-reentrant Function\nC.No Vulnerabilities\nD.CWE-480:Use of Incorrect Operator\nE.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_modify_local_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n char *charPtr;\r\n structCharInt.charFirst = 1;\r\n charPtr = &structCharInt.charFirst;\r\n \r\n *(int*)(charPtr + sizeof(int)) = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n}\r\n\r\nvoid My_modify_local_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_modify_local_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_modify_local_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-188:Reliance on Data/Memory Layout|E.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.No Vulnerabilities\nC.CWE-1290:Incorrect Decoding of Security Identifiers \nD.CWE-377:Insecure Temporary File\nE.CWE-1329:Reliance on Component That is Not Updateable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define MKTEMP mktemp\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_mktemp_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n char * filename;\r\n char tmpl[] = \"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_mktemp_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_mktemp_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_mktemp_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-377:Insecure Temporary File|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.CWE-462:Duplicate Key in Associative List (Alist)\nE.CWE-312:Cleartext Storage of Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_02()\r\n{\r\n if(1)\r\n {\r\n \r\n printLine(getenv(\"PATH\"));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\nvoid My_basic_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable|E.CWE-312:Cleartext Storage of Sensitive Information", "cwe": "526"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1312:Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\nB.CWE-392:Missing Report of Error Condition\nC.No Vulnerabilities\nD.CWE-232:Improper Handling of Undefined Values\nE.CWE-284:Improper Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateWindowStation_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateWindowStation_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateWindowStation_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateWindowStation_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-284:Improper Access Control|A.CWE-1312:Missing Protection for Mirrored Regions in On-Chip Fabric Firewall", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-469:Use of Pointer Subtraction to Determine Size\nB.CWE-576:EJB Bad Practices: Use of Java I/O\nC.CWE-114:Process Control\nD.CWE-73:External Control of File Name or Path\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic wchar_t * mSource(wchar_t * data)\r\n{\r\n \r\n wcscpy(data, L\"winsrv.dll\");\r\n return data;\r\n}\r\n\r\nvoid My_w32_wchar_t_relativePath_42()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = mSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic wchar_t * nG2BSource(wchar_t * data)\r\n{\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n return data;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_relativePath_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_relativePath_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_relativePath_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|D.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-297:Improper Validation of Certificate with Host Mismatch\nC.CWE-280:Improper Handling of Insufficient Permissions or Privileges \nD.CWE-36:Absolute Path Traversal\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_char_environment_open_67\r\n{\r\n\r\ntypedef struct _structType\r\n{\r\n char * structFirst;\r\n} structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(structType myStruct);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n structType myStruct;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n myStruct.structFirst = data;\r\n mSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n structType myStruct;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n myStruct.structFirst = data;\r\n nG2BSink(myStruct);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_open_67; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-36:Absolute Path Traversal|E.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-271:Privilege Dropping / Lowering Errors\nB.No Vulnerabilities\nC.CWE-909:Missing Initialization of Resource\nD.CWE-755:Improper Handling of Exceptional Conditions\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_01()\r\n{\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n}\r\n\r\nvoid My_fopen_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-390:Detection of Error Condition Without Action|D.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1294:Insecure Security Identifier Mechanism\nB.No Vulnerabilities\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.CWE-1390:Weak Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_11()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_char_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1269:Product Released in Non-Release Configuration\nB.No Vulnerabilities\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-1100:Insufficient Isolation of System-Dependent Functions\nE.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_char_64()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n My_char_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n My_char_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_char_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.CWE-1164:Irrelevant Code\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.CWE-763:Release of Invalid Pointer or Reference\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_file_02()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(1)\r\n {\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(1)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_file_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_file_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_file_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|D.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1190:DMA Device Enabled Too Early in Boot Phase\nB.No Vulnerabilities\nC.CWE-73:External Control of File Name or Path\nD.CWE-114:Process Control\nE.CWE-1285:Improper Validation of Specified Index, Position, or Offset in Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_w32_wchar_t_file_81\r\n{\r\n\r\nclass My_w32_wchar_t_file_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_wchar_t_file_81 : public My_w32_wchar_t_file_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_wchar_t_file_81G2B : public My_w32_wchar_t_file_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-283:Unverified Ownership\nB.CWE-252:Unchecked Return Value\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-920:Improper Restriction of Power Consumption\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fputc_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n fputc((int)'A', stdout);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (fputc((int)'A', stdout) == EOF)\r\n {\r\n printLine(\"fputc failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n if (fputc((int)'A', stdout) == EOF)\r\n {\r\n printLine(\"fputc failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fputc_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fputc_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fputc_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-514:Covert Channel\nB.No Vulnerabilities\nC.CWE-104:Struts: Form Bean Does Not Extend Validation Class\nD.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nE.CWE-330:Use of Insufficiently Random Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|E.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-325:Missing Cryptographic Step\nD.CWE-807:Reliance on Untrusted Inputs in a Security Decision\nE.CWE-430:Deployment of Wrong Handler\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptHashData_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptHashData_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptHashData_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptHashData_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-325:Missing Cryptographic Step|B.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nC.CWE-1394:Use of Default Cryptographic Key\nD.CWE-435:Improper Interaction Between Multiple Correctly-Behaving Entities\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_realloc_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(wchar_t));\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_realloc_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_realloc_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_realloc_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-675:Multiple Operations on Resource in Single-Operation Context\nD.CWE-1094:Excessive Index Range Scan for a Data Resource\nE.CWE-331:Insufficient Entropy\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_08()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(staticReturnsTrue())\r\n {\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(staticReturnsTrue())\r\n {\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(staticReturnsTrue())\r\n {\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\nvoid My_fopen_08()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-675:Multiple Operations on Resource in Single-Operation Context|B.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-345:Insufficient Verification of Data Authenticity\nD.CWE-1220:Insufficient Granularity of Access Control\nE.CWE-190:Integer Overflow or Wraparound\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_unsigned_int_max_multiply_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, unsigned int> dataMap);\r\n\r\nvoid m()\r\n{\r\n unsigned int data;\r\n map<int, unsigned int> dataMap;\r\n data = 0;\r\n \r\n data = UINT_MAX;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, unsigned int> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n unsigned int data;\r\n map<int, unsigned int> dataMap;\r\n data = 0;\r\n \r\n data = 2;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, unsigned int> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n unsigned int data;\r\n map<int, unsigned int> dataMap;\r\n data = 0;\r\n \r\n data = UINT_MAX;\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_unsigned_int_max_multiply_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1278:Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\nB.No Vulnerabilities\nC.CWE-319:Cleartext Transmission of Sensitive Information\nD.CWE-1176:Inefficient CPU Computation\nE.CWE-546:Suspicious Comment\n", "input": "static int generic_set_freq(struct dvb_frontend *fe, u32 freq /* in HZ */,\r\r\n\t\t\t enum v4l2_tuner_type new_type,\r\r\n\t\t\t unsigned int type,\r\r\n\t\t\t v4l2_std_id std,\r\r\n\t\t\t u16 int_freq)\r\r\n{\r\r\n\tstruct xc2028_data *priv = fe->tuner_priv;\r\r\n\tint\t\t rc = -EINVAL;\r\r\n\tunsigned char\t buf[4];\r\r\n\tu32\t\t div, offset = 0;\r\r\n\r\r\n\ttuner_dbg(\"%s called\\n\", __func__);\r\r\n\r\r\n\tmutex_lock(&priv->lock);\r\r\n\r\r\n\ttuner_dbg(\"should set frequency %d kHz\\n\", freq / 1000);\r\r\n\r\r\n\tif (check_firmware(fe, type, std, int_freq) < 0)\r\r\n\t\tgoto ret;\r\r\n\r\r\n\t/* On some cases xc2028 can disable video output, if\r\r\n\t * very weak signals are received. By sending a soft\r\r\n\t * reset, this is re-enabled. So, it is better to always\r\r\n\t * send a soft reset before changing channels, to be sure\r\r\n\t * that xc2028 will be in a safe state.\r\r\n\t * Maybe this might also be needed for DTV.\r\r\n\t */\r\r\n\tswitch (new_type) {\r\r\n\tcase V4L2_TUNER_ANALOG_TV:\r\r\n\t\trc = send_seq(priv, {0x00, 0x00});\r\r\n\r\r\n\t\t/* Analog mode requires offset = 0 */\r\r\n\t\tbreak;\r\r\n\tcase V4L2_TUNER_RADIO:\r\r\n\t\t/* Radio mode requires offset = 0 */\r\r\n\t\tbreak;\r\r\n\tcase V4L2_TUNER_DIGITAL_TV:\r\r\n\t\t/*\r\r\n\t\t * Digital modes require an offset to adjust to the\r\r\n\t\t * proper frequency. The offset depends on what\r\r\n\t\t * firmware version is used.\r\r\n\t\t */\r\r\n\r\r\n\t\t/*\r\r\n\t\t * Adjust to the center frequency. This is calculated by the\r\r\n\t\t * formula: offset = 1.25MHz - BW/2\r\r\n\t\t * For DTV 7/8, the firmware uses BW = 8000, so it needs a\r\r\n\t\t * further adjustment to get the frequency center on VHF\r\r\n\t\t */\r\r\n\r\r\n\t\t/*\r\r\n\t\t * The firmware DTV78 used to work fine in UHF band (8 MHz\r\r\n\t\t * bandwidth) but not at all in VHF band (7 MHz bandwidth).\r\r\n\t\t * The real problem was connected to the formula used to\r\r\n\t\t * calculate the center frequency offset in VHF band.\r\r\n\t\t * In fact, removing the 500KHz adjustment fixed the problem.\r\r\n\t\t * This is coherent to what was implemented for the DTV7\r\r\n\t\t * firmware.\r\r\n\t\t * In the end, now the center frequency is the same for all 3\r\r\n\t\t * firmwares (DTV7, DTV8, DTV78) and doesn't depend on channel\r\r\n\t\t * bandwidth.\r\r\n\t\t */\r\r\n\r\r\n\t\tif (priv->cur_fw.type & DTV6)\r\r\n\t\t\toffset = 1750000;\r\r\n\t\telse\t/* DTV7 or DTV8 or DTV78 */\r\r\n\t\t\toffset = 2750000;\r\r\n\r\r\n\t\t/*\r\r\n\t\t * xc3028 additional \"magic\"\r\r\n\t\t * Depending on the firmware version, it needs some adjustments\r\r\n\t\t * to properly centralize the frequency. This seems to be\r\r\n\t\t * needed to compensate the SCODE table adjustments made by\r\r\n\t\t * newer firmwares\r\r\n\t\t */\r\r\n\r\r\n\t\t/*\r\r\n\t\t * The proper adjustment would be to do it at s-code table.\r\r\n\t\t * However, this didn't work, as reported by\r\r\n\t\t * Robert Lowery <rglowery@exemail.com.au>\r\r\n\t\t */\r\r\n\r\r\n#if 0\r\r\n\t\t/*\r\r\n\t\t * Still need tests for XC3028L (firmware 3.2 or upper)\r\r\n\t\t * So, for now, let's just comment the per-firmware\r\r\n\t\t * version of this change. Reports with xc3028l working\r\r\n\t\t * with and without the lines below are welcome\r\r\n\t\t */\r\r\n\r\r\n\t\tif (priv->firm_version < 0x0302) {\r\r\n\t\t\tif (priv->cur_fw.type & DTV7)\r\r\n\t\t\t\toffset += 500000;\r\r\n\t\t} else {\r\r\n\t\t\tif (priv->cur_fw.type & DTV7)\r\r\n\t\t\t\toffset -= 300000;\r\r\n\t\t\telse if (type != ATSC) /* DVB @6MHz, DTV 8 and DTV 7/8 */\r\r\n\t\t\t\toffset += 200000;\r\r\n\t\t}\r\r\n#endif\r\r\n\t\tbreak;\r\r\n\tdefault:\r\r\n\t\ttuner_err(\"Unsupported tuner type %d.\\n\", new_type);\r\r\n\t\tbreak;\r\r\n\t}\r\r\n\r\r\n\tdiv = (freq - offset + DIV / 2) / DIV;\r\r\n\r\r\n\t/* CMD= Set frequency */\r\r\n\tif (priv->firm_version < 0x0202)\r\r\n\t\trc = send_seq(priv, {0x00, XREG_RF_FREQ, 0x00, 0x00});\r\r\n\telse\r\r\n\t\trc = send_seq(priv, {0x80, XREG_RF_FREQ, 0x00, 0x00});\r\r\n\tif (rc < 0)\r\r\n\t\tgoto ret;\r\r\n\r\r\n\t/* Return code shouldn't be checked.\r\r\n\t The reset CLK is needed only with tm6000.\r\r\n\t Driver should work fine even if this fails.\r\r\n\t */\r\r\n\tif (priv->ctrl.msleep)\r\r\n\t\tmsleep(priv->ctrl.msleep);\r\r\n\tdo_tuner_callback(fe, XC2028_RESET_CLK, 1);\r\r\n\r\r\n\tmsleep(10);\r\r\n\r\r\n\tbuf[0] = 0xff & (div >> 24);\r\r\n\tbuf[1] = 0xff & (div >> 16);\r\r\n\tbuf[2] = 0xff & (div >> 8);\r\r\n\tbuf[3] = 0xff & (div);\r\r\n\r\r\n\trc = i2c_send(priv, buf, sizeof(buf));\r\r\n\tif (rc < 0)\r\r\n\t\tgoto ret;\r\r\n\tmsleep(100);\r\r\n\r\r\n\tpriv->frequency = freq;\r\r\n\r\r\n\ttuner_dbg(\"divisor= %*ph (freq=%d.%03d)\\n\", 4, buf,\r\r\n\t freq / 1000000, (freq % 1000000) / 1000);\r\r\n\r\r\n\trc = 0;\r\r\n\r\r\nret:\r\r\n\tmutex_unlock(&priv->lock);\r\r\n\r\r\n\treturn rc;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.No Vulnerabilities|B.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-1393:Use of Default Password\nC.No Vulnerabilities\nD.CWE-416:Use After Free\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_rand_divide_52bSink(int data);\r\n\r\nvoid My_int_rand_divide_52()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n My_int_rand_divide_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_rand_divide_52bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n My_int_rand_divide_52bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_int_rand_divide_52bB2GSink(int data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n My_int_rand_divide_52bB2GSink(data);\r\n}\r\n\r\nvoid My_int_rand_divide_52()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_rand_divide_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_rand_divide_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|E.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-339:Small Seed Space in PRNG\nB.No Vulnerabilities\nC.CWE-1064:Invokable Control Element with Signature Containing an Excessive Number of Parameters\nD.CWE-459:Incomplete Cleanup\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_alloca_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_alloca_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_alloca_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_alloca_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|D.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nC.No Vulnerabilities\nD.CWE-114:Process Control\nE.CWE-267:Privilege Defined With Unsafe Actions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_w32_wchar_t_console_81\r\n{\r\n\r\nclass My_w32_wchar_t_console_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_wchar_t_console_81 : public My_w32_wchar_t_console_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_wchar_t_console_81G2B : public My_w32_wchar_t_console_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|A.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-277:Insecure Inherited Permissions\nB.CWE-42:Path Equivalence: 'filename.' (Trailing Dot)\nC.No Vulnerabilities\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_stat_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n struct STAT statBuffer;\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (STAT(filename, &statBuffer) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_stat_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_stat_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_stat_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|D.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-273:Improper Check for Dropped Privileges\nB.CWE-806:Buffer Access Using Size of Source Buffer\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-1077:Floating Point Comparison with Incorrect Operator\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <rpcdce.h>\r\n# pragma comment(lib, \"rpcrt4\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RpcImpersonateClient_02()\r\n{\r\n if(1)\r\n {\r\n RpcImpersonateClient(0);\r\n \r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\nvoid My_w32_RpcImpersonateClient_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RpcImpersonateClient_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RpcImpersonateClient_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-273:Improper Check for Dropped Privileges|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-116:Improper Encoding or Escaping of Output\nC.No Vulnerabilities\nD.CWE-273:Improper Check for Dropped Privileges\nE.CWE-608:Struts: Non-private Field in ActionForm Class\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <rpcdce.h>\r\n# pragma comment(lib, \"rpcrt4\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RpcImpersonateClient_16()\r\n{\r\n while(1)\r\n {\r\n RpcImpersonateClient(0);\r\n \r\n \r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_RpcImpersonateClient_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RpcImpersonateClient_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RpcImpersonateClient_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-273:Improper Check for Dropped Privileges|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-617:Reachable Assertion\nC.CWE-1384:Improper Handling of Physical or Environmental Conditions\nD.CWE-170:Improper Null Termination\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_08()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_listen_socket_08()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-617:Reachable Assertion|A.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-926:Improper Export of Android Application Components\nD.CWE-427:Uncontrolled Search Path Element\nE.CWE-1070:Serializable Data Element Containing non-Serializable Item Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH L\"%SystemRoot%\\\\system32\"\r\n#define PUTENV _wputenv\r\n#else\r\n#define NEW_PATH L\"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} My_wchar_t_console_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_console_34()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_console_34_unionType myUnion;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (250-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(250-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n \r\n PUTENV(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_console_34_unionType myUnion;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, NEW_PATH);\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n \r\n PUTENV(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_console_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_console_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_console_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.CWE-1025:Comparison Using Wrong Factors\nC.No Vulnerabilities\nD.CWE-416:Use After Free\nE.CWE-328:Use of Weak Hash\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define SHA1_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_SHA1_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA1_SUM_SIZE], calcHash[SHA1_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA1_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA1_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA1_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_SHA1_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_SHA1_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_SHA1_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-328:Use of Weak Hash|A.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1123:Excessive Use of Self-Modifying Code\nB.CWE-396:Declaration of Catch for Generic Exception\nC.No Vulnerabilities\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-560:Use of umask() with chmod-style Argument\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_and_domain_error_14\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalFive==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n catch (domain_error &)\r\n {\r\n \r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_and_domain_error_14; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-396:Declaration of Catch for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-123:Write-what-where Condition\nB.No Vulnerabilities\nC.CWE-478:Missing Default Case in Multiple Condition Expression\nD.CWE-787:Out-of-bounds Write\nE.CWE-1390:Weak Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_53bSink(mStruct data);\r\n\r\nvoid My_connect_socket_53()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_53bG2BSink(mStruct data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n My_connect_socket_53bG2BSink(data);\r\n}\r\n\r\nvoid My_connect_socket_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-459:Incomplete Cleanup\nB.CWE-404:Improper Resource Shutdown or Release\nC.No Vulnerabilities\nD.CWE-138:Improper Neutralization of Special Elements\nE.CWE-111:Direct Use of Unsafe JNI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#define FDOPEN fdopen\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#define FDOPEN fdopen\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char filename[] = \"mXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n char filename[] = \"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char filename[] = \"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-459:Incomplete Cleanup|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "459"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption\nC.CWE-507:Trojan Horse\nD.CWE-476:NULL Pointer Dereference\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_03()\r\n{\r\n char * data;\r\n if(5==5)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(5==5)\r\n {\r\n \r\n \r\n printHexCharLine(data[0]);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n if(5==5)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printHexCharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n if(5==5)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(5==5)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printHexCharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = \"N\";\r\n }\r\n if(5==5)\r\n {\r\n \r\n \r\n printHexCharLine(data[0]);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n if(5==5)\r\n {\r\n \r\n data = \"N\";\r\n }\r\n if(5==5)\r\n {\r\n \r\n \r\n printHexCharLine(data[0]);\r\n }\r\n}\r\n\r\nvoid My_char_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-476:NULL Pointer Dereference|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-546:Suspicious Comment\nB.CWE-606:Unchecked Input for Loop Condition\nC.CWE-527:Exposure of Version-Control Repository to an Unauthorized Control Sphere\nD.CWE-1284:Improper Validation of Specified Quantity in Input\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_listen_socket_01()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"15\");\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_listen_socket_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-606:Unchecked Input for Loop Condition|D.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-377:Insecure Temporary File\nB.CWE-691:Insufficient Control Flow Management\nC.CWE-99:Improper Control of Resource Identifiers ('Resource Injection')\nD.No Vulnerabilities\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define MKTEMP mktemp\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_mktemp_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char * filename;\r\n char tmpl[] = \"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_mktemp_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_mktemp_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_mktemp_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-377:Insecure Temporary File|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-311:Missing Encryption of Sensitive Data\nB.No Vulnerabilities\nC.CWE-1394:Use of Default Cryptographic Key\nD.CWE-1258:Exposure of Sensitive System Information Due to Uncleared Debug Information\nE.CWE-319:Cleartext Transmission of Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_listen_socket_52bSink(char * password);\r\n\r\nvoid My_w32_char_listen_socket_52()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_char_listen_socket_52bSink(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_listen_socket_52bG2BSink(char * password);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_listen_socket_52bG2BSink(password);\r\n}\r\n\r\n\r\nvoid My_w32_char_listen_socket_52bB2GSink(char * password);\r\n\r\nstatic void nB2G()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_char_listen_socket_52bB2GSink(password);\r\n}\r\n\r\nvoid My_w32_char_listen_socket_52()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_listen_socket_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_listen_socket_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-319:Cleartext Transmission of Sensitive Information|A.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-665:Improper Initialization\nB.CWE-457:Use of Uninitialized Variable\nC.CWE-91:XML Injection (aka Blind XPath Injection)\nD.CWE-620:Unverified Password Change\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_array_malloc_partial_init_18()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n goto source;\r\nsource:\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n goto source;\r\nsource:\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n goto source;\r\nsource:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_array_malloc_partial_init_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_array_malloc_partial_init_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_array_malloc_partial_init_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-457:Use of Uninitialized Variable|A.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-131:Incorrect Calculation of Buffer Size\nB.No Vulnerabilities\nC.CWE-535:Exposure of Information Through Shell Error Message\nD.CWE-475:Undefined Behavior for Input to API\nE.CWE-211:Externally-Generated Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access with password: %s\\n\", password);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-535:Exposure of Information Through Shell Error Message|E.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-185:Incorrect Regular Expression\nB.CWE-253:Incorrect Check of Function Return Value\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-536:Servlet Runtime Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateSelf_18()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n if (ImpersonateSelf(SecurityImpersonation) > 0)\r\n {\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n if (!ImpersonateSelf(SecurityImpersonation))\r\n {\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateSelf_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateSelf_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateSelf_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-253:Incorrect Check of Function Return Value|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-480:Use of Incorrect Operator\nB.No Vulnerabilities\nC.CWE-185:Incorrect Regular Expression\nD.CWE-426:Untrusted Search Path\nE.CWE-673:External Influence of Sphere Definition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM system\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_system_41Sink(char * data)\r\n{\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_char_system_41()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n My_char_system_41Sink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nvoid My_char_system_41G2BSink(char * data)\r\n{\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n My_char_system_41G2BSink(data);\r\n}\r\n\r\nvoid My_char_system_41()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_system_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_system_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-426:Untrusted Search Path|E.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1118:Insufficient Documentation of Error Handling Techniques\nB.CWE-682:Incorrect Calculation\nC.CWE-190:Integer Overflow or Wraparound\nD.No Vulnerabilities\nE.CWE-494:Download of Code Without Integrity Check\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nint My_int_fscanf_multiply_68Data;\r\nint My_int_fscanf_multiply_68G2BData;\r\nint My_int_fscanf_multiply_68B2GData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_fscanf_multiply_68bSink();\r\n\r\nvoid My_int_fscanf_multiply_68()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n My_int_fscanf_multiply_68Data = data;\r\n My_int_fscanf_multiply_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_fscanf_multiply_68bG2BSink();\r\nvoid My_int_fscanf_multiply_68bB2GSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n My_int_fscanf_multiply_68G2BData = data;\r\n My_int_fscanf_multiply_68bG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n My_int_fscanf_multiply_68B2GData = data;\r\n My_int_fscanf_multiply_68bB2GSink();\r\n}\r\n\r\nvoid My_int_fscanf_multiply_68()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fscanf_multiply_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fscanf_multiply_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-252:Unchecked Return Value\nD.CWE-193:Off-by-one Error\nE.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define SRC \"string\"\r\n\r\n#ifdef _WIN32\r\n#define SNPRINTF _snprintf\r\n#else\r\n#define SNPRINTF snprintf\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_snprintf_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\r\n {\r\n printLine(\"snprintf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\r\n {\r\n printLine(\"snprintf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_snprintf_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_snprintf_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_snprintf_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-252:Unchecked Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-768:Incorrect Short Circuit Evaluation\nB.CWE-233:Improper Handling of Parameters\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.CWE-272:Least Privilege Violation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n TRUE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegOpenUSKey_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegOpenUSKey_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-272:Least Privilege Violation|C.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-271:Privilege Dropping / Lowering Errors\nC.CWE-444:Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\nD.CWE-644:Improper Neutralization of HTTP Headers for Scripting Syntax\nE.CWE-272:Least Privilege Violation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n TRUE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegOpenUSKey_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegOpenUSKey_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-272:Least Privilege Violation|B.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1091:Use of Object without Invoking Destructor Method\nB.CWE-1164:Irrelevant Code\nC.CWE-563:Assignment to Variable without Use\nD.No Vulnerabilities\nE.CWE-44:Path Equivalence: 'file.name' (Internal Dot)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_uninit_variable_int_01()\r\n{\r\n int data;\r\n \r\n ; \r\n \r\n \r\n ; \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n ; \r\n \r\n data = 5;\r\n printIntLine(data);\r\n}\r\n\r\nvoid My_unused_uninit_variable_int_01()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_uninit_variable_int_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_uninit_variable_int_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-563:Assignment to Variable without Use|B.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-256:Plaintext Storage of a Password\nB.CWE-617:Reachable Assertion\nC.CWE-522:Insufficiently Protected Credentials\nD.CWE-1093:Excessively Complex Data Representation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_63bSink(wchar_t * * dataPtr);\r\n\r\nvoid My_w32_wchar_t_63()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n My_w32_wchar_t_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_63bG2BSink(wchar_t * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n My_w32_wchar_t_63bG2BSink(&data);\r\n}\r\n\r\n\r\nvoid My_w32_wchar_t_63bB2GSink(wchar_t * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n My_w32_wchar_t_63bB2GSink(&data);\r\n}\r\n\r\nvoid My_w32_wchar_t_63()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-256:Plaintext Storage of a Password|C.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-487:Reliance on Package-level Scope\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.No Vulnerabilities\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <process.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_environment_w32_spawnv_32()\r\n{\r\n char * data;\r\n char * *dataPtr1 = &data;\r\n char * *dataPtr2 = &data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n {\r\n char * data = *dataPtr1;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n char * data = *dataPtr2;\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * *dataPtr1 = &data;\r\n char * *dataPtr2 = &data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n {\r\n char * data = *dataPtr1;\r\n \r\n strcat(data, \"*.*\");\r\n *dataPtr1 = data;\r\n }\r\n {\r\n char * data = *dataPtr2;\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_environment_w32_spawnv_32()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_w32_spawnv_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_w32_spawnv_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.No Vulnerabilities\nC.CWE-1164:Irrelevant Code\nD.CWE-1106:Insufficient Use of Symbolic Constants\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <float.h>\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2float_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printFloatLine((float)doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > FLT_MAX || doubleNumber < FLT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as a float\");\r\n }\r\n else\r\n {\r\n printFloatLine((float)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double2float_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2float_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2float_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-681:Incorrect Conversion between Numeric Types|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-520:.NET Misconfiguration: Use of Impersonation\nC.No Vulnerabilities\nD.CWE-123:Write-what-where Condition\nE.CWE-602:Client-Side Enforcement of Server-Side Security\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_05()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(staticTrue)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_listen_socket_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-123:Write-what-where Condition|A.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-680:Integer Overflow to Buffer Overflow\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-675:Multiple Operations on Resource in Single-Operation Context\nE.CWE-595:Comparison of Object References Instead of Object Contents\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_new_fgets_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticTrue)\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_fgets_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-680:Integer Overflow to Buffer Overflow|C.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-261:Weak Encoding for Password\nB.CWE-104:Struts: Form Bean Does Not Extend Validation Class\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-400:Uncontrolled Resource Consumption\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fscanf_for_loop_18()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n goto source;\r\nsource:\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n goto sink;\r\nsink:\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n goto source;\r\nsource:\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n goto sink;\r\nsink:\r\n {\r\n size_t i = 0;\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n goto source;\r\nsource:\r\n \r\n count = 20;\r\n goto sink;\r\nsink:\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_fscanf_for_loop_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_for_loop_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_for_loop_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-400:Uncontrolled Resource Consumption|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer\nB.No Vulnerabilities\nC.CWE-511:Logic/Time Bomb\nD.CWE-532:Insertion of Sensitive Information into Log File\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CompareFileTime_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CompareFileTime_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CompareFileTime_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CompareFileTime_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|E.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-253:Incorrect Check of Function Return Value\nB.No Vulnerabilities\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-202:Exposure of Sensitive Information Through Data Queries\nE.CWE-554:ASP.NET Misconfiguration: Not Using Input Validation Framework\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <rpcdce.h>\r\n#pragma comment(lib, \"rpcrt4\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RpcImpersonateClient_02()\r\n{\r\n if(1)\r\n {\r\n \r\n if (RpcImpersonateClient(0) == RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\nvoid My_w32_RpcImpersonateClient_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RpcImpersonateClient_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RpcImpersonateClient_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-253:Incorrect Check of Function Return Value|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-179:Incorrect Behavior Order: Early Validation\nB.CWE-827:Improper Control of Document Type Definition\nC.CWE-506:Embedded Malicious Code\nD.CWE-510:Trapdoor\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <ws2tcpip.h>\r\n#else\r\n#include <netdb.h>\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_hostname_based_logic_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char hostname[NI_MAXHOST];\r\n char servInfo[NI_MAXSERV];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n if (getnameinfo((struct sockaddr *)&acceptService,\r\n sizeof(struct sockaddr),\r\n hostname,\r\n NI_MAXHOST, servInfo, NI_MAXSERV, NI_NUMERICSERV) != 0)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"admin.google.com\", hostname) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_hostname_based_logic_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_hostname_based_logic_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_hostname_based_logic_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-510:Trapdoor|C.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-940:Improper Verification of Source of a Communication Channel\nC.CWE-425:Direct Request ('Forced Browsing')\nD.CWE-682:Incorrect Calculation\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint overmagnified_subdeaconship = 0;\r\nint global_variable;\r\nvoid lossenite_sella(void **sinarquist_stichter);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid receptible_recruitors(void (*unestranged_bivalves)(void **));\r\nvoid *erythrophage_bourdis(void *lenotre_amputation);\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&overmagnified_subdeaconship,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n receptible_recruitors(lossenite_sella);\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid lossenite_sella(void **sinarquist_stichter)\r\n{\r\n void *runfish_catalyzing = 0;\r\n char *cohere_monaghan;\r\n ++global_variable;;\r\n setup_printf_context();\r\n cohere_monaghan = getenv(\"PREFABRICATES_DOORSTEPS\");\r\n if (cohere_monaghan != 0) {;\r\n runfish_catalyzing = ((void *)cohere_monaghan);\r\n *sinarquist_stichter = runfish_catalyzing;\r\n }\r\n}\r\n\r\nvoid receptible_recruitors(void (*unestranged_bivalves)(void **))\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *ariadne_recent = 0;\r\n void *rimpi_arrode = 0;\r\n ++global_variable;\r\n void *math_epithelioma = 0;\r\n unestranged_bivalves(&math_epithelioma);\r\n if (((char *)math_epithelioma) != 0) {;\r\n rimpi_arrode = erythrophage_bourdis(math_epithelioma);\r\n ariadne_recent = ((char *)((char *)rimpi_arrode));\r\n \r\n input = atoi(ariadne_recent);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nvoid *erythrophage_bourdis(void *lenotre_amputation)\r\n{\r\n ++global_variable;\r\n return lenotre_amputation;\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|D.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-176:Improper Handling of Unicode Encoding\nB.CWE-782:Exposed IOCTL with Insufficient Access Control\nC.CWE-172:Encoding Error\nD.CWE-619:Dangling Database Cursor ('Cursor Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_05()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-176:Improper Handling of Unicode Encoding|C.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-673:External Influence of Sphere Definition\nB.CWE-1290:Incorrect Decoding of Security Identifiers \nC.No Vulnerabilities\nD.CWE-186:Overly Restrictive Regular Expression\nE.CWE-426:Untrusted Search Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _popen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_popen_13()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n }\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n }\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n }\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_popen_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_popen_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_popen_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-426:Untrusted Search Path|A.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.No Vulnerabilities\nC.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-415:Double Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_char_44\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n \r\n delete [] data;\r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n \r\n data = NULL;\r\n data = new char[100];\r\n \r\n delete [] data;\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n \r\n delete [] data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n \r\n data = NULL;\r\n data = new char[100];\r\n \r\n funcPtr(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(char * data)\r\n{\r\n \r\n \r\n ; \r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nB2GSink;\r\n \r\n data = NULL;\r\n data = new char[100];\r\n \r\n delete [] data;\r\n funcPtr(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_char_44; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-415:Double Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1245:Improper Finite State Machines (FSMs) in Hardware Logic\nB.CWE-763:Release of Invalid Pointer or Reference\nC.CWE-261:Weak Encoding for Password\nD.CWE-762:Mismatched Memory Management Routines\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_delete_array_wchar_t_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = new wchar_t;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = new wchar_t;\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = new wchar_t;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new wchar_t[100];\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = new wchar_t[100];\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_wchar_t_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-762:Mismatched Memory Management Routines|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-440:Expected Behavior Violation\nC.CWE-476:NULL Pointer Dereference\nD.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_int64_t_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n int64_t * &dataRef = data;\r\n \r\n data = NULL;\r\n {\r\n int64_t * data = dataRef;\r\n \r\n printLongLongLine(*data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n int64_t tmpData = 5LL;\r\n int64_t * &dataRef = data;\r\n \r\n {\r\n data = &tmpData;\r\n }\r\n {\r\n int64_t * data = dataRef;\r\n \r\n printLongLongLine(*data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n int64_t * &dataRef = data;\r\n \r\n data = NULL;\r\n {\r\n int64_t * data = dataRef;\r\n \r\n if (data != NULL)\r\n {\r\n printLongLongLine(*data);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int64_t_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-122:Heap-based Buffer Overflow\nB.CWE-787:Out-of-bounds Write\nC.CWE-1070:Serializable Data Element Containing non-Serializable Item Elements\nD.No Vulnerabilities\nE.CWE-640:Weak Password Recovery Mechanism for Forgotten Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_sizeof_int64_t_52bSink(int64_t * data);\r\n\r\nvoid My_sizeof_int64_t_52()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n \r\n \r\n data = (int64_t *)malloc(sizeof(data));\r\n *data = 2147483643LL;\r\n My_sizeof_int64_t_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_sizeof_int64_t_52bG2BSink(int64_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n \r\n data = (int64_t *)malloc(sizeof(*data));\r\n *data = 2147483643LL;\r\n My_sizeof_int64_t_52bG2BSink(data);\r\n}\r\n\r\nvoid My_sizeof_int64_t_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_sizeof_int64_t_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_sizeof_int64_t_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-122:Heap-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-479:Signal Handler Use of a Non-reentrant Function\nB.CWE-645:Overly Restrictive Account Lockout Mechanism\nC.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nD.CWE-195:Signed to Unsigned Conversion Error\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\nstatic void helperM(int sig)\r\n{\r\n \r\n \r\n void *voidPointer = malloc(10);\r\n if (voidPointer == NULL) {exit(-1);}\r\n free(voidPointer);\r\n}\r\n\r\nstatic volatile sig_atomic_t volatileSigAtomic = 0;\r\n\r\nstatic void helperN(int sig)\r\n{\r\n \r\n volatileSigAtomic = sig;\r\n}\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n signal(SIGINT, helperM);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\nvoid My_basic_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-479:Signal Handler Use of a Non-reentrant Function|C.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe", "cwe": "479"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-142:Improper Neutralization of Value Delimiters\nC.CWE-832:Unlock of a Resource that is not Locked\nD.CWE-468:Incorrect Pointer Scaling\nE.CWE-667:Improper Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_01()\r\n{\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n}\r\n\r\nvoid My_basic_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-832:Unlock of a Resource that is not Locked|E.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-309:Use of Password System for Primary Authentication\nB.No Vulnerabilities\nC.CWE-459:Incomplete Cleanup\nD.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nE.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_declare_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_declare_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_declare_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_declare_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|C.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-401:Missing Release of Memory after Effective Lifetime\nB.CWE-1173:Improper Use of Validation Framework\nC.No Vulnerabilities\nD.CWE-623:Unsafe ActiveX Control Marked Safe For Scripting\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_wchar_t_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(wchar_t * * dataPtr);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = new wchar_t;\r\n \r\n *data = L'A';\r\n printHexCharLine((char)*data);\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(wchar_t * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n wchar_t dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = L'A';\r\n printHexCharLine((char)*data);\r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(wchar_t * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = new wchar_t;\r\n \r\n *data = L'A';\r\n printHexCharLine((char)*data);\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-401:Missing Release of Memory after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1314:Missing Write Protection for Parametric Data Values\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-449:The UI Performs the Wrong Action\nE.CWE-427:Uncontrolled Search Path Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_listen_socket_11()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n strcat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_char_listen_socket_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-427:Uncontrolled Search Path Element|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-271:Privilege Dropping / Lowering Errors\nC.No Vulnerabilities\nD.CWE-618:Exposed Unsafe ActiveX Method\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_accept_bind_01()\r\n{\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_listen_accept_bind_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_accept_bind_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_accept_bind_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-640:Weak Password Recovery Mechanism for Forgotten Password\nB.CWE-391:Unchecked Error Condition\nC.No Vulnerabilities\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-38:Path Traversal: '\\absolute\\pathname\\here'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_strtol_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n long longNumber;\r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n printf(\"%li\\n\", longNumber);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_strtol_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_strtol_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_strtol_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-391:Unchecked Error Condition|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-1261:Improper Handling of Single Event Upsets\nC.CWE-416:Use After Free\nD.CWE-693:Protection Mechanism Failure\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_struct_01\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n data = new twoIntsStruct;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n delete data;\r\n \r\n printStructLine(data);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n data = new twoIntsStruct;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n \r\n printStructLine(data);\r\n \r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n data = new twoIntsStruct;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n delete data;\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_struct_01; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-416:Use After Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-183:Permissive List of Allowed Inputs\nD.CWE-1393:Use of Default Password\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_char_memcpy_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_malloc_char_memcpy_83\r\n{\r\npublic:\r\n My_malloc_char_memcpy_83(char * dataCopy);\r\n ~My_malloc_char_memcpy_83();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_malloc_char_memcpy_83G2B\r\n{\r\npublic:\r\n My_malloc_char_memcpy_83G2B(char * dataCopy);\r\n ~My_malloc_char_memcpy_83G2B();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-155:Improper Neutralization of Wildcards or Matching Symbols\nB.CWE-590:Free of Memory not on the Heap\nC.CWE-506:Embedded Malicious Code\nD.CWE-510:Trapdoor\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_listen_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(30000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_listen_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-510:Trapdoor|C.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nB.No Vulnerabilities\nC.CWE-331:Insufficient Entropy\nD.CWE-413:Improper Resource Locking\nE.CWE-1286:Improper Validation of Syntactic Correctness of Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic wchar_t * mSource(wchar_t * password)\r\n{\r\n if(mStatic)\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n return password;\r\n}\r\n\r\nvoid My_w32_wchar_t_21()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n mStatic = 1; \r\n password = mSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic wchar_t * nG2B1Source(wchar_t * password)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n return password;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n nG2B1Static = 0; \r\n password = nG2B1Source(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n\r\nstatic wchar_t * nG2B2Source(wchar_t * password)\r\n{\r\n if(nG2B2Static)\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n return password;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n nG2B2Static = 1; \r\n password = nG2B2Source(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-591:Sensitive Data Storage in Improperly Locked Memory|D.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1164:Irrelevant Code\nB.CWE-563:Assignment to Variable without Use\nC.No Vulnerabilities\nD.CWE-1336:Improper Neutralization of Special Elements Used in a Template Engine\nE.CWE-80:Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_uninit_variable_char_05()\r\n{\r\n char data;\r\n \r\n ; \r\n if(staticTrue)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char data;\r\n \r\n ; \r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 'C';\r\n printHexCharLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char data;\r\n \r\n ; \r\n if(staticTrue)\r\n {\r\n \r\n data = 'C';\r\n printHexCharLine(data);\r\n }\r\n}\r\n\r\nvoid My_unused_uninit_variable_char_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_uninit_variable_char_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_uninit_variable_char_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-563:Assignment to Variable without Use|A.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-823:Use of Out-of-range Pointer Offset\nB.No Vulnerabilities\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-1068:Inconsistency Between Implementation and Documented Design\nE.CWE-259:Use of Hard-coded Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_54bSink(wchar_t * password);\r\n\r\nvoid My_w32_wchar_t_54()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n \r\n wcscpy(password, PASSWORD);\r\n My_w32_wchar_t_54bSink(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_54bG2BSink(wchar_t * password);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n My_w32_wchar_t_54bG2BSink(password);\r\n}\r\n\r\nvoid My_w32_wchar_t_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-689:Permission Race Condition During Resource Copy\nB.No Vulnerabilities\nC.CWE-372:Incomplete Internal State Distinction\nD.CWE-1164:Irrelevant Code\nE.CWE-563:Assignment to Variable without Use\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_unused_value_long_82\r\n{\r\n\r\nclass My_unused_value_long_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(long data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_unused_value_long_82 : public My_unused_value_long_82_base\r\n{\r\npublic:\r\n void action(long data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_unused_value_long_82G2B : public My_unused_value_long_82_base\r\n{\r\npublic:\r\n void action(long data);\r\n};\r\n\r\nclass My_unused_value_long_82B2G : public My_unused_value_long_82_base\r\n{\r\npublic:\r\n void action(long data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-805:Buffer Access with Incorrect Length Value\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-488:Exposure of Data Element to Wrong Session\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#include <windows.h>\r\n#define BUFSIZE 1024\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_w32CreateNamedPipe_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n BOOL fConnected = FALSE;\r\n hPipe = CreateNamedPipeW(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE, \r\n PIPE_TYPE_MESSAGE |\r\n PIPE_READMODE_MESSAGE |\r\n PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n \r\n fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\r\n \r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n BOOL fConnected = FALSE;\r\n hPipe = CreateNamedPipeW(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE, \r\n PIPE_TYPE_MESSAGE |\r\n PIPE_READMODE_MESSAGE |\r\n PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n \r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\r\n \r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n BOOL fConnected = FALSE;\r\n hPipe = CreateNamedPipeW(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE, \r\n PIPE_TYPE_MESSAGE |\r\n PIPE_READMODE_MESSAGE |\r\n PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n \r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\r\n \r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_w32CreateNamedPipe_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_w32CreateNamedPipe_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_w32CreateNamedPipe_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-252:Unchecked Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1233:Security-Sensitive Hardware Controls with Missing Lock Bit Protection\nB.No Vulnerabilities\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-910:Use of Expired File Descriptor\nE.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_listen_socket_07()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_07()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nC.CWE-172:Encoding Error\nD.CWE-600:Uncaught Exception in Servlet \nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_realloc_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(char));\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_realloc_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_realloc_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_realloc_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-514:Covert Channel\nB.CWE-512:Spyware\nC.CWE-284:Improper Access Control\nD.CWE-603:Use of Client-Side Authentication\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateWindowStation_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateWindowStation_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateWindowStation_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateWindowStation_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-284:Improper Access Control|A.CWE-514:Covert Channel", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1277:Firmware Not Updateable\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_list_int_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n list<int> data;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n list<int> data;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n list<int> data;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n list<int> data;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-672:Operation on a Resource after Expiration or Release|C.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nB.CWE-363:Race Condition Enabling Link Following\nC.No Vulnerabilities\nD.CWE-1050:Excessive Platform Resource Consumption within a Loop\nE.CWE-838:Inappropriate Encoding for Output Context\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <sys/types.h> \r\n#include <unistd.h> \r\nint unchristianized_sesser = 0;\r\n\r\nstruct overprotected_unblacked \r\n{\r\n char *courier_spiceland;\r\n double outstepped_bellylike;\r\n char *maricolous_localisation;\r\n char hardheaded_empress;\r\n int subangularity_longbow;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n \r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForChange(char* file, char* sleepFile) {\r\n int fd;\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForChange\\n\");\r\n strcat(filename, file);\r\n strcat(filename, \".pid\");\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nint path_is_relative(char *path) {\r\n char *chr = 0;\r\n \r\n chr = strchr(path,'/');\r\n if (chr == 0) {\r\n \r\n printf(\"Path is relative\\n\");\r\n return 1;\r\n } else {\r\n \r\n printf(\"Path is not relative\\n\");\r\n return 0;\r\n }\r\n}\r\nchar * get_absolute_path(char * path) {\r\n char * abs_path = malloc (sizeof(char) * (strlen(\"/opt//workspace/testData/\") * strlen(path) + 1));\r\n \r\n if (abs_path == NULL) {\r\n printf(\"Cannot allocate memory for path\\n\");\r\n } else {\r\n printf(\"Creating absolute path\\n\");\r\n strcpy(abs_path, \"/opt//workspace/testData/\");\r\n strcat(abs_path, path);\r\n }\r\n return abs_path;\r\n}\r\nint isSymLink(char *file) {\r\n struct stat statbuf;\r\n \r\n if (lstat(file, &statbuf) < 0) { \r\n printf(\"Error accessing path.\\n\");\r\n return 1; \r\n }\r\n if (S_ISLNK(statbuf.st_mode) == 1) {\r\n printf(\"Path is symlink.\\n\");\r\n return 1;\r\n }\r\n printf(\"Path is valid.\\n\");\r\n return 0;\r\n}\r\nint path_is_not_symlink(char * abs_path) {\r\n \r\n return (isSymLink(abs_path) == 0);\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int size = 0;\r\n FILE *file = 0;\r\n char *buffer = 0;\r\n char *str = 0;\r\n char *abs_path = 0;\r\n char *sleep_file = 0;\r\n char *menoetius_selvedged = 0;\r\n struct overprotected_unblacked morsels_mistakingly = {0};\r\n long pedately_longlinermen[10];\r\n struct overprotected_unblacked formolit_annuloid[10] = {0};\r\n struct overprotected_unblacked supernatation_gynoeciumcia;\r\n char *uncorking_anammonid;;\r\n if (__sync_bool_compare_and_swap(&unchristianized_sesser,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n uncorking_anammonid = getenv(\"GRIPPIEST_ECAUDATE\");\r\n if (uncorking_anammonid != 0) {;\r\n supernatation_gynoeciumcia . courier_spiceland = ((char *)uncorking_anammonid);\r\n formolit_annuloid[5] = supernatation_gynoeciumcia;\r\n pedately_longlinermen[1] = 5;\r\n morsels_mistakingly = *(formolit_annuloid + pedately_longlinermen[1]);\r\n menoetius_selvedged = ((char *)morsels_mistakingly . courier_spiceland);\r\n \r\n str = malloc(sizeof(char) * (strlen(menoetius_selvedged) + 1));\r\n sleep_file = malloc(sizeof(char) * (strlen(menoetius_selvedged) + 1));\r\n if (str != NULL && sleep_file != NULL &&\r\n (sscanf(menoetius_selvedged, \"%s %s\",\r\n sleep_file,\r\n str) == 2) &&\r\n (strlen(str) != 0) &&\r\n (strlen(sleep_file) != 0))\r\n {\r\n \r\n \r\n if (path_is_relative(str)) {\r\n abs_path = get_absolute_path(str);\r\n if (abs_path != NULL) {\r\n if (path_is_not_symlink(abs_path)) {\r\n \r\n \r\n waitForChange(abs_path, sleep_file);\r\n file = fopen(abs_path,\"rb\");\r\n \r\n if (file != 0) {\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\r\n if (buffer) {\r\n \r\n \r\n fread(buffer,sizeof(char ),size,file);\r\n buffer[size] = '\\0';\r\n printf(buffer);\r\n fclose(file);\r\n free(buffer);\r\n \r\n }\r\n }\r\n }\r\n free (abs_path);\r\n }\r\n }\r\n free(str);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-363:Race Condition Enabling Link Following|A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition", "cwe": "363"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-665:Improper Initialization\nB.No Vulnerabilities\nC.CWE-1317:Improper Access Control in Fabric Bridge\nD.CWE-1022:Use of Web Link to Untrusted Target with window.opener Access\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_cat_66bSink(char * dataArray[]);\r\n\r\nvoid My_char_cat_66()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n \r\n dataArray[2] = data;\r\n My_char_cat_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_cat_66bG2BSink(char * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = '\\0'; \r\n dataArray[2] = data;\r\n My_char_cat_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_char_cat_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_cat_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_cat_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-343:Predictable Value Range from Previous Values\nB.CWE-344:Use of Invariant Value in Dynamically Changing Context\nC.No Vulnerabilities\nD.CWE-763:Release of Invalid Pointer or Reference\nE.CWE-761:Free of Pointer not at Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\nnamespace My_wchar_t_connect_socket_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n mSource(data);\r\n \r\n for (; *data != L'\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSource(wchar_t * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n nB2GSource(data);\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_connect_socket_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-761:Free of Pointer not at Start of Buffer|D.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1325:Improperly Controlled Sequential Memory Allocation\nC.CWE-780:Use of RSA Algorithm without OAEP\nD.CWE-284:Improper Access Control\nE.CWE-575:EJB Bad Practices: Use of AWT Swing\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateWindowStation_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateWindowStation_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateWindowStation_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateWindowStation_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-284:Improper Access Control|E.CWE-575:EJB Bad Practices: Use of AWT Swing", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-617:Reachable Assertion\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_connect_socket_02\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(1)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(1)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n if(1)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n if(1)\r\n {\r\n \r\n data = 20;\r\n }\r\n if(1)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_connect_socket_02; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-466:Return of Pointer Value Outside of Expected Range\nB.No Vulnerabilities\nC.CWE-675:Multiple Operations on Resource in Single-Operation Context\nD.CWE-233:Improper Handling of Parameters\nE.CWE-573:Improper Following of Specification by Caller\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_freopen_31()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n {\r\n FILE * dataCopy = data;\r\n FILE * data = dataCopy;\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n {\r\n FILE * dataCopy = data;\r\n FILE * data = dataCopy;\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n {\r\n FILE * dataCopy = data;\r\n FILE * data = dataCopy;\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid My_freopen_31()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-675:Multiple Operations on Resource in Single-Operation Context|E.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1023:Incomplete Comparison with Missing Factors\nB.No Vulnerabilities\nC.CWE-837:Improper Enforcement of a Single, Unique Action\nD.CWE-122:Heap-based Buffer Overflow\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_c_src_wchar_t_cpy_01()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n {\r\n wchar_t dest[50] = L\"\";\r\n \r\n wcscpy(dest, data);\r\n printWLine(data);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n wmemset(data, L'A', 50-1); \r\n data[50-1] = L'\\0'; \r\n {\r\n wchar_t dest[50] = L\"\";\r\n \r\n wcscpy(dest, data);\r\n printWLine(data);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_c_src_wchar_t_cpy_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_c_src_wchar_t_cpy_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_c_src_wchar_t_cpy_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-122:Heap-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-484:Omitted Break Statement in Switch\nB.CWE-25:Path Traversal: '/../filedir'\nC.No Vulnerabilities\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-1080:Source Code File with Excessive Number of Lines of Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n break;\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-484:Omitted Break Statement in Switch|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "484"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1245:Improper Finite State Machines (FSMs) in Hardware Logic\nB.CWE-129:Improper Validation of Array Index\nC.No Vulnerabilities\nD.CWE-459:Incomplete Cleanup\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_declare_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_declare_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_declare_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_declare_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|D.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-127:Buffer Under-read\nC.CWE-1093:Excessively Complex Data Representation\nD.CWE-1294:Insecure Security Identifier Mechanism\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_char_cpy_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(char * &data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL;\r\n mSource(data);\r\n {\r\n char dest[100*2];\r\n memset(dest, 'C', 100*2-1); \r\n dest[100*2-1] = '\\0'; \r\n \r\n strcpy(dest, data);\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(char * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n data = NULL;\r\n nG2BSource(data);\r\n {\r\n char dest[100*2];\r\n memset(dest, 'C', 100*2-1); \r\n dest[100*2-1] = '\\0'; \r\n \r\n strcpy(dest, data);\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_cpy_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-468:Incorrect Pointer Scaling\nB.No Vulnerabilities\nC.CWE-682:Incorrect Calculation\nD.CWE-147:Improper Neutralization of Input Terminators\nE.CWE-306:Missing Authentication for Critical Function\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ptr_to_int_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+2));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ptr_to_int_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ptr_to_int_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ptr_to_int_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-468:Incorrect Pointer Scaling|C.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-163:Improper Neutralization of Multiple Trailing Special Elements\nB.No Vulnerabilities\nC.CWE-131:Incorrect Calculation of Buffer Size\nD.CWE-316:Cleartext Storage of Sensitive Information in Memory\nE.CWE-467:Use of sizeof() on a Pointer Type\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char * mChar = NULL;\r\n \r\n mChar = (char *)malloc(sizeof(mChar));\r\n if (mChar == NULL) {exit(-1);}\r\n *mChar = 'B';\r\n printHexCharLine(*mChar);\r\n free(mChar);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * nChar = NULL;\r\n \r\n nChar = (char *)malloc(sizeof(*nChar));\r\n if (nChar == NULL) {exit(-1);}\r\n *nChar = 'G';\r\n printHexCharLine(*nChar);\r\n free(nChar);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char * nChar = NULL;\r\n \r\n nChar = (char *)malloc(sizeof(*nChar));\r\n if (nChar == NULL) {exit(-1);}\r\n *nChar = 'G';\r\n printHexCharLine(*nChar);\r\n free(nChar);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-467:Use of sizeof() on a Pointer Type|C.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-474:Use of Function with Inconsistent Implementations\nB.CWE-284:Improper Access Control\nC.CWE-1357:Reliance on Insufficiently Trustworthy Component\nD.No Vulnerabilities\nE.CWE-322:Key Exchange without Entity Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateFile_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HANDLE hFile;\r\n char * fileName = \"C:\\\\temp\\\\file.txt\";\r\n \r\n hFile = CreateFileA(\r\n fileName,\r\n FILE_ALL_ACCESS,\r\n FILE_SHARE_READ,\r\n NULL,\r\n CREATE_NEW,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"File could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"File created successfully\");\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n HANDLE hFile;\r\n char * fileName = \"C:\\\\temp\\\\file.txt\";\r\n \r\n hFile = CreateFileA(\r\n fileName,\r\n GENERIC_READ,\r\n FILE_SHARE_READ,\r\n NULL,\r\n CREATE_NEW,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"File could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"File created successfully\");\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HANDLE hFile;\r\n char * fileName = \"C:\\\\temp\\\\file.txt\";\r\n \r\n hFile = CreateFileA(\r\n fileName,\r\n GENERIC_READ,\r\n FILE_SHARE_READ,\r\n NULL,\r\n CREATE_NEW,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"File could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"File created successfully\");\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateFile_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateFile_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateFile_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-284:Improper Access Control|C.CWE-1357:Reliance on Insufficiently Trustworthy Component", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-839:Numeric Range Comparison Without Minimum Check\nB.CWE-416:Use After Free\nC.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\nD.No Vulnerabilities\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_new_delete_array_wchar_t_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_wchar_t_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.No Vulnerabilities\nC.CWE-415:Double Free\nD.CWE-386:Symbolic Name not Mapping to Correct Object\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(int * data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n printIntLine(*data);\r\n }\r\n}\r\n\r\nvoid My_int_21()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(int * data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(*data);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(int * data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(*data);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(int * data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n \r\n printIntLine(*data);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n int tmpData = 5;\r\n \r\n {\r\n data = &tmpData;\r\n }\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_int_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-476:NULL Pointer Dereference|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-413:Improper Resource Locking\nB.CWE-14:Compiler Removal of Code to Clear Buffers\nC.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nD.No Vulnerabilities\nE.CWE-1283:Mutable Attestation or Measurement Reporting Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_64bSink(void * passwordVoidPtr);\r\n\r\nvoid My_w32_wchar_t_64()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n My_w32_wchar_t_64bSink(&password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_64bG2BSink(void * passwordVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n My_w32_wchar_t_64bG2BSink(&password);\r\n}\r\n\r\nvoid My_w32_wchar_t_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-591:Sensitive Data Storage in Improperly Locked Memory|A.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-484:Omitted Break Statement in Switch\nC.No Vulnerabilities\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-467:Use of sizeof() on a Pointer Type\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n break;\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n break;\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-484:Omitted Break Statement in Switch|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "484"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-778:Insufficient Logging\nB.No Vulnerabilities\nC.CWE-796:Only Filtering Special Elements Relative to a Marker\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-253:Incorrect Check of Function Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fprintf_01()\r\n{\r\n \r\n if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\r\n {\r\n printLine(\"fprintf failed!\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n \r\n if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\r\n {\r\n printLine(\"fprintf failed!\");\r\n }\r\n}\r\n\r\nvoid My_char_fprintf_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fprintf_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fprintf_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-253:Incorrect Check of Function Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-1290:Incorrect Decoding of Security Identifiers \nC.CWE-36:Absolute Path Traversal\nD.No Vulnerabilities\nE.CWE-510:Trapdoor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifdef _WIN32\r\n#define FOPEN fopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\nnamespace My_char_listen_socket_fopen_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_fopen_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-36:Absolute Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-1112:Incomplete Documentation of Program Execution\nC.CWE-686:Function Call With Incorrect Argument Type\nD.CWE-122:Heap-based Buffer Overflow\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_My_My_My_My_CWE131_loop_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-122:Heap-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-20:Improper Input Validation\nC.No Vulnerabilities\nD.CWE-431:Missing Handler\nE.CWE-391:Unchecked Error Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#include <math.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_sqrt_01()\r\n{\r\n {\r\n double doubleNumber;\r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n printDoubleLine(doubleNumber);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n}\r\n\r\nvoid My_sqrt_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_sqrt_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_sqrt_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-391:Unchecked Error Condition|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\nB.CWE-825:Expired Pointer Dereference\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.CWE-546:Suspicious Comment\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_HACK_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_HACK_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_HACK_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_HACK_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-546:Suspicious Comment|C.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-497:Exposure of Sensitive System Information to an Unauthorized Control Sphere\nB.CWE-252:Unchecked Return Value\nC.No Vulnerabilities\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#include <windows.h>\r\n#define BUFSIZE 1024\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_w32CreateMutex_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n HANDLE hMutex = NULL;\r\n hMutex = CreateMutexW(NULL, FALSE, NULL);\r\n \r\n \r\n CloseHandle(hMutex);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n HANDLE hMutex = NULL;\r\n hMutex = CreateMutexW(NULL, FALSE, NULL);\r\n \r\n if (hMutex == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n CloseHandle(hMutex);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_w32CreateMutex_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_w32CreateMutex_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_w32CreateMutex_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-692:Incomplete Denylist to Cross-Site Scripting\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.No Vulnerabilities\nE.CWE-475:Undefined Behavior for Input to API\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <process.h>\r\n#define EXECVP _execvp\r\n\r\nnamespace My_char_environment_w32_execvp_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(char * &data)\r\n{\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(char * &data)\r\n{\r\n \r\n strcat(data, \"*.*\");\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_w32_execvp_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1323:Improper Management of Sensitive Trace Data\nB.CWE-787:Out-of-bounds Write\nC.CWE-340:Generation of Predictable Numbers or Identifiers\nD.CWE-122:Heap-based Buffer Overflow\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING L\"AAAAAAAAAA\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_CWE193_wchar_t_memcpy_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-122:Heap-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-497:Exposure of Sensitive System Information to an Unauthorized Control Sphere\nB.CWE-386:Symbolic Name not Mapping to Correct Object\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-617:Reachable Assertion\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_10()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_listen_socket_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-617:Reachable Assertion|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-118:Incorrect Access of Indexable Resource ('Range Error')\nB.No Vulnerabilities\nC.CWE-693:Protection Mechanism Failure\nD.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nE.CWE-796:Only Filtering Special Elements Relative to a Marker\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RC5_01()\r\n{\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_RC5_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RC5_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RC5_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|C.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-680:Integer Overflow to Buffer Overflow\nB.No Vulnerabilities\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-535:Exposure of Information Through Shell Error Message\nE.CWE-115:Misinterpretation of Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic int mSource(int data)\r\n{\r\n \r\n data = RAND32();\r\n return data;\r\n}\r\n\r\nvoid My_malloc_rand_42()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = mSource(data);\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic int nG2BSource(int data)\r\n{\r\n \r\n data = 20;\r\n return data;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = nG2BSource(data);\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\nvoid My_malloc_rand_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_rand_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_rand_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-680:Integer Overflow to Buffer Overflow|C.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-252:Unchecked Return Value\nC.No Vulnerabilities\nD.CWE-200:Exposure of Sensitive Information to an Unauthorized Actor\nE.CWE-48:Path Equivalence: 'file name' (Internal Whitespace)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32ImpersonateSelf_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n ImpersonateSelf(SecurityImpersonation);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (!ImpersonateSelf(SecurityImpersonation))\r\n {\r\n exit(1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n if (!ImpersonateSelf(SecurityImpersonation))\r\n {\r\n exit(1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32ImpersonateSelf_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32ImpersonateSelf_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32ImpersonateSelf_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1391:Use of Weak Credentials\nB.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-79:Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\nnamespace My_w32CreateFile_no_close_81\r\n{\r\n\r\nclass My_w32CreateFile_no_close_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(HANDLE data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32CreateFile_no_close_81 : public My_w32CreateFile_no_close_81_base\r\n{\r\npublic:\r\n void action(HANDLE data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32CreateFile_no_close_81B2G : public My_w32CreateFile_no_close_81_base\r\n{\r\npublic:\r\n void action(HANDLE data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-335:Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\nC.CWE-114:Process Control\nD.CWE-80:Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\nE.CWE-73:External Control of File Name or Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_file_32()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_file_32()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_file_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_file_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|E.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-703:Improper Check or Handling of Exceptional Conditions\nC.CWE-273:Improper Check for Dropped Privileges\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-357:Insufficient UI Warning of Dangerous Operations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#define BUFSIZE 1024\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n ImpersonateNamedPipeClient(hPipe);\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateNamedPipeClient_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateNamedPipeClient_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-273:Improper Check for Dropped Privileges|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.CWE-587:Assignment of a Fixed Address to a Pointer\nD.No Vulnerabilities\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic long * mSource(long * data)\r\n{\r\n \r\n data = (long *)calloc(1, sizeof(long));\r\n return data;\r\n}\r\n\r\nvoid My_long_calloc_42()\r\n{\r\n long * data;\r\n data = NULL; \r\n data = mSource(data);\r\n \r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic long * nB2GSource(long * data)\r\n{\r\n \r\n data = (long *)calloc(1, sizeof(long));\r\n return data;\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n long * data;\r\n data = NULL; \r\n data = nB2GSource(data);\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_long_calloc_42()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_long_calloc_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_long_calloc_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-690:Unchecked Return Value to NULL Pointer Dereference|E.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1292:Incorrect Conversion of Security Identifiers\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-1224:Improper Restriction of Write-Once Bit Fields\nD.No Vulnerabilities\nE.CWE-773:Missing Reference to Active File Descriptor or Handle\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_12()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = fopen(\"MSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_12()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-167:Improper Handling of Additional Special Element\nB.CWE-694:Use of Multiple Resources with Duplicate Identifier\nC.CWE-546:Suspicious Comment\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_TODO_16()\r\n{\r\n while(1)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n \r\n printLine(\"Hello\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_TODO_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_TODO_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_TODO_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-195:Signed to Unsigned Conversion Error\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-291:Reliance on IP Address for Authentication\nD.CWE-117:Improper Output Neutralization for Logs\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int data)\r\n{\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_rand_memmove_44()\r\n{\r\n int data;\r\n \r\n void (*funcPtr) (int) = mSink;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(int data)\r\n{\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = nG2BSink;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_rand_memmove_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_memmove_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_memmove_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-253:Incorrect Check of Function Return Value\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nD.No Vulnerabilities\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_putchar_01()\r\n{\r\n \r\n if (putchar((int)'A') == 0)\r\n {\r\n printLine(\"putchar failed!\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n \r\n if (putchar((int)'A') == EOF)\r\n {\r\n printLine(\"putchar failed!\");\r\n }\r\n}\r\n\r\nvoid My_char_putchar_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_putchar_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_putchar_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-253:Incorrect Check of Function Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-673:External Influence of Sphere Definition\nB.CWE-1262:Improper Access Control for Register Interface\nC.CWE-182:Collapse of Data into Unsafe Value\nD.CWE-426:Untrusted Search Path\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _popen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_popen_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_popen_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_popen_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_popen_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-426:Untrusted Search Path|A.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-495:Private Data Structure Returned From A Public Method\nB.CWE-319:Cleartext Transmission of Sensitive Information\nC.CWE-585:Empty Synchronized Block\nD.No Vulnerabilities\nE.CWE-311:Missing Encryption of Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_listen_socket_32()\r\n{\r\n wchar_t * password;\r\n wchar_t * *passwordPtr1 = &password;\r\n wchar_t * *passwordPtr2 = &password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n wchar_t * password = *passwordPtr1;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n *passwordPtr1 = password;\r\n }\r\n {\r\n wchar_t * password = *passwordPtr2;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t * *passwordPtr1 = &password;\r\n wchar_t * *passwordPtr2 = &password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n wchar_t * password = *passwordPtr1;\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n *passwordPtr1 = password;\r\n }\r\n {\r\n wchar_t * password = *passwordPtr2;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * password;\r\n wchar_t * *passwordPtr1 = &password;\r\n wchar_t * *passwordPtr2 = &password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n wchar_t * password = *passwordPtr1;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n *passwordPtr1 = password;\r\n }\r\n {\r\n wchar_t * password = *passwordPtr2;\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_32()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-319:Cleartext Transmission of Sensitive Information|E.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.No Vulnerabilities\nD.CWE-186:Overly Restrictive Regular Expression\nE.CWE-415:Double Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_new_delete_int64_t_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = new int64_t;\r\n \r\n delete data;\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = new int64_t;\r\n \r\n delete data;\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = new int64_t;\r\n \r\n delete data;\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new int64_t;\r\n \r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = new int64_t;\r\n \r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_int64_t_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-415:Double Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-123:Write-what-where Condition\nB.CWE-687:Function Call With Incorrectly Specified Argument Value\nC.CWE-787:Out-of-bounds Write\nD.No Vulnerabilities\nE.CWE-1191:On-Chip Debug and Test Interface With Improper Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_connect_socket_04()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_04()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-123:Write-what-where Condition|C.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-665:Improper Initialization\nC.CWE-357:Insufficient UI Warning of Dangerous Operations\nD.CWE-325:Missing Cryptographic Step\nE.CWE-457:Use of Uninitialized Variable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double_pointer_11()\r\n{\r\n double * data;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n printDoubleLine(*data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n double * data;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n data = (double *)malloc(sizeof(double));\r\n if (data == NULL) {exit(-1);}\r\n *data = 5.0;\r\n printDoubleLine(*data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n double * data;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n \r\n data = (double *)malloc(sizeof(double));\r\n if (data == NULL) {exit(-1);}\r\n *data = 5.0;\r\n printDoubleLine(*data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n double * data;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n data = (double *)malloc(sizeof(double));\r\n if (data == NULL) {exit(-1);}\r\n *data = 5.0;\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n printDoubleLine(*data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n double * data;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n \r\n data = (double *)malloc(sizeof(double));\r\n if (data == NULL) {exit(-1);}\r\n *data = 5.0;\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n printDoubleLine(*data);\r\n }\r\n}\r\n\r\nvoid My_double_pointer_11()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double_pointer_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double_pointer_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-457:Use of Uninitialized Variable|B.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.CWE-1253:Incorrect Selection of Fuse Values\nC.No Vulnerabilities\nD.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nE.CWE-1317:Improper Access Control in Fabric Bridge\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_realloc_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(char));\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n password = realloc(password, 200 * sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n \r\n strcpy(password, \"Nothing to see here\");\r\n printLine(password);\r\n free(password);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_realloc_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_realloc_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_realloc_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-1080:Source Code File with Excessive Number of Lines of Code\nD.CWE-1335:Incorrect Bitwise Shift of Integer\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_char_memcpy_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = new char[50];\r\n memset(data, 'A', 50-1); \r\n data[50-1] = '\\0'; \r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new char[100];\r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n \r\n data = new char[100];\r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_memcpy_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-506:Embedded Malicious Code\nC.CWE-31:Path Traversal: 'dir\\..\\..\\filename'\nD.CWE-926:Improper Export of Android Application Components\nE.CWE-511:Logic/Time Bomb\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define NUM_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_rand_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-511:Logic/Time Bomb|B.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-319:Cleartext Transmission of Sensitive Information\nB.No Vulnerabilities\nC.CWE-1075:Unconditional Control Flow Transfer outside of Switch Block\nD.CWE-311:Missing Encryption of Sensitive Data\nE.CWE-863:Incorrect Authorization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_w32_wchar_t_listen_socket_22Global = 0;\r\n\r\nvoid My_w32_wchar_t_listen_socket_22Sink(wchar_t * password);\r\n\r\nvoid My_w32_wchar_t_listen_socket_22()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_wchar_t_listen_socket_22Global = 1; \r\n My_w32_wchar_t_listen_socket_22Sink(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_w32_wchar_t_listen_socket_22B2G1Global = 0;\r\nint My_w32_wchar_t_listen_socket_22B2G2Global = 0;\r\nint My_w32_wchar_t_listen_socket_22G2BGlobal = 0;\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_22B2G1Sink(wchar_t * password);\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_wchar_t_listen_socket_22B2G1Global = 0; \r\n My_w32_wchar_t_listen_socket_22B2G1Sink(password);\r\n}\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_22B2G2Sink(wchar_t * password);\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_wchar_t_listen_socket_22B2G2Global = 1; \r\n My_w32_wchar_t_listen_socket_22B2G2Sink(password);\r\n}\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_22G2BSink(wchar_t * password);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n My_w32_wchar_t_listen_socket_22G2BGlobal = 1; \r\n My_w32_wchar_t_listen_socket_22G2BSink(password);\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_22()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-319:Cleartext Transmission of Sensitive Information|D.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-164:Improper Neutralization of Internal Special Elements\nB.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nC.No Vulnerabilities\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-332:Insufficient Entropy in PRNG\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_04()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_char_04()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-364:Signal Handler Race Condition\nB.CWE-426:Untrusted Search Path\nC.CWE-673:External Influence of Sphere Definition\nD.CWE-482:Comparing instead of Assigning\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _wpopen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_wchar_t_popen_22Global = 0;\r\n\r\nwchar_t * My_wchar_t_popen_22Source(wchar_t * data);\r\n\r\nvoid My_wchar_t_popen_22()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n My_wchar_t_popen_22Global = 1; \r\n data = My_wchar_t_popen_22Source(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_wchar_t_popen_22G2B1Global = 0;\r\nint My_wchar_t_popen_22G2B2Global = 0;\r\n\r\n\r\nwchar_t * My_wchar_t_popen_22G2B1Source(wchar_t * data);\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n My_wchar_t_popen_22G2B1Global = 0; \r\n data = My_wchar_t_popen_22G2B1Source(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nwchar_t * My_wchar_t_popen_22G2B2Source(wchar_t * data);\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n My_wchar_t_popen_22G2B2Global = 1; \r\n data = My_wchar_t_popen_22G2B2Source(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_popen_22()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_popen_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_popen_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-426:Untrusted Search Path|C.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-511:Logic/Time Bomb\nB.CWE-368:Context Switching Race Condition\nC.CWE-506:Embedded Malicious Code\nD.No Vulnerabilities\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <time.h>\r\n\r\n#define TIME_CHECK ((time_t)1199163600) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_time_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_time_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_time_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_time_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-511:Logic/Time Bomb|C.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1298:Hardware Logic Contains Race Conditions\nB.CWE-284:Improper Access Control\nC.No Vulnerabilities\nD.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption\nE.CWE-1294:Insecure Security Identifier Mechanism\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n#include <shlwapi.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_SHRegCreateUSKey_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_ALL_ACCESS,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_SHRegCreateUSKey_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_SHRegCreateUSKey_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_SHRegCreateUSKey_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-284:Improper Access Control|D.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.CWE-180:Incorrect Behavior Order: Validate Before Canonicalize\nD.CWE-252:Unchecked Return Value\nE.CWE-1127:Compilation with Insufficient Warnings or Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_realloc_09()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n \r\n data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"Initialize\");\r\n printWLine(data);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n \r\n data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n wcscpy(data, L\"Initialize\");\r\n printWLine(data);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n \r\n data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n wcscpy(data, L\"Initialize\");\r\n printWLine(data);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_realloc_09()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_realloc_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_realloc_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-690:Unchecked Return Value to NULL Pointer Dereference|D.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-439:Behavioral Change in New Version or Environment\nC.CWE-121:Stack-based Buffer Overflow\nD.CWE-437:Incomplete Model of Endpoint Features\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_My_CWE131_loop_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-121:Stack-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-463:Deletion of Data Structure Sentinel\nB.No Vulnerabilities\nC.CWE-762:Mismatched Memory Management Routines\nD.CWE-590:Free of Memory not on the Heap\nE.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_struct_static_45\r\n{\r\n\r\nstatic twoIntsStruct * mData;\r\nstatic twoIntsStruct * nG2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n twoIntsStruct * data = mData;\r\n printStructLine(data);\r\n \r\n delete data;\r\n}\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n {\r\n \r\n static twoIntsStruct dataBuffer;\r\n dataBuffer.intOne = 1;\r\n dataBuffer.intTwo = 1;\r\n data = &dataBuffer;\r\n }\r\n mData = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n twoIntsStruct * data = nG2BData;\r\n printStructLine(data);\r\n \r\n delete data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n {\r\n \r\n twoIntsStruct * dataBuffer = new twoIntsStruct;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n nG2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_struct_static_45; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|C.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1288:Improper Validation of Consistency within Input\nB.CWE-588:Attempt to Access Child of a Non-structure Pointer\nC.No Vulnerabilities\nD.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = &dataMBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-588:Attempt to Access Child of a Non-structure Pointer|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-324:Use of a Key Past its Expiration Date\nB.CWE-770:Allocation of Resources Without Limits or Throttling\nC.CWE-95:Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nD.No Vulnerabilities\nE.CWE-253:Incorrect Check of Function Return Value\n", "input": "slurmd_req(slurm_msg_t *msg)\r\r\n{\r\r\n\tint rc;\r\r\n\r\r\n\tif (msg == NULL) {\r\r\n\t\tif (startup == 0)\r\r\n\t\t\tstartup = time(NULL);\r\r\n\t\tFREE_NULL_LIST(waiters);\r\r\n\t\tslurm_mutex_lock(&job_limits_mutex);\r\r\n\t\tif (job_limits_list) {\r\r\n\t\t\tFREE_NULL_LIST(job_limits_list);\r\r\n\t\t\tjob_limits_loaded = false;\r\r\n\t\t}\r\r\n\t\tslurm_mutex_unlock(&job_limits_mutex);\r\r\n\t\treturn;\r\r\n\t}\r\r\n\r\r\n\tswitch (msg->msg_type) {\r\r\n\tcase REQUEST_LAUNCH_PROLOG:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_LAUNCH_PROLOG\");\r\r\n\t\t_rpc_prolog(msg);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_BATCH_JOB_LAUNCH:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_BATCH_JOB_LAUNCH\");\r\r\n\t\t/* Mutex locking moved into _rpc_batch_job() due to\r\r\n\t\t * very slow prolog on Blue Gene system. Only batch\r\r\n\t\t * jobs are supported on Blue Gene (no job steps). */\r\r\n\t\t_rpc_batch_job(msg, true);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_LAUNCH_TASKS:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_LAUNCH_TASKS\");\r\r\n\t\tslurm_mutex_lock(&launch_mutex);\r\r\n\t\t_rpc_launch_tasks(msg);\r\r\n\t\tslurm_mutex_unlock(&launch_mutex);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_SIGNAL_TASKS:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_SIGNAL_TASKS\");\r\r\n\t\t_rpc_signal_tasks(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_CHECKPOINT_TASKS:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_CHECKPOINT_TASKS\");\r\r\n\t\t_rpc_checkpoint_tasks(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_TERMINATE_TASKS:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_TERMINATE_TASKS\");\r\r\n\t\t_rpc_terminate_tasks(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_KILL_PREEMPTED:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_KILL_PREEMPTED\");\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\t_rpc_timelimit(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_KILL_TIMELIMIT:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_KILL_TIMELIMIT\");\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\t_rpc_timelimit(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_REATTACH_TASKS:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_REATTACH_TASKS\");\r\r\n\t\t_rpc_reattach_tasks(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_SIGNAL_JOB:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_SIGNAL_JOB\");\r\r\n\t\t_rpc_signal_job(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_SUSPEND_INT:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_SUSPEND_INT\");\r\r\n\t\t_rpc_suspend_job(msg);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_ABORT_JOB:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_ABORT_JOB\");\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\t_rpc_abort_job(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_TERMINATE_JOB:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_TERMINATE_JOB\");\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\t_rpc_terminate_job(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_COMPLETE_BATCH_SCRIPT:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_COMPLETE_BATCH_SCRIPT\");\r\r\n\t\t_rpc_complete_batch(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_UPDATE_JOB_TIME:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_UPDATE_JOB_TIME\");\r\r\n\t\t_rpc_update_time(msg);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_SHUTDOWN:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_SHUTDOWN\");\r\r\n\t\t_rpc_shutdown(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_RECONFIGURE:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_RECONFIGURE\");\r\r\n\t\t_rpc_reconfig(msg);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_REBOOT_NODES:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_REBOOT_NODES\");\r\r\n\t\t_rpc_reboot(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_NODE_REGISTRATION_STATUS:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_NODE_REGISTRATION_STATUS\");\r\r\n\t\t/* Treat as ping (for slurmctld agent, just return SUCCESS) */\r\r\n\t\trc = _rpc_ping(msg);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\t/* Then initiate a separate node registration */\r\r\n\t\tif (rc == SLURM_SUCCESS)\r\r\n\t\t\tsend_registration_msg(SLURM_SUCCESS, true);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_PING:\r\r\n\t\t_rpc_ping(msg);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_HEALTH_CHECK:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_HEALTH_CHECK\");\r\r\n\t\t_rpc_health_check(msg);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_ACCT_GATHER_UPDATE:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_ACCT_GATHER_UPDATE\");\r\r\n\t\t_rpc_acct_gather_update(msg);\r\r\n\t\tlast_slurmctld_msg = time(NULL);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_ACCT_GATHER_ENERGY:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_ACCT_GATHER_ENERGY\");\r\r\n\t\t_rpc_acct_gather_energy(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_JOB_ID:\r\r\n\t\t_rpc_pid2jid(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_FILE_BCAST:\r\r\n\t\trc = _rpc_file_bcast(msg);\r\r\n\t\tslurm_send_rc_msg(msg, rc);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_STEP_COMPLETE:\r\r\n\t\t(void) _rpc_step_complete(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_STEP_COMPLETE_AGGR:\r\r\n\t\t(void) _rpc_step_complete_aggr(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_JOB_STEP_STAT:\r\r\n\t\t(void) _rpc_stat_jobacct(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_JOB_STEP_PIDS:\r\r\n\t\t(void) _rpc_list_pids(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_DAEMON_STATUS:\r\r\n\t\t_rpc_daemon_status(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_JOB_NOTIFY:\r\r\n\t\t_rpc_job_notify(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_FORWARD_DATA:\r\r\n\t\t_rpc_forward_data(msg);\r\r\n\t\tbreak;\r\r\n\tcase REQUEST_NETWORK_CALLERID:\r\r\n\t\tdebug2(\"Processing RPC: REQUEST_NETWORK_CALLERID\");\r\r\n\t\t_rpc_network_callerid(msg);\r\r\n\t\tbreak;\r\r\n\tcase MESSAGE_COMPOSITE:\r\r\n\t\terror(\"Processing RPC: MESSAGE_COMPOSITE: \"\r\r\n\t\t \"This should never happen\");\r\r\n\t\tmsg_aggr_add_msg(msg, 0, NULL);\r\r\n\t\tbreak;\r\r\n\tcase RESPONSE_MESSAGE_COMPOSITE:\r\r\n\t\tdebug2(\"Processing RPC: RESPONSE_MESSAGE_COMPOSITE\");\r\r\n\t\tmsg_aggr_resp(msg);\r\r\n\t\tbreak;\r\r\n\tdefault:\r\r\n\t\terror(\"slurmd_req: invalid request msg type %d\",\r\r\n\t\t msg->msg_type);\r\r\n\t\tslurm_send_rc_msg(msg, EINVAL);\r\r\n\t\tbreak;\r\r\n\t}\r\r\n\treturn;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.No Vulnerabilities|D.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-163:Improper Neutralization of Multiple Trailing Special Elements\nB.No Vulnerabilities\nC.CWE-313:Cleartext Storage in a File or on Disk\nD.CWE-273:Improper Check for Dropped Privileges\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#define BUFSIZE 1024\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n ImpersonateNamedPipeClient(hPipe);\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateNamedPipeClient_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateNamedPipeClient_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-273:Improper Check for Dropped Privileges|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1294:Insecure Security Identifier Mechanism\nB.CWE-783:Operator Precedence Logic Error\nC.CWE-771:Missing Reference to Active Allocated Resource\nD.No Vulnerabilities\nE.CWE-773:Missing Reference to Active File Descriptor or Handle\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_17()\r\n{\r\n int j;\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n data = fopen(\"MSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int k;\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_17()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-773:Missing Reference to Active File Descriptor or Handle|C.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-521:Weak Password Requirements\nC.CWE-174:Double Decoding of the Same Data\nD.No Vulnerabilities\nE.CWE-377:Insecure Temporary File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define TMPNAM tmpnam\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TMPNAM tmpnam\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_tmpnam_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char * filename;\r\n int fileDesc;\r\n filename = TMPNAM(NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_tmpnam_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_tmpnam_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_tmpnam_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-377:Insecure Temporary File|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-588:Attempt to Access Child of a Non-structure Pointer\nB.No Vulnerabilities\nC.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-343:Predictable Value Range from Previous Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_67\r\n{\r\n\r\ntypedef struct _structType\r\n{\r\n void * structFirst;\r\n} structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(structType myStruct);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n structType myStruct;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n myStruct.structFirst = data;\r\n mSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n structType myStruct;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n myStruct.structFirst = data;\r\n nG2BSink(myStruct);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_67; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-588:Attempt to Access Child of a Non-structure Pointer|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-210:Self-generated Error Message Containing Sensitive Information\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-1164:Irrelevant Code\nE.CWE-563:Assignment to Variable without Use\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_init_variable_char_01()\r\n{\r\n char data;\r\n \r\n data = 'C';\r\n \r\n \r\n ; \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char data;\r\n \r\n data = 'C';\r\n \r\n printHexCharLine(data);\r\n}\r\n\r\nvoid My_unused_init_variable_char_01()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_init_variable_char_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_init_variable_char_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-515:Covert Storage Channel\nB.CWE-469:Use of Pointer Subtraction to Determine Size\nC.CWE-682:Incorrect Calculation\nD.CWE-159:Improper Handling of Invalid Use of Special Elements\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SOURCE_STRING \"abc/opqrstu\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char string2[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string2);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char string1[] = SOURCE_STRING;\r\n char * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = strchr(string1, '/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-469:Use of Pointer Subtraction to Determine Size|C.CWE-682:Incorrect Calculation", "cwe": "469"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1280:Access Control Check Implemented After Asset is Accessed\nB.No Vulnerabilities\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-194:Unexpected Sign Extension\nE.CWE-421:Race Condition During Access to Alternate Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_listen_socket_strncpy_81\r\n{\r\n\r\nclass My_listen_socket_strncpy_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(short data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_listen_socket_strncpy_81 : public My_listen_socket_strncpy_81_base\r\n{\r\npublic:\r\n void action(short data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_listen_socket_strncpy_81G2B : public My_listen_socket_strncpy_81_base\r\n{\r\npublic:\r\n void action(short data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-194:Unexpected Sign Extension|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-652:Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')\nC.CWE-475:Undefined Behavior for Input to API\nD.No Vulnerabilities\nE.CWE-638:Not Using Complete Mediation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-475:Undefined Behavior for Input to API|A.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-368:Context Switching Race Condition\nD.CWE-1323:Improper Management of Sensitive Trace Data\nE.CWE-197:Numeric Truncation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_listen_socket_to_short_32()\r\n{\r\n int data;\r\n int *dataPtr1 = &data;\r\n int *dataPtr2 = &data;\r\n \r\n data = -1;\r\n {\r\n int data = *dataPtr1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int data = *dataPtr2;\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n int *dataPtr1 = &data;\r\n int *dataPtr2 = &data;\r\n \r\n data = -1;\r\n {\r\n int data = *dataPtr1;\r\n \r\n data = CHAR_MAX-5;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n int data = *dataPtr2;\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_listen_socket_to_short_32()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_listen_socket_to_short_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_listen_socket_to_short_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-197:Numeric Truncation Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-7:J2EE Misconfiguration: Missing Custom Error Page\nB.CWE-704:Incorrect Type Conversion or Cast\nC.No Vulnerabilities\nD.CWE-691:Insufficient Control Flow Management\nE.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_31()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n {\r\n void * dataCopy = data;\r\n void * data = dataCopy;\r\n \r\n printIntLine(*((int*)data));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n {\r\n void * dataCopy = data;\r\n void * data = dataCopy;\r\n \r\n printIntLine(*((int*)data));\r\n }\r\n}\r\n\r\nvoid My_char_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-796:Only Filtering Special Elements Relative to a Marker\nB.CWE-52:Path Equivalence: '/multiple/trailing/slash//'\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.No Vulnerabilities\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\nnamespace My_wchar_t_file_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(wchar_t * &data)\r\n{\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n mSource(data);\r\n \r\n for (; *data != L'\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2GSource(wchar_t * &data)\r\n{\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n nB2GSource(data);\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_file_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1291:Public Key Re-Use for Signing both Debug and Production Code\nB.No Vulnerabilities\nC.CWE-926:Improper Export of Android Application Components\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-124:Buffer Underwrite ('Buffer Underflow')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_wchar_t_memmove_05()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n memmove(data, source, 100*sizeof(wchar_t));\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n memmove(data, source, 100*sizeof(wchar_t));\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n memmove(data, source, 100*sizeof(wchar_t));\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_memmove_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_memmove_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_memmove_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-124:Buffer Underwrite ('Buffer Underflow')|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nB.No Vulnerabilities\nC.CWE-446:UI Discrepancy for Security Feature\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\nnamespace My_w32_wchar_t_connect_socket_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_connect_socket_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-115:Misinterpretation of Input\nB.CWE-123:Write-what-where Condition\nC.No Vulnerabilities\nD.CWE-787:Out-of-bounds Write\nE.CWE-1190:DMA Device Enabled Too Early in Boot Phase\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_connect_socket_22Global = 0;\r\n\r\nmStruct My_connect_socket_22Source(mStruct data);\r\n\r\nvoid My_connect_socket_22()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n My_connect_socket_22Global = 1; \r\n data = My_connect_socket_22Source(data);\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_connect_socket_22G2B1Global = 0;\r\nint My_connect_socket_22G2B2Global = 0;\r\n\r\n\r\nmStruct My_connect_socket_22G2B1Source(mStruct data);\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n My_connect_socket_22G2B1Global = 0; \r\n data = My_connect_socket_22G2B1Source(data);\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nmStruct My_connect_socket_22G2B2Source(mStruct data);\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n My_connect_socket_22G2B2Global = 1; \r\n data = My_connect_socket_22G2B2Source(data);\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_22()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-627:Dynamic Variable Evaluation\nE.CWE-1245:Improper Finite State Machines (FSMs) in Hardware Logic\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_wchar_t_malloc_54\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n \r\n data = new wchar_t;\r\n nG2BSink_b(data);\r\n}\r\n\r\n\r\nvoid nB2GSink_b(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n nB2GSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_wchar_t_malloc_54; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-476:NULL Pointer Dereference\nD.CWE-912:Hidden Functionality\nE.CWE-1087:Class with Virtual Method without a Virtual Destructor\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint fellies_forceless = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid unhorny_hydatigenous(void **manus_dillseed);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n void (*unkill_tsukupin)(void **) = unhorny_hydatigenous;\r\n void **chorgi_symbionts = 0;\r\n void *browny_bravo = 0;\r\n char *thespian_tableman;;\r\n if (__sync_bool_compare_and_swap(&fellies_forceless,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n thespian_tableman = getenv(\"DAFTAR_GROOVIEST\");\r\n if (thespian_tableman != 0) {;\r\n browny_bravo = ((void *)thespian_tableman);\r\n chorgi_symbionts = &browny_bravo;\r\n unkill_tsukupin(chorgi_symbionts);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid unhorny_hydatigenous(void **manus_dillseed)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *beveled_qkt = 0;\r\n ++global_variable;;\r\n beveled_qkt = ((char *)((char *)( *manus_dillseed)));\r\n \r\n buffer_value = atoi(beveled_qkt);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1394:Use of Default Cryptographic Key\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-771:Missing Reference to Active Allocated Resource\nE.CWE-420:Unprotected Alternate Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_13()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = fopen(\"MSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|D.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1078:Inappropriate Source Code Style or Formatting\nB.CWE-187:Partial String Comparison\nC.CWE-272:Least Privilege Violation\nD.CWE-546:Suspicious Comment\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_LATER_05()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_LATER_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_LATER_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_LATER_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-546:Suspicious Comment|A.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-252:Unchecked Return Value\nC.CWE-478:Missing Default Case in Multiple Condition Expression\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define SRC L\"sscanf\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_sscanf_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n swscanf(SRC, L\"%99s\\0\", data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_sscanf_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_sscanf_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_sscanf_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-99:Improper Control of Resource Identifiers ('Resource Injection')\nB.CWE-274:Improper Handling of Insufficient Privileges\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.No Vulnerabilities\nE.CWE-197:Numeric Truncation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fgets_to_short_31()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = CHAR_MAX-5;\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_fgets_to_short_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fgets_to_short_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fgets_to_short_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-197:Numeric Truncation Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-87:Improper Neutralization of Alternate XSS Syntax\nB.CWE-396:Declaration of Catch for Generic Exception\nC.CWE-565:Reliance on Cookies without Validation and Integrity Checking\nD.CWE-317:Cleartext Storage of Sensitive Information in GUI\nE.No Vulnerabilities\n", "input": "int ssl_get_new_session(SSL *s, int session)\r\r\n{\r\r\n /* This gets used by clients and servers. */\r\r\n\r\r\n unsigned int tmp;\r\r\n SSL_SESSION *ss = NULL;\r\r\n GEN_SESSION_CB cb = def_generate_session_id;\r\r\n\r\r\n if ((ss = SSL_SESSION_new()) == NULL)\r\r\n return (0);\r\r\n\r\r\n /* If the context has a default timeout, use it */\r\r\n if (s->session_ctx->session_timeout == 0)\r\r\n ss->timeout = SSL_get_default_timeout(s);\r\r\n else\r\r\n ss->timeout = s->session_ctx->session_timeout;\r\r\n\r\r\n SSL_SESSION_free(s->session);\r\r\n s->session = NULL;\r\r\n\r\r\n if (session) {\r\r\n if (s->version == SSL3_VERSION) {\r\r\n ss->ssl_version = SSL3_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == TLS1_VERSION) {\r\r\n ss->ssl_version = TLS1_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == TLS1_1_VERSION) {\r\r\n ss->ssl_version = TLS1_1_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == TLS1_2_VERSION) {\r\r\n ss->ssl_version = TLS1_2_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == DTLS1_M_VER) {\r\r\n ss->ssl_version = DTLS1_M_VER;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == DTLS1_VERSION) {\r\r\n ss->ssl_version = DTLS1_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == DTLS1_2_VERSION) {\r\r\n ss->ssl_version = DTLS1_2_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else {\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION);\r\r\n SSL_SESSION_free(ss);\r\r\n return (0);\r\r\n }\r\r\n\r\r\n /*-\r\r\n * If RFC5077 ticket, use empty session ID (as server).\r\r\n * Note that:\r\r\n * (a) ssl_get_prev_session() does lookahead into the\r\r\n * ClientHello extensions to find the session ticket.\r\r\n * When ssl_get_prev_session() fails, s3_srvr.c calls\r\r\n * ssl_get_new_session() in ssl3_get_client_hello().\r\r\n * At that point, it has not yet parsed the extensions,\r\r\n * however, because of the lookahead, it already knows\r\r\n * whether a ticket is expected or not.\r\r\n *\r\r\n * (b) s3_clnt.c calls ssl_get_new_session() before parsing\r\r\n * ServerHello extensions, and before recording the session\r\r\n * ID received from the server, so this block is a noop.\r\r\n */\r\r\n if (s->tlsext_ticket_expected) {\r\r\n ss->session_id_length = 0;\r\r\n goto sess_id_done;\r\r\n }\r\r\n\r\r\n /* Choose which callback will set the session ID */\r\r\n CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\r\r\n if (s->generate_session_id)\r\r\n cb = s->generate_session_id;\r\r\n else if (s->session_ctx->generate_session_id)\r\r\n cb = s->session_ctx->generate_session_id;\r\r\n CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\r\r\n /* Choose a session ID */\r\r\n tmp = ss->session_id_length;\r\r\n if (!cb(s, ss->session_id, &tmp)) {\r\r\n /* The callback failed */\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION,\r\r\n SSL_R_SSL_SESSION_ID_CALLBACK_FAILED);\r\r\n SSL_SESSION_free(ss);\r\r\n return (0);\r\r\n }\r\r\n /*\r\r\n * Don't allow the callback to set the session length to zero. nor\r\r\n * set it higher than it was.\r\r\n */\r\r\n if (!tmp || (tmp > ss->session_id_length)) {\r\r\n /* The callback set an illegal length */\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION,\r\r\n SSL_R_SSL_SESSION_ID_HAS_M_LENGTH);\r\r\n SSL_SESSION_free(ss);\r\r\n return (0);\r\r\n }\r\r\n ss->session_id_length = tmp;\r\r\n /* Finally, check for a conflict */\r\r\n if (SSL_has_matching_session_id(s, ss->session_id,\r\r\n ss->session_id_length)) {\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_SSL_SESSION_ID_CONFLICT);\r\r\n SSL_SESSION_free(ss);\r\r\n return (0);\r\r\n }\r\r\n\r\r\n sess_id_done:\r\r\n if (s->tlsext_hostname) {\r\r\n ss->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\r\r\n if (ss->tlsext_hostname == NULL) {\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);\r\r\n SSL_SESSION_free(ss);\r\r\n return 0;\r\r\n }\r\r\n }\r\r\n } else {\r\r\n ss->session_id_length = 0;\r\r\n }\r\r\n\r\r\n if (s->sid_ctx_length > sizeof ss->sid_ctx) {\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);\r\r\n SSL_SESSION_free(ss);\r\r\n return 0;\r\r\n }\r\r\n memcpy(ss->sid_ctx, s->sid_ctx, s->sid_ctx_length);\r\r\n ss->sid_ctx_length = s->sid_ctx_length;\r\r\n s->session = ss;\r\r\n ss->ssl_version = s->version;\r\r\n ss->verify_result = X509_V_OK;\r\r\n\r\r\n return (1);\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.No Vulnerabilities|E.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-178:Improper Handling of Case Sensitivity\nB.CWE-252:Unchecked Return Value\nC.CWE-921:Storage of Sensitive Data in a Mechanism without Access Control\nD.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(twoIntsStruct * data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_struct_malloc_21()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\n\r\n\r\nstatic void nB2G1Sink(twoIntsStruct * data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(twoIntsStruct * data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\nvoid My_struct_malloc_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_malloc_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_malloc_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-690:Unchecked Return Value to NULL Pointer Dereference|B.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-186:Overly Restrictive Regular Expression\nB.No Vulnerabilities\nC.CWE-284:Improper Access Control\nD.CWE-806:Buffer Access Using Size of Source Buffer\nE.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateWindowStation_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n wchar_t * wStationName = L\"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationW(\r\n wStationName,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n wchar_t * wStationName = L\"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationW(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n wchar_t * wStationName = L\"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationW(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateWindowStation_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateWindowStation_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateWindowStation_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-284:Improper Access Control|A.CWE-186:Overly Restrictive Regular Expression", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-940:Improper Verification of Source of a Communication Channel\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-1058:Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element\nE.CWE-475:Undefined Behavior for Input to API\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(char));\r\n printLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(char));\r\n printLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-475:Undefined Behavior for Input to API|C.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-299:Improper Check for Certificate Revocation\nB.No Vulnerabilities\nC.CWE-756:Missing Custom Error Page\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-483:Incorrect Block Delimitation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_semicolon_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0);\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_semicolon_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_semicolon_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_semicolon_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-483:Incorrect Block Delimitation|D.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "483"}
