{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint alani_coppersmith = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar process_buffer(char *buffer_param)\r\n{\r\n \r\n char first_char;\r\n first_char = buffer_param[0] - 97;\r\n free(buffer_param);\r\n return first_char;\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int oc_i = 0;\r\n int tainted_len;\r\n char **buffer_ptr = 0;\r\n int main_first_char = 0;\r\n int buffer_len;\r\n char *buffer = 0;\r\n char *annalist_asphyxiation = 0;\r\n char **aedoeology_enteroplasty = 0;\r\n int **********mandyai_vouchees = 0;\r\n int *********abstentions_ignorantism = 0;\r\n int ********overdramatized_thalassal = 0;\r\n int *******nonputting_deciduata = 0;\r\n int ******antiscepticism_sarcomeric = 0;\r\n int *****monarchize_fastus = 0;\r\n int ****placodont_brum = 0;\r\n int ***swinge_barbulyie = 0;\r\n int **heterologically_communer = 0;\r\n int *fumid_nightish = 0;\r\n int nivellator_joseph;\r\n char **roofless_osphresiometry[10] = {0};\r\n char *mopan_superhero[27] = {0};\r\n char *melvie_asylabia;;\r\n if (__sync_bool_compare_and_swap(&alani_coppersmith,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&melvie_asylabia,\"VICTIMISE_WALLSEND\");\r\n if (melvie_asylabia != 0) {;\r\n mopan_superhero[1] = melvie_asylabia;\r\n nivellator_joseph = 5;\r\n fumid_nightish = &nivellator_joseph;\r\n heterologically_communer = &fumid_nightish;\r\n swinge_barbulyie = &heterologically_communer;\r\n placodont_brum = &swinge_barbulyie;\r\n monarchize_fastus = &placodont_brum;\r\n antiscepticism_sarcomeric = &monarchize_fastus;\r\n nonputting_deciduata = &antiscepticism_sarcomeric;\r\n overdramatized_thalassal = &nonputting_deciduata;\r\n abstentions_ignorantism = &overdramatized_thalassal;\r\n mandyai_vouchees = &abstentions_ignorantism;\r\n roofless_osphresiometry[ *( *( *( *( *( *( *( *( *( *mandyai_vouchees)))))))))] = mopan_superhero;\r\n aedoeology_enteroplasty = roofless_osphresiometry[ *( *( *( *( *( *( *( *( *( *mandyai_vouchees)))))))))];\r\n if (aedoeology_enteroplasty[1] != 0) {\r\n goto manbarklak_quenches;\r\n }\r\n ++global_variable;\r\n manbarklak_quenches:;\r\n annalist_asphyxiation = ((char *)aedoeology_enteroplasty[1]);\r\n \r\n buffer_len = 4;\r\n buffer = malloc(65528);\r\n if (buffer != NULL) {\r\n strncpy(buffer, annalist_asphyxiation, buffer_len);\r\n buffer[buffer_len - 1] = 0;\r\n printf(\"%s\\n\", buffer);\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n if (buffer[0] >= 97) {\r\n \r\n main_first_char = process_buffer(buffer);\r\n }\r\n \r\n buffer_ptr = malloc(65528);\r\n \r\n if (buffer_ptr != NULL) {\r\n *buffer_ptr = annalist_asphyxiation;\r\n \r\n \r\n \r\n \r\n \r\n strncpy(buffer, annalist_asphyxiation, buffer_len);\r\n buffer[buffer_len - 1] = '\\0';\r\n tainted_len = strlen( *buffer_ptr); \r\n \r\n printf(\"%c\\n\", main_first_char);\r\n for (; oc_i < buffer_len; ++oc_i) {\r\n buffer[oc_i] = toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\", buffer);\r\n if (main_first_char == 0) {\r\n if (buffer != 0) {\r\n free(buffer);\r\n }\r\n }\r\n if (buffer_ptr != 0) {\r\n free(buffer_ptr);\r\n }\r\n }\r\n }\r\n \r\n;\r\n if (aedoeology_enteroplasty[1] != 0) \r\n free(((char *)aedoeology_enteroplasty[1]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n strncpy(buffer, annalist_asphyxiation, buffer_len);\n buffer[buffer_len - 1] = '\\0';\n tainted_len = strlen( *buffer_ptr); \n```", "cwe": "416"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint featherwood_cornuting = 0;\r\nint global_variable;\r\n\r\nstruct rompish_siddons \r\n{\r\n char *crackbrained_mia;\r\n double subtrapezoidal_excellency;\r\n char *punkeys_bioclimatician;\r\n char foliiform_homomorphism;\r\n int openly_lallans;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid prepurchases_szeged(struct rompish_siddons *unelbowed_bassia);\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n void (*branchiopoda_mismeets)(struct rompish_siddons *) = prepurchases_szeged;\r\n struct rompish_siddons *predivide_scrappler = {0};\r\n struct rompish_siddons sigillation_phalaenae;\r\n int hypercalcaemia_semijuridical = 125;\r\n char *alkoran_slipcases;;\r\n if (__sync_bool_compare_and_swap(&featherwood_cornuting,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&alkoran_slipcases,\"8625\",hypercalcaemia_semijuridical);\r\n if (alkoran_slipcases != 0) {;\r\n sigillation_phalaenae . crackbrained_mia = ((char *)alkoran_slipcases);\r\n predivide_scrappler = &sigillation_phalaenae;\r\n branchiopoda_mismeets(predivide_scrappler);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid prepurchases_szeged(struct rompish_siddons *unelbowed_bassia)\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *paralgesia_phren = 0;\r\n ++global_variable;;\r\n paralgesia_phren = ((char *)( *unelbowed_bassia) . crackbrained_mia);\r\n \r\n \r\n\r\n if (strlen(paralgesia_phren) < 63) {\r\n skip_malloc_buffer = malloc(strlen(paralgesia_phren + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,paralgesia_phren);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\n if (( *unelbowed_bassia) . crackbrained_mia != 0) \r\n free(((char *)( *unelbowed_bassia) . crackbrained_mia));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n strcpy(skip_malloc_buffer,paralgesia_phren);\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint trilly_nontangibleness = 0;\r\n\r\nunion undercrop_wessands \r\n{\r\n char *polypi_fims;\r\n double rotting_scrubbily;\r\n char *bachelry_amphilochus;\r\n char unimpressible_peritonealgia;\r\n int rimed_levining;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *hairbrained_veblenism);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid telodendria_nonmedicinally(int curtsies_consecutive,union undercrop_wessands truest_forlay);\r\nint search(char *str_param,char c_param)\r\n{\r\n \r\n if ( *str_param == c_param) {\r\n return 1;\r\n } else if ( *str_param == 0) {\r\n \r\n \r\n return search(&str_param[0],c_param);\r\n } else {\r\n return search(&str_param[1],c_param);\r\n }\r\n}\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&trilly_nontangibleness,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nvoid handle_taint(char *hairbrained_veblenism)\r\n{\r\n int enchronicle_diseducate = 7;\r\n union undercrop_wessands philippus_cymenes = {0};\r\n int *laotian_blanch = 0;\r\n int sabayons_trainmen;\r\n union undercrop_wessands wooshes_rectorates[10] = {0};\r\n union undercrop_wessands colliquation_gymnosophist;\r\n ++global_variable;;\r\n if (hairbrained_veblenism != 0) {;\r\n colliquation_gymnosophist . polypi_fims = hairbrained_veblenism;\r\n sabayons_trainmen = 5;\r\n laotian_blanch = &sabayons_trainmen;\r\n wooshes_rectorates[ *laotian_blanch] = colliquation_gymnosophist;\r\n philippus_cymenes = wooshes_rectorates[ *laotian_blanch];\r\n telodendria_nonmedicinally(enchronicle_diseducate,philippus_cymenes);\r\n }\r\n}\r\n\r\nvoid telodendria_nonmedicinally(int curtsies_consecutive,union undercrop_wessands truest_forlay)\r\n{\r\n int found;\r\n char *avignonese_amphiarthrodial = 0;\r\n ++global_variable;\r\n curtsies_consecutive--;\r\n if (curtsies_consecutive > 0) {\r\n telodendria_nonmedicinally(curtsies_consecutive,truest_forlay);\r\n return ;\r\n }\r\n avignonese_amphiarthrodial = ((char *)truest_forlay . polypi_fims);\r\n \r\n \r\n \r\n found = search(&avignonese_amphiarthrodial[1],avignonese_amphiarthrodial[0]);\r\n \r\n \r\n \r\n;\r\n if (truest_forlay . polypi_fims != 0) \r\n free(((char *)truest_forlay . polypi_fims));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` found = search(&avignonese_amphiarthrodial[1],avignonese_amphiarthrodial[0]);\n```", "cwe": "674"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nint bianka_unfoolishness = 0;\r\nint global_variable;\r\n\r\nstruct sassamansville_steamerload \r\n{\r\n char *odontolite_fontinas;\r\n double distrust_tesserarian;\r\n char *theolog_accessors;\r\n char miff_jemine;\r\n int antihormone_bantry;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid tackingly_entireness(struct sassamansville_steamerload chromate_bissextile);\r\nvoid scribes_dinettes(struct sassamansville_steamerload zebulun_apothecal);\r\nstruct struct {\r\n void (*function_ptr_1)();\r\n unsigned int input_num;\r\n void (*function_ptr_2)();\r\n};\r\nvoid function() {\r\n \r\n}\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n struct sassamansville_steamerload cheshire_uninweaved = {0};\r\n long brewers_tusches[10];\r\n struct sassamansville_steamerload pyramidic_hexagynous[10] = {0};\r\n struct sassamansville_steamerload postmasterlike_esterifiable;\r\n int forcelet_ladonna = 7;\r\n char *underborn_zipangu;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&bianka_unfoolishness,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&underborn_zipangu,\"8267\",forcelet_ladonna);\r\n if (underborn_zipangu != 0) {;\r\n postmasterlike_esterifiable . odontolite_fontinas = ((char *)underborn_zipangu);\r\n pyramidic_hexagynous[5] = postmasterlike_esterifiable;\r\n brewers_tusches[1] = 5;\r\n cheshire_uninweaved = *(pyramidic_hexagynous + brewers_tusches[1]);\r\n tackingly_entireness(cheshire_uninweaved);\r\n }\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nvoid tackingly_entireness(struct sassamansville_steamerload chromate_bissextile)\r\n{\r\n ++global_variable;;\r\n scribes_dinettes(chromate_bissextile);\r\n}\r\n\r\nvoid scribes_dinettes(struct sassamansville_steamerload zebulun_apothecal)\r\n{\r\n char *byte_4 = 0;\r\n char *byte_3 = 0;\r\n unsigned int *ptr = 0;\r\n struct struct ssS;\r\n char *fatheadedness_relicensing = 0;\r\n ++global_variable;;\r\n fatheadedness_relicensing = ((char *)zebulun_apothecal . odontolite_fontinas);\r\n \r\n ssS.function_ptr_1 = function;\r\n ssS.function_ptr_2 = function;\r\n if (strlen(fatheadedness_relicensing) >= 1 &&\r\n fatheadedness_relicensing[0] != '-') {\r\n ssS.input_num = strtoul(fatheadedness_relicensing,0U,16);\r\n ptr = &(ssS.input_num);\r\n if ( *ptr > 65535) {\r\n \r\n \r\n \r\n byte_3 = ((char *)(ptr + 2));\r\n byte_4 = ((char *)(ptr + 3));\r\n *byte_3 = 0;\r\n *byte_4 = 0;\r\n \r\n \r\n \r\n }\r\n \r\n \r\n ssS.function_ptr_2();\r\n \r\n printf(\"Value = %i\\n\", ssS.input_num);\r\n } else if (strlen(fatheadedness_relicensing) == 0) {\r\n printf(\"Input is empty string\\n\");\r\n } else {\r\n printf(\"Input is negative number\\n\");\r\n }\r\n \r\n;\r\n if (zebulun_apothecal . odontolite_fontinas != 0) \r\n free(((char *)zebulun_apothecal . odontolite_fontinas));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n ssS.function_ptr_2();\n```", "cwe": "682"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint demeritoriously_penryn = 0;\r\n\r\nstruct nonpliancy_mesologic \r\n{\r\n char *perdured_turkana;\r\n double motheriness_brandiron;\r\n char *aegemony_yellowed;\r\n char elle_aghanee;\r\n int livelihood_cuyapo;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *inflammatorily_squirming);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&demeritoriously_penryn,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid handle_taint(char *inflammatorily_squirming)\r\n{\r\n int stack_size = 0;\r\n char *accrington_maidly = 0;\r\n struct nonpliancy_mesologic uninterposed_gymnoconia = {0};\r\n int **************************************************blady_colitoxemia = 0;\r\n int *************************************************tilapia_lengthen = 0;\r\n int ************************************************cruors_abnegate = 0;\r\n int ***********************************************microsomatous_multiflow = 0;\r\n int **********************************************shipbuilding_torulin = 0;\r\n int *********************************************nonconcur_appointer = 0;\r\n int ********************************************ferromagnetism_clorinda = 0;\r\n int *******************************************addleheadedly_triumphancy = 0;\r\n int ******************************************cavilers_cannons = 0;\r\n int *****************************************memlinc_stairways = 0;\r\n int ****************************************falloff_gervais = 0;\r\n int ***************************************surtout_ideamonger = 0;\r\n int **************************************geelhout_yokeage = 0;\r\n int *************************************grapey_ablepharia = 0;\r\n int ************************************humanitarian_insurgent = 0;\r\n int ***********************************zaurak_syllid = 0;\r\n int **********************************kraits_calamondin = 0;\r\n int *********************************overspice_quizzification = 0;\r\n int ********************************canonizations_ashkum = 0;\r\n int *******************************clervaux_exhortator = 0;\r\n int ******************************teutonic_triazane = 0;\r\n int *****************************respiratored_bulbul = 0;\r\n int ****************************ingles_airtightness = 0;\r\n int ***************************pressurizers_chrysocale = 0;\r\n int **************************mapleface_precontest = 0;\r\n int *************************seamanships_underexposure = 0;\r\n int ************************devow_amroc = 0;\r\n int ***********************bylander_pilledness = 0;\r\n int **********************casco_taglet = 0;\r\n int *********************rejeopardized_dormitary = 0;\r\n int ********************characterology_abstersion = 0;\r\n int *******************carlini_betonica = 0;\r\n int ******************pellagras_hurler = 0;\r\n int *****************myeline_meninting = 0;\r\n int ****************palaeentomology_linus = 0;\r\n int ***************hearting_piman = 0;\r\n int **************translucidus_poll = 0;\r\n int *************turista_badinages = 0;\r\n int ************blepharedema_major = 0;\r\n int ***********afr_cacothansia = 0;\r\n int **********preultimate_potherbs = 0;\r\n int *********counterfallacy_eranthemum = 0;\r\n int ********striolate_pedregal = 0;\r\n int *******dipneust_precoincidently = 0;\r\n int ******precoincidently_asseth = 0;\r\n int *****chines_cloudberry = 0;\r\n int ****percoids_peltries = 0;\r\n int ***neurocoele_bancroft = 0;\r\n int **utopisms_chasse = 0;\r\n int *susanoo_unworthies = 0;\r\n int represcribed_solvencies;\r\n struct nonpliancy_mesologic unfreezes_sandman[10] = {0};\r\n struct nonpliancy_mesologic casseroled_hypercalcemic;\r\n ++global_variable;;\r\n if (inflammatorily_squirming != 0) {;\r\n casseroled_hypercalcemic . perdured_turkana = ((char *)inflammatorily_squirming);\r\n represcribed_solvencies = 5;\r\n susanoo_unworthies = &represcribed_solvencies;\r\n utopisms_chasse = &susanoo_unworthies;\r\n neurocoele_bancroft = &utopisms_chasse;\r\n percoids_peltries = &neurocoele_bancroft;\r\n chines_cloudberry = &percoids_peltries;\r\n precoincidently_asseth = &chines_cloudberry;\r\n dipneust_precoincidently = &precoincidently_asseth;\r\n striolate_pedregal = &dipneust_precoincidently;\r\n counterfallacy_eranthemum = &striolate_pedregal;\r\n preultimate_potherbs = &counterfallacy_eranthemum;\r\n afr_cacothansia = &preultimate_potherbs;\r\n blepharedema_major = &afr_cacothansia;\r\n turista_badinages = &blepharedema_major;\r\n translucidus_poll = &turista_badinages;\r\n hearting_piman = &translucidus_poll;\r\n palaeentomology_linus = &hearting_piman;\r\n myeline_meninting = &palaeentomology_linus;\r\n pellagras_hurler = &myeline_meninting;\r\n carlini_betonica = &pellagras_hurler;\r\n characterology_abstersion = &carlini_betonica;\r\n rejeopardized_dormitary = &characterology_abstersion;\r\n casco_taglet = &rejeopardized_dormitary;\r\n bylander_pilledness = &casco_taglet;\r\n devow_amroc = &bylander_pilledness;\r\n seamanships_underexposure = &devow_amroc;\r\n mapleface_precontest = &seamanships_underexposure;\r\n pressurizers_chrysocale = &mapleface_precontest;\r\n ingles_airtightness = &pressurizers_chrysocale;\r\n respiratored_bulbul = &ingles_airtightness;\r\n teutonic_triazane = &respiratored_bulbul;\r\n clervaux_exhortator = &teutonic_triazane;\r\n canonizations_ashkum = &clervaux_exhortator;\r\n overspice_quizzification = &canonizations_ashkum;\r\n kraits_calamondin = &overspice_quizzification;\r\n zaurak_syllid = &kraits_calamondin;\r\n humanitarian_insurgent = &zaurak_syllid;\r\n grapey_ablepharia = &humanitarian_insurgent;\r\n geelhout_yokeage = &grapey_ablepharia;\r\n surtout_ideamonger = &geelhout_yokeage;\r\n falloff_gervais = &surtout_ideamonger;\r\n memlinc_stairways = &falloff_gervais;\r\n cavilers_cannons = &memlinc_stairways;\r\n addleheadedly_triumphancy = &cavilers_cannons;\r\n ferromagnetism_clorinda = &addleheadedly_triumphancy;\r\n nonconcur_appointer = &ferromagnetism_clorinda;\r\n shipbuilding_torulin = &nonconcur_appointer;\r\n microsomatous_multiflow = &shipbuilding_torulin;\r\n cruors_abnegate = &microsomatous_multiflow;\r\n tilapia_lengthen = &cruors_abnegate;\r\n blady_colitoxemia = &tilapia_lengthen;\r\n unfreezes_sandman[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *blady_colitoxemia)))))))))))))))))))))))))))))))))))))))))))))))))] = casseroled_hypercalcemic;\r\n uninterposed_gymnoconia = unfreezes_sandman[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *blady_colitoxemia)))))))))))))))))))))))))))))))))))))))))))))))))];\r\n accrington_maidly = ((char *)uninterposed_gymnoconia . perdured_turkana);\r\n \r\n \r\n \r\n if (strlen(accrington_maidly) > 1 &&\r\n accrington_maidly[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n stack_size = strtoul(accrington_maidly,0,0);\r\n printf(\"Allocating stack array\\n\");\r\n \r\n \r\n \r\n char stack_string[stack_size];\r\n memset(stack_string,'x',stack_size - 1);\r\n \r\n }\r\n \r\n \r\n;\r\n if (uninterposed_gymnoconia . perdured_turkana != 0) \r\n free(((char *)uninterposed_gymnoconia . perdured_turkana));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n char stack_string[stack_size];\n memset(stack_string,'x',stack_size - 1);\n```", "cwe": "789"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint selfing_fims = 0;\r\ntypedef char *precollapse_buckleya;\r\nint global_variable;\r\nvoid handle_taint(char *imposts_yetling);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid keester_gnomonological(int frary_bankeress,precollapse_buckleya nonutility_allons);\r\nvoid hispanicized_boatyards(int radmilla_promotions,precollapse_buckleya nonsparkling_spellable);\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&selfing_fims,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid handle_taint(char *imposts_yetling)\r\n{\r\n int cumenyl_minoration = 7;\r\n precollapse_buckleya preconjectured_venomproof = 0;\r\n ++global_variable;;\r\n if (imposts_yetling != 0) {;\r\n preconjectured_venomproof = imposts_yetling;\r\n keester_gnomonological(cumenyl_minoration,preconjectured_venomproof);\r\n }\r\n}\r\n\r\nvoid keester_gnomonological(int frary_bankeress,precollapse_buckleya nonutility_allons)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *olograph_shotshell = 0;\r\n ++global_variable;\r\n frary_bankeress--;\r\n if (frary_bankeress > 0) {\r\n hispanicized_boatyards(frary_bankeress,nonutility_allons);\r\n return ;\r\n }\r\n olograph_shotshell = ((char *)nonutility_allons);\r\n \r\n len = strtol(olograph_shotshell,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (nonutility_allons != 0) \r\n free(((char *)nonutility_allons));\r\nclose_printf_context();\r\n}\r\n\r\nvoid hispanicized_boatyards(int radmilla_promotions,precollapse_buckleya nonsparkling_spellable)\r\n{\r\n ++global_variable;\r\n keester_gnomonological(radmilla_promotions,nonsparkling_spellable);\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint polemicize_tormentedly = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *lao_alethoscope = 0;\r\n char ***************************************************unsalvability_daubing = 0;\r\n char **************************************************nonconformable_unviolent = 0;\r\n char *************************************************autographed_sanatoriums = 0;\r\n char ************************************************rechallenging_toploftily = 0;\r\n char ***********************************************implacental_cooeys = 0;\r\n char **********************************************nomos_paeanize = 0;\r\n char *********************************************debs_codeinas = 0;\r\n char ********************************************waterage_raffled = 0;\r\n char *******************************************dygal_shieldmaker = 0;\r\n char ******************************************dodecahedron_filigreed = 0;\r\n char *****************************************semipause_sokols = 0;\r\n char ****************************************galer_mislaid = 0;\r\n char ***************************************polymastigous_situs = 0;\r\n char **************************************heteropterous_unfertilisable = 0;\r\n char *************************************clactonian_theosophic = 0;\r\n char ************************************overpayments_engineerings = 0;\r\n char ***********************************stickmen_shuzo = 0;\r\n char **********************************annadiana_unsophisticated = 0;\r\n char *********************************headmaster_jillions = 0;\r\n char ********************************strongpoint_spolium = 0;\r\n char *******************************coesite_amyelous = 0;\r\n char ******************************borderism_democratizing = 0;\r\n char *****************************cannonades_voltize = 0;\r\n char ****************************usphs_introverse = 0;\r\n char ***************************baresarks_amphigoric = 0;\r\n char **************************overbrag_eau = 0;\r\n char *************************pleopod_nipponize = 0;\r\n char ************************jaghatai_bumpier = 0;\r\n char ***********************imm_overfatigue = 0;\r\n char **********************starboard_wastrife = 0;\r\n char *********************zalucki_indraught = 0;\r\n char ********************compactedly_reengraving = 0;\r\n char *******************bosque_vinegarist = 0;\r\n char ******************newberg_filum = 0;\r\n char *****************unobtrusiveness_dutymonger = 0;\r\n char ****************droghlin_pasquillic = 0;\r\n char ***************contrabandist_liomyofibroma = 0;\r\n char **************antarctical_chrysophyll = 0;\r\n char *************cadee_linos = 0;\r\n char ************underpressure_steaded = 0;\r\n char ***********semishrubby_outtrick = 0;\r\n char **********admixing_inefficient = 0;\r\n char *********microcosms_lainer = 0;\r\n char ********misogynistic_forbborne = 0;\r\n char *******noncontagiously_poucey = 0;\r\n char ******unfilched_forensics = 0;\r\n char *****turnovers_lechuguillas = 0;\r\n char ****unpromoted_fuselage = 0;\r\n char ***overshepherd_laymen = 0;\r\n char **hayesville_uncoarse = 0;\r\n char *sexily_appert = 0;\r\n int reload_dilatedly = 0;\r\n char *bellyached_prototypic = 0;\r\n char *herzel_overlit;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&polemicize_tormentedly,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&herzel_overlit,\"TUBEROSE_CANIONED\");\r\n if (herzel_overlit != 0) {;\r\n reload_dilatedly = ((int )(strlen(herzel_overlit)));\r\n bellyached_prototypic = ((char *)(malloc(reload_dilatedly + 1)));\r\n if (bellyached_prototypic == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(bellyached_prototypic,0,reload_dilatedly + 1);\r\n memcpy(bellyached_prototypic,herzel_overlit,reload_dilatedly);\r\n if (herzel_overlit != 0) \r\n free(((char *)herzel_overlit));\r\n hayesville_uncoarse = &bellyached_prototypic;\r\n overshepherd_laymen = &hayesville_uncoarse;\r\n unpromoted_fuselage = &overshepherd_laymen;\r\n turnovers_lechuguillas = &unpromoted_fuselage;\r\n unfilched_forensics = &turnovers_lechuguillas;\r\n noncontagiously_poucey = &unfilched_forensics;\r\n misogynistic_forbborne = &noncontagiously_poucey;\r\n microcosms_lainer = &misogynistic_forbborne;\r\n admixing_inefficient = &microcosms_lainer;\r\n semishrubby_outtrick = &admixing_inefficient;\r\n underpressure_steaded = &semishrubby_outtrick;\r\n cadee_linos = &underpressure_steaded;\r\n antarctical_chrysophyll = &cadee_linos;\r\n contrabandist_liomyofibroma = &antarctical_chrysophyll;\r\n droghlin_pasquillic = &contrabandist_liomyofibroma;\r\n unobtrusiveness_dutymonger = &droghlin_pasquillic;\r\n newberg_filum = &unobtrusiveness_dutymonger;\r\n bosque_vinegarist = &newberg_filum;\r\n compactedly_reengraving = &bosque_vinegarist;\r\n zalucki_indraught = &compactedly_reengraving;\r\n starboard_wastrife = &zalucki_indraught;\r\n imm_overfatigue = &starboard_wastrife;\r\n jaghatai_bumpier = &imm_overfatigue;\r\n pleopod_nipponize = &jaghatai_bumpier;\r\n overbrag_eau = &pleopod_nipponize;\r\n baresarks_amphigoric = &overbrag_eau;\r\n usphs_introverse = &baresarks_amphigoric;\r\n cannonades_voltize = &usphs_introverse;\r\n borderism_democratizing = &cannonades_voltize;\r\n coesite_amyelous = &borderism_democratizing;\r\n strongpoint_spolium = &coesite_amyelous;\r\n headmaster_jillions = &strongpoint_spolium;\r\n annadiana_unsophisticated = &headmaster_jillions;\r\n stickmen_shuzo = &annadiana_unsophisticated;\r\n overpayments_engineerings = &stickmen_shuzo;\r\n clactonian_theosophic = &overpayments_engineerings;\r\n heteropterous_unfertilisable = &clactonian_theosophic;\r\n polymastigous_situs = &heteropterous_unfertilisable;\r\n galer_mislaid = &polymastigous_situs;\r\n semipause_sokols = &galer_mislaid;\r\n dodecahedron_filigreed = &semipause_sokols;\r\n dygal_shieldmaker = &dodecahedron_filigreed;\r\n waterage_raffled = &dygal_shieldmaker;\r\n debs_codeinas = &waterage_raffled;\r\n nomos_paeanize = &debs_codeinas;\r\n implacental_cooeys = &nomos_paeanize;\r\n rechallenging_toploftily = &implacental_cooeys;\r\n autographed_sanatoriums = &rechallenging_toploftily;\r\n nonconformable_unviolent = &autographed_sanatoriums;\r\n unsalvability_daubing = &nonconformable_unviolent;\r\n if ( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unsalvability_daubing))))))))))))))))))))))))))))))))))))))))))))))))) != 0) {\r\n goto psychoclinical_banuyo;\r\n }\r\n ++global_variable;\r\n psychoclinical_banuyo:;\r\n lao_alethoscope = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unsalvability_daubing)))))))))))))))))))))))))))))))))))))))))))))))))));\r\n \r\n len = strtol(lao_alethoscope,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if ( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unsalvability_daubing))))))))))))))))))))))))))))))))))))))))))))))))) != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unsalvability_daubing))))))))))))))))))))))))))))))))))))))))))))))))))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <math.h> \r\n#include <signal.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint baseballdom_inclined = 0;\r\nint global_variable;\r\nvoid megamastictoral_aubert(void **asininity_unadornedness);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid confluxibleness_trailmaking(void (*telefacsimile_quakily)(void **));\r\nstruct data {\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nstruct data *Data;\r\nint loop;\r\nint *global1;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForSig() {\r\n int fd;\r\n char outStr[25] = {0};\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForSig\\n\");\r\n sprintf(outStr, \"%d.pid\", getpid());\r\n strcat(filename, \"/opt//workspace/testData/\");\r\n strcat(filename, outStr);\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n \r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n \r\n printf(\"Error writing to file.\");\r\n }\r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n \r\n printf(\"Reading file1\\n\");\r\n readFile(Data->file1);\r\n readFile(Data->file2);\r\n }\r\n}\r\nvoid sig_handler (int sig) {\r\n printf(\"In sig_handler\\n\");\r\n \r\n \r\n \r\n \r\n \r\n global1[0] = -1;\r\n free(global1);\r\n global1 = NULL;\r\n \r\n \r\n printf(\"In sig handler\");\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&baseballdom_inclined,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n confluxibleness_trailmaking(megamastictoral_aubert);\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid megamastictoral_aubert(void **asininity_unadornedness)\r\n{\r\n void *fiercen_depreciations = 0;\r\n char *acrawl_kintra;\r\n ++global_variable;;\r\n setup_printf_context();\r\n acrawl_kintra = getenv(\"SPAYING_TITILLATES\");\r\n if (acrawl_kintra != 0) {;\r\n fiercen_depreciations = ((void *)acrawl_kintra);\r\n *asininity_unadornedness = fiercen_depreciations;\r\n }\r\n}\r\n\r\nvoid confluxibleness_trailmaking(void (*telefacsimile_quakily)(void **))\r\n{\r\n char *spryness_telecasting = 0;\r\n void **silenced_reprehends = 0;\r\n void **diceratidae_seidlitz = 0;\r\n ++global_variable;\r\n void *lacerated_lickspittle = 0;\r\n telefacsimile_quakily(&lacerated_lickspittle);\r\n if (((char *)lacerated_lickspittle) != 0) {;\r\n silenced_reprehends = &lacerated_lickspittle;\r\n diceratidae_seidlitz = silenced_reprehends + 5;\r\n spryness_telecasting = ((char *)((char *)( *(diceratidae_seidlitz - 5))));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(spryness_telecasting) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(spryness_telecasting) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(spryness_telecasting) + 1));\r\n if (Data->data) {\r\n if ((sscanf(spryness_telecasting, \"%s %s %s\",\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 3) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n global1 = calloc(1, sizeof(int));\r\n \r\n \r\n \r\n \r\n if (signal(SIGUSR1, sig_handler) == SIG_ERR) {\r\n \r\n printf (\"Error catching SIGUSR1!\\n\");\r\n }\r\n printf(\"Set up SIGUSR1 handler\\n\");\r\n if (Data->data[0] >= 'A' && Data->data[0] <= 'Z') {\r\n if (signal(SIGUSR2, sig_handler) == SIG_ERR) {\r\n \r\n printf (\"Error catching SIGUSR2!\\n\");\r\n }\r\n printf(\"Set up SIGUSR2 handler\\n\");\r\n }\r\n waitForSig();\r\n printf(\"After waitForSig\\n\");\r\n signal(SIGUSR1, SIG_IGN); \r\n signal(SIGUSR2, SIG_IGN); \r\n if (global1 != NULL) {\r\n free(global1);\r\n global1 = NULL;\r\n }\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free (Data);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n global1[0] = -1;\n free(global1);\n global1 = NULL;\n```", "cwe": "831"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint mange_macrograph = 0;\r\n\r\nstruct ringmaster_overaptly \r\n{\r\n char *afton_tinder;\r\n double annalist_pennon;\r\n char *dithioic_impostress;\r\n char crushability_perendure;\r\n int crp_superinfinitely;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *taejon_ecophene);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid defeasibility_civility(int semiraw_kuprin,struct ringmaster_overaptly contradictively_gezer);\r\nstruct data {\r\n int qsize;\r\n int data_size;\r\n char *data;\r\n};\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid arrFunc (struct data *Data) {\r\n int *arr = malloc(sizeof(int) * Data->qsize);\r\n int i;\r\n int j;\r\n FILE *fp;\r\n static int ctr;\r\n \r\n \r\n ctr = 0; \r\n for(i = 0; \r\n i < Data->data_size; \r\n i++, ctr++)\r\n {\r\n \r\n Data->data[ctr] = '\\0';\r\n printf(\"I: %d, C: %d\\n\", i, ctr);\r\n if (Data->qsize > 5) {\r\n fp = fopen(\"asdfqwer1234\", \"w+\");\r\n fprintf(fp, \"%d\", i);\r\n fclose(fp);\r\n for (j = 0; j < Data->qsize; j++) {\r\n arr[j] = Data->qsize - j;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n }\r\n }\r\n free(arr);\r\n \r\n \r\n \r\n}\r\nvoid *replaceSymbols(void *data) {\r\n struct data *Data = data;\r\n int i;\r\n \r\n pthread_mutex_lock(&mutex);\r\n for(i = 0; i < Data->data_size; i++) {\r\n if (((Data->data[i] >= '!' && Data->data[i] <= '/') ||\r\n (Data->data[i] >= ':' && Data->data[i] <= '@') ||\r\n (Data->data[i] >= '[' && Data->data[i] <= '`') ||\r\n (Data->data[i] >= '{' && Data->data[i] <= '~')) &&\r\n (Data->data[i] != '@' && Data->data[i] != '.'))\r\n {\r\n Data->data[i] = '_';\r\n }\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n arrFunc(Data);\r\n return NULL;\r\n}\r\nvoid *toCaps(void *data) {\r\n struct data *Data = data;\r\n int threadTiming = 500000;\r\n int j;\r\n int *arr;\r\n int i;\r\n \r\n \r\n arr = malloc(sizeof(int)*threadTiming);\r\n if (arr != NULL) {\r\n for (j = 0; j < threadTiming; j++) {\r\n arr[j] = threadTiming - j;\r\n }\r\n qsort(arr, threadTiming, sizeof(int), &comp);\r\n free (arr);\r\n arr = NULL;\r\n }\r\n pthread_mutex_lock(&mutex);\r\n for(i = 0; i < Data->data_size; i++) {\r\n if(Data->data[i] >= 'a' && Data->data[i] <= 'z') {\r\n Data->data[i] -= 'a' - 'A';\r\n }\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n arrFunc(Data);\r\n return NULL;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&mange_macrograph,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid handle_taint(char *taejon_ecophene)\r\n{\r\n int hammal_doggones = 7;\r\n struct ringmaster_overaptly anarchists_draperess = {0};\r\n int *highheartedly_overbalancing = 0;\r\n int immobile_nonplanetary;\r\n struct ringmaster_overaptly jaygees_gnetaceae[10] = {0};\r\n struct ringmaster_overaptly readopt_phalluses;\r\n ++global_variable;;\r\n if (taejon_ecophene != 0) {;\r\n readopt_phalluses . afton_tinder = ((char *)taejon_ecophene);\r\n immobile_nonplanetary = 5;\r\n highheartedly_overbalancing = &immobile_nonplanetary;\r\n jaygees_gnetaceae[ *highheartedly_overbalancing] = readopt_phalluses;\r\n anarchists_draperess = jaygees_gnetaceae[ *highheartedly_overbalancing];\r\n defeasibility_civility(hammal_doggones,anarchists_draperess);\r\n }\r\n}\r\n\r\nvoid defeasibility_civility(int semiraw_kuprin,struct ringmaster_overaptly contradictively_gezer)\r\n{\r\n pthread_t t0, t1;\r\n struct data *Data = malloc(sizeof(struct data));\r\n char *ungravitative_capillariomotor = 0;\r\n ++global_variable;\r\n semiraw_kuprin--;\r\n if (semiraw_kuprin > 0) {\r\n defeasibility_civility(semiraw_kuprin,contradictively_gezer);\r\n return ;\r\n }\r\n ungravitative_capillariomotor = ((char *)contradictively_gezer . afton_tinder);\r\n \r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(ungravitative_capillariomotor)+ 1));\r\n if (Data->data &&\r\n (sscanf(ungravitative_capillariomotor, \"%d %s\", &Data->qsize, Data->data) == 2) &&\r\n (strlen(Data->data) != 0)) {\r\n pthread_mutex_init(&mutex, NULL);\r\n Data->data_size = strlen(Data->data);\r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, replaceSymbols, (void*)Data) != 0) {\r\n printf(\"Error initilizing thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toCaps, (void*)Data) != 0) {\r\n printf(\"Error initilizing thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex);\r\n \r\n \r\n free(Data->data);\r\n \r\n }\r\n else {\r\n printf(\"Error parsing input.\\n\");\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (contradictively_gezer . afton_tinder != 0) \r\n free(((char *)contradictively_gezer . afton_tinder));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n free(Data->data);\n```", "cwe": "663"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint honorariums_missourian = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid capman_gape(char **nonrendition_barotseland);\r\nvoid facemark_counterlath(char **vergences_impassionedness);\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n char **neither_stepping = 0;\r\n char *effectualize_wizardly = 0;\r\n char *schmelzes_subglabrous;;\r\n if (__sync_bool_compare_and_swap(&honorariums_missourian,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n schmelzes_subglabrous = getenv(\"HOROLOGIUM_HEIGHTENING\");\r\n if (schmelzes_subglabrous != 0) {;\r\n neither_stepping = &schmelzes_subglabrous;\r\n capman_gape(neither_stepping);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid capman_gape(char **nonrendition_barotseland)\r\n{\r\n ++global_variable;;\r\n facemark_counterlath(nonrendition_barotseland);\r\n}\r\n\r\nvoid facemark_counterlath(char **vergences_impassionedness)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *dischase_stanks = 0;\r\n ++global_variable;;\r\n dischase_stanks = ((char *)( *vergences_impassionedness));\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(dischase_stanks) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (dischase_stanks[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &dischase_stanks[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint scriver_canstick = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid glycyl_undeludedly(char *apepsy_preindemnifying);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n void (*bescourge_mids)(char *) = glycyl_undeludedly;\r\n char *assam_gorhen;;\r\n if (__sync_bool_compare_and_swap(&scriver_canstick,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n assam_gorhen = getenv(\"LYCANTHROPOUS_CARBOLXYLOL\");\r\n if (assam_gorhen != 0) {;\r\n bescourge_mids(assam_gorhen);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid glycyl_undeludedly(char *apepsy_preindemnifying)\r\n{\r\n int oc_i = 0;\r\n char buff[64];\r\n char source[1024];\r\n char *octometer_saucemen = 0;\r\n ++global_variable;;\r\n octometer_saucemen = ((char *)apepsy_preindemnifying);\r\n \r\n memset(buff, 65, 64);\r\n buff[63] = '\\0';\r\n memset(source,0,1024);\r\n strncpy(source,octometer_saucemen,sizeof(source));\r\n source[1023] = 0;\r\n if (strlen(source) + 1 <= sizeof(buff)) {\r\n \r\n \r\n \r\n \r\n \r\n \r\n strncpy(buff,source,sizeof(source));\r\n \r\n \r\n }\r\n for (; oc_i < strlen(buff); ++oc_i) {\r\n buff[oc_i] = toupper(buff[oc_i]);\r\n }\r\n printf(\"%s\\n\",buff);\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n strncpy(buff,source,sizeof(source));\n```", "cwe": "806"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint refind_summeriest = 0;\r\n\r\nstruct enclasped_cassideous \r\n{\r\n char *dyspeptically_coghle;\r\n double nola_vitameric;\r\n char *downtrod_libya;\r\n char epizoan_ignorers;\r\n int sascha_prefixed;\r\n}\r\n;\r\nint global_variable;\r\nvoid triumphs_draughter(struct enclasped_cassideous *fetches_hypochdria);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid ramuscule_nielled(void (*pteroclomorphic_rickart)(struct enclasped_cassideous *));\r\nunsigned int get_size(char *ss_tainted)\r\n{\r\n \r\n unsigned long uns_int = 0UL;\r\n uns_int = strtoul(ss_tainted,0,0);\r\n if (uns_int > ((unsigned long )4294967295U) ||\r\n uns_int == 0)\r\n uns_int = 1U;\r\n return (unsigned int )uns_int;\r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&refind_summeriest,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n ramuscule_nielled(triumphs_draughter);\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid triumphs_draughter(struct enclasped_cassideous *fetches_hypochdria)\r\n{\r\n struct enclasped_cassideous asemic_uptowners;\r\n char *oppositions_coryell;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&oppositions_coryell,\"ACCORDANCY_TODIES\");\r\n if (oppositions_coryell != 0) {;\r\n asemic_uptowners . dyspeptically_coghle = ((char *)oppositions_coryell);\r\n *fetches_hypochdria = asemic_uptowners;\r\n }\r\n}\r\n\r\nvoid ramuscule_nielled(void (*pteroclomorphic_rickart)(struct enclasped_cassideous *))\r\n{\r\n char *other_buff = 0;\r\n int size = 0;\r\n int num = 0;\r\n char buff[200] = {0};\r\n int output_counter = 0;\r\n char *haitians_anastas = 0;\r\n struct enclasped_cassideous *bordered_misyoke = {0};\r\n struct enclasped_cassideous *tartarian_mesenterium = {0};\r\n ++global_variable;\r\n struct enclasped_cassideous felonwort_benji = {0};\r\n pteroclomorphic_rickart(&felonwort_benji);\r\n if (felonwort_benji . dyspeptically_coghle != 0) {;\r\n bordered_misyoke = &felonwort_benji;\r\n tartarian_mesenterium = bordered_misyoke + 5;\r\n haitians_anastas = ((char *)( *(tartarian_mesenterium - 5)) . dyspeptically_coghle);\r\n \r\n if (strlen(haitians_anastas) > 0 &&\r\n haitians_anastas[0] == '-') {\r\n printf(\"Negative number given as input\\n\");\r\n } else {\r\n \r\n \r\n num = get_size(haitians_anastas);\r\n other_buff = getenv(\"SS_BUFF\");\r\n \r\n \r\n \r\n if (other_buff != 0) {\r\n strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\r\n size = ((int )(strlen(buff)));\r\n \r\n \r\n while (num < size) {\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n if (num > 0)\r\n ++num;\r\n }\r\n \r\n } else {\r\n printf(\"Missing value for other_buff\\n\");\r\n }\r\n printf(\"finished evaluating\\n\");\r\n }\r\n \r\n;\r\n if (( *(tartarian_mesenterium - 5)) . dyspeptically_coghle != 0) \r\n free(((char *)( *(tartarian_mesenterium - 5)) . dyspeptically_coghle));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while (num < size) {\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n if (num > 0)\n ++num;\n }\n```", "cwe": "196"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint biconically_chasteweed = 0;\r\nint global_variable;\r\nvoid handle_taint(char *rabelaisianism_visuometer);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid eschalot_withhie(char *const relationist_funerally);\r\nvoid deliberateness_composers(int superset_tipplers,char *shotshell_story);\r\nvoid gyrophoraceae_shamble(int underlid_eeling,char *halser_unallowable);\r\nvoid function() {\r\n \r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&biconically_chasteweed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *rabelaisianism_visuometer)\r\n{\r\n ++global_variable;;\r\n if (rabelaisianism_visuometer != 0) {;\r\n eschalot_withhie(rabelaisianism_visuometer);\r\n }\r\n}\r\n\r\nvoid eschalot_withhie(char *const relationist_funerally)\r\n{\r\n int incongruent_preadherence = 7;\r\n ++global_variable;;\r\n deliberateness_composers(incongruent_preadherence,relationist_funerally);\r\n}\r\n\r\nvoid deliberateness_composers(int superset_tipplers,char *shotshell_story)\r\n{\r\n void (*function_ptr_1)() = 0;\r\n void (*function_ptr_2)() = 0;\r\n unsigned long input_num;\r\n void (*function_ptr_3)() = 0;\r\n void (*function_ptr_4)() = 0;\r\n char *byte_4 = 0;\r\n char *byte_3 = 0;\r\n unsigned long *ptr = 0;\r\n char *kieler_thumblike = 0;\r\n ++global_variable;\r\n superset_tipplers--;\r\n if (superset_tipplers > 0) {\r\n gyrophoraceae_shamble(superset_tipplers,shotshell_story);\r\n return ;\r\n }\r\n kieler_thumblike = ((char *)((char *)shotshell_story));\r\n \r\n function_ptr_1 = function;\r\n function_ptr_2 = function;\r\n function_ptr_3 = function;\r\n function_ptr_4 = function;\r\n if (strlen(kieler_thumblike) >= 1 &&\r\n kieler_thumblike[0] != '-') {\r\n input_num = strtoul(kieler_thumblike,0U,16);\r\n ptr = &input_num;\r\n if ( *ptr > 65535) {\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n byte_3 = ((char *)(ptr + 2));\r\n byte_4 = ((char *)(ptr + 3));\r\n \r\n \r\n *byte_3 = 0;\r\n *byte_4 = 0;\r\n \r\n \r\n \r\n \r\n \r\n }\r\n \r\n \r\n function_ptr_1();\r\n function_ptr_2();\r\n function_ptr_3();\r\n function_ptr_4();\r\n \r\n printf(\"Value = %i\\n\", input_num);\r\n } else if (strlen(kieler_thumblike) == 0) {\r\n printf(\"Input is empty string\\n\");\r\n } else {\r\n printf(\"Input is negative number\\n\");\r\n }\r\n \r\n;\r\n if (((char *)shotshell_story) != 0) \r\n free(((char *)((char *)shotshell_story)));\r\nclose_printf_context();\r\n}\r\n\r\nvoid gyrophoraceae_shamble(int underlid_eeling,char *halser_unallowable)\r\n{\r\n ++global_variable;\r\n deliberateness_composers(underlid_eeling,halser_unallowable);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n function_ptr_1();\n function_ptr_2();\n function_ptr_3();\n function_ptr_4();\n```", "cwe": "682"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint fortas_circuitry = 0;\r\nint global_variable;\r\nvoid handle_taint(char *uredinologist_lyndeborough);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid besmut_dampproofer(int homeothermism_taxonomic,void **masera_antiepileptic);\r\nstruct struct {\r\n char base_path[20];\r\n char * buff_pointer;\r\n};\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&fortas_circuitry,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *uredinologist_lyndeborough)\r\n{\r\n int transversal_miliolite = 7;\r\n int paxilla_grandeza;\r\n void **expos_ornithomimidae = 0;\r\n void **anchorhold_quitter = 0;\r\n void *reconsoling_mozamb = 0;\r\n ++global_variable;;\r\n if (uredinologist_lyndeborough != 0) {;\r\n reconsoling_mozamb = ((void *)uredinologist_lyndeborough);\r\n paxilla_grandeza = 1;\r\n expos_ornithomimidae = &reconsoling_mozamb;\r\n anchorhold_quitter = ((void **)(((unsigned long )expos_ornithomimidae) * paxilla_grandeza * paxilla_grandeza)) + 5;\r\n besmut_dampproofer(transversal_miliolite,anchorhold_quitter);\r\n }\r\n}\r\n\r\nvoid besmut_dampproofer(int homeothermism_taxonomic,void **masera_antiepileptic)\r\n{\r\n int oc_i = 0;\r\n int opt_var = 0;\r\n int i;\r\n struct struct data;\r\n char *timeproof_endoceras = 0;\r\n ++global_variable;\r\n homeothermism_taxonomic--;\r\n if (homeothermism_taxonomic > 0) {\r\n besmut_dampproofer(homeothermism_taxonomic,masera_antiepileptic);\r\n return ;\r\n }\r\n timeproof_endoceras = ((char *)((char *)( *(masera_antiepileptic - 5))));\r\n \r\n if (strlen(timeproof_endoceras) < 20) {\r\n for (i = 0; i < 20; i++) {\r\n data.base_path[i] = 0;\r\n }\r\n data.buff_pointer = data.base_path;\r\n \r\n \r\n\r\n\r\n realpath(timeproof_endoceras, data.base_path);\r\n opt_var = strlen( data.buff_pointer);\r\n \r\n for (; oc_i < opt_var; ++oc_i) {\r\n data.base_path[oc_i] =\r\n toupper(data.base_path[oc_i]);\r\n }\r\n printf(\"%s\\n\", data.base_path);\r\n printf(\"%s\\n\", data.buff_pointer);\r\n \r\n \r\n }\r\n \r\n;\r\n if (((char *)( *(masera_antiepileptic - 5))) != 0) \r\n free(((char *)((char *)( *(masera_antiepileptic - 5)))));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n\n realpath(timeproof_endoceras, data.base_path);\n opt_var = strlen( data.buff_pointer);\n \n for (; oc_i < opt_var; ++oc_i) {\n data.base_path[oc_i] =\n toupper(data.base_path[oc_i]);\n }\n printf(\"%s\\n\", data.base_path);\n printf(\"%s\\n\", data.buff_pointer);\n```", "cwe": "785"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint understandingly_hazeline = 0;\r\nint global_variable;\r\nvoid handle_taint(char *tragicomic_unionisation);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid unsun_parenchymous(int sequester_shorling,char **satchel_koitapu);\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&understandingly_hazeline,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid handle_taint(char *tragicomic_unionisation)\r\n{\r\n int mereswine_forceless = 7;\r\n char **savanna_fumatoriums = 0;\r\n long oscillations_sumpweeds[10];\r\n char **pensacola_preventiveness[10] = {0};\r\n char *ecthymatous_costa[75] = {0};\r\n ++global_variable;;\r\n if (tragicomic_unionisation != 0) {;\r\n ecthymatous_costa[73] = tragicomic_unionisation;\r\n pensacola_preventiveness[5] = ecthymatous_costa;\r\n oscillations_sumpweeds[1] = 5;\r\n savanna_fumatoriums = *(pensacola_preventiveness + oscillations_sumpweeds[1]);\r\n unsun_parenchymous(mereswine_forceless,savanna_fumatoriums);\r\n }\r\n}\r\n\r\nvoid unsun_parenchymous(int sequester_shorling,char **satchel_koitapu)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *sympathise_stockmen = 0;\r\n ++global_variable;\r\n sequester_shorling--;\r\n if (sequester_shorling > 0) {\r\n unsun_parenchymous(sequester_shorling,satchel_koitapu);\r\n return ;\r\n }\r\n sympathise_stockmen = ((char *)satchel_koitapu[73]);\r\n \r\n len = strtol(sympathise_stockmen,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (satchel_koitapu[73] != 0) \r\n free(((char *)satchel_koitapu[73]));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint sune_relievers = 0;\r\nint global_variable;\r\nvoid handle_taint(char *processing_igloos);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid soweto_megapodes(int mentcle_whorishness,char *herve_vocative);\r\nstruct data {\r\n int qsize;\r\n int data_size;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nstruct data2 {\r\n int qsize;\r\n int data_size;\r\n int data_size2;\r\n char *data;\r\n char *data2;\r\n};\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nstruct data2 *ssD2 = 0;\r\nstruct data2 *init_data2 (struct data *ssD) {\r\n \r\n \r\n printf(\"Checking for initalization\\n\");\r\n \r\n if (ssD2 == NULL) {\r\n pthread_mutex_lock(&mutex);\r\n if (ssD2 == NULL) {\r\n printf(\"Initializing\\n\");\r\n ssD2 = calloc(1, sizeof(struct data2));\r\n readFile(ssD->file2);\r\n ssD2->data = ssD->data;\r\n ssD2->qsize = ssD->qsize;\r\n ssD2->data_size = ssD->data_size;\r\n ssD2->data2 = ssD->data;\r\n ssD2->data_size2 = ssD->data_size;\r\n } else {\r\n printf(\"No need to initialize\\n\");\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n } else {\r\n printf(\"Data is already initialized\\n\");\r\n }\r\n \r\n return ssD2;\r\n}\r\nvoid *doStuff(void *ssD) {\r\n struct data2 *ssD2;\r\n \r\n printf(\"Inside doStuff\\n\");\r\n ssD2 = init_data2((struct data*)ssD);\r\n return NULL;\r\n}\r\nvoid *doStuff2(void *Data) {\r\n struct data2 *ssD2;\r\n struct data *ssD = Data;\r\n int i;\r\n int *arr;\r\n \r\n printf(\"Inside doStuff2\\n\");\r\n arr = malloc(sizeof(int) * ssD->qsize);\r\n for (i = 0; i < ssD->qsize; i++) {\r\n arr[i] = ssD->qsize - i;\r\n }\r\n qsort(arr, ssD->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(ssD->file1);\r\n ssD2 = init_data2((struct data*)ssD);\r\n \r\n \r\n \r\n \r\n if (ssD2->data2[0] != '\\0') {\r\n printf(\"%s\\n\", ssD2->data2);\r\n }\r\n \r\n return NULL;\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&sune_relievers,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\n\r\nvoid handle_taint(char *processing_igloos)\r\n{\r\n int stafford_optimised = 7;\r\n char *heeder_fandangos = 0;\r\n int **terentian_fri = 0;\r\n int *reilluminated_ftw = 0;\r\n int felice_filipiniana;\r\n char *cheville_toccatas[10] = {0};\r\n int univocal_barytic = 0;\r\n char *haplite_blinnie = 0;\r\n ++global_variable;;\r\n if (processing_igloos != 0) {;\r\n univocal_barytic = ((int )(strlen(processing_igloos)));\r\n haplite_blinnie = ((char *)(malloc(univocal_barytic + 1)));\r\n if (haplite_blinnie == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(haplite_blinnie,0,univocal_barytic + 1);\r\n memcpy(haplite_blinnie,processing_igloos,univocal_barytic);\r\n if (processing_igloos != 0) \r\n free(((char *)processing_igloos));\r\n felice_filipiniana = 5;\r\n reilluminated_ftw = &felice_filipiniana;\r\n terentian_fri = &reilluminated_ftw;\r\n cheville_toccatas[ *( *terentian_fri)] = haplite_blinnie;\r\n heeder_fandangos = cheville_toccatas[ *( *terentian_fri)];\r\n soweto_megapodes(stafford_optimised,heeder_fandangos);\r\n }\r\n}\r\n\r\nvoid soweto_megapodes(int mentcle_whorishness,char *herve_vocative)\r\n{\r\n pthread_t t0, t1;\r\n struct data *Data;\r\n char *binous_miscolour = 0;\r\n ++global_variable;\r\n mentcle_whorishness--;\r\n if (mentcle_whorishness > 0) {\r\n soweto_megapodes(mentcle_whorishness,herve_vocative);\r\n return ;\r\n }\r\n binous_miscolour = ((char *)herve_vocative);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(binous_miscolour) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(binous_miscolour) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(binous_miscolour) + 1));\r\n if (Data->data) {\r\n if ((sscanf(binous_miscolour, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n Data->data_size = strlen(Data->data);\r\n if (pthread_mutex_init(&mutex, NULL) != 0) {\r\n printf(\"Mutex failed to initilize.\");\r\n }\r\n \r\n if (pthread_create(&t0, NULL, doStuff, (void *)Data) != 0) {\r\n printf(\"Error creating thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, doStuff2, (void *)Data) != 0) {\r\n printf(\"Error creating thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex);\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n if (ssD2) {\r\n free (ssD2);\r\n }\r\n \r\n;\r\n if (herve_vocative != 0) \r\n free(((char *)herve_vocative));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n if (ssD2->data2[0] != '\\0') {\n printf(\"%s\\n\", ssD2->data2);\n }\n```", "cwe": "609"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint loka_syncryptic = 0;\r\n\r\nunion metallurgically_befriender \r\n{\r\n char *decurves_hypocotyleal;\r\n double blip_compulsory;\r\n char *ganglioside_oolak;\r\n char fabaceae_coccosteus;\r\n int escapes_beclothe;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *cohusband_multipointed);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nunion metallurgically_befriender venatory_cydnus(union metallurgically_befriender uncandor_typhoons);\r\nvoid nosonomy_overpay(union metallurgically_befriender repels_depilatory);\r\nvoid tiburtine_pectoral(union metallurgically_befriender hullers_omphalitis);\r\nvoid cleanup(FILE **ptrs,int size)\r\n{\r\n int i = 0;\r\n \r\n for (i = 0; i < size; i++) {\r\n if (ptrs[i] != 0) {\r\n fclose(ptrs[i]);\r\n }\r\n }\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&loka_syncryptic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid handle_taint(char *cohusband_multipointed)\r\n{\r\n union metallurgically_befriender postvorta_bretwalda = {0};\r\n union metallurgically_befriender unabrasive_unjarring;\r\n ++global_variable;;\r\n if (cohusband_multipointed != 0) {;\r\n unabrasive_unjarring . decurves_hypocotyleal = cohusband_multipointed;\r\n postvorta_bretwalda = venatory_cydnus(unabrasive_unjarring);\r\n nosonomy_overpay(postvorta_bretwalda);\r\n }\r\n}\r\n\r\nunion metallurgically_befriender venatory_cydnus(union metallurgically_befriender uncandor_typhoons)\r\n{\r\n ++global_variable;\r\n return uncandor_typhoons;\r\n}\r\n\r\nvoid nosonomy_overpay(union metallurgically_befriender repels_depilatory)\r\n{\r\n ++global_variable;;\r\n tiburtine_pectoral(repels_depilatory);\r\n}\r\n\r\nvoid tiburtine_pectoral(union metallurgically_befriender hullers_omphalitis)\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[10];\r\n char filename[80];\r\n char *polynaphthene_metricise = 0;\r\n ++global_variable;;\r\n polynaphthene_metricise = ((char *)hullers_omphalitis . decurves_hypocotyleal);\r\n \r\n files = fopen(polynaphthene_metricise,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0) {\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n }\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi % 10] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n if (files != 0)\r\n fclose(files);\r\n cleanup(file_list, ((ssi-1)%10)+1);\r\n \r\n;\r\n if (hullers_omphalitis . decurves_hypocotyleal != 0) \r\n free(((char *)hullers_omphalitis . decurves_hypocotyleal));\r\nclose_printf_context();\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0) {\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n }\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi % 10] = file;\n ssi++;\n }\n```", "cwe": "773"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint imputrescence_felicitators = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint 191_global_var = 0;\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n FILE * random_data = 0;\r\n char * buff = 0;\r\n unsigned long long num = 0;\r\n unsigned long long i = 0;\r\n char *sympiesometer_sherurd = 0;\r\n void *minefield_placet = 0;\r\n long mismanageable_adamance[10];\r\n void *crool_schuyler[10] = {0};\r\n void *lyricists_sori = 0;\r\n char *idism_metanotum;;\r\n if (__sync_bool_compare_and_swap(&imputrescence_felicitators,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&idism_metanotum,\"CERCARIFORM_MARJ\");\r\n if (idism_metanotum != 0) {;\r\n lyricists_sori = ((void *)idism_metanotum);\r\n crool_schuyler[5] = lyricists_sori;\r\n mismanageable_adamance[1] = 5;\r\n minefield_placet = *(crool_schuyler + mismanageable_adamance[1]);\r\n sympiesometer_sherurd = ((char *)((char *)minefield_placet));\r\n \r\n random_data = fopen(\"/dev/urandom\", \"r\");\r\n if(random_data != NULL){\r\n num = strtoull(sympiesometer_sherurd, NULL, 10);\r\n if(num > (unsigned long long) 0 ){\r\n if(num > (unsigned long long) 100 ){\r\n num = (unsigned long long) 100;\r\n }\r\n \r\n \r\n \r\n \r\n \r\n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\r\n for(i = 0; i < num - (unsigned long long) 10; i++){\r\n buff[i] = fgetc(random_data);\r\n }\r\n \r\n \r\n }\r\n printf(\"data is: %s\", buff);\r\n fclose(random_data);\r\n if(buff != NULL){\r\n free(buff);\r\n }\r\n }\r\n \r\n;\r\n if (((char *)minefield_placet) != 0) \r\n free(((char *)((char *)minefield_placet)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n for(i = 0; i < num - (unsigned long long) 10; i++){\n buff[i] = fgetc(random_data);\n }\n```", "cwe": "191"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint rapturously_qualmish = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n int i;\r\n int index;\r\n char **ptr_after = 0;\r\n unsigned char *count = 0;\r\n char **ptr_before = 0;\r\n unsigned char str_buf[40] = {0};\r\n char *hotelman_unpetrify = 0;\r\n int edom_skiagraphing;\r\n char **leafage_anagrammatised = 0;\r\n char **etherous_hoarser = 0;\r\n char *protomartyr_mapland;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&rapturously_qualmish,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&protomartyr_mapland,\"CZECHOSLOVAK_AIRLIKE\");\r\n if (protomartyr_mapland != 0) {;\r\n edom_skiagraphing = 1;\r\n leafage_anagrammatised = &protomartyr_mapland;\r\n etherous_hoarser = ((char **)(((unsigned long )leafage_anagrammatised) * edom_skiagraphing * edom_skiagraphing)) + 5;\r\n if ( *(etherous_hoarser - 5) != 0) {\r\n goto plouky_angerona;\r\n }\r\n ++global_variable;\r\n plouky_angerona:;\r\n hotelman_unpetrify = ((char *)( *(etherous_hoarser - 5)));\r\n \r\n ptr_after = malloc(sizeof(char *));\r\n if (ptr_after == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n count = malloc(sizeof(unsigned char ) * 62);\r\n if (count == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n ptr_before = malloc(sizeof(char *));\r\n if (ptr_before == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n *ptr_before = hotelman_unpetrify;\r\n *ptr_after = hotelman_unpetrify;\r\n strncpy((char*) str_buf,hotelman_unpetrify,39);\r\n str_buf[39] = 0;\r\n for (i = 0; i < 62; i++) {\r\n count[i] = 0;\r\n }\r\n \r\n \r\n for (i = 0; i < strlen(hotelman_unpetrify); i++) {\r\n \r\n \r\n if (hotelman_unpetrify[i] > 96) {\r\n index = hotelman_unpetrify[i] - 'a' + 36;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else if (hotelman_unpetrify[i] < 58) {\r\n index = hotelman_unpetrify[i] - 48;\r\n \r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else {\r\n index = hotelman_unpetrify[i] - 'A' + 10;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n }\r\n \r\n \r\n for (i = 0; i < 62; i++)\r\n printf(\"index %d: %d\\n\",i,count[i]);\r\n printf(\"%d %d\\n\",strlen( *ptr_before),strlen( *ptr_after));\r\n if (ptr_before != 0) {\r\n free(ptr_before);\r\n }\r\n if (count != 0) {\r\n free(count);\r\n }\r\n if (ptr_after != 0) {\r\n free(ptr_after);\r\n }\r\n \r\n;\r\n if ( *(etherous_hoarser - 5) != 0) \r\n free(((char *)( *(etherous_hoarser - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (i = 0; i < strlen(hotelman_unpetrify); i++) {\n \n \n if (hotelman_unpetrify[i] > 96) {\n index = hotelman_unpetrify[i] - 'a' + 36;\n if (count[index] < 255)\n count[index]++;\n }\n else if (hotelman_unpetrify[i] < 58) {\n index = hotelman_unpetrify[i] - 48;\n \n if (count[index] < 255)\n count[index]++;\n }\n else {\n index = hotelman_unpetrify[i] - 'A' + 10;\n if (count[index] < 255)\n count[index]++;\n }\n }\n```", "cwe": "129"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint param_samsun = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n int oc_i = 0;\r\n int opt_var;\r\n char source[1024];\r\n char * buffer;\r\n char *swops_digesting = 0;\r\n char **provand_unbarrel = 0;\r\n int *carara_protested = 0;\r\n int newchwang_odalisks;\r\n char **maru_ganching[10] = {0};\r\n char *decannulation_wooingly[4] = {0};\r\n char *cotonou_subbing;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&param_samsun,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&cotonou_subbing,\"CONGLOMERATIC_EUPHORBIA\");\r\n if (cotonou_subbing != 0) {;\r\n decannulation_wooingly[3] = cotonou_subbing;\r\n maru_ganching[5] = decannulation_wooingly;\r\n newchwang_odalisks = 5;\r\n carara_protested = &newchwang_odalisks;\r\n provand_unbarrel = *(maru_ganching + *carara_protested);\r\n if (provand_unbarrel[3] != 0) {\r\n goto viscountcy_prewrapped;\r\n }\r\n ++global_variable;\r\n viscountcy_prewrapped:;\r\n swops_digesting = ((char *)provand_unbarrel[3]);\r\n \r\n buffer = (char*) malloc (sizeof(char*) * 64);\r\n if (buffer != NULL) {\r\n memset(source, 0, 1024);\r\n memset(buffer, 65, 64);\r\n buffer[64 - 1] = '\\0';\r\n strncpy(source, swops_digesting, sizeof(source));\r\n source[1023] = '\\0';\r\n if (strlen(source) + 1 <= 64) {\r\n \r\n \r\n \r\n \r\n \r\n \r\n strncpy(buffer, source, sizeof(source));\r\n \r\n \r\n }\r\n opt_var = strlen(buffer);\r\n for (; oc_i < opt_var; ++oc_i) {\r\n buffer[oc_i] =\r\n toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\", buffer);\r\n free(buffer);\r\n }\r\n \r\n;\r\n if (provand_unbarrel[3] != 0) \r\n free(((char *)provand_unbarrel[3]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n strncpy(buffer, source, sizeof(source));\n```", "cwe": "806"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint entropion_cardplayer = 0;\r\nint global_variable;\r\nvoid handle_taint(char *dripps_boylike);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid wahahe_anaxone(int remunerable_westchester,... );\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&entropion_cardplayer,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *dripps_boylike)\r\n{\r\n char *haggling_grasser[42] = {0};\r\n ++global_variable;;\r\n if (dripps_boylike != 0) {;\r\n haggling_grasser[39] = dripps_boylike;\r\n wahahe_anaxone(1,haggling_grasser);\r\n }\r\n}\r\n\r\nvoid wahahe_anaxone(int remunerable_westchester,... )\r\n{\r\n int oc_i = 0;\r\n char * data = 0;\r\n char *redskins_jarnut = 0;\r\n char **disbrain_unhandled = 0;\r\n va_list uncompressible_precinctive;\r\n ++global_variable;;\r\n if (remunerable_westchester > 0) {\r\n __builtin_va_start(uncompressible_precinctive,remunerable_westchester);\r\n disbrain_unhandled = (va_arg(uncompressible_precinctive,char **));\r\n __builtin_va_end(uncompressible_precinctive);\r\n }\r\n redskins_jarnut = ((char *)disbrain_unhandled[39]);\r\n \r\n data = (char*) malloc(8 * sizeof(char));\r\n if (data != NULL) {\r\n \r\n \r\n \r\n \r\n \r\n strncpy(data, redskins_jarnut, strlen(redskins_jarnut) + 1);\r\n for (; oc_i < strlen(data); ++oc_i) {\r\n data[oc_i] = toupper(data[oc_i]);\r\n }\r\n printf(\"%s\\n\", data);\r\n \r\n \r\n free(data);\r\n }\r\n \r\n;\r\n if (disbrain_unhandled[39] != 0) \r\n free(((char *)disbrain_unhandled[39]));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n strncpy(data, redskins_jarnut, strlen(redskins_jarnut) + 1);\n for (; oc_i < strlen(data); ++oc_i) {\n data[oc_i] = toupper(data[oc_i]);\n }\n printf(\"%s\\n\", data);\n```", "cwe": "805"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint remoboth_nag = 0;\r\nint global_variable;\r\ntypedef char *viridities_tolusafranine;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nviridities_tolusafranine measurelessly_larbolins(viridities_tolusafranine defeminize_interthread);\r\nvoid pantagogue_selaginella(viridities_tolusafranine inversions_precompilation);\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n viridities_tolusafranine canterburianism_ble = 0;\r\n viridities_tolusafranine euplotid_dittoing = 0;\r\n char *fieldale_undercuts;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&remoboth_nag,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n fieldale_undercuts = getenv(\"LIGGER_ASSERTED\");\r\n if (fieldale_undercuts != 0) {;\r\n euplotid_dittoing = fieldale_undercuts;\r\n canterburianism_ble = measurelessly_larbolins(euplotid_dittoing);\r\n pantagogue_selaginella(canterburianism_ble);\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nviridities_tolusafranine measurelessly_larbolins(viridities_tolusafranine defeminize_interthread)\r\n{\r\n ++global_variable;\r\n return defeminize_interthread;\r\n}\r\n\r\nvoid pantagogue_selaginella(viridities_tolusafranine inversions_precompilation)\r\n{\r\n int i = 0;\r\n char * other_buff = 0;\r\n int buff_size = 0;\r\n int other_size = 0;\r\n int size;\r\n char *paean_chablis = 0;\r\n ++global_variable;;\r\n paean_chablis = ((char *)inversions_precompilation);\r\n \r\n buff_size = strlen(paean_chablis) + 1;\r\n other_size = 64;\r\n other_buff = (char*) malloc (other_size * sizeof (char));\r\n if (other_buff != NULL) {\r\n size = other_size < buff_size ? other_size : buff_size;\r\n for (i = 0; i < size; i++) {\r\n other_buff[other_size - i - 1] =\r\n paean_chablis[buff_size - i - 1];\r\n }\r\n \r\n \r\n for (i = 0; i < buff_size; i++) {\r\n \r\n \r\n printf(\"%02x\",other_buff[other_size - i - 1]);\r\n }\r\n printf(\"\\n\");\r\n free (other_buff);\r\n \r\n \r\n \r\n \r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "127"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint nattinesses_morphemes = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n char *buffer = 0U;\r\n int len;\r\n char *semimercerized_snickle = 0;\r\n int mistimes_trustlessly;\r\n int faldstool_veuve;\r\n void ***********subchoroid_mesocephalism = 0;\r\n void **********garnishing_psyllium = 0;\r\n void *********pilgarlic_diminutely = 0;\r\n void ********disconvenience_asystole = 0;\r\n void *******farragoes_beaners = 0;\r\n void ******elutriate_ekpwele = 0;\r\n void *****alesia_weissite = 0;\r\n void ****irl_misplace = 0;\r\n void ***rapture_moreland = 0;\r\n void **conglobate_sebacic = 0;\r\n void *disespouse_aberdeen = 0;\r\n void *hydrobranchiate_quinze = 0;\r\n char *footsteps_aviator;\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&nattinesses_morphemes,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&footsteps_aviator,\"UNROSINED_SANDEEP\");\r\n if (footsteps_aviator != 0) {;\r\n hydrobranchiate_quinze = ((void *)footsteps_aviator);\r\n conglobate_sebacic = &hydrobranchiate_quinze;\r\n rapture_moreland = &conglobate_sebacic;\r\n irl_misplace = &rapture_moreland;\r\n alesia_weissite = &irl_misplace;\r\n elutriate_ekpwele = &alesia_weissite;\r\n farragoes_beaners = &elutriate_ekpwele;\r\n disconvenience_asystole = &farragoes_beaners;\r\n pilgarlic_diminutely = &disconvenience_asystole;\r\n garnishing_psyllium = &pilgarlic_diminutely;\r\n subchoroid_mesocephalism = &garnishing_psyllium;\r\n faldstool_veuve = 5;\r\n while(1 == 1){\r\n faldstool_veuve = faldstool_veuve * 2;\r\n faldstool_veuve = faldstool_veuve + 2;\r\n if (faldstool_veuve > 1000) {\r\n break; \r\n }\r\n }\r\n mistimes_trustlessly = faldstool_veuve;\r\n semimercerized_snickle = ((char *)((char *)( *( *( *( *( *( *( *( *( *( *subchoroid_mesocephalism))))))))))));\r\n \r\n len = atoi(semimercerized_snickle);\r\n \r\n\r\n if (len < 4096) {\r\n buffer = ((char *)(malloc(4096 * sizeof(char ))));\r\n if (buffer != 0) {\r\n memset(buffer,'a',4096);\r\n \r\n \r\n\r\n memset(&buffer[len],'b',4096 - len);\r\n \r\n buffer[4095] = 0;\r\n printf(\"%s\\n\",buffer);\r\n free(buffer);\r\n }\r\n } else {\r\n printf(\"Number is too large to use\\n\");\r\n }\r\n \r\n \r\n;\r\n if (((char *)( *( *( *( *( *( *( *( *( *( *subchoroid_mesocephalism))))))))))) != 0) \r\n free(((char *)((char *)( *( *( *( *( *( *( *( *( *( *subchoroid_mesocephalism)))))))))))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(&buffer[len],'b',4096 - len);\n```", "cwe": "839"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <sys/types.h> \r\n#include <unistd.h> \r\nint unchristianized_sesser = 0;\r\n\r\nstruct overprotected_unblacked \r\n{\r\n char *courier_spiceland;\r\n double outstepped_bellylike;\r\n char *maricolous_localisation;\r\n char hardheaded_empress;\r\n int subangularity_longbow;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n \r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForChange(char* file, char* sleepFile) {\r\n int fd;\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForChange\\n\");\r\n strcat(filename, file);\r\n strcat(filename, \".pid\");\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nint path_is_relative(char *path) {\r\n char *chr = 0;\r\n \r\n chr = strchr(path,'/');\r\n if (chr == 0) {\r\n \r\n printf(\"Path is relative\\n\");\r\n return 1;\r\n } else {\r\n \r\n printf(\"Path is not relative\\n\");\r\n return 0;\r\n }\r\n}\r\nchar * get_absolute_path(char * path) {\r\n char * abs_path = malloc (sizeof(char) * (strlen(\"/opt//workspace/testData/\") * strlen(path) + 1));\r\n \r\n if (abs_path == NULL) {\r\n printf(\"Cannot allocate memory for path\\n\");\r\n } else {\r\n printf(\"Creating absolute path\\n\");\r\n strcpy(abs_path, \"/opt//workspace/testData/\");\r\n strcat(abs_path, path);\r\n }\r\n return abs_path;\r\n}\r\nint isSymLink(char *file) {\r\n struct stat statbuf;\r\n \r\n if (lstat(file, &statbuf) < 0) { \r\n printf(\"Error accessing path.\\n\");\r\n return 1; \r\n }\r\n if (S_ISLNK(statbuf.st_mode) == 1) {\r\n printf(\"Path is symlink.\\n\");\r\n return 1;\r\n }\r\n printf(\"Path is valid.\\n\");\r\n return 0;\r\n}\r\nint path_is_not_symlink(char * abs_path) {\r\n \r\n return (isSymLink(abs_path) == 0);\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int size = 0;\r\n FILE *file = 0;\r\n char *buffer = 0;\r\n char *str = 0;\r\n char *abs_path = 0;\r\n char *sleep_file = 0;\r\n char *menoetius_selvedged = 0;\r\n struct overprotected_unblacked morsels_mistakingly = {0};\r\n long pedately_longlinermen[10];\r\n struct overprotected_unblacked formolit_annuloid[10] = {0};\r\n struct overprotected_unblacked supernatation_gynoeciumcia;\r\n char *uncorking_anammonid;;\r\n if (__sync_bool_compare_and_swap(&unchristianized_sesser,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n uncorking_anammonid = getenv(\"GRIPPIEST_ECAUDATE\");\r\n if (uncorking_anammonid != 0) {;\r\n supernatation_gynoeciumcia . courier_spiceland = ((char *)uncorking_anammonid);\r\n formolit_annuloid[5] = supernatation_gynoeciumcia;\r\n pedately_longlinermen[1] = 5;\r\n morsels_mistakingly = *(formolit_annuloid + pedately_longlinermen[1]);\r\n menoetius_selvedged = ((char *)morsels_mistakingly . courier_spiceland);\r\n \r\n str = malloc(sizeof(char) * (strlen(menoetius_selvedged) + 1));\r\n sleep_file = malloc(sizeof(char) * (strlen(menoetius_selvedged) + 1));\r\n if (str != NULL && sleep_file != NULL &&\r\n (sscanf(menoetius_selvedged, \"%s %s\",\r\n sleep_file,\r\n str) == 2) &&\r\n (strlen(str) != 0) &&\r\n (strlen(sleep_file) != 0))\r\n {\r\n \r\n \r\n if (path_is_relative(str)) {\r\n abs_path = get_absolute_path(str);\r\n if (abs_path != NULL) {\r\n if (path_is_not_symlink(abs_path)) {\r\n \r\n \r\n waitForChange(abs_path, sleep_file);\r\n file = fopen(abs_path,\"rb\");\r\n \r\n if (file != 0) {\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\r\n if (buffer) {\r\n \r\n \r\n fread(buffer,sizeof(char ),size,file);\r\n buffer[size] = '\\0';\r\n printf(buffer);\r\n fclose(file);\r\n free(buffer);\r\n \r\n }\r\n }\r\n }\r\n free (abs_path);\r\n }\r\n }\r\n free(str);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fread(buffer,sizeof(char ),size,file);\n buffer[size] = '\\0';\n printf(buffer);\n fclose(file);\n free(buffer);\n```", "cwe": "363"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint mercatoria_culbut = 0;\r\n\r\nstruct pattu_cochabamba \r\n{\r\n char *deductibles_christensen;\r\n double mildred_oculists;\r\n char *gyrofrequency_outgrown;\r\n char kelpies_bassette;\r\n int litai_glycerolate;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *fennish_wheelings = 0;\r\n jmp_buf highspire_pilastered;\r\n int unmeasurable_functionalistic;\r\n struct pattu_cochabamba morcote_creche = {0};\r\n int **************************************************saviour_ventripotent = 0;\r\n int *************************************************uncompliability_integrability = 0;\r\n int ************************************************dimensum_zentner = 0;\r\n int ***********************************************brout_phantastical = 0;\r\n int **********************************************guildford_glenellyn = 0;\r\n int *********************************************dietist_hasten = 0;\r\n int ********************************************sanitisation_strippers = 0;\r\n int *******************************************demesgne_excarnate = 0;\r\n int ******************************************meanless_clei = 0;\r\n int *****************************************unnascent_aglance = 0;\r\n int ****************************************wielding_disdainable = 0;\r\n int ***************************************ranging_presaged = 0;\r\n int **************************************casefying_englishman = 0;\r\n int *************************************unfusibness_diagnostician = 0;\r\n int ************************************quinquepunctal_aposteriori = 0;\r\n int ***********************************ropinesses_histamines = 0;\r\n int **********************************birls_alfonson = 0;\r\n int *********************************capitative_kaya = 0;\r\n int ********************************bethesde_hecatonstylon = 0;\r\n int *******************************gel_subaerial = 0;\r\n int ******************************endromididae_preataxic = 0;\r\n int *****************************unpunched_alchemise = 0;\r\n int ****************************iconoclasticism_keenes = 0;\r\n int ***************************psychopathy_attiwendaronk = 0;\r\n int **************************gleda_poach = 0;\r\n int *************************menstruant_ira = 0;\r\n int ************************icicles_lugones = 0;\r\n int ***********************author_dezincking = 0;\r\n int **********************xid_lerne = 0;\r\n int *********************unqualification_chant = 0;\r\n int ********************whooplas_excantation = 0;\r\n int *******************spookily_ambuscades = 0;\r\n int ******************forecounsel_fripperer = 0;\r\n int *****************lipschitz_falla = 0;\r\n int ****************abound_overwove = 0;\r\n int ***************wretchlessness_debugs = 0;\r\n int **************basipetal_blackpool = 0;\r\n int *************throttlingly_kandahar = 0;\r\n int ************yobs_huswives = 0;\r\n int ***********oklahoma_graeae = 0;\r\n int **********faisal_recursive = 0;\r\n int *********ballottines_subfulgent = 0;\r\n int ********beckelite_potiphar = 0;\r\n int *******helodes_totalistic = 0;\r\n int ******boosters_misers = 0;\r\n int *****subrigidness_comparer = 0;\r\n int ****bics_boned = 0;\r\n int ***unrequitement_filipinization = 0;\r\n int **hedgehogs_karlotte = 0;\r\n int *valentines_rosamund = 0;\r\n int sarcosperm_malnutrite;\r\n struct pattu_cochabamba sledgemeter_surcingles[10] = {0};\r\n struct pattu_cochabamba burmese_compliments;\r\n char *eyereach_orpington;\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&mercatoria_culbut,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n eyereach_orpington = getenv(\"RECAPACITATE_PENUCHE\");\r\n if (eyereach_orpington != 0) {;\r\n burmese_compliments . deductibles_christensen = ((char *)eyereach_orpington);\r\n sarcosperm_malnutrite = 5;\r\n valentines_rosamund = &sarcosperm_malnutrite;\r\n hedgehogs_karlotte = &valentines_rosamund;\r\n unrequitement_filipinization = &hedgehogs_karlotte;\r\n bics_boned = &unrequitement_filipinization;\r\n subrigidness_comparer = &bics_boned;\r\n boosters_misers = &subrigidness_comparer;\r\n helodes_totalistic = &boosters_misers;\r\n beckelite_potiphar = &helodes_totalistic;\r\n ballottines_subfulgent = &beckelite_potiphar;\r\n faisal_recursive = &ballottines_subfulgent;\r\n oklahoma_graeae = &faisal_recursive;\r\n yobs_huswives = &oklahoma_graeae;\r\n throttlingly_kandahar = &yobs_huswives;\r\n basipetal_blackpool = &throttlingly_kandahar;\r\n wretchlessness_debugs = &basipetal_blackpool;\r\n abound_overwove = &wretchlessness_debugs;\r\n lipschitz_falla = &abound_overwove;\r\n forecounsel_fripperer = &lipschitz_falla;\r\n spookily_ambuscades = &forecounsel_fripperer;\r\n whooplas_excantation = &spookily_ambuscades;\r\n unqualification_chant = &whooplas_excantation;\r\n xid_lerne = &unqualification_chant;\r\n author_dezincking = &xid_lerne;\r\n icicles_lugones = &author_dezincking;\r\n menstruant_ira = &icicles_lugones;\r\n gleda_poach = &menstruant_ira;\r\n psychopathy_attiwendaronk = &gleda_poach;\r\n iconoclasticism_keenes = &psychopathy_attiwendaronk;\r\n unpunched_alchemise = &iconoclasticism_keenes;\r\n endromididae_preataxic = &unpunched_alchemise;\r\n gel_subaerial = &endromididae_preataxic;\r\n bethesde_hecatonstylon = &gel_subaerial;\r\n capitative_kaya = &bethesde_hecatonstylon;\r\n birls_alfonson = &capitative_kaya;\r\n ropinesses_histamines = &birls_alfonson;\r\n quinquepunctal_aposteriori = &ropinesses_histamines;\r\n unfusibness_diagnostician = &quinquepunctal_aposteriori;\r\n casefying_englishman = &unfusibness_diagnostician;\r\n ranging_presaged = &casefying_englishman;\r\n wielding_disdainable = &ranging_presaged;\r\n unnascent_aglance = &wielding_disdainable;\r\n meanless_clei = &unnascent_aglance;\r\n demesgne_excarnate = &meanless_clei;\r\n sanitisation_strippers = &demesgne_excarnate;\r\n dietist_hasten = &sanitisation_strippers;\r\n guildford_glenellyn = &dietist_hasten;\r\n brout_phantastical = &guildford_glenellyn;\r\n dimensum_zentner = &brout_phantastical;\r\n uncompliability_integrability = &dimensum_zentner;\r\n saviour_ventripotent = &uncompliability_integrability;\r\n sledgemeter_surcingles[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *saviour_ventripotent)))))))))))))))))))))))))))))))))))))))))))))))))] = burmese_compliments;\r\n morcote_creche = sledgemeter_surcingles[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *saviour_ventripotent)))))))))))))))))))))))))))))))))))))))))))))))))];\r\n unmeasurable_functionalistic = setjmp(highspire_pilastered);\r\n if (unmeasurable_functionalistic == 0) {\r\n longjmp(highspire_pilastered,1);\r\n }\r\n fennish_wheelings = ((char *)morcote_creche . deductibles_christensen);\r\n \r\n if (strlen(fennish_wheelings) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(fennish_wheelings) == 1) {\r\n parsed_input = malloc((strlen(fennish_wheelings)+1) * sizeof(char));\r\n urlDecode(fennish_wheelings, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint kinaesthesia_endways = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid underfoot_cheeked(char *diruption_coderived);\r\nvoid alexi_goonda(char *hide_equivote);\r\nvoid plinthlike_sudan(char *perikaryal_merrow);\r\nvoid galleria_vialogue(char *universally_temperate);\r\nvoid countenancing_maxillodental(char *babbitt_bedeafens);\r\nvoid gestapo_unimprecated(char *stromatolite_rearrested);\r\nvoid cathedral_neocolonially(char *eulogises_tomahawking);\r\nvoid knurlier_fringe(char *overintensities_monkeying);\r\nvoid unstoutly_undiffusiveness(char *nonmetamorphic_suasion);\r\nvoid fleapit_loaning(char *erected_waxy);\r\nvoid tads_hannah(char *nonplused_polonnaruwa);\r\nvoid plasmocyte_brindlish(char *shapable_primeval);\r\nvoid haulmier_beclowned(char *inputted_lahar);\r\nvoid hyperdeified_astrologies(char *noachian_wagnerite);\r\nvoid juieta_reforget(char *herniotomist_plumify);\r\nvoid shillelagh_duthie(char *jural_gangrels);\r\nvoid nephite_tressed(char *lucid_superarbiter);\r\nvoid disbranching_precirculate(char *yucaipa_para);\r\nvoid cymbaled_nembutsu(char *antirabies_hypopepsy);\r\nvoid remoboth_hadden(char *radiciferous_pagodalike);\r\nvoid malka_respect(char *picrated_grippers);\r\nvoid pinz_bewailer(char *carlyle_possessiones);\r\nvoid griphite_psychoclinical(char *lyford_chordotomy);\r\nvoid april_tisman(char *chilicothe_winterer);\r\nvoid trucial_intermaxilla(char *imbathe_imprejudicate);\r\nvoid procarnival_conformers(char *heyerdahl_spermines);\r\nvoid ichthyopolist_editorializers(char *reindictment_ceevee);\r\nvoid coprophagist_hydroselenide(char *microcosmic_sherill);\r\nvoid mca_killifish(char *radarscopes_autodrome);\r\nvoid triumphed_nonreconcilably(char *cibarial_acadia);\r\nvoid byelovo_teutonisation(char *stenocardia_fevering);\r\nvoid ostrogoth_unexacting(char *ichorous_coinitial);\r\nvoid hemotoxic_digest(char *rocklings_rice);\r\nvoid gelable_irresolvable(char *twelve_latewhiles);\r\nvoid tamassee_mammals(char *rewardingly_uruguayan);\r\nvoid polyadelphia_dasyatis(char *cocainist_lardizabalaceae);\r\nvoid snappers_palynomorph(char *leodicid_furzier);\r\nvoid goodly_spartans(char *habilitate_pensionaries);\r\nvoid minorage_unodoriferously(char *foamflower_clustering);\r\nvoid tritical_bouffes(char *indecence_hexsub);\r\nvoid fixatif_zeugobranchia(char *angiospasm_phascaceous);\r\nvoid grenloch_fetoplacental(char *gayla_evius);\r\nvoid unquested_jape(char *paraperiodic_separatedly);\r\nvoid galimatias_beroida(char *wondrousnesses_enargite);\r\nvoid misimproving_seriates(char *gruppetto_dutch);\r\nvoid monochlorinated_statesville(char *indraught_remail);\r\nvoid pebrine_pylas(char *hansenosis_dichlone);\r\nvoid phytase_ingressiveness(char *acerbated_regrate);\r\nvoid rentaler_bevesselled(char *sinify_superinfinitely);\r\nvoid phacotherapy_belshazzar(char *tallyhos_lan);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n char *liquidy_foraminate = 0;\r\n int *derivability_jublilation = 0;\r\n int yard_lorsung;\r\n char *divulsing_aghas[10] = {0};\r\n char *presupplication_telecamera;;\r\n if (__sync_bool_compare_and_swap(&kinaesthesia_endways,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n presupplication_telecamera = getenv(\"DEVOTEDLY_AGU\");\r\n if (presupplication_telecamera != 0) {;\r\n yard_lorsung = 5;\r\n derivability_jublilation = &yard_lorsung;\r\n divulsing_aghas[ *derivability_jublilation] = presupplication_telecamera;\r\n liquidy_foraminate = divulsing_aghas[ *derivability_jublilation];\r\n underfoot_cheeked(liquidy_foraminate);\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid underfoot_cheeked(char *diruption_coderived)\r\n{\r\n ++global_variable;;\r\n alexi_goonda(diruption_coderived);\r\n}\r\n\r\nvoid alexi_goonda(char *hide_equivote)\r\n{\r\n ++global_variable;;\r\n plinthlike_sudan(hide_equivote);\r\n}\r\n\r\nvoid plinthlike_sudan(char *perikaryal_merrow)\r\n{\r\n ++global_variable;;\r\n galleria_vialogue(perikaryal_merrow);\r\n}\r\n\r\nvoid galleria_vialogue(char *universally_temperate)\r\n{\r\n ++global_variable;;\r\n countenancing_maxillodental(universally_temperate);\r\n}\r\n\r\nvoid countenancing_maxillodental(char *babbitt_bedeafens)\r\n{\r\n ++global_variable;;\r\n gestapo_unimprecated(babbitt_bedeafens);\r\n}\r\n\r\nvoid gestapo_unimprecated(char *stromatolite_rearrested)\r\n{\r\n ++global_variable;;\r\n cathedral_neocolonially(stromatolite_rearrested);\r\n}\r\n\r\nvoid cathedral_neocolonially(char *eulogises_tomahawking)\r\n{\r\n ++global_variable;;\r\n knurlier_fringe(eulogises_tomahawking);\r\n}\r\n\r\nvoid knurlier_fringe(char *overintensities_monkeying)\r\n{\r\n ++global_variable;;\r\n unstoutly_undiffusiveness(overintensities_monkeying);\r\n}\r\n\r\nvoid unstoutly_undiffusiveness(char *nonmetamorphic_suasion)\r\n{\r\n ++global_variable;;\r\n fleapit_loaning(nonmetamorphic_suasion);\r\n}\r\n\r\nvoid fleapit_loaning(char *erected_waxy)\r\n{\r\n ++global_variable;;\r\n tads_hannah(erected_waxy);\r\n}\r\n\r\nvoid tads_hannah(char *nonplused_polonnaruwa)\r\n{\r\n ++global_variable;;\r\n plasmocyte_brindlish(nonplused_polonnaruwa);\r\n}\r\n\r\nvoid plasmocyte_brindlish(char *shapable_primeval)\r\n{\r\n ++global_variable;;\r\n haulmier_beclowned(shapable_primeval);\r\n}\r\n\r\nvoid haulmier_beclowned(char *inputted_lahar)\r\n{\r\n ++global_variable;;\r\n hyperdeified_astrologies(inputted_lahar);\r\n}\r\n\r\nvoid hyperdeified_astrologies(char *noachian_wagnerite)\r\n{\r\n ++global_variable;;\r\n juieta_reforget(noachian_wagnerite);\r\n}\r\n\r\nvoid juieta_reforget(char *herniotomist_plumify)\r\n{\r\n ++global_variable;;\r\n shillelagh_duthie(herniotomist_plumify);\r\n}\r\n\r\nvoid shillelagh_duthie(char *jural_gangrels)\r\n{\r\n ++global_variable;;\r\n nephite_tressed(jural_gangrels);\r\n}\r\n\r\nvoid nephite_tressed(char *lucid_superarbiter)\r\n{\r\n ++global_variable;;\r\n disbranching_precirculate(lucid_superarbiter);\r\n}\r\n\r\nvoid disbranching_precirculate(char *yucaipa_para)\r\n{\r\n ++global_variable;;\r\n cymbaled_nembutsu(yucaipa_para);\r\n}\r\n\r\nvoid cymbaled_nembutsu(char *antirabies_hypopepsy)\r\n{\r\n ++global_variable;;\r\n remoboth_hadden(antirabies_hypopepsy);\r\n}\r\n\r\nvoid remoboth_hadden(char *radiciferous_pagodalike)\r\n{\r\n ++global_variable;;\r\n malka_respect(radiciferous_pagodalike);\r\n}\r\n\r\nvoid malka_respect(char *picrated_grippers)\r\n{\r\n ++global_variable;;\r\n pinz_bewailer(picrated_grippers);\r\n}\r\n\r\nvoid pinz_bewailer(char *carlyle_possessiones)\r\n{\r\n ++global_variable;;\r\n griphite_psychoclinical(carlyle_possessiones);\r\n}\r\n\r\nvoid griphite_psychoclinical(char *lyford_chordotomy)\r\n{\r\n ++global_variable;;\r\n april_tisman(lyford_chordotomy);\r\n}\r\n\r\nvoid april_tisman(char *chilicothe_winterer)\r\n{\r\n ++global_variable;;\r\n trucial_intermaxilla(chilicothe_winterer);\r\n}\r\n\r\nvoid trucial_intermaxilla(char *imbathe_imprejudicate)\r\n{\r\n ++global_variable;;\r\n procarnival_conformers(imbathe_imprejudicate);\r\n}\r\n\r\nvoid procarnival_conformers(char *heyerdahl_spermines)\r\n{\r\n ++global_variable;;\r\n ichthyopolist_editorializers(heyerdahl_spermines);\r\n}\r\n\r\nvoid ichthyopolist_editorializers(char *reindictment_ceevee)\r\n{\r\n ++global_variable;;\r\n coprophagist_hydroselenide(reindictment_ceevee);\r\n}\r\n\r\nvoid coprophagist_hydroselenide(char *microcosmic_sherill)\r\n{\r\n ++global_variable;;\r\n mca_killifish(microcosmic_sherill);\r\n}\r\n\r\nvoid mca_killifish(char *radarscopes_autodrome)\r\n{\r\n ++global_variable;;\r\n triumphed_nonreconcilably(radarscopes_autodrome);\r\n}\r\n\r\nvoid triumphed_nonreconcilably(char *cibarial_acadia)\r\n{\r\n ++global_variable;;\r\n byelovo_teutonisation(cibarial_acadia);\r\n}\r\n\r\nvoid byelovo_teutonisation(char *stenocardia_fevering)\r\n{\r\n ++global_variable;;\r\n ostrogoth_unexacting(stenocardia_fevering);\r\n}\r\n\r\nvoid ostrogoth_unexacting(char *ichorous_coinitial)\r\n{\r\n ++global_variable;;\r\n hemotoxic_digest(ichorous_coinitial);\r\n}\r\n\r\nvoid hemotoxic_digest(char *rocklings_rice)\r\n{\r\n ++global_variable;;\r\n gelable_irresolvable(rocklings_rice);\r\n}\r\n\r\nvoid gelable_irresolvable(char *twelve_latewhiles)\r\n{\r\n ++global_variable;;\r\n tamassee_mammals(twelve_latewhiles);\r\n}\r\n\r\nvoid tamassee_mammals(char *rewardingly_uruguayan)\r\n{\r\n ++global_variable;;\r\n polyadelphia_dasyatis(rewardingly_uruguayan);\r\n}\r\n\r\nvoid polyadelphia_dasyatis(char *cocainist_lardizabalaceae)\r\n{\r\n ++global_variable;;\r\n snappers_palynomorph(cocainist_lardizabalaceae);\r\n}\r\n\r\nvoid snappers_palynomorph(char *leodicid_furzier)\r\n{\r\n ++global_variable;;\r\n goodly_spartans(leodicid_furzier);\r\n}\r\n\r\nvoid goodly_spartans(char *habilitate_pensionaries)\r\n{\r\n ++global_variable;;\r\n minorage_unodoriferously(habilitate_pensionaries);\r\n}\r\n\r\nvoid minorage_unodoriferously(char *foamflower_clustering)\r\n{\r\n ++global_variable;;\r\n tritical_bouffes(foamflower_clustering);\r\n}\r\n\r\nvoid tritical_bouffes(char *indecence_hexsub)\r\n{\r\n ++global_variable;;\r\n fixatif_zeugobranchia(indecence_hexsub);\r\n}\r\n\r\nvoid fixatif_zeugobranchia(char *angiospasm_phascaceous)\r\n{\r\n ++global_variable;;\r\n grenloch_fetoplacental(angiospasm_phascaceous);\r\n}\r\n\r\nvoid grenloch_fetoplacental(char *gayla_evius)\r\n{\r\n ++global_variable;;\r\n unquested_jape(gayla_evius);\r\n}\r\n\r\nvoid unquested_jape(char *paraperiodic_separatedly)\r\n{\r\n ++global_variable;;\r\n galimatias_beroida(paraperiodic_separatedly);\r\n}\r\n\r\nvoid galimatias_beroida(char *wondrousnesses_enargite)\r\n{\r\n ++global_variable;;\r\n misimproving_seriates(wondrousnesses_enargite);\r\n}\r\n\r\nvoid misimproving_seriates(char *gruppetto_dutch)\r\n{\r\n ++global_variable;;\r\n monochlorinated_statesville(gruppetto_dutch);\r\n}\r\n\r\nvoid monochlorinated_statesville(char *indraught_remail)\r\n{\r\n ++global_variable;;\r\n pebrine_pylas(indraught_remail);\r\n}\r\n\r\nvoid pebrine_pylas(char *hansenosis_dichlone)\r\n{\r\n ++global_variable;;\r\n phytase_ingressiveness(hansenosis_dichlone);\r\n}\r\n\r\nvoid phytase_ingressiveness(char *acerbated_regrate)\r\n{\r\n ++global_variable;;\r\n rentaler_bevesselled(acerbated_regrate);\r\n}\r\n\r\nvoid rentaler_bevesselled(char *sinify_superinfinitely)\r\n{\r\n ++global_variable;;\r\n phacotherapy_belshazzar(sinify_superinfinitely);\r\n}\r\n\r\nvoid phacotherapy_belshazzar(char *tallyhos_lan)\r\n{\r\n int ss_i = 0;\r\n char *proggers_odyl = 0;\r\n ++global_variable;;\r\n proggers_odyl = ((char *)tallyhos_lan);\r\n \r\n printf(\"checking input\\n\");\r\n \r\n \r\n \r\n while(ss_i < strlen(proggers_odyl)){\r\n \r\n if (proggers_odyl[ss_i] >= 48) {\r\n \r\n ++ss_i;\r\n }\r\n }\r\n \r\n \r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while(ss_i < strlen(proggers_odyl)){\n \n if (proggers_odyl[ss_i] >= 48) {\n \n ++ss_i;\n }\n }\n```", "cwe": "835"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint polygarchy_geothlypis = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid undecretory_artemis(char *mudd_hypopodia);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n#define MCGREGOR_PARAPHS(x) undecretory_artemis((char *) x)\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n char *tomahawking_heathlike;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&polygarchy_geothlypis,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n tomahawking_heathlike = getenv(\"GUD_ORGANICISTIC\");\r\n if (tomahawking_heathlike != 0) {;\r\n\tMCGREGOR_PARAPHS(tomahawking_heathlike);\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid undecretory_artemis(char *mudd_hypopodia)\r\n{\r\n int oc_i = 0;\r\n int file_desc;\r\n char buffer[128];\r\n char input_buf[128] = {0};\r\n char *contrabandage_nicknames = 0;\r\n ++global_variable;;\r\n contrabandage_nicknames = ((char *)mudd_hypopodia);\r\n \r\n memset(buffer,'x',128);\r\n buffer[127] = 0;\r\n file_desc = open(contrabandage_nicknames,0);\r\n if (file_desc > -1) {\r\n \r\n \r\n read(file_desc,input_buf,128);\r\n close(file_desc);\r\n \r\n \r\n \r\n strcpy(buffer,input_buf);\r\n \r\n for (; oc_i < strlen(buffer); ++oc_i) {\r\n buffer[oc_i] = toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\",buffer);\r\n \r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n strcpy(buffer,input_buf);\n \n for (; oc_i < strlen(buffer); ++oc_i) {\n buffer[oc_i] = toupper(buffer[oc_i]);\n }\n printf(\"%s\\n\",buffer);\n```", "cwe": "170"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint ineluctability_myringa = 0;\r\n\r\nunion berylliosis_triton \r\n{\r\n char *sevenbark_respondendum;\r\n double blunderings_aleukaemic;\r\n char *punctually_unpromise;\r\n char battology_brechan;\r\n int lhary_throatboll;\r\n}\r\n;\r\nint global_variable;\r\nvoid noctivagous_strongmen(union berylliosis_triton *waistcoated_campagus);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid sixteener_airview(void (*doe_baird)(union berylliosis_triton *));\r\nstruct struct {\r\n void (*function_ptr_1)();\r\n unsigned int input_num;\r\n void (*function_ptr_2)();\r\n};\r\nvoid function() {\r\n \r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&ineluctability_myringa,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n sixteener_airview(noctivagous_strongmen);\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid noctivagous_strongmen(union berylliosis_triton *waistcoated_campagus)\r\n{\r\n union berylliosis_triton subclassified_vagabondizing;\r\n char *lovesick_titulado;\r\n ++global_variable;;\r\n setup_printf_context();\r\n lovesick_titulado = getenv(\"STEMONACEAE_THORACAL\");\r\n if (lovesick_titulado != 0) {;\r\n subclassified_vagabondizing . sevenbark_respondendum = lovesick_titulado;\r\n *waistcoated_campagus = subclassified_vagabondizing;\r\n }\r\n}\r\n\r\nvoid sixteener_airview(void (*doe_baird)(union berylliosis_triton *))\r\n{\r\n char *byte_4 = 0;\r\n char *byte_3 = 0;\r\n unsigned int *ptr = 0;\r\n struct struct ssS;\r\n char *comer_eumelanin = 0;\r\n ++global_variable;\r\n union berylliosis_triton jonis_nonexhibitive = {0};\r\n doe_baird(&jonis_nonexhibitive);\r\n if (jonis_nonexhibitive . sevenbark_respondendum != 0) {;\r\n comer_eumelanin = ((char *)jonis_nonexhibitive . sevenbark_respondendum);\r\n \r\n ssS.function_ptr_1 = function;\r\n ssS.function_ptr_2 = function;\r\n if (strlen(comer_eumelanin) >= 1 &&\r\n comer_eumelanin[0] != '-') {\r\n ssS.input_num = strtoul(comer_eumelanin,0U,16);\r\n ptr = &(ssS.input_num);\r\n if ( *ptr > 65535) {\r\n \r\n \r\n \r\n byte_3 = ((char *)(ptr + 2));\r\n byte_4 = ((char *)(ptr + 3));\r\n *byte_3 = 0;\r\n *byte_4 = 0;\r\n \r\n \r\n \r\n }\r\n \r\n \r\n ssS.function_ptr_2();\r\n \r\n printf(\"Value = %i\\n\", ssS.input_num);\r\n } else if (strlen(comer_eumelanin) == 0) {\r\n printf(\"Input is empty string\\n\");\r\n } else {\r\n printf(\"Input is negative number\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n ssS.function_ptr_2();\n```", "cwe": "682"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint reroyalize_uncalcareous = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint returnChunkSize(void *dest,void *src)\r\n{\r\n \r\n if (strlen(dest) < strlen(src)) {\r\n\r\n return -1;\r\n }\r\n return strlen(dest);\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n const int MAXLEN = 16;\r\n char dest[MAXLEN];\r\n size_t size_var = 0;\r\n char *cortez_scordature = 0;\r\n int confrere_recanters;\r\n int aridity_phenoquinone;\r\n char ***eto_lanza = 0;\r\n char **preinterceding_schizotrypanum = 0;\r\n char *bartonella_larghissimo = 0;\r\n int teknonymously_tef = 0;\r\n char *pluckiest_glossoplegia = 0;\r\n char *telsonic_bisulcate;;\r\n if (__sync_bool_compare_and_swap(&reroyalize_uncalcareous,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&telsonic_bisulcate,\"CURTAXE_PROCEDENDO\");\r\n if (telsonic_bisulcate != 0) {;\r\n teknonymously_tef = ((int )(strlen(telsonic_bisulcate)));\r\n pluckiest_glossoplegia = ((char *)(malloc(teknonymously_tef + 1)));\r\n if (pluckiest_glossoplegia == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(pluckiest_glossoplegia,0,teknonymously_tef + 1);\r\n memcpy(pluckiest_glossoplegia,telsonic_bisulcate,teknonymously_tef);\r\n if (telsonic_bisulcate != 0) \r\n free(((char *)telsonic_bisulcate));\r\n preinterceding_schizotrypanum = &pluckiest_glossoplegia;\r\n eto_lanza = &preinterceding_schizotrypanum;\r\n aridity_phenoquinone = 5;\r\n while(1 == 1){\r\n aridity_phenoquinone = aridity_phenoquinone * 2;\r\n aridity_phenoquinone = aridity_phenoquinone + 2;\r\n if (aridity_phenoquinone > 1000) {\r\n break; \r\n }\r\n }\r\n confrere_recanters = aridity_phenoquinone;\r\n cortez_scordature = ((char *)( *( *eto_lanza)));\r\n \r\n memset(dest,'x',MAXLEN);\r\n dest[MAXLEN - 1] = '\\0';\r\n \r\n size_var = returnChunkSize(dest, cortez_scordature);\r\n \r\n \r\n \r\n\r\n if (size_var > 0)\r\n memcpy(dest, cortez_scordature, size_var);\r\n printf(\"%s\\n\",dest);\r\n \r\n \r\n;\r\n if ( *( *eto_lanza) != 0) \r\n free(((char *)( *( *eto_lanza))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n if (size_var > 0)\n memcpy(dest, cortez_scordature, size_var);\n printf(\"%s\\n\",dest);\n```", "cwe": "195"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\n#include <sys/stat.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint photostats_unamendable = 0;\r\ntypedef char *gymnocidium_racketeer;\r\nint global_variable;\r\nvoid handle_taint(char *amassers_woodkern);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\npthread_t t0, t1, t2;\r\nsem_t sem;\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int *arr;\r\n int i = 0;\r\n int i = 0;\r\n \r\n printf(\"Inside toCap\\n\");\r\n \r\n sem_wait(&sem); \r\n \r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n for(i = 0; i < strlen(Data->data); i++) {\r\n if (Data->data[i] >= 'a' && Data->data[i] <= 'z') { \r\n Data->data[i] -= 32; \r\n }\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\nint isalpha(char c) {\r\n return ((c >= 'A' && c <= 'Z') ||\r\n (c >= 'a' && c <= 'z'));\r\n}\r\nvoid *delNonAlpha (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n int j = 0;\r\n char *temp = NULL;\r\n \r\n printf(\"Inside delNonAlpha\\n\");\r\n \r\n sem_wait(&sem);\r\n temp = malloc(sizeof(char) * (strlen(Data->data) + 1));\r\n while(Data->data[i] != '\\0') {\r\n if (isalpha(Data->data[i])) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[++j] = '\\0';\r\n free(Data->data);\r\n Data->data = NULL; \r\n \r\n \r\n readFile(Data->file2);\r\n \r\n Data->data = temp;\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&photostats_unamendable,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\n\r\nvoid handle_taint(char *amassers_woodkern)\r\n{\r\n pthread_t t0, t1;\r\n int hasNonAlpha = 0;\r\n int i = 0;\r\n struct data* Data;\r\n char *nonfeasance_lithodidae = 0;\r\n jmp_buf pirate_costars;\r\n int tabardillo_sapremias;\r\n gymnocidium_racketeer *voq_disenthrone = 0;\r\n gymnocidium_racketeer everettville_dabbles = 0;\r\n gymnocidium_racketeer scanting_claggum = 0;\r\n ++global_variable;;\r\n if (amassers_woodkern != 0) {;\r\n scanting_claggum = amassers_woodkern;\r\n voq_disenthrone = &scanting_claggum;\r\n tabardillo_sapremias = setjmp(pirate_costars);\r\n if (tabardillo_sapremias == 0) {\r\n longjmp(pirate_costars,1);\r\n }\r\n nonfeasance_lithodidae = ((char *)( *voq_disenthrone));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(nonfeasance_lithodidae) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(nonfeasance_lithodidae) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(nonfeasance_lithodidae) + 1));\r\n if (Data->data) {\r\n if ((sscanf(nonfeasance_lithodidae, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0)) {\r\n sem_init(&sem, 0, 1);\r\n while (Data->data[i] != '\\0') { \r\n if(isalpha(Data->data[i]) == 0) {\r\n hasNonAlpha = 1;\r\n }\r\n i++;\r\n }\r\n if (hasNonAlpha != 0) {\r\n \r\n \r\n sem_post(&sem);\r\n pthread_create(&t0, NULL, delNonAlpha, Data); \r\n \r\n } \r\n pthread_create(&t1, NULL, toCap, Data);\r\n if (hasNonAlpha != 0) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n } else {\r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ( *voq_disenthrone != 0) \r\n free(((char *)( *voq_disenthrone)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n readFile(Data->file2);\n```", "cwe": "765"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\nint desktops_sesquinona = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid chocho_cumbrance(char *const islanded_lyburn);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int phthalanilic_unforbiddenness = 30;\r\n char *birdless_nemaline;;\r\n if (__sync_bool_compare_and_swap(&desktops_sesquinona,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&birdless_nemaline,\"4357\",phthalanilic_unforbiddenness);\r\n if (birdless_nemaline != 0) {;\r\n chocho_cumbrance(birdless_nemaline);\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid chocho_cumbrance(char *const islanded_lyburn)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *maximins_plecotine = 0;\r\n int stringwood_histone;\r\n int supernaturalist_yawn;\r\n ++global_variable;;\r\n supernaturalist_yawn = 5;\r\n while(1 == 1){\r\n supernaturalist_yawn = supernaturalist_yawn * 2;\r\n supernaturalist_yawn = supernaturalist_yawn + 2;\r\n if (supernaturalist_yawn > 1000) {\r\n break; \r\n }\r\n }\r\n stringwood_histone = supernaturalist_yawn;\r\n maximins_plecotine = ((char *)((char *)islanded_lyburn));\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",maximins_plecotine);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (((char *)islanded_lyburn) != 0) \r\n free(((char *)((char *)islanded_lyburn)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint erath_sublacustrine = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid philomythic_bronchotomy(int receiptless_unroasted,char **minsteryard_megadonty);\r\nvoid ficuses_hornswoggled(int polygene_mutable,char **modishly_knowableness);\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int faithbreach_warrigals = 7;\r\n char **overcherished_unprovide = 0;\r\n char **merribush_spraggs = 0;\r\n int townships_navete = 0;\r\n char *voltages_sjenicki = 0;\r\n char *electrotrephine_offend;;\r\n if (__sync_bool_compare_and_swap(&erath_sublacustrine,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n electrotrephine_offend = getenv(\"KAOHSIUNG_GRAUBUNDEN\");\r\n if (electrotrephine_offend != 0) {;\r\n townships_navete = ((int )(strlen(electrotrephine_offend)));\r\n voltages_sjenicki = ((char *)(malloc(townships_navete + 1)));\r\n if (voltages_sjenicki == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(voltages_sjenicki,0,townships_navete + 1);\r\n memcpy(voltages_sjenicki,electrotrephine_offend,townships_navete);\r\n overcherished_unprovide = &voltages_sjenicki;\r\n merribush_spraggs = overcherished_unprovide + 5;\r\n philomythic_bronchotomy(faithbreach_warrigals,merribush_spraggs);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid philomythic_bronchotomy(int receiptless_unroasted,char **minsteryard_megadonty)\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *posher_vitreouslike = 0;\r\n ++global_variable;\r\n receiptless_unroasted--;\r\n if (receiptless_unroasted > 0) {\r\n ficuses_hornswoggled(receiptless_unroasted,minsteryard_megadonty);\r\n return ;\r\n }\r\n posher_vitreouslike = ((char *)( *(minsteryard_megadonty - 5)));\r\n \r\n while(isalnum(posher_vitreouslike[size]) && size < strlen(posher_vitreouslike)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(posher_vitreouslike)) {\r\n posher_vitreouslike = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,posher_vitreouslike);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if ( *(minsteryard_megadonty - 5) != 0) \r\n free(((char *)( *(minsteryard_megadonty - 5))));\r\nclose_printf_context();\r\n}\r\n\r\nvoid ficuses_hornswoggled(int polygene_mutable,char **modishly_knowableness)\r\n{\r\n ++global_variable;\r\n philomythic_bronchotomy(polygene_mutable,modishly_knowableness);\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,posher_vitreouslike);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint encodement_forecastleman = 0;\r\n\r\nunion thorough_cavit \r\n{\r\n char *fleam_stickball;\r\n double depilatory_pseudoethically;\r\n char *sprayfully_underlinemen;\r\n char belgravian_buddleias;\r\n int misrepresents_confection;\r\n}\r\n;\r\nint global_variable;\r\nvoid bend_godded(union thorough_cavit *belugite_parnellite);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid opisthodont_cyanin(void (*message_zygopterous)(union thorough_cavit *));\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_t t0, t1;\r\npthread_mutex_t mutex_0, mutex_1;\r\nint dev_amount = 1;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcDevamount(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int qsize;\r\n \r\n printf(\"Inside calcDevAmount\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n \r\n \r\n dev_amount = Data->data[0] - 'A'; \r\n qsize = Data->qsize;\r\n if (dev_amount < 0) { \r\n dev_amount *= -1; \r\n }\r\n \r\n readFile(Data->file2);\r\n if (dev_amount == 0) { \r\n dev_amount += 1; \r\n }\r\n \r\n \r\n pthread_mutex_unlock(&mutex_0);\r\n return NULL;\r\n}\r\nvoid *devChar(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i;\r\n int i;\r\n int *arr = NULL;\r\n \r\n printf(\"Inside devChar\\n\");\r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n pthread_mutex_lock(&mutex_1);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n \r\n \r\n \r\n for (i = 0; i < strlen(Data->data); i++) { \r\n Data->data[i] /= dev_amount; \r\n }\r\n \r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&encodement_forecastleman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n opisthodont_cyanin(bend_godded);\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid bend_godded(union thorough_cavit *belugite_parnellite)\r\n{\r\n union thorough_cavit trainways_superinduction;\r\n char *dulsea_cupriferous;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&dulsea_cupriferous,\"MATRICULATING_WADESTOWN\");\r\n if (dulsea_cupriferous != 0) {;\r\n trainways_superinduction . fleam_stickball = dulsea_cupriferous;\r\n *belugite_parnellite = trainways_superinduction;\r\n }\r\n}\r\n\r\nvoid opisthodont_cyanin(void (*message_zygopterous)(union thorough_cavit *))\r\n{\r\n struct data* Data;\r\n char *airmail_masculineness = 0;\r\n union thorough_cavit melammdim_chaffinch = {0};\r\n int *subprostatic_honora = 0;\r\n int indistinctly_enthusiasm;\r\n union thorough_cavit hyperite_gonium[10] = {0};\r\n ++global_variable;\r\n union thorough_cavit venison_elasticate = {0};\r\n message_zygopterous(&venison_elasticate);\r\n if (venison_elasticate . fleam_stickball != 0) {;\r\n hyperite_gonium[5] = venison_elasticate;\r\n indistinctly_enthusiasm = 5;\r\n subprostatic_honora = &indistinctly_enthusiasm;\r\n melammdim_chaffinch = *(hyperite_gonium + *subprostatic_honora);\r\n airmail_masculineness = ((char *)melammdim_chaffinch . fleam_stickball);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n if (Data->data) {\r\n if ((sscanf(airmail_masculineness, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n \r\n \r\n \r\n \r\n \r\n if (strlen(Data->data) > 50) { \r\n \r\n if (pthread_create(&t0, NULL, calcDevamount, Data) != 0) { \r\n printf(\"Error initializing thread 0.\");\r\n }\r\n }\r\n if (pthread_create(&t1, NULL, devChar, Data) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n if (strlen(Data->data) > 50) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (melammdim_chaffinch . fleam_stickball != 0) \r\n free(((char *)melammdim_chaffinch . fleam_stickball));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n for (i = 0; i < strlen(Data->data); i++) { \n Data->data[i] /= dev_amount; \n }\n```", "cwe": "821"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint brum_amphore = 0;\r\nint global_variable;\r\ntypedef char *hirsutulous_impredicability;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid biopyribole_pelodytidae(hirsutulous_impredicability **nabcheat_nervomuscular);\r\nvoid pulpous_unsifted(hirsutulous_impredicability **malpighiaceous_fatelike);\r\nvoid photolitho_aftertimes(hirsutulous_impredicability **thiocarbamyl_protraditional);\r\nvoid myringa_pines(hirsutulous_impredicability **soloman_gld);\r\nvoid cecilla_wineyard(hirsutulous_impredicability **malcontent_abductors);\r\nvoid confederative_bacteriopsonic(hirsutulous_impredicability **neatherd_unloveliness);\r\nvoid sachs_unmaster(hirsutulous_impredicability **heteronomously_graynesses);\r\nvoid kakapo_victorianize(hirsutulous_impredicability **combusted_unchapleted);\r\nvoid spraining_discoloured(hirsutulous_impredicability **angiorrhaphy_spoilage);\r\nvoid rodolphe_alleviater(hirsutulous_impredicability **aceric_reknits);\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n hirsutulous_impredicability **beglads_barmkin = 0;\r\n hirsutulous_impredicability *lactucarium_spindling = 0;\r\n hirsutulous_impredicability dag_feluccas = 0;\r\n hirsutulous_impredicability superodorsal_triflet = 0;\r\n char *worldman_scleranth;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&brum_amphore,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&worldman_scleranth,\"LOOTED_REMOVABLE\");\r\n if (worldman_scleranth != 0) {;\r\n superodorsal_triflet = worldman_scleranth;\r\n lactucarium_spindling = &superodorsal_triflet;\r\n beglads_barmkin = &lactucarium_spindling;\r\n biopyribole_pelodytidae(beglads_barmkin);\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid biopyribole_pelodytidae(hirsutulous_impredicability **nabcheat_nervomuscular)\r\n{\r\n ++global_variable;;\r\n pulpous_unsifted(nabcheat_nervomuscular);\r\n}\r\n\r\nvoid pulpous_unsifted(hirsutulous_impredicability **malpighiaceous_fatelike)\r\n{\r\n ++global_variable;;\r\n photolitho_aftertimes(malpighiaceous_fatelike);\r\n}\r\n\r\nvoid photolitho_aftertimes(hirsutulous_impredicability **thiocarbamyl_protraditional)\r\n{\r\n ++global_variable;;\r\n myringa_pines(thiocarbamyl_protraditional);\r\n}\r\n\r\nvoid myringa_pines(hirsutulous_impredicability **soloman_gld)\r\n{\r\n ++global_variable;;\r\n cecilla_wineyard(soloman_gld);\r\n}\r\n\r\nvoid cecilla_wineyard(hirsutulous_impredicability **malcontent_abductors)\r\n{\r\n ++global_variable;;\r\n confederative_bacteriopsonic(malcontent_abductors);\r\n}\r\n\r\nvoid confederative_bacteriopsonic(hirsutulous_impredicability **neatherd_unloveliness)\r\n{\r\n ++global_variable;;\r\n sachs_unmaster(neatherd_unloveliness);\r\n}\r\n\r\nvoid sachs_unmaster(hirsutulous_impredicability **heteronomously_graynesses)\r\n{\r\n ++global_variable;;\r\n kakapo_victorianize(heteronomously_graynesses);\r\n}\r\n\r\nvoid kakapo_victorianize(hirsutulous_impredicability **combusted_unchapleted)\r\n{\r\n ++global_variable;;\r\n spraining_discoloured(combusted_unchapleted);\r\n}\r\n\r\nvoid spraining_discoloured(hirsutulous_impredicability **angiorrhaphy_spoilage)\r\n{\r\n ++global_variable;;\r\n rodolphe_alleviater(angiorrhaphy_spoilage);\r\n}\r\n\r\nvoid rodolphe_alleviater(hirsutulous_impredicability **aceric_reknits)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *uncoopered_stockishly = 0;\r\n ++global_variable;;\r\n uncoopered_stockishly = ((char *)( *( *aceric_reknits)));\r\n \r\n len = strtol(uncoopered_stockishly,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if ( *( *aceric_reknits) != 0) \r\n free(((char *)( *( *aceric_reknits))));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint academie_pigeonweed = 0;\r\nint global_variable;\r\n\r\nstruct unmistakingly_polypragmonist \r\n{\r\n char *donaldsonville_underdresses;\r\n double strippers_virgilio;\r\n char *fizgig_dermatoplasm;\r\n char firn_dermestes;\r\n int felsophyre_uncursing;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *bidarkee_squashberry = 0;\r\n int osi_digit;\r\n struct unmistakingly_polypragmonist *sab_paedagogy = {0};\r\n struct unmistakingly_polypragmonist *tabletted_unparcelled = {0};\r\n struct unmistakingly_polypragmonist shebang_pommelion;\r\n int reversible_millepunctate = 22;\r\n char *unpicketed_cupolaman;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&academie_pigeonweed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&unpicketed_cupolaman,\"4301\",reversible_millepunctate);\r\n if (unpicketed_cupolaman != 0) {;\r\n shebang_pommelion . donaldsonville_underdresses = ((char *)unpicketed_cupolaman);\r\n osi_digit = 1;\r\n sab_paedagogy = &shebang_pommelion;\r\n tabletted_unparcelled = ((struct unmistakingly_polypragmonist *)(((unsigned long )sab_paedagogy) * osi_digit * osi_digit)) + 5;\r\n if (( *(tabletted_unparcelled - 5)) . donaldsonville_underdresses != 0) {\r\n goto gastroadynamic_afterage;\r\n }\r\n ++global_variable;\r\n gastroadynamic_afterage:;\r\n bidarkee_squashberry = ((char *)( *(tabletted_unparcelled - 5)) . donaldsonville_underdresses);\r\n \r\n len = strtol(bidarkee_squashberry,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (( *(tabletted_unparcelled - 5)) . donaldsonville_underdresses != 0) \r\n free(((char *)( *(tabletted_unparcelled - 5)) . donaldsonville_underdresses));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <mongoose.h> \r\n#include <string.h> \r\n#include <openssl/evp.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <sys/types.h> \r\n#include <sys/wait.h> \r\n#include <unistd.h> \r\n#include <sys/stat.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint masterwort_enclog = 0;\r\nint global_variable;\r\nvoid handle_taint(char *prided_mackinaw);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid coppin_vaishnavism(void **yobi_myogen);\r\nvoid acy_rebore(void **daynet_illuminance);\r\nvoid undergirdle_preoperation(void **negligibly_libelist);\r\nvoid asarabacca_moralioralist(void **nonimmanent_apedom);\r\nvoid cuspated_raasch(void **monkeys_wontons);\r\nvoid trochleate_venner(void **jackerooing_impar);\r\nvoid fitnesses_countermanded(void **marksman_wharfman);\r\nvoid urbaneness_raspingly(void **gemse_regentess);\r\nvoid grainier_jhvh(void **unstuffily_carpium);\r\nvoid djerba_lampeter(void **kingdomless_camptonite);\r\nvoid polychaetan_outgained(void **omniregency_raasch);\r\nvoid pseudaconin_murarium(void **ukiyoye_seleniuret);\r\nvoid breakaxe_pacchionian(void **institutionally_misnutrition);\r\nvoid allegoriser_lynnworth(void **braize_tribally);\r\nvoid rotations_antignostic(void **lustily_comaker);\r\nvoid gap_balearian(void **sociocentricity_dahle);\r\nvoid lamplighted_hormigo(void **repletion_sucklers);\r\nvoid dorchester_anticorruption(void **himene_tel);\r\nvoid livened_prevariation(void **totemization_sellably);\r\nvoid impostrous_kashruths(void **linerless_aspirating);\r\nvoid sextuberculate_fustigated(void **hedonisms_fleuronee);\r\nvoid herbist_grazer(void **tintingly_circularizers);\r\nvoid aiguilles_mokamoka(void **wrand_norito);\r\nvoid inexplorable_protestantlike(void **epileptics_lits);\r\nvoid coverlets_nauropometer(void **budgie_preceremonial);\r\nvoid heriot_unpromoted(void **relaunder_shandry);\r\nvoid kachcha_windlassing(void **hydatigenous_wakamba);\r\nvoid dismain_amphigonic(void **shogunal_nebbishes);\r\nvoid ebony_whats(void **unsummarized_torres);\r\nvoid taata_siruelas(void **fredrick_scythize);\r\nvoid usward_debunked(void **arean_asclepiade);\r\nvoid inexpiableness_patmo(void **neurosecretory_alvearium);\r\nvoid discernably_famiglietti(void **eiderdowns_sycophantical);\r\nvoid terrier_reemployed(void **electrons_peneios);\r\nvoid parasols_procure(void **maroquin_lehi);\r\nvoid kerflummox_sawings(void **frontiersman_brochidodromous);\r\nvoid loa_tackled(void **chipchop_serviced);\r\nvoid scansions_brist(void **imbrications_cresotic);\r\nvoid environic_camblet(void **tavernless_brist);\r\nvoid nonsubstitutive_culminating(void **shouldna_weinstock);\r\nvoid aramanta_undealt(void **rubberwise_americanisms);\r\nvoid fannin_golee(void **kester_minxish);\r\nvoid gosain_daira(void **soubrette_gamest);\r\nvoid overwheel_gastrogenital(void **alcoothionic_ministeriality);\r\nvoid adelheid_ergatomorphism(void **minorities_coleville);\r\nvoid unforgivably_fidging(void **gammers_draconianism);\r\nvoid nonpossibly_glans(void **priapisms_panipat);\r\nvoid cering_rollinsville(void **onrushes_contextured);\r\nvoid curiosa_tuberculoses(void **murrains_sinologue);\r\nvoid urbanest_nontreated(void **pseudofamously_saratoga);\r\nvoid evp_hash(const char *algorithm_name,char *filename) {\r\n int ii = 0;\r\n FILE *file_stream = 0;\r\n char hash_print_val[129] = {0};\r\n unsigned char file_contents[1024];\r\n size_t file_contents_size = 1024;\r\n size_t file_contents_size_read = 0;\r\n const EVP_MD *md_engine = 0;\r\n unsigned char md_value[64];\r\n unsigned int md_value_len = 0;\r\n EVP_MD_CTX *md_context = 0;\r\n int hash_update_result = 0;\r\n \r\n memset(md_value,0,64);\r\n file_stream = fopen(filename,\"rb\");\r\n if (file_stream != 0) {\r\n md_engine = EVP_get_digestbyname(algorithm_name);\r\n if (md_engine != 0) {\r\n md_context = EVP_MD_CTX_create();\r\n if (md_context != 0) {\r\n if (EVP_DigestInit_ex(md_context,md_engine,0)) {\r\n \r\n while(!feof(file_stream)) {\r\n \r\n memset(file_contents,0,file_contents_size);\r\n file_contents_size_read = fread(file_contents,\r\n sizeof(unsigned char ),file_contents_size,file_stream);\r\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\r\n if (1 != hash_update_result) {\r\n break;\r\n }\r\n }\r\n \r\n if (1 == hash_update_result) {\r\n if (EVP_DigestFinal_ex(md_context,md_value,&md_value_len)) {\r\n for (ii = 0; ii < md_value_len; ++ii) {\r\n sprintf(&hash_print_val[ii * 2],\"%02x\",md_value[ii]);\r\n }\r\n printf(\"%s %s\\n\",hash_print_val,filename);\r\n } else {\r\n printf(\"Failure finalizing hash for file '%s' with algorithm '%s'.\\n\",\r\n filename,algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failure hashing file '%s' with algorithm '%s'.\\n\",filename,algorithm_name);\r\n }\r\n }\r\n EVP_MD_CTX_destroy(md_context);\r\n } else {\r\n printf(\"Could not create a context for hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Could not load hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failed to open file: '%s'\\n\",filename);\r\n }\r\n if (file_stream != 0) {\r\n fclose(file_stream);\r\n file_stream = 0;\r\n }\r\n}\r\nstruct pid_fd {\r\n pid_t pid;\r\n int fd_array[2];\r\n};\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&masterwort_enclog,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid handle_taint(char *prided_mackinaw)\r\n{\r\n void **nonlethally_lobelines = 0;\r\n void *lensed_texline = 0;\r\n ++global_variable;;\r\n if (prided_mackinaw != 0) {;\r\n lensed_texline = ((void *)prided_mackinaw);\r\n nonlethally_lobelines = &lensed_texline;\r\n coppin_vaishnavism(nonlethally_lobelines);\r\n }\r\n}\r\n\r\nvoid coppin_vaishnavism(void **yobi_myogen)\r\n{\r\n ++global_variable;;\r\n acy_rebore(yobi_myogen);\r\n}\r\n\r\nvoid acy_rebore(void **daynet_illuminance)\r\n{\r\n ++global_variable;;\r\n undergirdle_preoperation(daynet_illuminance);\r\n}\r\n\r\nvoid undergirdle_preoperation(void **negligibly_libelist)\r\n{\r\n ++global_variable;;\r\n asarabacca_moralioralist(negligibly_libelist);\r\n}\r\n\r\nvoid asarabacca_moralioralist(void **nonimmanent_apedom)\r\n{\r\n ++global_variable;;\r\n cuspated_raasch(nonimmanent_apedom);\r\n}\r\n\r\nvoid cuspated_raasch(void **monkeys_wontons)\r\n{\r\n ++global_variable;;\r\n trochleate_venner(monkeys_wontons);\r\n}\r\n\r\nvoid trochleate_venner(void **jackerooing_impar)\r\n{\r\n ++global_variable;;\r\n fitnesses_countermanded(jackerooing_impar);\r\n}\r\n\r\nvoid fitnesses_countermanded(void **marksman_wharfman)\r\n{\r\n ++global_variable;;\r\n urbaneness_raspingly(marksman_wharfman);\r\n}\r\n\r\nvoid urbaneness_raspingly(void **gemse_regentess)\r\n{\r\n ++global_variable;;\r\n grainier_jhvh(gemse_regentess);\r\n}\r\n\r\nvoid grainier_jhvh(void **unstuffily_carpium)\r\n{\r\n ++global_variable;;\r\n djerba_lampeter(unstuffily_carpium);\r\n}\r\n\r\nvoid djerba_lampeter(void **kingdomless_camptonite)\r\n{\r\n ++global_variable;;\r\n polychaetan_outgained(kingdomless_camptonite);\r\n}\r\n\r\nvoid polychaetan_outgained(void **omniregency_raasch)\r\n{\r\n ++global_variable;;\r\n pseudaconin_murarium(omniregency_raasch);\r\n}\r\n\r\nvoid pseudaconin_murarium(void **ukiyoye_seleniuret)\r\n{\r\n ++global_variable;;\r\n breakaxe_pacchionian(ukiyoye_seleniuret);\r\n}\r\n\r\nvoid breakaxe_pacchionian(void **institutionally_misnutrition)\r\n{\r\n ++global_variable;;\r\n allegoriser_lynnworth(institutionally_misnutrition);\r\n}\r\n\r\nvoid allegoriser_lynnworth(void **braize_tribally)\r\n{\r\n ++global_variable;;\r\n rotations_antignostic(braize_tribally);\r\n}\r\n\r\nvoid rotations_antignostic(void **lustily_comaker)\r\n{\r\n ++global_variable;;\r\n gap_balearian(lustily_comaker);\r\n}\r\n\r\nvoid gap_balearian(void **sociocentricity_dahle)\r\n{\r\n ++global_variable;;\r\n lamplighted_hormigo(sociocentricity_dahle);\r\n}\r\n\r\nvoid lamplighted_hormigo(void **repletion_sucklers)\r\n{\r\n ++global_variable;;\r\n dorchester_anticorruption(repletion_sucklers);\r\n}\r\n\r\nvoid dorchester_anticorruption(void **himene_tel)\r\n{\r\n ++global_variable;;\r\n livened_prevariation(himene_tel);\r\n}\r\n\r\nvoid livened_prevariation(void **totemization_sellably)\r\n{\r\n ++global_variable;;\r\n impostrous_kashruths(totemization_sellably);\r\n}\r\n\r\nvoid impostrous_kashruths(void **linerless_aspirating)\r\n{\r\n ++global_variable;;\r\n sextuberculate_fustigated(linerless_aspirating);\r\n}\r\n\r\nvoid sextuberculate_fustigated(void **hedonisms_fleuronee)\r\n{\r\n ++global_variable;;\r\n herbist_grazer(hedonisms_fleuronee);\r\n}\r\n\r\nvoid herbist_grazer(void **tintingly_circularizers)\r\n{\r\n ++global_variable;;\r\n aiguilles_mokamoka(tintingly_circularizers);\r\n}\r\n\r\nvoid aiguilles_mokamoka(void **wrand_norito)\r\n{\r\n ++global_variable;;\r\n inexplorable_protestantlike(wrand_norito);\r\n}\r\n\r\nvoid inexplorable_protestantlike(void **epileptics_lits)\r\n{\r\n ++global_variable;;\r\n coverlets_nauropometer(epileptics_lits);\r\n}\r\n\r\nvoid coverlets_nauropometer(void **budgie_preceremonial)\r\n{\r\n ++global_variable;;\r\n heriot_unpromoted(budgie_preceremonial);\r\n}\r\n\r\nvoid heriot_unpromoted(void **relaunder_shandry)\r\n{\r\n ++global_variable;;\r\n kachcha_windlassing(relaunder_shandry);\r\n}\r\n\r\nvoid kachcha_windlassing(void **hydatigenous_wakamba)\r\n{\r\n ++global_variable;;\r\n dismain_amphigonic(hydatigenous_wakamba);\r\n}\r\n\r\nvoid dismain_amphigonic(void **shogunal_nebbishes)\r\n{\r\n ++global_variable;;\r\n ebony_whats(shogunal_nebbishes);\r\n}\r\n\r\nvoid ebony_whats(void **unsummarized_torres)\r\n{\r\n ++global_variable;;\r\n taata_siruelas(unsummarized_torres);\r\n}\r\n\r\nvoid taata_siruelas(void **fredrick_scythize)\r\n{\r\n ++global_variable;;\r\n usward_debunked(fredrick_scythize);\r\n}\r\n\r\nvoid usward_debunked(void **arean_asclepiade)\r\n{\r\n ++global_variable;;\r\n inexpiableness_patmo(arean_asclepiade);\r\n}\r\n\r\nvoid inexpiableness_patmo(void **neurosecretory_alvearium)\r\n{\r\n ++global_variable;;\r\n discernably_famiglietti(neurosecretory_alvearium);\r\n}\r\n\r\nvoid discernably_famiglietti(void **eiderdowns_sycophantical)\r\n{\r\n ++global_variable;;\r\n terrier_reemployed(eiderdowns_sycophantical);\r\n}\r\n\r\nvoid terrier_reemployed(void **electrons_peneios)\r\n{\r\n ++global_variable;;\r\n parasols_procure(electrons_peneios);\r\n}\r\n\r\nvoid parasols_procure(void **maroquin_lehi)\r\n{\r\n ++global_variable;;\r\n kerflummox_sawings(maroquin_lehi);\r\n}\r\n\r\nvoid kerflummox_sawings(void **frontiersman_brochidodromous)\r\n{\r\n ++global_variable;;\r\n loa_tackled(frontiersman_brochidodromous);\r\n}\r\n\r\nvoid loa_tackled(void **chipchop_serviced)\r\n{\r\n ++global_variable;;\r\n scansions_brist(chipchop_serviced);\r\n}\r\n\r\nvoid scansions_brist(void **imbrications_cresotic)\r\n{\r\n ++global_variable;;\r\n environic_camblet(imbrications_cresotic);\r\n}\r\n\r\nvoid environic_camblet(void **tavernless_brist)\r\n{\r\n ++global_variable;;\r\n nonsubstitutive_culminating(tavernless_brist);\r\n}\r\n\r\nvoid nonsubstitutive_culminating(void **shouldna_weinstock)\r\n{\r\n ++global_variable;;\r\n aramanta_undealt(shouldna_weinstock);\r\n}\r\n\r\nvoid aramanta_undealt(void **rubberwise_americanisms)\r\n{\r\n ++global_variable;;\r\n fannin_golee(rubberwise_americanisms);\r\n}\r\n\r\nvoid fannin_golee(void **kester_minxish)\r\n{\r\n ++global_variable;;\r\n gosain_daira(kester_minxish);\r\n}\r\n\r\nvoid gosain_daira(void **soubrette_gamest)\r\n{\r\n ++global_variable;;\r\n overwheel_gastrogenital(soubrette_gamest);\r\n}\r\n\r\nvoid overwheel_gastrogenital(void **alcoothionic_ministeriality)\r\n{\r\n ++global_variable;;\r\n adelheid_ergatomorphism(alcoothionic_ministeriality);\r\n}\r\n\r\nvoid adelheid_ergatomorphism(void **minorities_coleville)\r\n{\r\n ++global_variable;;\r\n unforgivably_fidging(minorities_coleville);\r\n}\r\n\r\nvoid unforgivably_fidging(void **gammers_draconianism)\r\n{\r\n ++global_variable;;\r\n nonpossibly_glans(gammers_draconianism);\r\n}\r\n\r\nvoid nonpossibly_glans(void **priapisms_panipat)\r\n{\r\n ++global_variable;;\r\n cering_rollinsville(priapisms_panipat);\r\n}\r\n\r\nvoid cering_rollinsville(void **onrushes_contextured)\r\n{\r\n ++global_variable;;\r\n curiosa_tuberculoses(onrushes_contextured);\r\n}\r\n\r\nvoid curiosa_tuberculoses(void **murrains_sinologue)\r\n{\r\n ++global_variable;;\r\n urbanest_nontreated(murrains_sinologue);\r\n}\r\n\r\nvoid urbanest_nontreated(void **pseudofamously_saratoga)\r\n{\r\n int child_signal = 0;\r\n int child_pids_count = 21;\r\n pid_t child_pids[21];\r\n pid_t child_pid = -1;\r\n int ii = 0;\r\n int jj = 0;\r\n int algorithms_count = 7;\r\n const char *algorithms[7];\r\n struct pid_fd fd_array[21];\r\n int error = 0;\r\n int index = -1;\r\n char buf;\r\n char *singleness_bihari = 0;\r\n ++global_variable;;\r\n singleness_bihari = ((char *)((char *)( *pseudofamously_saratoga)));\r\n \r\n algorithms[0] = \"MD5\";\r\n algorithms[1] = \"SHA1\";\r\n algorithms[2] = \"SHA224\";\r\n algorithms[3] = \"SHA256\";\r\n algorithms[4] = \"SHA384\";\r\n algorithms[5] = \"SHA512\";\r\n algorithms[6] = \"RIPEMD160\";\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_pids[ii] = -1;\r\n }\r\n if (!error) {\r\n OPENSSL_add_all_algorithms_noconf();\r\n fflush(stdout);\r\n fflush(stdin);\r\n \r\n for (ii = 0; ii < 3; ++ii) {\r\n for (jj = 0; jj < algorithms_count; ++jj) {\r\n index = jj + ii * algorithms_count;\r\n if (pipe(fd_array[index].fd_array) == -1) {\r\n error = 1;\r\n printf(\"Error opening pipe\\n\");\r\n } else {\r\n child_pid = fork();\r\n if (child_pid >= 0) {\r\n if (child_pid == 0) {\r\n close(fd_array[index].fd_array[0]);\r\n dup2(fd_array[index].fd_array[1], STDOUT_FILENO);\r\n \r\n \r\n evp_hash(algorithms[jj], singleness_bihari);\r\n \r\n close(fd_array[index].fd_array[1]);\r\n exit(0);\r\n } else {\r\n close(fd_array[index].fd_array[1]);\r\n fd_array[index].pid = child_pid;\r\n continue;\r\n }\r\n } else {\r\n \r\n printf(\"Failed to fork a child process.\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n }\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_signal = 0;\r\n if (fd_array[ii].pid < 1) {\r\n continue;\r\n }\r\n if (-1 == waitpid(fd_array[ii].pid, &child_signal, 0)) {\r\n \r\n printf(\"Failed to wait for child process: %d\\n\",child_signal);\r\n } else {\r\n if (WIFEXITED(child_signal)) {\r\n printf(\"Child process exited with status: %d\\n\",WEXITSTATUS(child_signal));\r\n } else if (WIFSIGNALED(child_signal)) {\r\n \r\n printf(\"Child process received signal: %d\\n\",WTERMSIG(child_signal));\r\n }\r\n while (read(fd_array[ii].fd_array[0], &buf, 1) > 0) {\r\n printf(\"%c\", buf);\r\n }\r\n close(fd_array[ii].fd_array[0]);\r\n }\r\n }\r\n }\r\n \r\n;\r\n if (((char *)( *pseudofamously_saratoga)) != 0) \r\n free(((char *)((char *)( *pseudofamously_saratoga))));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(!feof(file_stream)) {\n \n memset(file_contents,0,file_contents_size);\n file_contents_size_read = fread(file_contents,\n sizeof(unsigned char ),file_contents_size,file_stream);\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\n if (1 != hash_update_result) {\n break;\n }\n }\n```", "cwe": "400"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint saman_satcitananda = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid abigeus_olyphant(void **tritencephalon_chromate);\r\nunsigned int get_size(char *ss_tainted)\r\n{\r\n \r\n unsigned long uns_int = 0UL;\r\n uns_int = strtoul(ss_tainted,0,0);\r\n if (uns_int > ((unsigned long )4294967295U) ||\r\n uns_int == 0)\r\n uns_int = 1U;\r\n return (unsigned int )uns_int;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n#define JACANA_AGNOLA(x) abigeus_olyphant((void **) x)\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n void **aquamanilia_romeos = 0;\r\n void **fanterie_adducible = 0;\r\n void *tecassir_pall = 0;\r\n int oxtongue_spermatolysis = 11;\r\n char *relationist_unruminatingly;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&saman_satcitananda,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&relationist_unruminatingly,\"4895\",oxtongue_spermatolysis);\r\n if (relationist_unruminatingly != 0) {;\r\n tecassir_pall = ((void *)relationist_unruminatingly);\r\n aquamanilia_romeos = &tecassir_pall;\r\n fanterie_adducible = aquamanilia_romeos + 5;\r\n\tJACANA_AGNOLA(fanterie_adducible);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid abigeus_olyphant(void **tritencephalon_chromate)\r\n{\r\n char *other_buff = 0;\r\n int size = 0;\r\n int num = 0;\r\n char buff[200] = {0};\r\n int output_counter = 0;\r\n char *praetextae_megalosauridae = 0;\r\n ++global_variable;;\r\n praetextae_megalosauridae = ((char *)((char *)( *(tritencephalon_chromate - 5))));\r\n \r\n if (strlen(praetextae_megalosauridae) > 0 &&\r\n praetextae_megalosauridae[0] == '-') {\r\n printf(\"Negative number given as input\\n\");\r\n } else {\r\n \r\n \r\n num = get_size(praetextae_megalosauridae);\r\n other_buff = getenv(\"SS_BUFF\");\r\n \r\n \r\n \r\n if (other_buff != 0) {\r\n strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\r\n size = ((int )(strlen(buff)));\r\n \r\n \r\n while (num < size) {\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n if (num > 0)\r\n ++num;\r\n }\r\n \r\n } else {\r\n printf(\"Missing value for other_buff\\n\");\r\n }\r\n printf(\"finished evaluating\\n\");\r\n }\r\n \r\n;\r\n if (((char *)( *(tritencephalon_chromate - 5))) != 0) \r\n free(((char *)((char *)( *(tritencephalon_chromate - 5)))));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` \n while (num < size) {\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n if (num > 0)\n ++num;\n }\n```", "cwe": "196"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\nint sloths_nonvirtuously = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid paraglossal_propleuron(int pompster_manganate,... );\r\nvoid encrinidae_choriambi(char *complish_orinasality);\r\nvoid insulinizing_uppiles(char *subattenuate_unzip);\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int dongola_usucaptible = 0;\r\n char *aweing_criseyde = 0;\r\n char *seminomas_neurosynapse;;\r\n if (__sync_bool_compare_and_swap(&sloths_nonvirtuously,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n seminomas_neurosynapse = getenv(\"UNENJOYABLENESS_GLUMALES\");\r\n if (seminomas_neurosynapse != 0) {;\r\n dongola_usucaptible = ((int )(strlen(seminomas_neurosynapse)));\r\n aweing_criseyde = ((char *)(malloc(dongola_usucaptible + 1)));\r\n if (aweing_criseyde == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(aweing_criseyde,0,dongola_usucaptible + 1);\r\n memcpy(aweing_criseyde,seminomas_neurosynapse,dongola_usucaptible);\r\n paraglossal_propleuron(1,aweing_criseyde);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid paraglossal_propleuron(int pompster_manganate,... )\r\n{\r\n char *seignories_radiologically = 0;\r\n va_list interleague_nondeductive;\r\n ++global_variable;;\r\n if (pompster_manganate > 0) {\r\n __builtin_va_start(interleague_nondeductive,pompster_manganate);\r\n seignories_radiologically = (va_arg(interleague_nondeductive,char *));\r\n __builtin_va_end(interleague_nondeductive);\r\n }\r\n encrinidae_choriambi(seignories_radiologically);\r\n}\r\n\r\nvoid encrinidae_choriambi(char *complish_orinasality)\r\n{\r\n ++global_variable;;\r\n insulinizing_uppiles(complish_orinasality);\r\n}\r\n\r\nvoid insulinizing_uppiles(char *subattenuate_unzip)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *sanctologist_nonlimitative = 0;\r\n ++global_variable;;\r\n sanctologist_nonlimitative = ((char *)subattenuate_unzip);\r\n \r\n len = strtol(sanctologist_nonlimitative,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (subattenuate_unzip != 0) \r\n free(((char *)subattenuate_unzip));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include </trace.h> \r\nint incomber_imbiber = 0;\r\nint global_variable;\r\n\r\nunion hypsodonty_witess \r\n{\r\n char *predescend_conciator;\r\n double mordecai_allhallows;\r\n char *sarcolemmata_sporophyll;\r\n char conceptualistic_temperish;\r\n int deallocation_midwest;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid crookbilled_annalee(union hypsodonty_witess *mirroring_nonliability);\r\nint 190_global_var = 0;\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n#define CONTEXTURED_VAGALLY(x) crookbilled_annalee((union hypsodonty_witess *) x)\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int gilbertown_insweeping;\r\n union hypsodonty_witess *uredosporous_joey = {0};\r\n union hypsodonty_witess *incomplete_staid = {0};\r\n union hypsodonty_witess paratitles_sertule;\r\n char *antimodernness_concents;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&incomber_imbiber,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&antimodernness_concents,\"WARNINGPROOF_VASTEST\");\r\n if (antimodernness_concents != 0) {;\r\n paratitles_sertule . predescend_conciator = antimodernness_concents;\r\n gilbertown_insweeping = 1;\r\n uredosporous_joey = &paratitles_sertule;\r\n incomplete_staid = ((union hypsodonty_witess *)(((unsigned long )uredosporous_joey) * gilbertown_insweeping * gilbertown_insweeping)) + 5;\r\n\tCONTEXTURED_VAGALLY(incomplete_staid);\r\n }\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nvoid crookbilled_annalee(union hypsodonty_witess *mirroring_nonliability)\r\n{\r\n int tainted_int = 0;\r\n int output_counter = 0;\r\n char *worrit_osse = 0;\r\n ++global_variable;;\r\n worrit_osse = ((char *)( *(mirroring_nonliability - 5)) . predescend_conciator);\r\n \r\n tainted_int = atoi(worrit_osse);\r\n if (tainted_int > 0) {\r\n \r\n\r\n tainted_int = tainted_int * tainted_int;\r\n \r\n \r\n \r\n while (tainted_int != 0) {\r\n\r\n if (tainted_int != INT_MIN) {\r\n tainted_int--;\r\n }\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n ++190_global_var;\r\n if (190_global_var >= INT_MAX) {\r\n 190_global_var = 0;\r\n }\r\n }\r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\n if (( *(mirroring_nonliability - 5)) . predescend_conciator != 0) \r\n free(((char *)( *(mirroring_nonliability - 5)) . predescend_conciator));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while (tainted_int != 0) {\n\n if (tainted_int != INT_MIN) {\n tainted_int--;\n }\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n ++190_global_var;\n if (190_global_var >= INT_MAX) {\n 190_global_var = 0;\n }\n }\n```", "cwe": "190"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint freezingly_telephotography = 0;\r\n\r\nstruct christiansen_wampums \r\n{\r\n char *vikky_alada;\r\n double amidate_brokeress;\r\n char *unsack_tampoy;\r\n char scalades_phantasmagories;\r\n int enfilading_mouille;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int i = 0;\r\n int opt_var;\r\n char *heap_buffer_64 = 0;\r\n char *etiam_whitey = 0;\r\n struct christiansen_wampums *ungreased_fleuret = {0};\r\n struct christiansen_wampums *subcurate_divulsing = {0};\r\n struct christiansen_wampums berhymes_dishware;\r\n int perrin_mackinac = 596;\r\n char *adumbrations_bathycolpian;;\r\n if (__sync_bool_compare_and_swap(&freezingly_telephotography,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&adumbrations_bathycolpian,\"7292\",perrin_mackinac);\r\n if (adumbrations_bathycolpian != 0) {;\r\n berhymes_dishware . vikky_alada = ((char *)adumbrations_bathycolpian);\r\n ungreased_fleuret = &berhymes_dishware;\r\n subcurate_divulsing = ungreased_fleuret + 5;\r\n etiam_whitey = ((char *)( *(subcurate_divulsing - 5)) . vikky_alada);\r\n \r\n heap_buffer_64 = (char*) malloc(64 * sizeof(char));\r\n if (heap_buffer_64 != NULL) {\r\n memset(heap_buffer_64,0,64);\r\n \r\n \r\n \r\n \r\n \r\n \r\n strcpy(heap_buffer_64, etiam_whitey);\r\n \r\n \r\n \r\n opt_var = strlen( heap_buffer_64);\r\n \r\n for (; i < opt_var; ++i) {\r\n heap_buffer_64[i] = toupper(heap_buffer_64[i]);\r\n }\r\n \r\n \r\n \r\n printf(\"%s\\n\",heap_buffer_64);\r\n free(heap_buffer_64);\r\n \r\n \r\n \r\n }\r\n;\r\n if (( *(subcurate_divulsing - 5)) . vikky_alada != 0) \r\n free(((char *)( *(subcurate_divulsing - 5)) . vikky_alada));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n }\n;\n if (( *(subcurate_divulsing - 5)) . vikky_alada != 0) \n free(((char *)( *(subcurate_divulsing - 5)) . vikky_alada));\nclose_printf_context();\n }\n }\n }\n ;\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\n int i;\n unsigned int size;\n uint8_t *p;\n p = pkt -> data + pkt -> size - 8 - 5;\n for (i = 1; ; i++) {\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\n if (size > 2147483647 || p - pkt -> data < size) {\n return 0;\n }\n if (p[4] & 128) {\n break; \n }\n p -= size + 5;\n }\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\n if (!pkt -> side_data) {\n return - 12;\n }\n p = pkt -> data + pkt -> size - 8 - 5;\n for (i = 0; ; i++) {\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\n do {\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\n abort();\n }\n }while (0);\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\n pkt -> side_data[i] . size = size;\n pkt -> side_data[i] . type = (p[4] & 127);\n if (!pkt -> side_data[i] . data) {\n return - 12;\n }\n memcpy(pkt -> side_data[i] . data,(p - size),size);\n pkt -> size -= size + 5;\n if (p[4] & 128) {\n break; \n }\n p -= size + 5;\n }\n pkt -> size -= 8;\n pkt -> side_data_elems = i + 1;\n return 1;\n }\n return 0;\n}\n\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\n{\n int i;\n for (i = 0; i < pkt -> side_data_elems; i++) {\n if (pkt -> side_data[i] . type == type) {\n if (size > pkt -> side_data[i] . size) {\n return - 12;\n }\n pkt -> side_data[i] . size = size;\n return 0;\n }\n }\n return - 2;\n```", "cwe": "120"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint futz_quinitol = 0;\r\n\r\nstruct sniffable_working \r\n{\r\n char *swagger_unporousness;\r\n double hydatina_gastronomies;\r\n char *shoq_acy;\r\n char factitively_skirling;\r\n int predisposition_neighbour;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *lunarium_rubie);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct sniffable_working phaethonic_tilton(struct sniffable_working contribution_swigart);\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&futz_quinitol,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid handle_taint(char *lunarium_rubie)\r\n{\r\n FILE *csv = 0;\r\n FILE *temp = 0;\r\n char col1[80] = {0};\r\n char col2[80] = {0};\r\n char col3[80] = {0};\r\n char *cols[3] = {0};\r\n char *sciroccos_nonelliptic = 0;\r\n jmp_buf shroffed_unrelieved;\r\n int addis_anilinophile;\r\n struct sniffable_working mammifera_undeviable = {0};\r\n struct sniffable_working ancodont_dipware;\r\n ++global_variable;;\r\n if (lunarium_rubie != 0) {;\r\n ancodont_dipware . swagger_unporousness = ((char *)lunarium_rubie);\r\n mammifera_undeviable = phaethonic_tilton(ancodont_dipware);\r\n addis_anilinophile = setjmp(shroffed_unrelieved);\r\n if (addis_anilinophile == 0) {\r\n longjmp(shroffed_unrelieved,1);\r\n }\r\n sciroccos_nonelliptic = ((char *)mammifera_undeviable . swagger_unporousness);\r\n \r\n \r\n csv = fopen(sciroccos_nonelliptic,\"r\");\r\n if (csv != 0) {\r\n \r\n\r\n fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\r\n \r\n \r\n \r\n \r\n if (strlen(col1) > 0)\r\n cols[0] = col1;\r\n if (strlen(col2) > 0)\r\n cols[1] = col2;\r\n if (strlen(col3) > 0)\r\n cols[2] = col3;\r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n\r\n printf(\"VALUES=\\\"\");\r\n fputs(cols[0],temp);\r\n printf(cols[0]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[1],temp);\r\n printf(cols[1]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[2],temp);\r\n printf(cols[2]);\r\n \r\n printf(\"\\\"\\n\");\r\n fclose(temp);\r\n }\r\n }\r\n \r\n;\r\n if (mammifera_undeviable . swagger_unporousness != 0) \r\n free(((char *)mammifera_undeviable . swagger_unporousness));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nstruct sniffable_working phaethonic_tilton(struct sniffable_working contribution_swigart)\r\n{\r\n ++global_variable;\r\n return contribution_swigart;\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "```\n printf(\"VALUES=\\\"\");\n fputs(cols[0],temp);\n printf(cols[0]);\n printf(\"\\\",\\\"\");\n fputs(cols[1],temp);\n printf(cols[1]);\n printf(\"\\\",\\\"\");\n fputs(cols[2],temp);\n printf(cols[2]);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\nint peltigeraceae_anticompetitive = 0;\r\nint global_variable;\r\nvoid handle_taint(char *asz_aimlessnesses);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid omnirevealing_perfectionizer(char *endsweep_beetlers);\r\nvoid playward_abstrahent(char *coni_algivorous);\r\nvoid limnaea_enlargedness(char *kunmiut_anteversion);\r\nvoid offshoots_baronnes(char *fasciate_asopus);\r\nvoid commorth_repermit(char *electrostatics_englebert);\r\nvoid premen_spoolwood(char *defeminize_oversocializing);\r\nvoid blackberrylike_skydivers(char *photomagnetism_polemical);\r\nvoid boobies_cimbri(char *pestify_uniparient);\r\nvoid ignorantness_stoneworks(char *hitachi_undangerously);\r\nvoid enjoiners_krogh(char *deadlihead_unindigenous);\r\nvoid destructors_breacher(char *slipshoddiness_stinson);\r\nvoid sere_breviate(char *unconcatenated_unsuppressive);\r\nvoid slovenliness_autotetraploidy(char *fungia_archbishopry);\r\nvoid flopping_humorless(char *alectorides_trapstick);\r\nvoid pythia_antitypically(char *zoologic_octans);\r\nvoid bangwaketsi_autodigestive(char *footstone_phloretic);\r\nvoid uncriticisingly_socinian(char *quinquina_superminis);\r\nvoid gallies_unwilfulness(char *andorra_pesetas);\r\nvoid peevishness_handicaps(char *glandless_immaneness);\r\nvoid roygbiv_flypast(char *premention_exulted);\r\nvoid olpae_belong(char *chatting_potboiling);\r\nvoid freeze_overtechnical(char *downrightness_delimiting);\r\nvoid bobooti_pycnogonidium(char *mitterrand_bohlen);\r\nvoid enlister_hecuba(char *cleannesses_abelonian);\r\nvoid odoriferosity_glacialism(char *keratinoid_heyday);\r\nvoid fidele_preinflectional(char *nonevasively_anchusins);\r\nvoid motherer_bespattered(char *antiracer_wfpcii);\r\nvoid creedon_daltonism(char *harelda_irritate);\r\nvoid squirmers_shulwar(char *tramlines_lappaceous);\r\nvoid estatesman_agneaux(char *gobos_fustics);\r\nvoid ethicoaesthetic_romane(char *absampere_murtherer);\r\nvoid plea_befavour(char *viscerosomatic_scotino);\r\nvoid zuisin_newelty(char *wettable_mullites);\r\nvoid cradleside_clarts(char *seko_wisha);\r\nvoid postclavicula_kodurite(char *preadults_enterozoon);\r\nvoid photoelectronic_stegosaurian(char *parastemonal_emanating);\r\nvoid overnice_strengthfulness(char *maltalent_disorganizing);\r\nvoid operatively_theistical(char *pachyntic_interarrival);\r\nvoid punkiness_progrede(char *garnisheing_thereright);\r\nvoid sinarquist_execrations(char *withdraw_sailable);\r\nvoid dizzyingly_deer(char *plt_lienopancreatic);\r\nvoid reputed_oiw(char *prognoses_reviser);\r\nvoid pothole_notabilities(char *capiases_fardo);\r\nvoid wakerife_hormigo(char *urushiol_harkener);\r\nvoid metrical_vicecomites(char *alodies_passifloraceous);\r\nvoid coleridgian_frust(char *crownsville_promise);\r\nvoid intertillage_embarricado(char *semifiction_spinnerette);\r\nvoid pseudorandom_zoophaga(char *cladophyll_overinfluential);\r\nvoid fantasying_maught(char *stats_causeways);\r\nvoid allys_falerno(char *rejoining_presumers);\r\nstruct list {\r\n int data;\r\n struct list *previous;\r\n struct list *next;\r\n};\r\nstruct queue {\r\n pthread_mutex_t lock;\r\n pthread_cond_t is_empty;\r\n pthread_cond_t is_full;\r\n int size;\r\n int capacity;\r\n struct list *head;\r\n struct list *tail;\r\n};\r\nstruct data {\r\n int qsize;\r\n int data;\r\n char* file1;\r\n char* file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nint enqueue(struct queue *ssQ, int data) {\r\n int rtnval = 0;\r\n if (ssQ != NULL) {\r\n struct list *elem = malloc(sizeof(struct list));\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size >= ssQ->capacity) {\r\n pthread_cond_wait(&(ssQ->is_full), &(ssQ->lock));\r\n }\r\n elem->next = NULL;\r\n elem->previous = ssQ->tail;\r\n elem->data = data;\r\n if (ssQ->tail != NULL) {\r\n ssQ->tail->next = elem;\r\n }\r\n ssQ->tail = elem;\r\n ssQ->size++;\r\n if (ssQ->head == NULL) {\r\n ssQ->head = elem;\r\n }\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_empty));\r\n }\r\n else {\r\n rtnval = -1;\r\n }\r\n return rtnval;\r\n}\r\nint dequeue(struct queue *ssQ) {\r\n int val = -1;\r\n if (ssQ != NULL) {\r\n struct list *elem;\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size <= 0) {\r\n pthread_cond_wait(&(ssQ->is_empty), &(ssQ->lock));\r\n }\r\n elem = ssQ->head;\r\n ssQ->head = elem->next;\r\n if(ssQ->head != NULL) {\r\n ssQ->head->previous = NULL;\r\n }\r\n else {\r\n ssQ->tail = NULL;\r\n }\r\n val = elem->data;\r\n ssQ->size--;\r\n free(elem);\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_full));\r\n }\r\n return val;\r\n}\r\nstruct queue *get_instance (char* file2) {\r\n static struct queue *ssQ = NULL;\r\n \r\n \r\n \r\n if (ssQ == NULL) {\r\n if (file2 != NULL) {\r\n readFile(file2);\r\n }\r\n ssQ = (struct queue *)calloc(1, sizeof(struct queue));\r\n pthread_mutex_init(&(ssQ->lock), NULL);\r\n pthread_cond_init(&(ssQ->is_empty), NULL);\r\n pthread_cond_init(&(ssQ->is_full), NULL);\r\n ssQ->size = 0;\r\n ssQ->capacity = 30;\r\n ssQ->head = NULL;\r\n ssQ->tail = NULL;\r\n }\r\n \r\n \r\n return ssQ;\r\n}\r\nvoid *print_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ = get_instance(ssD->file2);\r\n int i;\r\n \r\n \r\n \r\n while ((i = dequeue(ssQ)) != -1) {\r\n printf(\"Data: %d\\n\", i);\r\n }\r\n \r\n return NULL;\r\n}\r\nvoid *calc_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ;\r\n int *qsort_arr;\r\n int i;\r\n \r\n qsort_arr = malloc(sizeof(int)*ssD->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < ssD->qsize; i++) {\r\n qsort_arr[i] = ssD->qsize - i;\r\n }\r\n qsort(qsort_arr, ssD->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(ssD->file1);\r\n ssQ = get_instance(NULL);\r\n \r\n for (i = 0; i < ssD->data; i++) {\r\n \r\n if (enqueue(ssQ, i) == -1) {\r\n break;\r\n }\r\n }\r\n enqueue(ssQ, -1);\r\n \r\n return NULL;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&peltigeraceae_anticompetitive,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *asz_aimlessnesses)\r\n{\r\n int sacristans_surprisingness = 0;\r\n char *unnibbied_chassin = 0;\r\n ++global_variable;;\r\n if (asz_aimlessnesses != 0) {;\r\n sacristans_surprisingness = ((int )(strlen(asz_aimlessnesses)));\r\n unnibbied_chassin = ((char *)(malloc(sacristans_surprisingness + 1)));\r\n if (unnibbied_chassin == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(unnibbied_chassin,0,sacristans_surprisingness + 1);\r\n memcpy(unnibbied_chassin,asz_aimlessnesses,sacristans_surprisingness);\r\n if (asz_aimlessnesses != 0) \r\n free(((char *)asz_aimlessnesses));\r\n omnirevealing_perfectionizer(unnibbied_chassin);\r\n }\r\n}\r\n\r\nvoid omnirevealing_perfectionizer(char *endsweep_beetlers)\r\n{\r\n ++global_variable;;\r\n playward_abstrahent(endsweep_beetlers);\r\n}\r\n\r\nvoid playward_abstrahent(char *coni_algivorous)\r\n{\r\n ++global_variable;;\r\n limnaea_enlargedness(coni_algivorous);\r\n}\r\n\r\nvoid limnaea_enlargedness(char *kunmiut_anteversion)\r\n{\r\n ++global_variable;;\r\n offshoots_baronnes(kunmiut_anteversion);\r\n}\r\n\r\nvoid offshoots_baronnes(char *fasciate_asopus)\r\n{\r\n ++global_variable;;\r\n commorth_repermit(fasciate_asopus);\r\n}\r\n\r\nvoid commorth_repermit(char *electrostatics_englebert)\r\n{\r\n ++global_variable;;\r\n premen_spoolwood(electrostatics_englebert);\r\n}\r\n\r\nvoid premen_spoolwood(char *defeminize_oversocializing)\r\n{\r\n ++global_variable;;\r\n blackberrylike_skydivers(defeminize_oversocializing);\r\n}\r\n\r\nvoid blackberrylike_skydivers(char *photomagnetism_polemical)\r\n{\r\n ++global_variable;;\r\n boobies_cimbri(photomagnetism_polemical);\r\n}\r\n\r\nvoid boobies_cimbri(char *pestify_uniparient)\r\n{\r\n ++global_variable;;\r\n ignorantness_stoneworks(pestify_uniparient);\r\n}\r\n\r\nvoid ignorantness_stoneworks(char *hitachi_undangerously)\r\n{\r\n ++global_variable;;\r\n enjoiners_krogh(hitachi_undangerously);\r\n}\r\n\r\nvoid enjoiners_krogh(char *deadlihead_unindigenous)\r\n{\r\n ++global_variable;;\r\n destructors_breacher(deadlihead_unindigenous);\r\n}\r\n\r\nvoid destructors_breacher(char *slipshoddiness_stinson)\r\n{\r\n ++global_variable;;\r\n sere_breviate(slipshoddiness_stinson);\r\n}\r\n\r\nvoid sere_breviate(char *unconcatenated_unsuppressive)\r\n{\r\n ++global_variable;;\r\n slovenliness_autotetraploidy(unconcatenated_unsuppressive);\r\n}\r\n\r\nvoid slovenliness_autotetraploidy(char *fungia_archbishopry)\r\n{\r\n ++global_variable;;\r\n flopping_humorless(fungia_archbishopry);\r\n}\r\n\r\nvoid flopping_humorless(char *alectorides_trapstick)\r\n{\r\n ++global_variable;;\r\n pythia_antitypically(alectorides_trapstick);\r\n}\r\n\r\nvoid pythia_antitypically(char *zoologic_octans)\r\n{\r\n ++global_variable;;\r\n bangwaketsi_autodigestive(zoologic_octans);\r\n}\r\n\r\nvoid bangwaketsi_autodigestive(char *footstone_phloretic)\r\n{\r\n ++global_variable;;\r\n uncriticisingly_socinian(footstone_phloretic);\r\n}\r\n\r\nvoid uncriticisingly_socinian(char *quinquina_superminis)\r\n{\r\n ++global_variable;;\r\n gallies_unwilfulness(quinquina_superminis);\r\n}\r\n\r\nvoid gallies_unwilfulness(char *andorra_pesetas)\r\n{\r\n ++global_variable;;\r\n peevishness_handicaps(andorra_pesetas);\r\n}\r\n\r\nvoid peevishness_handicaps(char *glandless_immaneness)\r\n{\r\n ++global_variable;;\r\n roygbiv_flypast(glandless_immaneness);\r\n}\r\n\r\nvoid roygbiv_flypast(char *premention_exulted)\r\n{\r\n ++global_variable;;\r\n olpae_belong(premention_exulted);\r\n}\r\n\r\nvoid olpae_belong(char *chatting_potboiling)\r\n{\r\n ++global_variable;;\r\n freeze_overtechnical(chatting_potboiling);\r\n}\r\n\r\nvoid freeze_overtechnical(char *downrightness_delimiting)\r\n{\r\n ++global_variable;;\r\n bobooti_pycnogonidium(downrightness_delimiting);\r\n}\r\n\r\nvoid bobooti_pycnogonidium(char *mitterrand_bohlen)\r\n{\r\n ++global_variable;;\r\n enlister_hecuba(mitterrand_bohlen);\r\n}\r\n\r\nvoid enlister_hecuba(char *cleannesses_abelonian)\r\n{\r\n ++global_variable;;\r\n odoriferosity_glacialism(cleannesses_abelonian);\r\n}\r\n\r\nvoid odoriferosity_glacialism(char *keratinoid_heyday)\r\n{\r\n ++global_variable;;\r\n fidele_preinflectional(keratinoid_heyday);\r\n}\r\n\r\nvoid fidele_preinflectional(char *nonevasively_anchusins)\r\n{\r\n ++global_variable;;\r\n motherer_bespattered(nonevasively_anchusins);\r\n}\r\n\r\nvoid motherer_bespattered(char *antiracer_wfpcii)\r\n{\r\n ++global_variable;;\r\n creedon_daltonism(antiracer_wfpcii);\r\n}\r\n\r\nvoid creedon_daltonism(char *harelda_irritate)\r\n{\r\n ++global_variable;;\r\n squirmers_shulwar(harelda_irritate);\r\n}\r\n\r\nvoid squirmers_shulwar(char *tramlines_lappaceous)\r\n{\r\n ++global_variable;;\r\n estatesman_agneaux(tramlines_lappaceous);\r\n}\r\n\r\nvoid estatesman_agneaux(char *gobos_fustics)\r\n{\r\n ++global_variable;;\r\n ethicoaesthetic_romane(gobos_fustics);\r\n}\r\n\r\nvoid ethicoaesthetic_romane(char *absampere_murtherer)\r\n{\r\n ++global_variable;;\r\n plea_befavour(absampere_murtherer);\r\n}\r\n\r\nvoid plea_befavour(char *viscerosomatic_scotino)\r\n{\r\n ++global_variable;;\r\n zuisin_newelty(viscerosomatic_scotino);\r\n}\r\n\r\nvoid zuisin_newelty(char *wettable_mullites)\r\n{\r\n ++global_variable;;\r\n cradleside_clarts(wettable_mullites);\r\n}\r\n\r\nvoid cradleside_clarts(char *seko_wisha)\r\n{\r\n ++global_variable;;\r\n postclavicula_kodurite(seko_wisha);\r\n}\r\n\r\nvoid postclavicula_kodurite(char *preadults_enterozoon)\r\n{\r\n ++global_variable;;\r\n photoelectronic_stegosaurian(preadults_enterozoon);\r\n}\r\n\r\nvoid photoelectronic_stegosaurian(char *parastemonal_emanating)\r\n{\r\n ++global_variable;;\r\n overnice_strengthfulness(parastemonal_emanating);\r\n}\r\n\r\nvoid overnice_strengthfulness(char *maltalent_disorganizing)\r\n{\r\n ++global_variable;;\r\n operatively_theistical(maltalent_disorganizing);\r\n}\r\n\r\nvoid operatively_theistical(char *pachyntic_interarrival)\r\n{\r\n ++global_variable;;\r\n punkiness_progrede(pachyntic_interarrival);\r\n}\r\n\r\nvoid punkiness_progrede(char *garnisheing_thereright)\r\n{\r\n ++global_variable;;\r\n sinarquist_execrations(garnisheing_thereright);\r\n}\r\n\r\nvoid sinarquist_execrations(char *withdraw_sailable)\r\n{\r\n ++global_variable;;\r\n dizzyingly_deer(withdraw_sailable);\r\n}\r\n\r\nvoid dizzyingly_deer(char *plt_lienopancreatic)\r\n{\r\n ++global_variable;;\r\n reputed_oiw(plt_lienopancreatic);\r\n}\r\n\r\nvoid reputed_oiw(char *prognoses_reviser)\r\n{\r\n ++global_variable;;\r\n pothole_notabilities(prognoses_reviser);\r\n}\r\n\r\nvoid pothole_notabilities(char *capiases_fardo)\r\n{\r\n ++global_variable;;\r\n wakerife_hormigo(capiases_fardo);\r\n}\r\n\r\nvoid wakerife_hormigo(char *urushiol_harkener)\r\n{\r\n ++global_variable;;\r\n metrical_vicecomites(urushiol_harkener);\r\n}\r\n\r\nvoid metrical_vicecomites(char *alodies_passifloraceous)\r\n{\r\n ++global_variable;;\r\n coleridgian_frust(alodies_passifloraceous);\r\n}\r\n\r\nvoid coleridgian_frust(char *crownsville_promise)\r\n{\r\n ++global_variable;;\r\n intertillage_embarricado(crownsville_promise);\r\n}\r\n\r\nvoid intertillage_embarricado(char *semifiction_spinnerette)\r\n{\r\n ++global_variable;;\r\n pseudorandom_zoophaga(semifiction_spinnerette);\r\n}\r\n\r\nvoid pseudorandom_zoophaga(char *cladophyll_overinfluential)\r\n{\r\n ++global_variable;;\r\n fantasying_maught(cladophyll_overinfluential);\r\n}\r\n\r\nvoid fantasying_maught(char *stats_causeways)\r\n{\r\n ++global_variable;;\r\n allys_falerno(stats_causeways);\r\n}\r\n\r\nvoid allys_falerno(char *rejoining_presumers)\r\n{\r\n pthread_t t0, t1;\r\n struct data* Data;\r\n char *ordovician_goll = 0;\r\n ++global_variable;;\r\n ordovician_goll = ((char *)rejoining_presumers);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->file1 = malloc(sizeof(char) * (strlen(ordovician_goll) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(ordovician_goll) + 1));\r\n if ((sscanf(ordovician_goll, \"%d %s %s %d\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n &(Data->data)) == 4) &&\r\n Data->qsize >= 0 &&\r\n Data->data >= 0 &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, calc_data, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (pthread_create(&t1, NULL, print_data, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->file1);\r\n free(Data->file2);\r\n free(Data);\r\n }\r\n \r\n;\r\n if (rejoining_presumers != 0) \r\n free(((char *)rejoining_presumers));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while ((i = dequeue(ssQ)) != -1) {\n printf(\"Data: %d\\n\", i);\n }\n```", "cwe": "543"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint aswithe_hithermost = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid undoubtable_fluids(int radon_stovepipe,... );\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n char *jailish_ichthyosism[53] = {0};\r\n char *bodiliness_marva;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&aswithe_hithermost,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n bodiliness_marva = getenv(\"HIANAKOTO_ANAMNESES\");\r\n if (bodiliness_marva != 0) {;\r\n jailish_ichthyosism[39] = bodiliness_marva;\r\n undoubtable_fluids(1,jailish_ichthyosism);\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid undoubtable_fluids(int radon_stovepipe,... )\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *megnetosphere_mylan = 0;\r\n int unsensitize_oleo;\r\n int lamech_swoopers;\r\n char **aubree_frouze = 0;\r\n va_list mikrkra_melamdim;\r\n ++global_variable;;\r\n if (radon_stovepipe > 0) {\r\n __builtin_va_start(mikrkra_melamdim,radon_stovepipe);\r\n aubree_frouze = (va_arg(mikrkra_melamdim,char **));\r\n __builtin_va_end(mikrkra_melamdim);\r\n }\r\n lamech_swoopers = 5;\r\n while(1 == 1){\r\n lamech_swoopers = lamech_swoopers * 2;\r\n lamech_swoopers = lamech_swoopers + 2;\r\n if (lamech_swoopers > 1000) {\r\n break; \r\n }\r\n }\r\n unsensitize_oleo = lamech_swoopers;\r\n megnetosphere_mylan = ((char *)aubree_frouze[39]);\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(megnetosphere_mylan); ++i) {\r\n if (megnetosphere_mylan[i] == ';') {\r\n if (i == 0 || megnetosphere_mylan[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,megnetosphere_mylan);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <unistd.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint nonextendible_backslided = 0;\r\nint global_variable;\r\nvoid buddhi_autosauri(void **placodermal_discontinuer);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid temerate_waste(void (*adenogenous_debs)(void **));\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n \r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForChange(char* file, char* sleepFile) {\r\n int fd;\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForChange\\n\");\r\n strcat(filename, file);\r\n strcat(filename, \".pid\");\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nint path_is_relative(char *path) {\r\n char *chr = 0;\r\n \r\n chr = strchr(path,'/');\r\n if (chr == 0) {\r\n \r\n printf(\"Path is relative\\n\");\r\n return 1;\r\n } else {\r\n \r\n printf(\"Path is not relative\\n\");\r\n return 0;\r\n }\r\n}\r\nchar * get_absolute_path(char * path) {\r\n char * abs_path = malloc (sizeof(char) * (strlen(\"/opt//workspace/testData/\") * strlen(path) + 1));\r\n \r\n if (abs_path == NULL) {\r\n printf(\"Cannot allocate memory for path\\n\");\r\n } else {\r\n printf(\"Creating absolute path\\n\");\r\n strcpy(abs_path, \"/opt//workspace/testData/\");\r\n strcat(abs_path, path);\r\n }\r\n return abs_path;\r\n}\r\nint isSymLink(char *file) {\r\n struct stat statbuf;\r\n \r\n if (lstat(file, &statbuf) < 0) { \r\n printf(\"Error accessing path.\\n\");\r\n return 1; \r\n }\r\n if (S_ISLNK(statbuf.st_mode) == 1) {\r\n printf(\"Path is symlink.\\n\");\r\n return 1;\r\n }\r\n printf(\"Path is valid.\\n\");\r\n return 0;\r\n}\r\nint path_is_not_symlink(char * abs_path) {\r\n \r\n return (isSymLink(abs_path) == 0);\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&nonextendible_backslided,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n temerate_waste(buddhi_autosauri);\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid buddhi_autosauri(void **placodermal_discontinuer)\r\n{\r\n void *earthwards_togalike = 0;\r\n int empiry_overconstant = 50;\r\n char *gerundial_saucerize;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&gerundial_saucerize,\"6303\",empiry_overconstant);\r\n if (gerundial_saucerize != 0) {;\r\n earthwards_togalike = ((void *)gerundial_saucerize);\r\n *placodermal_discontinuer = earthwards_togalike;\r\n }\r\n}\r\n\r\nvoid temerate_waste(void (*adenogenous_debs)(void **))\r\n{\r\n int size = 0;\r\n FILE *file = 0;\r\n char *buffer = 0;\r\n char *str = 0;\r\n char *abs_path = 0;\r\n char *sleep_file = 0;\r\n char *constringe_basely = 0;\r\n void *gasser_comprized = 0;\r\n int **lituus_posse = 0;\r\n int *missioner_incavo = 0;\r\n int mudcap_haven;\r\n void *elul_pavestone[10] = {0};\r\n ++global_variable;\r\n void *sillabub_mendelejeff = 0;\r\n adenogenous_debs(&sillabub_mendelejeff);\r\n if (((char *)sillabub_mendelejeff) != 0) {;\r\n mudcap_haven = 5;\r\n missioner_incavo = &mudcap_haven;\r\n lituus_posse = &missioner_incavo;\r\n elul_pavestone[ *( *lituus_posse)] = sillabub_mendelejeff;\r\n gasser_comprized = elul_pavestone[ *( *lituus_posse)];\r\n constringe_basely = ((char *)((char *)gasser_comprized));\r\n \r\n str = malloc(sizeof(char) * (strlen(constringe_basely) + 1));\r\n sleep_file = malloc(sizeof(char) * (strlen(constringe_basely) + 1));\r\n if (str != NULL && sleep_file != NULL &&\r\n (sscanf(constringe_basely, \"%s %s\",\r\n sleep_file,\r\n str) == 2) &&\r\n (strlen(str) != 0) &&\r\n (strlen(sleep_file) != 0))\r\n {\r\n \r\n \r\n if (path_is_relative(str)) {\r\n abs_path = get_absolute_path(str);\r\n if (abs_path != NULL) {\r\n if (path_is_not_symlink(abs_path)) {\r\n \r\n \r\n waitForChange(abs_path, sleep_file);\r\n file = fopen(abs_path,\"rb\");\r\n \r\n if (file != 0) {\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\r\n if (buffer) {\r\n \r\n \r\n fread(buffer,sizeof(char ),size,file);\r\n buffer[size] = '\\0';\r\n printf(buffer);\r\n fclose(file);\r\n free(buffer);\r\n \r\n }\r\n }\r\n }\r\n free (abs_path);\r\n }\r\n }\r\n free(str);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n;\r\n if (((char *)gasser_comprized) != 0) \r\n free(((char *)((char *)gasser_comprized)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fread(buffer,sizeof(char ),size,file);\n buffer[size] = '\\0';\n printf(buffer);\n fclose(file);\n free(buffer);\n```", "cwe": "363"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint myoclonic_jinx = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid colourtype_oversnow(int hemmers_impassibleness,void *gnaphalium_multum);\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n int irenic_trierarchic = 7;\r\n void *hostiley_decertation = 0;\r\n long tophetic_wellat[10];\r\n void *padishah_crfc[10] = {0};\r\n void *wildwoods_haff = 0;\r\n char *guaiacs_nonliable;;\r\n if (__sync_bool_compare_and_swap(&myoclonic_jinx,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n guaiacs_nonliable = getenv(\"EXPONIBLE_AMPHIGAEA\");\r\n if (guaiacs_nonliable != 0) {;\r\n wildwoods_haff = ((void *)guaiacs_nonliable);\r\n padishah_crfc[5] = wildwoods_haff;\r\n tophetic_wellat[1] = 5;\r\n hostiley_decertation = *(padishah_crfc + tophetic_wellat[1]);\r\n colourtype_oversnow(irenic_trierarchic,hostiley_decertation);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid colourtype_oversnow(int hemmers_impassibleness,void *gnaphalium_multum)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *lapponian_overintensity = 0;\r\n ++global_variable;\r\n hemmers_impassibleness--;\r\n if (hemmers_impassibleness > 0) {\r\n colourtype_oversnow(hemmers_impassibleness,gnaphalium_multum);\r\n return ;\r\n }\r\n lapponian_overintensity = ((char *)((char *)gnaphalium_multum));\r\n \r\n len = strtol(lapponian_overintensity,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint chevrotin_vesicofixation = 0;\r\nint global_variable;\r\nvoid handle_taint(char *indoctrinator_blackhead);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid caputto_waymaker(char **loupen_unsuperiorly);\r\nvoid bespattered_kinematically(char **espichellite_theriomorph);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&chevrotin_vesicofixation,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *indoctrinator_blackhead)\r\n{\r\n int nonconversancy_beclowned;\r\n char **gaspy_wagener = 0;\r\n char **shabbiest_reymont = 0;\r\n char *unegally_novellike[88] = {0};\r\n ++global_variable;;\r\n if (indoctrinator_blackhead != 0) {;\r\n unegally_novellike[49] = indoctrinator_blackhead;\r\n nonconversancy_beclowned = 1;\r\n gaspy_wagener = unegally_novellike;\r\n shabbiest_reymont = ((char **)(((unsigned long )gaspy_wagener) * nonconversancy_beclowned * nonconversancy_beclowned)) + 5;\r\n caputto_waymaker(shabbiest_reymont);\r\n }\r\n}\r\n\r\nvoid caputto_waymaker(char **loupen_unsuperiorly)\r\n{\r\n ++global_variable;;\r\n bespattered_kinematically(loupen_unsuperiorly);\r\n}\r\n\r\nvoid bespattered_kinematically(char **espichellite_theriomorph)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *spraith_galatae = 0;\r\n ++global_variable;;\r\n spraith_galatae = ((char *)(espichellite_theriomorph - 5)[49]);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(spraith_galatae) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (spraith_galatae[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &spraith_galatae[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\n if ((espichellite_theriomorph - 5)[49] != 0) \r\n free(((char *)(espichellite_theriomorph - 5)[49]));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint braves_inpardonable = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid polysemant_unhid(char *const nonexpanded_waynant);\r\nint contains_char(char *str_param,char c_param)\r\n{\r\n \r\n int function_found;\r\n function_found = 0;\r\n \r\n \r\n\r\n while( *str_param != 0){\r\n if ( *str_param == c_param) {\r\n function_found = 1;\r\n break;\r\n }\r\n str_param = str_param + 1;\r\n }\r\n \r\n \r\n \r\n\r\n free(str_param);\r\n \r\n return function_found;\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int watchmake_ureterolysis = 0;\r\n char *mellisugent_saccule = 0;\r\n char *groveling_heliotropine;\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&braves_inpardonable,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&groveling_heliotropine,\"PSEUDOMILITARY_SKEINED\");\r\n if (groveling_heliotropine != 0) {;\r\n watchmake_ureterolysis = ((int )(strlen(groveling_heliotropine)));\r\n mellisugent_saccule = ((char *)(malloc(watchmake_ureterolysis + 1)));\r\n if (mellisugent_saccule == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(mellisugent_saccule,0,watchmake_ureterolysis + 1);\r\n memcpy(mellisugent_saccule,groveling_heliotropine,watchmake_ureterolysis);\r\n if (groveling_heliotropine != 0) \r\n free(((char *)groveling_heliotropine));\r\n polysemant_unhid(mellisugent_saccule);\r\n }\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid polysemant_unhid(char *const nonexpanded_waynant)\r\n{\r\n int oc_i = 0;\r\n int found;\r\n char *buffer = 0;\r\n int buffer_len;\r\n char *ciliform_tetramerous = 0;\r\n int bahada_porphyraceous;\r\n int jcr_spectrophobia;\r\n ++global_variable;;\r\n jcr_spectrophobia = 5;\r\n while(1 == 1){\r\n jcr_spectrophobia = jcr_spectrophobia * 2;\r\n jcr_spectrophobia = jcr_spectrophobia + 2;\r\n if (jcr_spectrophobia > 1000) {\r\n break; \r\n }\r\n }\r\n bahada_porphyraceous = jcr_spectrophobia;\r\n ciliform_tetramerous = ((char *)((char *)nonexpanded_waynant));\r\n \r\n buffer_len = strlen(ciliform_tetramerous) + 1;\r\n buffer = malloc(buffer_len * sizeof(char ));\r\n if (buffer == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(buffer,ciliform_tetramerous);\r\n for (; oc_i < buffer_len; ++oc_i) {\r\n buffer[oc_i] = toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\",buffer);\r\n \r\n found = contains_char(buffer,'E');\r\n if (found == 1)\r\n printf(\"%s\\n\",ciliform_tetramerous);\r\n \r\n;\r\n if (((char *)nonexpanded_waynant) != 0) \r\n free(((char *)((char *)nonexpanded_waynant)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n free(str_param);\n```", "cwe": "761"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint toxicogenic_bizes = 0;\r\n\r\nunion anisogamic_ezzard \r\n{\r\n char *unsummable_chancres;\r\n double xylometer_rile;\r\n char *undereyed_multiflow;\r\n char gangbang_edirne;\r\n int sansculottic_forcipal;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *catheterising_tightroping);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct data_struct {\r\n int (*func_member)(char *);\r\n char *str_member;\r\n};\r\nint modulus_function(char *modulus_param_str)\r\n{\r\n \r\n return modulus_param_str[0] % 2;\r\n}\r\nvoid set_function(char *set_param_str,struct data_struct *set_param_data_struct)\r\n{\r\n \r\n \r\n\r\n if (strlen(set_param_str) > 10U) {\r\n set_param_data_struct -> func_member = modulus_function;\r\n set_param_data_struct -> str_member = set_param_str;\r\n \r\n }\r\n if (strlen(set_param_str) < 10U) {\r\n set_param_data_struct -> func_member = modulus_function;\r\n set_param_data_struct -> str_member = \"default\";\r\n \r\n }\r\n \r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&toxicogenic_bizes,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *catheterising_tightroping)\r\n{\r\n int val = 0;\r\n struct data_struct my_foo;\r\n char *miliolitic_subfulgent = 0;\r\n union anisogamic_ezzard overrestrain_bistros;\r\n ++global_variable;;\r\n if (catheterising_tightroping != 0) {;\r\n overrestrain_bistros . unsummable_chancres = catheterising_tightroping;\r\n miliolitic_subfulgent = ((char *)overrestrain_bistros . unsummable_chancres);\r\n \r\n if (strlen(miliolitic_subfulgent) < 1) {\r\n printf(\"string is too short to test\\n\");\r\n } else {\r\n set_function(miliolitic_subfulgent, &my_foo);\r\n \r\n \r\n val = (my_foo . func_member(my_foo . str_member));\r\n \r\n if (val == 0)\r\n printf(\"mod is true\\n\");\r\n else\r\n printf(\"mod is false\\n\");\r\n }\r\n \r\n;\r\n if (overrestrain_bistros . unsummable_chancres != 0) \r\n free(((char *)overrestrain_bistros . unsummable_chancres));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n val = (my_foo . func_member(my_foo . str_member));\n```", "cwe": "824"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint revenants_incorporator = 0;\r\n\r\nstruct malingerers_quasiperiodic \r\n{\r\n char *scramble_minimising;\r\n double discinoid_jenequen;\r\n char *bleck_limnobiological;\r\n char sillers_admired;\r\n int chorographical_squashberry;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *gonococcal_berdyayev);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\ntypedef int (*fct_ptr)(const char *, const char *);\r\nfct_ptr switch_func(char *param)\r\n{\r\n \r\n int var_len = 0;\r\n fct_ptr fct_ptr_addr = (fct_ptr )0;\r\n var_len = strlen(param) % 3;\r\n if (var_len == 0) {\r\n return strcmp;\r\n }\r\n else if (var_len == 1) {\r\n return strcoll;\r\n }\r\n else {\r\n sscanf(param,\"%p\",&fct_ptr_addr);\r\n return fct_ptr_addr;\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&revenants_incorporator,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *gonococcal_berdyayev)\r\n{\r\n int cmp_flag = 0;\r\n char *patella_whoremonger = 0;\r\n struct malingerers_quasiperiodic *rheumiest_sooky = {0};\r\n struct malingerers_quasiperiodic *prote_recelebrated = {0};\r\n struct malingerers_quasiperiodic aggregated_eliquation;\r\n ++global_variable;;\r\n if (gonococcal_berdyayev != 0) {;\r\n aggregated_eliquation . scramble_minimising = ((char *)gonococcal_berdyayev);\r\n rheumiest_sooky = &aggregated_eliquation;\r\n prote_recelebrated = rheumiest_sooky + 5;\r\n patella_whoremonger = ((char *)( *(prote_recelebrated - 5)) . scramble_minimising);\r\n \r\n \r\n \r\n fct_ptr fp;\r\n const char *rand_word = \"criticisms_metallide\";\r\n fp = switch_func(patella_whoremonger);\r\n \r\n \r\n \r\n \r\n cmp_flag = ( *fp)(rand_word,patella_whoremonger);\r\n \r\n if (cmp_flag == 0)\r\n printf(\"strings are equal\\n\");\r\n else\r\n printf(\"strings are not equal\\n\");\r\n \r\n;\r\n if (( *(prote_recelebrated - 5)) . scramble_minimising != 0) \r\n free(((char *)( *(prote_recelebrated - 5)) . scramble_minimising));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n cmp_flag = ( *fp)(rand_word,patella_whoremonger);\n```", "cwe": "822"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint lamoure_hystricism = 0;\r\ntypedef char *athamantin_palaeontologist;\r\nint global_variable;\r\nvoid handle_taint(char *clothbound_radiotelegraphy);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid evergood_guarachas(const athamantin_palaeontologist centerboard_unmiraculous);\r\nvoid overeate_haplology(int authorized_pranged,athamantin_palaeontologist gulper_casseroled);\r\nvoid paronym_perrin(int breezeways_tamms,athamantin_palaeontologist cavalero_doggoneder);\r\nFILE *open_file(char *filename_param)\r\n{\r\n FILE *f;\r\n \r\n \r\n \r\n\r\n\r\n f = fopen(filename_param,\"w\");\r\n \r\n \r\n if (!f)\r\n return 0;\r\n else\r\n return f;\r\n fclose(f);\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&lamoure_hystricism,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid handle_taint(char *clothbound_radiotelegraphy)\r\n{\r\n athamantin_palaeontologist kreiker_zygophore = 0;\r\n ++global_variable;;\r\n if (clothbound_radiotelegraphy != 0) {;\r\n kreiker_zygophore = clothbound_radiotelegraphy;\r\n evergood_guarachas(kreiker_zygophore);\r\n }\r\n}\r\n\r\nvoid evergood_guarachas(const athamantin_palaeontologist centerboard_unmiraculous)\r\n{\r\n int soggily_prepossessions = 7;\r\n ++global_variable;;\r\n overeate_haplology(soggily_prepossessions,centerboard_unmiraculous);\r\n}\r\n\r\nvoid overeate_haplology(int authorized_pranged,athamantin_palaeontologist gulper_casseroled)\r\n{\r\n char * filename = 0;\r\n int filename_len = 0;\r\n unsigned int num_files;\r\n FILE **filearray;\r\n int i;\r\n char *islip_forpining = 0;\r\n ++global_variable;\r\n authorized_pranged--;\r\n if (authorized_pranged > 0) {\r\n paronym_perrin(authorized_pranged,gulper_casseroled);\r\n return ;\r\n }\r\n islip_forpining = ((char *)((athamantin_palaeontologist )gulper_casseroled));\r\n \r\n if (strlen(islip_forpining) > 0 &&\r\n islip_forpining[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n printf(\"Getting input value\\n\");\r\n num_files = strtoul(islip_forpining,0,16);\r\n if (num_files > 0xffff)\r\n num_files = 0;\r\n filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\r\n filename_len = strlen(\"/opt//workspace/testData/temp\") + 10;\r\n filename = (char*) malloc(filename_len * sizeof(char));\r\n if (filearray != 0) {\r\n for (i = 0; i < num_files; ++i)\r\n filearray[i] = 0;\r\n printf(\"Creating files\\n\");\r\n for (i = 0; i < num_files; ++i) {\r\n snprintf(filename,filename_len,\"%s_%08x\", \"/opt//workspace/testData/temp\", i);\r\n filearray[i] = open_file(filename);\r\n if (filearray[i] == 0)\r\n break;\r\n }\r\n if (i < num_files)\r\n printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\r\n for (i = 0; i < num_files; ++i)\r\n if (filearray[i] != 0)\r\n fclose(filearray[i]);\r\n free(filearray);\r\n free(filename);\r\n }\r\n }\r\n \r\n;\r\n if (((athamantin_palaeontologist )gulper_casseroled) != 0) \r\n free(((char *)((athamantin_palaeontologist )gulper_casseroled)));\r\nclose_printf_context();\r\n}\r\n\r\nvoid paronym_perrin(int breezeways_tamms,athamantin_palaeontologist cavalero_doggoneder)\r\n{\r\n ++global_variable;\r\n overeate_haplology(breezeways_tamms,cavalero_doggoneder);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n\n f = fopen(filename_param,\"w\");\n```", "cwe": "774"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint electrifiers_epipaleolithic = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int stack_size = 0;\r\n char *ellerian_uglis = 0;\r\n int brunfelsia_trehala;\r\n int lepidosirenidae_strobilation;\r\n void *dezincking_bossdom = 0;\r\n long oilery_accomplishment[10];\r\n void *laxest_indifferent[10] = {0};\r\n void *interlink_clinchfield = 0;\r\n char *fowled_squattered;;\r\n if (__sync_bool_compare_and_swap(&electrifiers_epipaleolithic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n fowled_squattered = getenv(\"PAILFULS_BALISTRARIA\");\r\n if (fowled_squattered != 0) {;\r\n interlink_clinchfield = ((void *)fowled_squattered);\r\n laxest_indifferent[5] = interlink_clinchfield;\r\n oilery_accomplishment[1] = 5;\r\n dezincking_bossdom = *(laxest_indifferent + oilery_accomplishment[1]);\r\n lepidosirenidae_strobilation = 5;\r\n while(1 == 1){\r\n lepidosirenidae_strobilation = lepidosirenidae_strobilation * 2;\r\n lepidosirenidae_strobilation = lepidosirenidae_strobilation + 2;\r\n if (lepidosirenidae_strobilation > 1000) {\r\n break; \r\n }\r\n }\r\n brunfelsia_trehala = lepidosirenidae_strobilation;\r\n ellerian_uglis = ((char *)((char *)dezincking_bossdom));\r\n \r\n \r\n \r\n if (strlen(ellerian_uglis) > 1 &&\r\n ellerian_uglis[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n stack_size = strtoul(ellerian_uglis,0,0);\r\n printf(\"Allocating stack array\\n\");\r\n \r\n \r\n \r\n char stack_string[stack_size];\r\n memset(stack_string,'x',stack_size - 1);\r\n \r\n }\r\n \r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n char stack_string[stack_size];\n memset(stack_string,'x',stack_size - 1);\n```", "cwe": "789"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint cassino_acutest = 0;\r\nint global_variable;\r\n\r\nunion entireness_dialoger \r\n{\r\n char *echinopanax_aggrieved;\r\n double cobless_isochronic;\r\n char *monotron_priggisms;\r\n char reconsidering_disputed;\r\n int carbolizing_homunculus;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid surviving_pomologically(const union entireness_dialoger microdetection_pieprint);\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n union entireness_dialoger scrutinate_scapement;\r\n char *regalize_equiaxe;;\r\n if (__sync_bool_compare_and_swap(&cassino_acutest,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&regalize_equiaxe,\"DOODLING_HYPERVIGILANTLY\");\r\n if (regalize_equiaxe != 0) {;\r\n scrutinate_scapement . echinopanax_aggrieved = regalize_equiaxe;\r\n surviving_pomologically(scrutinate_scapement);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid surviving_pomologically(const union entireness_dialoger microdetection_pieprint)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *unwading_internal = 0;\r\n ++global_variable;;\r\n if (((union entireness_dialoger )microdetection_pieprint) . echinopanax_aggrieved != 0) {\r\n goto disclaimer_turkic;\r\n }\r\n ++global_variable;\r\n disclaimer_turkic:;\r\n unwading_internal = ((char *)((union entireness_dialoger )microdetection_pieprint) . echinopanax_aggrieved);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, unwading_internal);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (((union entireness_dialoger )microdetection_pieprint) . echinopanax_aggrieved != 0) \r\n free(((char *)((union entireness_dialoger )microdetection_pieprint) . echinopanax_aggrieved));\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer)) {\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n } else {\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint corsak_nar = 0;\r\ntypedef char *coscinodiscus_metallist;\r\nint global_variable;\r\nvoid handle_taint(char *coadmires_nobie);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nshort get_int_value(char *ss_tainted_buff)\r\n{\r\n \r\n short to_short = 0;\r\n int tainted_int = 0;\r\n tainted_int = atoi(ss_tainted_buff);\r\n if (tainted_int != 0) {\r\n if (tainted_int > 30000)\r\n tainted_int = 30000;\r\n if (tainted_int < -30000)\r\n tainted_int = -30000;\r\n to_short = ((short )tainted_int);\r\n }\r\n return to_short;\r\n}\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&corsak_nar,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nvoid handle_taint(char *coadmires_nobie)\r\n{\r\n unsigned int to_unsign = 0;\r\n char *buff = 0;\r\n FILE *file = 0;\r\n int counter = 0;\r\n int bytes_read = 0;\r\n char *wildebeest_saeger = 0;\r\n coscinodiscus_metallist chitchats_wickerwork = 0;\r\n int *annarbor_germanious = 0;\r\n int polejumper_graypate;\r\n coscinodiscus_metallist whinnied_sixteen[10] = {0};\r\n coscinodiscus_metallist nubilities_entitlement = 0;\r\n ++global_variable;;\r\n if (coadmires_nobie != 0) {;\r\n nubilities_entitlement = coadmires_nobie;\r\n whinnied_sixteen[5] = nubilities_entitlement;\r\n polejumper_graypate = 5;\r\n annarbor_germanious = &polejumper_graypate;\r\n chitchats_wickerwork = *(whinnied_sixteen + *annarbor_germanious);\r\n if (chitchats_wickerwork != 0) {\r\n goto strategoi_heartease;\r\n }\r\n ++global_variable;\r\n strategoi_heartease:;\r\n wildebeest_saeger = ((char *)chitchats_wickerwork);\r\n \r\n buff = ((char *)(malloc(30000 * sizeof(char ))));\r\n if (buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(buff, 0, 30000);\r\n \r\n\r\n to_unsign = get_int_value(wildebeest_saeger);\r\n \r\n \r\n \r\n file = fopen(\"/opt//workspace/testData/myfile.txt\",\"r\");\r\n if (file != 0) {\r\n \r\n while (((unsigned int )counter) < to_unsign) {\r\n \r\n bytes_read = fread(&buff[counter],\r\n sizeof(char), 1000, file);\r\n if (bytes_read == 0) {\r\n break;\r\n }\r\n counter += bytes_read;\r\n }\r\n \r\n fclose(file);\r\n buff[to_unsign] = '\\0';\r\n printf(\"buff is %d long, and has contents: %s \\n\",strlen(buff), buff);\r\n } else {\r\n printf(\"Cannot open file %s\\n\", \"/opt//workspace/testData/myfile.txt\");\r\n }\r\n if (buff != 0) {\r\n free(buff);\r\n }\r\n \r\n;\r\n if (chitchats_wickerwork != 0) \r\n free(((char *)chitchats_wickerwork));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while (((unsigned int )counter) < to_unsign) {\n \n bytes_read = fread(&buff[counter],\n sizeof(char), 1000, file);\n if (bytes_read == 0) {\n break;\n }\n counter += bytes_read;\n }\n```", "cwe": "194"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint unconfidently_austroasiatic = 0;\r\nint global_variable;\r\n\r\nstruct doxologizing_nonsympathy \r\n{\r\n char *wittall_diallists;\r\n double buraq_remasticating;\r\n char *filister_kosos;\r\n char chevrotin_cicad;\r\n int clough_synalgic;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid kirmew_placoderm(struct doxologizing_nonsympathy *knoppy_unrepentingly);\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n#define READOPT_BITTERSWEETS(x) kirmew_placoderm((struct doxologizing_nonsympathy *) x)\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n struct doxologizing_nonsympathy *ferrety_gasser = {0};\r\n struct doxologizing_nonsympathy *weaken_thiobacillus = {0};\r\n struct doxologizing_nonsympathy demotist_dilatedly;\r\n char *procosmopolitan_hechshers;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&unconfidently_austroasiatic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&procosmopolitan_hechshers,\"MICROCOLUMNAR_RECOVERING\");\r\n if (procosmopolitan_hechshers != 0) {;\r\n demotist_dilatedly . wittall_diallists = ((char *)procosmopolitan_hechshers);\r\n ferrety_gasser = &demotist_dilatedly;\r\n weaken_thiobacillus = ferrety_gasser + 5;\r\n\tREADOPT_BITTERSWEETS(weaken_thiobacillus);\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid kirmew_placoderm(struct doxologizing_nonsympathy *knoppy_unrepentingly)\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *abstractional_wind = 0;\r\n ++global_variable;;\r\n abstractional_wind = ((char *)( *(knoppy_unrepentingly - 5)) . wittall_diallists);\r\n \r\n while(isalnum(abstractional_wind[size]) && size < strlen(abstractional_wind)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(abstractional_wind)) {\r\n abstractional_wind = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,abstractional_wind);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (( *(knoppy_unrepentingly - 5)) . wittall_diallists != 0) \r\n free(((char *)( *(knoppy_unrepentingly - 5)) . wittall_diallists));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,abstractional_wind);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint binaries_doctrinarity = 0;\r\nint global_variable;\r\n\r\nstruct statoreceptor_byordinar \r\n{\r\n char *tour_jamesstore;\r\n double marmoreally_teethbrush;\r\n char *underexposing_aerologists;\r\n char seraphims_archfire;\r\n int leavittsburg_scenarios;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid morsel_kirima(struct statoreceptor_byordinar serries_viole);\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n#define EAVEDROPPING_PROTOACTINIUM(x) morsel_kirima((struct statoreceptor_byordinar) x)\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n struct statoreceptor_byordinar desired_vincent = {0};\r\n int *fillmass_concents = 0;\r\n int calcifuge_kryptocyanine;\r\n struct statoreceptor_byordinar scrawly_phosphonic[10] = {0};\r\n struct statoreceptor_byordinar residencer_overvariety;\r\n char *beaupere_caligated;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&binaries_doctrinarity,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&beaupere_caligated,\"VAPORINGLY_DYSCRASITE\");\r\n if (beaupere_caligated != 0) {;\r\n residencer_overvariety . tour_jamesstore = ((char *)beaupere_caligated);\r\n scrawly_phosphonic[5] = residencer_overvariety;\r\n calcifuge_kryptocyanine = 5;\r\n fillmass_concents = &calcifuge_kryptocyanine;\r\n desired_vincent = *(scrawly_phosphonic + *fillmass_concents);\r\n\tEAVEDROPPING_PROTOACTINIUM(desired_vincent);\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid morsel_kirima(struct statoreceptor_byordinar serries_viole)\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[1020];\r\n char filename[80];\r\n char *linseed_winterizes = 0;\r\n ++global_variable;;\r\n linseed_winterizes = ((char *)serries_viole . tour_jamesstore);\r\n \r\n files = fopen(linseed_winterizes,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n if (files != 0)\r\n fclose(files);\r\n \r\n;\r\n if (serries_viole . tour_jamesstore != 0) \r\n free(((char *)serries_viole . tour_jamesstore));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi] = file;\n ssi++;\n }\n```", "cwe": "775"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <sys/stat.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint enumerators_coccygomorph = 0;\r\nint global_variable;\r\ntypedef char *subtlest_buckling;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid grubstreet_transpeciate(int unreined_inhonest,... );\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n subtlest_buckling pleurothotonus_fury = 0;\r\n char *paulette_umbilicaria;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&enumerators_coccygomorph,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&paulette_umbilicaria,\"ARTEFAC_TROGLODYTES\");\r\n if (paulette_umbilicaria != 0) {;\r\n pleurothotonus_fury = paulette_umbilicaria;\r\n grubstreet_transpeciate(1,pleurothotonus_fury);\r\n }\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\n\r\nvoid grubstreet_transpeciate(int unreined_inhonest,... )\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *countys_aminated = 0;\r\n subtlest_buckling karsha_tariff = 0;\r\n va_list ipse_puton;\r\n ++global_variable;;\r\n if (unreined_inhonest > 0) {\r\n __builtin_va_start(ipse_puton,unreined_inhonest);\r\n karsha_tariff = (va_arg(ipse_puton,subtlest_buckling ));\r\n __builtin_va_end(ipse_puton);\r\n }\r\n countys_aminated = ((char *)karsha_tariff);\r\n \r\n while(isalnum(countys_aminated[size]) && size < strlen(countys_aminated)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(countys_aminated)) {\r\n countys_aminated = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,countys_aminated);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (karsha_tariff != 0) \r\n free(((char *)karsha_tariff));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,countys_aminated);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nint bastia_facete = 0;\r\ntypedef char *evolvable_shackled;\r\nint global_variable;\r\nvoid drome_needful(evolvable_shackled *masterfast_agriculturist);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid jnana_amphicarpia(void (*staffelite_familiar)(evolvable_shackled *));\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&bastia_facete,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n jnana_amphicarpia(drome_needful);\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nvoid drome_needful(evolvable_shackled *masterfast_agriculturist)\r\n{\r\n evolvable_shackled extratellurian_sunna = 0;\r\n int memorablenesses_informatory = 76;\r\n char *moderates_vinegarer;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&moderates_vinegarer,\"7902\",memorablenesses_informatory);\r\n if (moderates_vinegarer != 0) {;\r\n extratellurian_sunna = moderates_vinegarer;\r\n *masterfast_agriculturist = extratellurian_sunna;\r\n }\r\n}\r\n\r\nvoid jnana_amphicarpia(void (*staffelite_familiar)(evolvable_shackled *))\r\n{\r\n char buffer_stack[128] = {0};\r\n char *nondemocracy_immortalism = 0;\r\n evolvable_shackled badass_neillia = 0;\r\n int **********derogated_opisthogastric = 0;\r\n int *********tricycling_bilabiate = 0;\r\n int ********localises_timestamps = 0;\r\n int *******armigers_obsidional = 0;\r\n int ******puckish_rebato = 0;\r\n int *****nuzzerana_wowserism = 0;\r\n int ****benzine_blowhard = 0;\r\n int ***rehypnotizing_supertower = 0;\r\n int **ozkum_nonpropagandist = 0;\r\n int *millstream_blackwash = 0;\r\n int conicality_unclarity;\r\n evolvable_shackled kinematically_saundra[10] = {0};\r\n ++global_variable;\r\n evolvable_shackled wasagara_apellous = 0;\r\n staffelite_familiar(&wasagara_apellous);\r\n if (wasagara_apellous != 0) {;\r\n conicality_unclarity = 5;\r\n millstream_blackwash = &conicality_unclarity;\r\n ozkum_nonpropagandist = &millstream_blackwash;\r\n rehypnotizing_supertower = &ozkum_nonpropagandist;\r\n benzine_blowhard = &rehypnotizing_supertower;\r\n nuzzerana_wowserism = &benzine_blowhard;\r\n puckish_rebato = &nuzzerana_wowserism;\r\n armigers_obsidional = &puckish_rebato;\r\n localises_timestamps = &armigers_obsidional;\r\n tricycling_bilabiate = &localises_timestamps;\r\n derogated_opisthogastric = &tricycling_bilabiate;\r\n kinematically_saundra[ *( *( *( *( *( *( *( *( *( *derogated_opisthogastric)))))))))] = wasagara_apellous;\r\n badass_neillia = kinematically_saundra[ *( *( *( *( *( *( *( *( *( *derogated_opisthogastric)))))))))];\r\n nondemocracy_immortalism = ((char *)badass_neillia);\r\n \r\n \r\n \r\n \r\n \r\n sprintf(buffer_stack,nondemocracy_immortalism);\r\n \r\n printf(\"%s\\n\",buffer_stack);\r\n \r\n \r\n;\r\n if (badass_neillia != 0) \r\n free(((char *)badass_neillia));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n sprintf(buffer_stack,nondemocracy_immortalism);\n \n printf(\"%s\\n\",buffer_stack);\n```", "cwe": "134"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint unshady_refenced = 0;\r\nint global_variable;\r\n\r\nstruct journeycake_subtrist \r\n{\r\n char *thyreolingual_tony;\r\n double buddhist_torulose;\r\n char *polysemantic_reffroze;\r\n char unhealthiness_forestudy;\r\n int tubatulabal_prelawfulness;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid getsul_skittering(struct journeycake_subtrist *passless_tripl);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int explicitly_semiaerial;\r\n struct journeycake_subtrist *ensconces_differentiable = {0};\r\n struct journeycake_subtrist *aeriness_flurrying = {0};\r\n struct journeycake_subtrist chalcostibite_fewterer;\r\n int hedging_kief = 29;\r\n char *skedaddled_salutatorily;;\r\n if (__sync_bool_compare_and_swap(&unshady_refenced,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&skedaddled_salutatorily,\"8598\",hedging_kief);\r\n if (skedaddled_salutatorily != 0) {;\r\n chalcostibite_fewterer . thyreolingual_tony = ((char *)skedaddled_salutatorily);\r\n explicitly_semiaerial = 1;\r\n ensconces_differentiable = &chalcostibite_fewterer;\r\n aeriness_flurrying = ((struct journeycake_subtrist *)(((unsigned long )ensconces_differentiable) * explicitly_semiaerial * explicitly_semiaerial)) + 5;\r\n getsul_skittering(aeriness_flurrying);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid getsul_skittering(struct journeycake_subtrist *passless_tripl)\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *subdie_collectivizing = 0;\r\n ++global_variable;;\r\n subdie_collectivizing = ((char *)( *(passless_tripl - 5)) . thyreolingual_tony);\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(subdie_collectivizing); ++i) {\r\n if (subdie_collectivizing[i] == ';') {\r\n if (i == 0 || subdie_collectivizing[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,subdie_collectivizing);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (( *(passless_tripl - 5)) . thyreolingual_tony != 0) \r\n free(((char *)( *(passless_tripl - 5)) . thyreolingual_tony));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint idiograph_alleman = 0;\r\nint global_variable;\r\n\r\nunion adenous_satsuma \r\n{\r\n char *evendown_vicing;\r\n double teamsters_polyplastic;\r\n char *craniognosy_hierarchic;\r\n char alg_paye;\r\n int asininities_lerne;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid zygion_assmannshausen(union adenous_satsuma *gynecomazia_cultured);\r\nint toupper(int c) {\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n#define MEDIZE_MEMORYLESS(x) zygion_assmannshausen((union adenous_satsuma *) x)\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n union adenous_satsuma *dowdy_sofa = {0};\r\n union adenous_satsuma anisotropically_orientality;\r\n char *worship_bridesman;;\r\n if (__sync_bool_compare_and_swap(&idiograph_alleman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n worship_bridesman = getenv(\"HOOL_NONCARTELIZED\");\r\n if (worship_bridesman != 0) {;\r\n anisotropically_orientality . evendown_vicing = worship_bridesman;\r\n dowdy_sofa = &anisotropically_orientality;\r\n\tMEDIZE_MEMORYLESS(dowdy_sofa);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid zygion_assmannshausen(union adenous_satsuma *gynecomazia_cultured)\r\n{\r\n int oc_i = 0;\r\n char stack_buffer_64[64];\r\n char *hirples_vindices = 0;\r\n ++global_variable;;\r\n hirples_vindices = ((char *)( *gynecomazia_cultured) . evendown_vicing);\r\n \r\n memset(stack_buffer_64,0,64);\r\n \r\n \r\n \r\n \r\n \r\n strcpy(stack_buffer_64,hirples_vindices);\r\n \r\n \r\n \r\n for (; oc_i < 64; ++oc_i) {\r\n stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",stack_buffer_64);\r\n \r\n \r\n \r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n;\nclose_printf_context();\n```", "cwe": "120"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint underrented_kristinaux = 0;\r\nint global_variable;\r\ntypedef char *alectoria_rsfsr;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid orwell_swilkie(int mandibula_overproneness,alectoria_rsfsr *chapterhouse_nietzscheanism);\r\nvoid eucalyptus_maimon(int ectocondyloid_brushball,alectoria_rsfsr *draisine_majolica);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int hippocratic_reshaken = 7;\r\n int howie_intrazonal;\r\n alectoria_rsfsr *phylloidal_cyanitic = 0;\r\n alectoria_rsfsr *retread_hooley = 0;\r\n alectoria_rsfsr disparpling_rheotrope = 0;\r\n char *cerebropedal_neutrophils;;\r\n if (__sync_bool_compare_and_swap(&underrented_kristinaux,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n cerebropedal_neutrophils = getenv(\"MERCHANDISED_MICROCOLUMNAR\");\r\n if (cerebropedal_neutrophils != 0) {;\r\n disparpling_rheotrope = cerebropedal_neutrophils;\r\n howie_intrazonal = 1;\r\n phylloidal_cyanitic = &disparpling_rheotrope;\r\n retread_hooley = ((alectoria_rsfsr *)(((unsigned long )phylloidal_cyanitic) * howie_intrazonal * howie_intrazonal)) + 5;\r\n orwell_swilkie(hippocratic_reshaken,retread_hooley);\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid orwell_swilkie(int mandibula_overproneness,alectoria_rsfsr *chapterhouse_nietzscheanism)\r\n{\r\n FILE *csv = 0;\r\n FILE *temp = 0;\r\n char col1[80] = {0};\r\n char col2[80] = {0};\r\n char col3[80] = {0};\r\n char *cols[3] = {0};\r\n char *diureticalness_saviorhood = 0;\r\n ++global_variable;\r\n mandibula_overproneness--;\r\n if (mandibula_overproneness > 0) {\r\n eucalyptus_maimon(mandibula_overproneness,chapterhouse_nietzscheanism);\r\n return ;\r\n }\r\n diureticalness_saviorhood = ((char *)( *(chapterhouse_nietzscheanism - 5)));\r\n \r\n \r\n csv = fopen(diureticalness_saviorhood,\"r\");\r\n if (csv != 0) {\r\n \r\n\r\n fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\r\n \r\n \r\n \r\n \r\n if (strlen(col1) > 0)\r\n cols[0] = col1;\r\n if (strlen(col2) > 0)\r\n cols[1] = col2;\r\n if (strlen(col3) > 0)\r\n cols[2] = col3;\r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n\r\n printf(\"VALUES=\\\"\");\r\n fputs(cols[0],temp);\r\n printf(cols[0]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[1],temp);\r\n printf(cols[1]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[2],temp);\r\n printf(cols[2]);\r\n \r\n printf(\"\\\"\\n\");\r\n fclose(temp);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n\r\nvoid eucalyptus_maimon(int ectocondyloid_brushball,alectoria_rsfsr *draisine_majolica)\r\n{\r\n ++global_variable;\r\n orwell_swilkie(ectocondyloid_brushball,draisine_majolica);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n printf(\"VALUES=\\\"\");\n fputs(cols[0],temp);\n printf(cols[0]);\n printf(\"\\\",\\\"\");\n fputs(cols[1],temp);\n printf(cols[1]);\n printf(\"\\\",\\\"\");\n fputs(cols[2],temp);\n printf(cols[2]);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <mongoose.h> \r\n#include <string.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint generalidad_cribbage = 0;\r\nint global_variable;\r\nvoid handle_taint(char *wampums_damolic);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&generalidad_cribbage,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid handle_taint(char *wampums_damolic)\r\n{\r\n char buffer[80];\r\n FILE *pFile = 0;\r\n char *demiheavenly_doolittle = 0;\r\n int cozier_unpostponable;\r\n int teletape_amenities;\r\n int hydrazobenzene_vesiculae;\r\n char **sauropterygian_monomorphism = 0;\r\n char **taharah_beteela = 0;\r\n char *exolve_cerotene[25] = {0};\r\n ++global_variable;;\r\n if (wampums_damolic != 0) {;\r\n exolve_cerotene[8] = wampums_damolic;\r\n hydrazobenzene_vesiculae = 1;\r\n sauropterygian_monomorphism = exolve_cerotene;\r\n taharah_beteela = ((char **)(((unsigned long )sauropterygian_monomorphism) * hydrazobenzene_vesiculae * hydrazobenzene_vesiculae)) + 5;\r\n teletape_amenities = 5;\r\n while(1 == 1){\r\n teletape_amenities = teletape_amenities * 2;\r\n teletape_amenities = teletape_amenities + 2;\r\n if (teletape_amenities > 1000) {\r\n break; \r\n }\r\n }\r\n cozier_unpostponable = teletape_amenities;\r\n demiheavenly_doolittle = ((char *)(taharah_beteela - 5)[8]);\r\n \r\n \r\n\r\n pFile = fopen(demiheavenly_doolittle,\"r\");\r\n buffer[0] = 0;\r\n \r\n \r\n \r\n\r\n fgets(buffer,79,pFile);\r\n printf(buffer);\r\n printf(\"\\n\");\r\n fclose(pFile);\r\n \r\n \r\n;\r\n if ((taharah_beteela - 5)[8] != 0) \r\n free(((char *)(taharah_beteela - 5)[8]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n fgets(buffer,79,pFile);\n printf(buffer);\n printf(\"\\n\");\n fclose(pFile);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint stealed_coheritor = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid sulfonal_rachillae(int archespsporia_redact,char *somnambulistic_middlesworth);\r\nstruct message_buffer {\r\n union {\r\n int name_id_member;\r\n char *name_member;\r\n } message_data;\r\n int message_type;\r\n};\r\nint process_buf(void *param)\r\n{\r\n \r\n struct message_buffer *message_param = 0;\r\n message_param = ((struct message_buffer *)param);\r\n if (message_param -> message_type == 1)\r\n return strlen(message_param -> message_data . name_member);\r\n else\r\n return message_param -> message_data . name_id_member;\r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{\r\n int domineeringly_earth = 7;\r\n char *nonillusiveness_purupuru = 0;\r\n long hieracosphinxes_mogilev[10];\r\n char *jarful_koeberliniaceae[10] = {0};\r\n char *ainsells_protractors;;\r\n if (__sync_bool_compare_and_swap(&stealed_coheritor,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&ainsells_protractors,\"GYMKHANA_UNFAILABLE\");\r\n if (ainsells_protractors != 0) {;\r\n jarful_koeberliniaceae[5] = ainsells_protractors;\r\n hieracosphinxes_mogilev[1] = 5;\r\n nonillusiveness_purupuru = *(jarful_koeberliniaceae + hieracosphinxes_mogilev[1]);\r\n sulfonal_rachillae(domineeringly_earth,nonillusiveness_purupuru);\r\n }\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid sulfonal_rachillae(int archespsporia_redact,char *somnambulistic_middlesworth)\r\n{\r\n int val;\r\n unsigned long id;\r\n struct message_buffer buf;\r\n char *jadder_renewed = 0;\r\n ++global_variable;\r\n archespsporia_redact--;\r\n if (archespsporia_redact > 0) {\r\n sulfonal_rachillae(archespsporia_redact,somnambulistic_middlesworth);\r\n return ;\r\n }\r\n jadder_renewed = ((char *)somnambulistic_middlesworth);\r\n \r\n buf . message_type = 1;\r\n buf . message_data . name_member = jadder_renewed;\r\n id = atoi(jadder_renewed);\r\n \r\n \r\n \r\n \r\n\r\n if (id != 0)\r\n buf . message_data . name_id_member = id;\r\n \r\n \r\n \r\n\r\n val = process_buf(&buf);\r\n printf(\"processing result is %i\\n\", val);\r\n \r\n \r\n \r\n;\r\n if (somnambulistic_middlesworth != 0) \r\n free(((char *)somnambulistic_middlesworth));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n val = process_buf(&buf);\n printf(\"processing result is %i\\n\", val);\n```", "cwe": "843"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint anastases_interlachen = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid sarraute_consonance(int spoutiness_heptachord,char **oxybenzyl_mislikers);\r\nchar process_buffer(char *buffer_param)\r\n{\r\n \r\n char first_char;\r\n first_char = buffer_param[0] - 97;\r\n free(buffer_param);\r\n return first_char;\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n int unconversant_nonspecie = 7;\r\n char **hygrophyte_wormroot = 0;\r\n char *schoolyard_unfluid;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&anastases_interlachen,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&schoolyard_unfluid,\"SAMBOS_TUCKERMANITY\");\r\n if (schoolyard_unfluid != 0) {;\r\n hygrophyte_wormroot = &schoolyard_unfluid;\r\n sarraute_consonance(unconversant_nonspecie,hygrophyte_wormroot);\r\n }\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\n\r\nvoid sarraute_consonance(int spoutiness_heptachord,char **oxybenzyl_mislikers)\r\n{\r\n char *buffer = 0;\r\n char *belched_ektenes = 0;\r\n ++global_variable;\r\n spoutiness_heptachord--;\r\n if (spoutiness_heptachord > 0) {\r\n sarraute_consonance(spoutiness_heptachord,oxybenzyl_mislikers);\r\n return ;\r\n }\r\n belched_ektenes = ((char *)( *oxybenzyl_mislikers));\r\n \r\n buffer = malloc((strlen(belched_ektenes) + 1) * sizeof(char ));\r\n if (buffer == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(buffer,belched_ektenes);\r\n \r\n \r\n if (buffer[0] >= 97) {\r\n printf(\"Index of first char: %i\\n\",process_buffer(buffer));\r\n }\r\n \r\n if (buffer != 0) {\r\n \r\n \r\n free(buffer);\r\n \r\n }\r\n \r\n;\r\n if ( *oxybenzyl_mislikers != 0) \r\n free(((char *)( *oxybenzyl_mislikers)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n free(buffer);\n```", "cwe": "415"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint phosphene_campaigning = 0;\r\nint global_variable;\r\nvoid institory_rhinologic(char **flanneled_lability);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid informatus_underkind(void (*geiger_giblets)(char **));\r\nchar *devanagari_obes(char *repapers_shrived);\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&phosphene_campaigning,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n informatus_underkind(institory_rhinologic);\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid institory_rhinologic(char **flanneled_lability)\r\n{\r\n char *craw_finches;\r\n ++global_variable;;\r\n setup_printf_context();\r\n craw_finches = getenv(\"BACONY_WHITTERICK\");\r\n if (craw_finches != 0) {;\r\n *flanneled_lability = craw_finches;\r\n }\r\n}\r\n\r\nvoid informatus_underkind(void (*geiger_giblets)(char **))\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *polystichoid_aerobium = 0;\r\n char *bertha_exsert = 0;\r\n ++global_variable;\r\n char *anlage_svetlana = 0;\r\n geiger_giblets(&anlage_svetlana);\r\n if (anlage_svetlana != 0) {;\r\n bertha_exsert = devanagari_obes(anlage_svetlana);\r\n polystichoid_aerobium = ((char *)bertha_exsert);\r\n \r\n \r\n\r\n if (strlen(polystichoid_aerobium) < 63) {\r\n skip_malloc_buffer = malloc(strlen(polystichoid_aerobium + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,polystichoid_aerobium);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nchar *devanagari_obes(char *repapers_shrived)\r\n{\r\n ++global_variable;\r\n return repapers_shrived;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n strcpy(skip_malloc_buffer,polystichoid_aerobium);\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <pthread.h> \r\n#include <signal.h> \r\n#include <unistd.h> \r\n#include <sys/stat.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint tetratone_windlassing = 0;\r\nint global_variable;\r\nvoid handle_taint(char *sailers_innocuously);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct data {\r\n int data_size;\r\n char *data;\r\n char *file1;\r\n};\r\nstruct data *Data;\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForSig(char* sleepFile) {\r\n int fd;\r\n char outStr[25] = {0};\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForSig\\n\");\r\n sprintf(outStr, \"%d.pid\", getpid());\r\n strcat(filename, \"/opt//workspace/testData/\");\r\n strcat(filename, outStr);\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n \r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nvoid delNonAlpha (void *data) {\r\n struct data *Data = (struct data*) data;\r\n int i = 0;\r\n int j = 0;\r\n char* temp = malloc(sizeof(char) * (Data->data_size + 1));\r\n \r\n printf(\"Grabbing lock\\n\");\r\n \r\n \r\n pthread_mutex_lock(&mutex); \r\n \r\n \r\n while(Data->data[i] != '\\0') {\r\n if((Data->data[i] >= 'A' && Data->data[i] <= 'Z') ||\r\n (Data->data[i] >= 'a' && Data->data[i] <= 'z')) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[j++] = '\\0';\r\n Data->data_size = j;\r\n free(Data->data);\r\n Data->data = temp;\r\n waitForSig(Data->file1); \r\n printf(\"Realeasing lock\\n\");\r\n pthread_mutex_unlock(&mutex);\r\n \r\n}\r\nvoid sig_handler (int sig) {\r\n \r\n \r\n if (Data != NULL) {\r\n \r\n \r\n delNonAlpha(Data); \r\n }\r\n signal(SIGUSR1, SIG_IGN);\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&tetratone_windlassing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid handle_taint(char *sailers_innocuously)\r\n{\r\n char *mentor_inexplicitness = 0;\r\n char **unsternness_pulleyless = 0;\r\n char *lectureships_postliterate = 0;\r\n ++global_variable;;\r\n if (sailers_innocuously != 0) {;\r\n unsternness_pulleyless = &sailers_innocuously;\r\n mentor_inexplicitness = ((char *)( *unsternness_pulleyless));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));\r\n if (Data->data && Data->file1) {\r\n if ((sscanf(mentor_inexplicitness, \"%s %s\",\r\n Data->file1,\r\n Data->data) == 2) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0))\r\n {\r\n \r\n \r\n Data->data_size = strlen(Data->data);\r\n if (pthread_mutex_init(&mutex, NULL) != 0) {\r\n printf(\"Mutex failed to initilize.\");\r\n }\r\n if (signal(SIGUSR1, sig_handler) == SIG_ERR) { \r\n \r\n printf (\"Error catching SIGUSR1!\\n\");\r\n }\r\n delNonAlpha(Data);\r\n signal(SIGUSR1, SIG_IGN); \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ( *unsternness_pulleyless != 0) \r\n free(((char *)( *unsternness_pulleyless)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n pthread_mutex_lock(&mutex); \n \n```", "cwe": "479"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint reknot_anomalogonatous = 0;\r\n\r\nunion subproctorship_foxings \r\n{\r\n char *rallinae_lustra;\r\n double athalla_witness;\r\n char *overinclinable_portulacaceae;\r\n char folacins_tholeiite;\r\n int medusiform_cleelum;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *omphalic_unlivability);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid function() {\r\n \r\n}\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&reknot_anomalogonatous,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nvoid handle_taint(char *omphalic_unlivability)\r\n{\r\n void (*function_ptr_1)() = 0;\r\n void (*function_ptr_2)() = 0;\r\n unsigned long input_num;\r\n void (*function_ptr_3)() = 0;\r\n void (*function_ptr_4)() = 0;\r\n char *byte_4 = 0;\r\n char *byte_3 = 0;\r\n unsigned long *ptr = 0;\r\n char *bobbled_baileyton = 0;\r\n int relessor_rash;\r\n int repute_undriven;\r\n union subproctorship_foxings *hebamic_krypticism = {0};\r\n union subproctorship_foxings copending_cown;\r\n ++global_variable;;\r\n if (omphalic_unlivability != 0) {;\r\n copending_cown . rallinae_lustra = omphalic_unlivability;\r\n hebamic_krypticism = &copending_cown;\r\n repute_undriven = 5;\r\n while(1 == 1){\r\n repute_undriven = repute_undriven * 2;\r\n repute_undriven = repute_undriven + 2;\r\n if (repute_undriven > 1000) {\r\n break; \r\n }\r\n }\r\n relessor_rash = repute_undriven;\r\n bobbled_baileyton = ((char *)( *hebamic_krypticism) . rallinae_lustra);\r\n \r\n function_ptr_1 = function;\r\n function_ptr_2 = function;\r\n function_ptr_3 = function;\r\n function_ptr_4 = function;\r\n if (strlen(bobbled_baileyton) >= 1 &&\r\n bobbled_baileyton[0] != '-') {\r\n input_num = strtoul(bobbled_baileyton,0U,16);\r\n ptr = &input_num;\r\n if ( *ptr > 65535) {\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n byte_3 = ((char *)(ptr + 2));\r\n byte_4 = ((char *)(ptr + 3));\r\n \r\n \r\n *byte_3 = 0;\r\n *byte_4 = 0;\r\n \r\n \r\n \r\n \r\n \r\n }\r\n \r\n \r\n function_ptr_1();\r\n function_ptr_2();\r\n function_ptr_3();\r\n function_ptr_4();\r\n \r\n printf(\"Value = %i\\n\", input_num);\r\n } else if (strlen(bobbled_baileyton) == 0) {\r\n printf(\"Input is empty string\\n\");\r\n } else {\r\n printf(\"Input is negative number\\n\");\r\n }\r\n \r\n;\r\n if (( *hebamic_krypticism) . rallinae_lustra != 0) \r\n free(((char *)( *hebamic_krypticism) . rallinae_lustra));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n function_ptr_1();\n function_ptr_2();\n function_ptr_3();\n function_ptr_4();\n```", "cwe": "682"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint vicaire_passed = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid gwelo_squelches(char *nabcheat_unregenerated);\r\nvoid aedicule_undeniable(char *aldoxime_speckfall);\r\nvoid charade_mitchiner(char *sylleptically_noonstead);\r\nvoid octans_bespattered(char *cruiskeen_diduce);\r\nvoid ulcerated_nokesville(char *cam_lotis);\r\nvoid arrowroot_pentecostarion(char *hales_geraldine);\r\nvoid ambitionless_unshadow(char *cryptomnesic_sorptions);\r\nvoid teneral_dumbfounderment(char *bronchotomy_halvahs);\r\nvoid chevise_postparotid(char *steepdown_scratchy);\r\nvoid obtrusionist_contrastingly(char *beady_predevelop);\r\nint search(char *str_param,char c_param)\r\n{\r\n if ( *str_param == c_param) {\r\n return 1;\r\n } else if ( *str_param == 0) {\r\n \r\n \r\n return search(&str_param[0],c_param);\r\n } else {\r\n return search(&str_param[1],c_param);\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n char *berliner_tristate = 0;\r\n int *bringela_overcare = 0;\r\n int unkindest_sportly;\r\n char *peopled_lewiston[10] = {0};\r\n int acecaffine_sheldfowl = 0;\r\n char *zaramo_obviations = 0;\r\n int seaworn_bertolde = 31;\r\n char *needlebill_nondevoutly;;\r\n if (__sync_bool_compare_and_swap(&vicaire_passed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&needlebill_nondevoutly,\"4236\",seaworn_bertolde);\r\n if (needlebill_nondevoutly != 0) {;\r\n acecaffine_sheldfowl = ((int )(strlen(needlebill_nondevoutly)));\r\n zaramo_obviations = ((char *)(malloc(acecaffine_sheldfowl + 1)));\r\n if (zaramo_obviations == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(zaramo_obviations,0,acecaffine_sheldfowl + 1);\r\n memcpy(zaramo_obviations,needlebill_nondevoutly,acecaffine_sheldfowl);\r\n if (needlebill_nondevoutly != 0) \r\n free(((char *)needlebill_nondevoutly));\r\n peopled_lewiston[5] = zaramo_obviations;\r\n unkindest_sportly = 5;\r\n bringela_overcare = &unkindest_sportly;\r\n berliner_tristate = *(peopled_lewiston + *bringela_overcare);\r\n gwelo_squelches(berliner_tristate);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid gwelo_squelches(char *nabcheat_unregenerated)\r\n{\r\n ++global_variable;;\r\n aedicule_undeniable(nabcheat_unregenerated);\r\n}\r\n\r\nvoid aedicule_undeniable(char *aldoxime_speckfall)\r\n{\r\n ++global_variable;;\r\n charade_mitchiner(aldoxime_speckfall);\r\n}\r\n\r\nvoid charade_mitchiner(char *sylleptically_noonstead)\r\n{\r\n ++global_variable;;\r\n octans_bespattered(sylleptically_noonstead);\r\n}\r\n\r\nvoid octans_bespattered(char *cruiskeen_diduce)\r\n{\r\n ++global_variable;;\r\n ulcerated_nokesville(cruiskeen_diduce);\r\n}\r\n\r\nvoid ulcerated_nokesville(char *cam_lotis)\r\n{\r\n ++global_variable;;\r\n arrowroot_pentecostarion(cam_lotis);\r\n}\r\n\r\nvoid arrowroot_pentecostarion(char *hales_geraldine)\r\n{\r\n ++global_variable;;\r\n ambitionless_unshadow(hales_geraldine);\r\n}\r\n\r\nvoid ambitionless_unshadow(char *cryptomnesic_sorptions)\r\n{\r\n ++global_variable;;\r\n teneral_dumbfounderment(cryptomnesic_sorptions);\r\n}\r\n\r\nvoid teneral_dumbfounderment(char *bronchotomy_halvahs)\r\n{\r\n ++global_variable;;\r\n chevise_postparotid(bronchotomy_halvahs);\r\n}\r\n\r\nvoid chevise_postparotid(char *steepdown_scratchy)\r\n{\r\n ++global_variable;;\r\n obtrusionist_contrastingly(steepdown_scratchy);\r\n}\r\n\r\nvoid obtrusionist_contrastingly(char *beady_predevelop)\r\n{\r\n int found;\r\n char *sayonara_nonvocational = 0;\r\n ++global_variable;;\r\n sayonara_nonvocational = ((char *)beady_predevelop);\r\n \r\n \r\n \r\n found = search(&sayonara_nonvocational[1],sayonara_nonvocational[0]);\r\n \r\n \r\n \r\n;\r\n if (beady_predevelop != 0) \r\n free(((char *)beady_predevelop));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` found = search(&sayonara_nonvocational[1],sayonara_nonvocational[0]);\n```", "cwe": "674"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include <stdarg.h> \r\n#include </trace.h> \r\nint wealthiness_cicatrize = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid nonlimitative_fixtures(int petrosum_eisell,... );\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n void *amelioratory_garlen = 0;\r\n char *antivirus_ashot;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&wealthiness_cicatrize,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n antivirus_ashot = getenv(\"TRITIATE_TELHARMONY\");\r\n if (antivirus_ashot != 0) {;\r\n amelioratory_garlen = ((void *)antivirus_ashot);\r\n nonlimitative_fixtures(1,amelioratory_garlen);\r\n }\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nvoid nonlimitative_fixtures(int petrosum_eisell,... )\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *hypertoxic_subincident = 0;\r\n void *ferriferous_profitter = 0;\r\n va_list huge_tallboy;\r\n ++global_variable;;\r\n if (petrosum_eisell > 0) {\r\n __builtin_va_start(huge_tallboy,petrosum_eisell);\r\n ferriferous_profitter = (va_arg(huge_tallboy,void *));\r\n __builtin_va_end(huge_tallboy);\r\n }\r\n hypertoxic_subincident = ((char *)((char *)ferriferous_profitter));\r\n \r\n input = atoi(hypertoxic_subincident);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n quotient = 1024 / mod;\n```", "cwe": "369"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <limits.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint adorn_sempre = 0;\r\n\r\nstruct unfeigningly_disinure \r\n{\r\n char *trollopian_supercharging;\r\n double anguinidae_emissive;\r\n char *damoiseau_underfurnisher;\r\n char unthinking_forehold;\r\n int wreckages_overfondness;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nshort get_int_value(char *ss_tainted_buff)\r\n{\r\n \r\n short to_short = 0;\r\n int tainted_int = 0;\r\n tainted_int = atoi(ss_tainted_buff);\r\n if (tainted_int != 0) {\r\n if (tainted_int > 30000)\r\n tainted_int = 30000;\r\n if (tainted_int < -30000)\r\n tainted_int = -30000;\r\n to_short = ((short )tainted_int);\r\n }\r\n return to_short;\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n unsigned int to_unsign = 0;\r\n char *buff = 0;\r\n FILE *file = 0;\r\n int counter = 0;\r\n int bytes_read = 0;\r\n char *unmaniac_noncadenced = 0;\r\n struct unfeigningly_disinure *slatemaker_restudy = {0};\r\n struct unfeigningly_disinure stagnate_biznagas;\r\n char *rosita_storefront;;\r\n if (__sync_bool_compare_and_swap(&adorn_sempre,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&rosita_storefront,\"PARTLESS_LIONISE\");\r\n if (rosita_storefront != 0) {;\r\n stagnate_biznagas . trollopian_supercharging = ((char *)rosita_storefront);\r\n slatemaker_restudy = &stagnate_biznagas;\r\n unmaniac_noncadenced = ((char *)( *slatemaker_restudy) . trollopian_supercharging);\r\n \r\n buff = ((char *)(malloc(30000 * sizeof(char ))));\r\n if (buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(buff, 0, 30000);\r\n \r\n\r\n to_unsign = get_int_value(unmaniac_noncadenced);\r\n \r\n \r\n \r\n file = fopen(\"/opt//workspace/testData/myfile.txt\",\"r\");\r\n if (file != 0) {\r\n \r\n while (((unsigned int )counter) < to_unsign) {\r\n \r\n bytes_read = fread(&buff[counter],\r\n sizeof(char), 1000, file);\r\n if (bytes_read == 0) {\r\n break;\r\n }\r\n counter += bytes_read;\r\n }\r\n \r\n fclose(file);\r\n buff[to_unsign] = '\\0';\r\n printf(\"buff is %d long, and has contents: %s \\n\",strlen(buff), buff);\r\n } else {\r\n printf(\"Cannot open file %s\\n\", \"/opt//workspace/testData/myfile.txt\");\r\n }\r\n if (buff != 0) {\r\n free(buff);\r\n }\r\n \r\n;\r\n if (( *slatemaker_restudy) . trollopian_supercharging != 0) \r\n free(((char *)( *slatemaker_restudy) . trollopian_supercharging));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` while (((unsigned int )counter) < to_unsign) {\n \n bytes_read = fread(&buff[counter],\n sizeof(char), 1000, file);\n if (bytes_read == 0) {\n break;\n }\n counter += bytes_read;\n }\n```", "cwe": "194"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint ficoides_hornlike = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid requiescat_kryska(char ***forspend_isotype);\r\nvoid cleanup(char **ptrs,int size)\r\n{\r\n int i = 0;\r\n \r\n for (; i < size; ++i) {\r\n if (ptrs[i] != 0) {\r\n free(ptrs[i]);\r\n }\r\n }\r\n}\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\nchar *isAlphaNum(char *str,int size_param)\r\n{\r\n int index = 0;\r\n \r\n for (index = 0; index < size_param; index++) {\r\n if (!isalnum(str[index])) {\r\n \r\n\r\n return 0;\r\n }\r\n }\r\n return str;\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n void (*airths_canman)(char ***) = requiescat_kryska;\r\n char ***hemianacusia_assimilate = 0;\r\n char **undispose_preenlistments = 0;\r\n char *conservancies_darfur = 0;\r\n int consoled_sarky = 45;\r\n char *incongruously_colation;;\r\n if (__sync_bool_compare_and_swap(&ficoides_hornlike,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&incongruously_colation,\"8583\",consoled_sarky);\r\n if (incongruously_colation != 0) {;\r\n undispose_preenlistments = &incongruously_colation;\r\n hemianacusia_assimilate = &undispose_preenlistments;\r\n airths_canman(hemianacusia_assimilate);\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid requiescat_kryska(char ***forspend_isotype)\r\n{\r\n char *contents;\r\n char filename[80];\r\n FILE *file;\r\n FILE **file_list;\r\n FILE *files;\r\n int str_list_index;\r\n char **str_list;\r\n int num_files = 10;\r\n int size;\r\n int ssi = 0;\r\n char *unornateness_metallist = 0;\r\n ++global_variable;;\r\n unornateness_metallist = ((char *)( *( *forspend_isotype)));\r\n \r\n str_list = malloc(sizeof(char *) * num_files);\r\n if (str_list != 0) {\r\n for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\r\n str_list[str_list_index] = 0;\r\n files = fopen(unornateness_metallist,\"rb\");\r\n if (files != 0) {\r\n file_list = malloc(num_files * sizeof(FILE *));\r\n if (file_list == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (ssi = 0; ssi < num_files; ++ssi) {\r\n if (fscanf(files,\"%79s\",filename) == 1) {\r\n file_list[ssi] = fopen(filename,\"rb\");\r\n }\r\n }\r\n ssi = 0;\r\n while(ssi < num_files){\r\n file = file_list[ssi];\r\n if (file == 0) {\r\n ++ssi;\r\n continue;\r\n }\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n contents = malloc((size + 1) * sizeof(char ));\r\n \r\n \r\n if (contents == 0 && errno == 12) {\r\n \r\n printf(\"Malloc error due to ulimit\\n\");\r\n }\r\n if (contents == 0) {\r\n fclose(file);\r\n break;\r\n }\r\n \r\n memset(contents,0,(size + 1) * sizeof(char ));\r\n fread(contents,1,size,file);\r\n \r\n contents = isAlphaNum(contents,size);\r\n \r\n str_list[ssi] = contents;\r\n fclose(file);\r\n ssi++;\r\n }\r\n fclose(files);\r\n if (file_list != 0) {\r\n free(file_list);\r\n }\r\n }\r\n cleanup(str_list,num_files);\r\n free(str_list);\r\n }\r\n \r\n;\r\n if ( *( *forspend_isotype) != 0) \r\n free(((char *)( *( *forspend_isotype))));\r\nclose_printf_context();\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` contents = isAlphaNum(contents,size);\n```", "cwe": "771"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint gluons_bushlet = 0;\r\n\r\nunion sonsy_alocasia \r\n{\r\n char *frenatae_eneugh;\r\n double lecithins_kine;\r\n char *captions_abscess;\r\n char twalpennyworth_meisterstck;\r\n int stupider_spleenwort;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *adjective_diuron);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid laders_bashlyks(int brainlessness_unanalagous,union sonsy_alocasia *myatonic_ingross);\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&gluons_bushlet,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid handle_taint(char *adjective_diuron)\r\n{\r\n int disaugment_gwelo = 7;\r\n int clition_mesoplanktonic;\r\n union sonsy_alocasia *kinaesthetic_savors = {0};\r\n union sonsy_alocasia *trustees_unentreatable = {0};\r\n union sonsy_alocasia osterhus_sanidinic;\r\n ++global_variable;;\r\n if (adjective_diuron != 0) {;\r\n osterhus_sanidinic . frenatae_eneugh = adjective_diuron;\r\n clition_mesoplanktonic = 1;\r\n kinaesthetic_savors = &osterhus_sanidinic;\r\n trustees_unentreatable = ((union sonsy_alocasia *)(((unsigned long )kinaesthetic_savors) * clition_mesoplanktonic * clition_mesoplanktonic)) + 5;\r\n laders_bashlyks(disaugment_gwelo,trustees_unentreatable);\r\n }\r\n}\r\n\r\nvoid laders_bashlyks(int brainlessness_unanalagous,union sonsy_alocasia *myatonic_ingross)\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *spicer_insculptured = 0;\r\n ++global_variable;\r\n brainlessness_unanalagous--;\r\n if (brainlessness_unanalagous > 0) {\r\n laders_bashlyks(brainlessness_unanalagous,myatonic_ingross);\r\n return ;\r\n }\r\n spicer_insculptured = ((char *)( *(myatonic_ingross - 5)) . frenatae_eneugh);\r\n \r\n \r\n\r\n if (strlen(spicer_insculptured) < 63) {\r\n skip_malloc_buffer = malloc(strlen(spicer_insculptured + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,spicer_insculptured);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\n if (( *(myatonic_ingross - 5)) . frenatae_eneugh != 0) \r\n free(((char *)( *(myatonic_ingross - 5)) . frenatae_eneugh));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n strcpy(skip_malloc_buffer,spicer_insculptured);\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <sys/types.h> \r\n#include <unistd.h> \r\nint tealeafy_moccasin = 0;\r\nint global_variable;\r\nvoid acoelomata_drago(char **turm_oregano);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid polysome_breastwood(void (*tennisy_metheglin)(char **));\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n \r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForChange(char* file, char* sleepFile) {\r\n int fd;\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForChange\\n\");\r\n strcat(filename, file);\r\n strcat(filename, \".pid\");\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nint path_is_relative(char *path) {\r\n char *chr = 0;\r\n \r\n chr = strchr(path,'/');\r\n if (chr == 0) {\r\n \r\n printf(\"Path is relative\\n\");\r\n return 1;\r\n } else {\r\n \r\n printf(\"Path is not relative\\n\");\r\n return 0;\r\n }\r\n}\r\nchar * get_absolute_path(char * path) {\r\n char * abs_path = malloc (sizeof(char) * (strlen(\"/opt//workspace/testData/\") * strlen(path) + 1));\r\n \r\n if (abs_path == NULL) {\r\n printf(\"Cannot allocate memory for path\\n\");\r\n } else {\r\n printf(\"Creating absolute path\\n\");\r\n strcpy(abs_path, \"/opt//workspace/testData/\");\r\n strcat(abs_path, path);\r\n }\r\n return abs_path;\r\n}\r\nint isSymLink(char *file) {\r\n struct stat statbuf;\r\n \r\n if (lstat(file, &statbuf) < 0) { \r\n printf(\"Error accessing path.\\n\");\r\n return 1; \r\n }\r\n if (S_ISLNK(statbuf.st_mode) == 1) {\r\n printf(\"Path is symlink.\\n\");\r\n return 1;\r\n }\r\n printf(\"Path is valid.\\n\");\r\n return 0;\r\n}\r\nint path_is_not_symlink(char * abs_path) {\r\n \r\n return (isSymLink(abs_path) == 0);\r\n}\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&tealeafy_moccasin,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n polysome_breastwood(acoelomata_drago);\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nvoid acoelomata_drago(char **turm_oregano)\r\n{\r\n int somas_undercase = 0;\r\n char *technography_validatable = 0;\r\n char *depectible_herakles;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&depectible_herakles,\"PREEXCUSED_NONILLUMINATIVE\");\r\n if (depectible_herakles != 0) {;\r\n somas_undercase = ((int )(strlen(depectible_herakles)));\r\n technography_validatable = ((char *)(malloc(somas_undercase + 1)));\r\n if (technography_validatable == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(technography_validatable,0,somas_undercase + 1);\r\n memcpy(technography_validatable,depectible_herakles,somas_undercase);\r\n if (depectible_herakles != 0) \r\n free(((char *)depectible_herakles));\r\n *turm_oregano = technography_validatable;\r\n }\r\n}\r\n\r\nvoid polysome_breastwood(void (*tennisy_metheglin)(char **))\r\n{\r\n int size = 0;\r\n FILE *file = 0;\r\n char *buffer = 0;\r\n char *str = 0;\r\n char *abs_path = 0;\r\n char *sleep_file = 0;\r\n char *vacciniform_flesher = 0;\r\n char **overruler_corseleted = 0;\r\n char **jagiellonian_scabish = 0;\r\n ++global_variable;\r\n char *reflourish_plectridial = 0;\r\n tennisy_metheglin(&reflourish_plectridial);\r\n if (reflourish_plectridial != 0) {;\r\n overruler_corseleted = &reflourish_plectridial;\r\n jagiellonian_scabish = overruler_corseleted + 5;\r\n vacciniform_flesher = ((char *)( *(jagiellonian_scabish - 5)));\r\n \r\n str = malloc(sizeof(char) * (strlen(vacciniform_flesher) + 1));\r\n sleep_file = malloc(sizeof(char) * (strlen(vacciniform_flesher) + 1));\r\n if (str != NULL && sleep_file != NULL &&\r\n (sscanf(vacciniform_flesher, \"%s %s\",\r\n sleep_file,\r\n str) == 2) &&\r\n (strlen(str) != 0) &&\r\n (strlen(sleep_file) != 0))\r\n {\r\n \r\n \r\n if (path_is_relative(str)) {\r\n abs_path = get_absolute_path(str);\r\n if (abs_path != NULL) {\r\n if (path_is_not_symlink(abs_path)) {\r\n \r\n \r\n waitForChange(abs_path, sleep_file);\r\n file = fopen(abs_path,\"rb\");\r\n \r\n if (file != 0) {\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\r\n if (buffer) {\r\n \r\n \r\n fread(buffer,sizeof(char ),size,file);\r\n buffer[size] = '\\0';\r\n printf(buffer);\r\n fclose(file);\r\n free(buffer);\r\n \r\n }\r\n }\r\n }\r\n free (abs_path);\r\n }\r\n }\r\n free(str);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n;\r\n if ( *(jagiellonian_scabish - 5) != 0) \r\n free(((char *)( *(jagiellonian_scabish - 5))));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fread(buffer,sizeof(char ),size,file);\n buffer[size] = '\\0';\n printf(buffer);\n fclose(file);\n free(buffer);\n```", "cwe": "363"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint endurability_devy = 0;\r\nint global_variable;\r\nvoid handle_taint(char *nullity_petre);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid mumruffin_caped(int convulsiveness_capitalizes,... );\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&endurability_devy,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *nullity_petre)\r\n{\r\n ++global_variable;;\r\n if (nullity_petre != 0) {;\r\n mumruffin_caped(1,nullity_petre);\r\n }\r\n}\r\n\r\nvoid mumruffin_caped(int convulsiveness_capitalizes,... )\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *zambezian_salicylanilide = 0;\r\n char *allochezia_kryska = 0;\r\n va_list skagen_mouthiness;\r\n ++global_variable;;\r\n if (convulsiveness_capitalizes > 0) {\r\n __builtin_va_start(skagen_mouthiness,convulsiveness_capitalizes);\r\n allochezia_kryska = (va_arg(skagen_mouthiness,char *));\r\n __builtin_va_end(skagen_mouthiness);\r\n }\r\n zambezian_salicylanilide = ((char *)allochezia_kryska);\r\n \r\n while(isalnum(zambezian_salicylanilide[size]) && size < strlen(zambezian_salicylanilide)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(zambezian_salicylanilide)) {\r\n zambezian_salicylanilide = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,zambezian_salicylanilide);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (allochezia_kryska != 0) \r\n free(((char *)allochezia_kryska));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,zambezian_salicylanilide);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint predelay_warryn = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid blastogenesis_hephaistos(int retransmits_chemotactically,char *heterotopous_berrendo);\r\nFILE *open_file(char *filename_param)\r\n{\r\n FILE *f;\r\n \r\n \r\n \r\n\r\n\r\n f = fopen(filename_param,\"w\");\r\n \r\n \r\n if (!f)\r\n return 0;\r\n else\r\n return f;\r\n fclose(f);\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int mediastinotomy_downbent = 7;\r\n char *diamonded_shedding = 0;\r\n int *trichinoid_aspersory = 0;\r\n int craking_sextern;\r\n char *neb_lekane[10] = {0};\r\n int csnet_giuseppe = 0;\r\n char *solipsism_thatd = 0;\r\n char *sebastianite_disorientate;;\r\n if (__sync_bool_compare_and_swap(&predelay_warryn,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n sebastianite_disorientate = getenv(\"MOONBLINK_DESUGARS\");\r\n if (sebastianite_disorientate != 0) {;\r\n csnet_giuseppe = ((int )(strlen(sebastianite_disorientate)));\r\n solipsism_thatd = ((char *)(malloc(csnet_giuseppe + 1)));\r\n if (solipsism_thatd == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(solipsism_thatd,0,csnet_giuseppe + 1);\r\n memcpy(solipsism_thatd,sebastianite_disorientate,csnet_giuseppe);\r\n neb_lekane[5] = solipsism_thatd;\r\n craking_sextern = 5;\r\n trichinoid_aspersory = &craking_sextern;\r\n diamonded_shedding = *(neb_lekane + *trichinoid_aspersory);\r\n blastogenesis_hephaistos(mediastinotomy_downbent,diamonded_shedding);\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid blastogenesis_hephaistos(int retransmits_chemotactically,char *heterotopous_berrendo)\r\n{\r\n char * filename = 0;\r\n int filename_len = 0;\r\n unsigned int num_files;\r\n FILE **filearray;\r\n int i;\r\n char *lurers_grubhood = 0;\r\n ++global_variable;\r\n retransmits_chemotactically--;\r\n if (retransmits_chemotactically > 0) {\r\n blastogenesis_hephaistos(retransmits_chemotactically,heterotopous_berrendo);\r\n return ;\r\n }\r\n lurers_grubhood = ((char *)heterotopous_berrendo);\r\n \r\n if (strlen(lurers_grubhood) > 0 &&\r\n lurers_grubhood[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n printf(\"Getting input value\\n\");\r\n num_files = strtoul(lurers_grubhood,0,16);\r\n if (num_files > 0xffff)\r\n num_files = 0;\r\n filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\r\n filename_len = strlen(\"/opt//workspace/testData/temp\") + 10;\r\n filename = (char*) malloc(filename_len * sizeof(char));\r\n if (filearray != 0) {\r\n for (i = 0; i < num_files; ++i)\r\n filearray[i] = 0;\r\n printf(\"Creating files\\n\");\r\n for (i = 0; i < num_files; ++i) {\r\n snprintf(filename,filename_len,\"%s_%08x\", \"/opt//workspace/testData/temp\", i);\r\n filearray[i] = open_file(filename);\r\n if (filearray[i] == 0)\r\n break;\r\n }\r\n if (i < num_files)\r\n printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\r\n for (i = 0; i < num_files; ++i)\r\n if (filearray[i] != 0)\r\n fclose(filearray[i]);\r\n free(filearray);\r\n free(filename);\r\n }\r\n }\r\n \r\n;\r\n if (heterotopous_berrendo != 0) \r\n free(((char *)heterotopous_berrendo));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n\n f = fopen(filename_param,\"w\");\n```", "cwe": "774"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint sentition_coolin = 0;\r\n\r\nstruct nonsignatories_myophan \r\n{\r\n char *diplotaxis_glassworks;\r\n double triacetate_beastbane;\r\n char *sleepyeye_syconoid;\r\n char saitic_catalaunian;\r\n int pinnisected_pteridologist;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *araise_enalite = 0;\r\n struct nonsignatories_myophan *jooss_misogyne = {0};\r\n struct nonsignatories_myophan matchable_moonshiny;\r\n char *drillstock_boomtown;\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&sentition_coolin,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n drillstock_boomtown = getenv(\"UNURGING_LOON\");\r\n if (drillstock_boomtown != 0) {;\r\n matchable_moonshiny . diplotaxis_glassworks = ((char *)drillstock_boomtown);\r\n jooss_misogyne = &matchable_moonshiny;\r\n araise_enalite = ((char *)( *jooss_misogyne) . diplotaxis_glassworks);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(araise_enalite) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (araise_enalite[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &araise_enalite[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint lesli_endangered = 0;\r\n\r\nunion mucocellulosic_seated \r\n{\r\n char *classicalities_perioesophageal;\r\n double coxiest_conductive;\r\n char *tinamidae_diastatically;\r\n char urartic_defalcator;\r\n int macrobius_acephalina;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar process_buffer(char *buffer_param)\r\n{\r\n \r\n char first_char;\r\n first_char = buffer_param[0] - 97;\r\n free(buffer_param);\r\n return first_char;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n char *buffer = 0;\r\n char *pruss_bibliopolic = 0;\r\n jmp_buf situationally_alexanders;\r\n int haithal_nobel;\r\n union mucocellulosic_seated tweedles_quomodos = {0};\r\n int **********cheirotherium_carbin = 0;\r\n int *********proscolex_sensitivenesses = 0;\r\n int ********eyewinks_nonnational = 0;\r\n int *******bondland_pua = 0;\r\n int ******subofficer_diffusive = 0;\r\n int *****pterographic_aglisten = 0;\r\n int ****palmiped_stercorean = 0;\r\n int ***kairotic_inblow = 0;\r\n int **decomposure_roseville = 0;\r\n int *transhuman_highted = 0;\r\n int lobuli_entremess;\r\n union mucocellulosic_seated majestical_overmuches[10] = {0};\r\n union mucocellulosic_seated tires_yaakov;\r\n int zeugobranchia_overbar = 44;\r\n char *axiolite_scumboard;;\r\n if (__sync_bool_compare_and_swap(&lesli_endangered,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&axiolite_scumboard,\"2674\",zeugobranchia_overbar);\r\n if (axiolite_scumboard != 0) {;\r\n tires_yaakov . classicalities_perioesophageal = axiolite_scumboard;\r\n lobuli_entremess = 5;\r\n transhuman_highted = &lobuli_entremess;\r\n decomposure_roseville = &transhuman_highted;\r\n kairotic_inblow = &decomposure_roseville;\r\n palmiped_stercorean = &kairotic_inblow;\r\n pterographic_aglisten = &palmiped_stercorean;\r\n subofficer_diffusive = &pterographic_aglisten;\r\n bondland_pua = &subofficer_diffusive;\r\n eyewinks_nonnational = &bondland_pua;\r\n proscolex_sensitivenesses = &eyewinks_nonnational;\r\n cheirotherium_carbin = &proscolex_sensitivenesses;\r\n majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))] = tires_yaakov;\r\n tweedles_quomodos = majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))];\r\n haithal_nobel = setjmp(situationally_alexanders);\r\n if (haithal_nobel == 0) {\r\n longjmp(situationally_alexanders,1);\r\n }\r\n pruss_bibliopolic = ((char *)tweedles_quomodos . classicalities_perioesophageal);\r\n \r\n buffer = malloc((strlen(pruss_bibliopolic) + 1) * sizeof(char ));\r\n if (buffer == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(buffer,pruss_bibliopolic);\r\n \r\n \r\n if (buffer[0] >= 97) {\r\n printf(\"Index of first char: %i\\n\",process_buffer(buffer));\r\n }\r\n \r\n if (buffer != 0) {\r\n \r\n \r\n free(buffer);\r\n \r\n }\r\n \r\n;\r\n if (tweedles_quomodos . classicalities_perioesophageal != 0) \r\n free(((char *)tweedles_quomodos . classicalities_perioesophageal));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n free(buffer);\n```", "cwe": "415"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint coronatorial_totality = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar **waff_entree(char **minim_osler);\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *recouper_nazdrowie = 0;\r\n jmp_buf protocolist_substraction;\r\n int handloomed_toasters;\r\n char **biclinia_olympionic = 0;\r\n char *endrin_precondition[80] = {0};\r\n char *unruled_terraciform;\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&coronatorial_totality,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&unruled_terraciform,\"DBRN_HYALESCENT\");\r\n if (unruled_terraciform != 0) {;\r\n endrin_precondition[32] = unruled_terraciform;\r\n biclinia_olympionic = waff_entree(endrin_precondition);\r\n handloomed_toasters = setjmp(protocolist_substraction);\r\n if (handloomed_toasters == 0) {\r\n longjmp(protocolist_substraction,1);\r\n }\r\n recouper_nazdrowie = ((char *)biclinia_olympionic[32]);\r\n \r\n len = strtol(recouper_nazdrowie,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (biclinia_olympionic[32] != 0) \r\n free(((char *)biclinia_olympionic[32]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nchar **waff_entree(char **minim_osler)\r\n{\r\n ++global_variable;\r\n return minim_osler;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint boser_estradas = 0;\r\nint global_variable;\r\nvoid preachily_miteproof(void **outwept_wheelwrighting);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid nitromannitol_saturdays(void (*jumart_nonsupporting)(void **));\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\nstruct struct {\r\n char buffer[8];\r\n char * buff_pointer;\r\n};\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&boser_estradas,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n nitromannitol_saturdays(preachily_miteproof);\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid preachily_miteproof(void **outwept_wheelwrighting)\r\n{\r\n void *untasteable_palmyra = 0;\r\n int disinterring_hewitt = 53;\r\n char *bics_hektograph;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&bics_hektograph,\"4362\",disinterring_hewitt);\r\n if (bics_hektograph != 0) {;\r\n untasteable_palmyra = ((void *)bics_hektograph);\r\n *outwept_wheelwrighting = untasteable_palmyra;\r\n }\r\n}\r\n\r\nvoid nitromannitol_saturdays(void (*jumart_nonsupporting)(void **))\r\n{\r\n int oc_i = 0;\r\n int ptr_deref;\r\n struct struct data;\r\n char *oursels_prothallic = 0;\r\n void **dermas_vassalism = 0;\r\n void **wherefore_chromite = 0;\r\n ++global_variable;\r\n void *bemadams_depressants = 0;\r\n jumart_nonsupporting(&bemadams_depressants);\r\n if (((char *)bemadams_depressants) != 0) {;\r\n dermas_vassalism = &bemadams_depressants;\r\n wherefore_chromite = dermas_vassalism + 5;\r\n oursels_prothallic = ((char *)((char *)( *(wherefore_chromite - 5))));\r\n \r\n data.buff_pointer = data.buffer;\r\n \r\n \r\n \r\n \r\n \r\n strncpy(data.buffer, oursels_prothallic, strlen(oursels_prothallic) + 1);\r\n ptr_deref = strlen( data.buff_pointer);\r\n for (; oc_i < ptr_deref; ++oc_i) {\r\n data.buffer[oc_i] = toupper(data.buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\", data.buffer);\r\n \r\n \r\n \r\n;\r\n if (((char *)( *(wherefore_chromite - 5))) != 0) \r\n free(((char *)((char *)( *(wherefore_chromite - 5)))));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n strncpy(data.buffer, oursels_prothallic, strlen(oursels_prothallic) + 1);\n ptr_deref = strlen( data.buff_pointer);\n for (; oc_i < ptr_deref; ++oc_i) {\n data.buffer[oc_i] = toupper(data.buffer[oc_i]);\n }\n printf(\"%s\\n\", data.buffer);\n```", "cwe": "805"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint centrad_author = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid renownful_worricow(int travestiment_saffell,... );\r\nvoid targetlike_xiphiplastron(char **syneidesis_downplays);\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n char *undyingly_agnoite[28] = {0};\r\n int semipassively_divagations = 66;\r\n char *milburn_subgeniculation;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&centrad_author,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&milburn_subgeniculation,\"4125\",semipassively_divagations);\r\n if (milburn_subgeniculation != 0) {;\r\n undyingly_agnoite[0] = milburn_subgeniculation;\r\n renownful_worricow(1,undyingly_agnoite);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#define FAUSANT_NONCADENT(x) targetlike_xiphiplastron((char **) x)\r\n\r\nvoid renownful_worricow(int travestiment_saffell,... )\r\n{\r\n char **polytheism_blockheadedly = 0;\r\n va_list lichenivorous_nitriding;\r\n ++global_variable;;\r\n if (travestiment_saffell > 0) {\r\n __builtin_va_start(lichenivorous_nitriding,travestiment_saffell);\r\n polytheism_blockheadedly = (va_arg(lichenivorous_nitriding,char **));\r\n __builtin_va_end(lichenivorous_nitriding);\r\n }\r\n\tFAUSANT_NONCADENT(polytheism_blockheadedly);\r\n}\r\n\r\nvoid targetlike_xiphiplastron(char **syneidesis_downplays)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *reevaluate_outwatching = 0;\r\n ++global_variable;;\r\n reevaluate_outwatching = ((char *)syneidesis_downplays[0]);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(reevaluate_outwatching) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (reevaluate_outwatching[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &reevaluate_outwatching[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\n if (syneidesis_downplays[0] != 0) \r\n free(((char *)syneidesis_downplays[0]));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint dunseith_retepore = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid cleanup(char **ptrs,int size)\r\n{\r\n int i = 0;\r\n \r\n for (; i < size; ++i) {\r\n if (ptrs[i] != 0) {\r\n free(ptrs[i]);\r\n }\r\n }\r\n}\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\nchar *isAlphaNum(char *str,int size_param)\r\n{\r\n int index = 0;\r\n \r\n for (index = 0; index < size_param; index++) {\r\n if (!isalnum(str[index])) {\r\n \r\n\r\n return 0;\r\n }\r\n }\r\n return str;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n char *contents;\r\n char filename[80];\r\n FILE *file;\r\n FILE **file_list;\r\n FILE *files;\r\n int str_list_index;\r\n char **str_list;\r\n int num_files = 10;\r\n int size;\r\n int ssi = 0;\r\n char *pitkin_martyrer = 0;\r\n jmp_buf benia_ruller;\r\n int miscolour_woodhouse;\r\n char **unjarring_paralogician = 0;\r\n int **innocuously_organoid = 0;\r\n int *beadiest_anglings = 0;\r\n int transpiercing_bullfrog;\r\n char **stable_hairpiece[10] = {0};\r\n char *shrubland_dissyllabised[66] = {0};\r\n char *gravida_timesaver;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&dunseith_retepore,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n gravida_timesaver = getenv(\"NEEDLEBILL_RITZES\");\r\n if (gravida_timesaver != 0) {;\r\n shrubland_dissyllabised[14] = gravida_timesaver;\r\n transpiercing_bullfrog = 5;\r\n beadiest_anglings = &transpiercing_bullfrog;\r\n innocuously_organoid = &beadiest_anglings;\r\n stable_hairpiece[ *( *innocuously_organoid)] = shrubland_dissyllabised;\r\n unjarring_paralogician = stable_hairpiece[ *( *innocuously_organoid)];\r\n miscolour_woodhouse = setjmp(benia_ruller);\r\n if (miscolour_woodhouse == 0) {\r\n longjmp(benia_ruller,1);\r\n }\r\n pitkin_martyrer = ((char *)unjarring_paralogician[14]);\r\n \r\n str_list = malloc(sizeof(char *) * num_files);\r\n if (str_list != 0) {\r\n for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\r\n str_list[str_list_index] = 0;\r\n files = fopen(pitkin_martyrer,\"rb\");\r\n if (files != 0) {\r\n file_list = malloc(num_files * sizeof(FILE *));\r\n if (file_list == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (ssi = 0; ssi < num_files; ++ssi) {\r\n if (fscanf(files,\"%79s\",filename) == 1) {\r\n file_list[ssi] = fopen(filename,\"rb\");\r\n }\r\n }\r\n ssi = 0;\r\n while(ssi < num_files){\r\n file = file_list[ssi];\r\n if (file == 0) {\r\n ++ssi;\r\n continue;\r\n }\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n contents = malloc((size + 1) * sizeof(char ));\r\n \r\n \r\n if (contents == 0 && errno == 12) {\r\n \r\n printf(\"Malloc error due to ulimit\\n\");\r\n }\r\n if (contents == 0) {\r\n fclose(file);\r\n break;\r\n }\r\n \r\n memset(contents,0,(size + 1) * sizeof(char ));\r\n fread(contents,1,size,file);\r\n \r\n contents = isAlphaNum(contents,size);\r\n \r\n str_list[ssi] = contents;\r\n fclose(file);\r\n ssi++;\r\n }\r\n fclose(files);\r\n if (file_list != 0) {\r\n free(file_list);\r\n }\r\n }\r\n cleanup(str_list,num_files);\r\n free(str_list);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` contents = isAlphaNum(contents,size);\n```", "cwe": "771"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <sys/stat.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint ungrow_noiselessly = 0;\r\n\r\nunion gibbert_obstructively \r\n{\r\n char *moslems_delsman;\r\n double drammach_lorriker;\r\n char *abolishing_humbugs;\r\n char yttriums_coniothyrium;\r\n int uncongeal_tinter;\r\n}\r\n;\r\nint global_variable;\r\nvoid enforcers_stretchy(union gibbert_obstructively *heterogenous_appay);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid underbedding_fictionize(void (*caricature_bitter)(union gibbert_obstructively *));\r\nunion gibbert_obstructively ascii_unrestrictive(union gibbert_obstructively languageless_pgnttrp);\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&ungrow_noiselessly,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n underbedding_fictionize(enforcers_stretchy);\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\n\r\nvoid enforcers_stretchy(union gibbert_obstructively *heterogenous_appay)\r\n{\r\n union gibbert_obstructively canty_streptobacillus;\r\n char *concupy_bogarde;\r\n ++global_variable;;\r\n setup_printf_context();\r\n concupy_bogarde = getenv(\"SKEED_BROOCHED\");\r\n if (concupy_bogarde != 0) {;\r\n canty_streptobacillus . moslems_delsman = concupy_bogarde;\r\n *heterogenous_appay = canty_streptobacillus;\r\n }\r\n}\r\n\r\nvoid underbedding_fictionize(void (*caricature_bitter)(union gibbert_obstructively *))\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *unpuritanical_illiopolis = 0;\r\n union gibbert_obstructively vishnuite_escapees = {0};\r\n ++global_variable;\r\n union gibbert_obstructively dihydroxy_stalkiest = {0};\r\n caricature_bitter(&dihydroxy_stalkiest);\r\n if (dihydroxy_stalkiest . moslems_delsman != 0) {;\r\n vishnuite_escapees = ascii_unrestrictive(dihydroxy_stalkiest);\r\n unpuritanical_illiopolis = ((char *)vishnuite_escapees . moslems_delsman);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",unpuritanical_illiopolis);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nunion gibbert_obstructively ascii_unrestrictive(union gibbert_obstructively languageless_pgnttrp)\r\n{\r\n ++global_variable;\r\n return languageless_pgnttrp;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nint obelize_interregal = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nstruct data {\r\n int inc_amount;\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcIncamount(void *data) {\r\n struct data *dataStruct = (struct data*)data;\r\n printf(\"In calcInamount\\n\");\r\n \r\n \r\n \r\n dataStruct->inc_amount = dataStruct->data[0] - 'A'; \r\n \r\n readFile(dataStruct->file2);\r\n if (dataStruct->inc_amount < 0) { \r\n dataStruct->inc_amount *= -1; \r\n }\r\n else if (dataStruct->inc_amount == 0) { \r\n dataStruct->inc_amount += 1;\r\n }\r\n \r\n \r\n return NULL;\r\n}\r\nvoid *toPound(void *data) {\r\n int i;\r\n struct data *dataStruct = (struct data*)data;\r\n int *arr = NULL;\r\n \r\n printf(\"In toPound\\n\");\r\n \r\n arr = malloc(sizeof(int) * dataStruct->qsize);\r\n for (i = 0; i < dataStruct->qsize; i++) {\r\n arr[i] = dataStruct->qsize - i;\r\n }\r\n qsort(arr, dataStruct->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(dataStruct->file1);\r\n \r\n \r\n \r\n for (i = 0; i < (int)strlen(dataStruct->data) - 1;\r\n i += dataStruct->inc_amount) \r\n {\r\n dataStruct->data[i] = '#'; \r\n }\r\n \r\n return NULL;\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n pthread_t t0, t1;\r\n struct data *dataStruct = malloc(sizeof(struct data));\r\n char *royalists_vitalist = 0;\r\n char **turkman_strander = 0;\r\n int **sagittarius_richeting = 0;\r\n int *liquidates_inarguable = 0;\r\n int rosa_dipterad;\r\n char **bioclimatician_popularised[10] = {0};\r\n char *strychnia_gamine[59] = {0};\r\n char *philodoxer_tincturing;;\r\n if (__sync_bool_compare_and_swap(&obelize_interregal,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n philodoxer_tincturing = getenv(\"RUBICAN_WOFT\");\r\n if (philodoxer_tincturing != 0) {;\r\n strychnia_gamine[30] = philodoxer_tincturing;\r\n rosa_dipterad = 5;\r\n liquidates_inarguable = &rosa_dipterad;\r\n sagittarius_richeting = &liquidates_inarguable;\r\n bioclimatician_popularised[ *( *sagittarius_richeting)] = strychnia_gamine;\r\n turkman_strander = bioclimatician_popularised[ *( *sagittarius_richeting)];\r\n royalists_vitalist = ((char *)turkman_strander[30]);\r\n \r\n if (dataStruct) {\r\n dataStruct->inc_amount = 1;\r\n dataStruct->data = malloc(sizeof(char) * (strlen(royalists_vitalist) + 1));\r\n dataStruct->file1 = malloc(sizeof(char) * (strlen(royalists_vitalist) + 1));\r\n dataStruct->file2 = malloc(sizeof(char) * (strlen(royalists_vitalist) + 1));\r\n if (dataStruct->data) {\r\n if ((sscanf(royalists_vitalist, \"%d %s %s %s\",\r\n &(dataStruct->qsize),\r\n dataStruct->file1,\r\n dataStruct->file2,\r\n dataStruct->data) == 4) &&\r\n (strlen(dataStruct->data) != 0) &&\r\n (strlen(dataStruct->file1) != 0) &&\r\n (strlen(dataStruct->file2) != 0)) {\r\n \r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\r\n printf(\"Error initializing thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n }\r\n free(dataStruct->data);\r\n } else {\r\n \r\n printf(\"Error parsing data.\\n\");\r\n }\r\n free (dataStruct);\r\n } else {\r\n \r\n printf(\"Error malloc()ing space for struct.\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n i += dataStruct->inc_amount) \n {\n dataStruct->data[i] = '#'; \n }\n```", "cwe": "820"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nint tauricornous_chancelled = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nstruct data {\r\n int inc_amount;\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcIncamount(void *data) {\r\n struct data *dataStruct = (struct data*)data;\r\n printf(\"In calcInamount\\n\");\r\n \r\n \r\n \r\n dataStruct->inc_amount = dataStruct->data[0] - 'A'; \r\n \r\n readFile(dataStruct->file2);\r\n if (dataStruct->inc_amount < 0) { \r\n dataStruct->inc_amount *= -1; \r\n }\r\n else if (dataStruct->inc_amount == 0) { \r\n dataStruct->inc_amount += 1;\r\n }\r\n \r\n \r\n return NULL;\r\n}\r\nvoid *toPound(void *data) {\r\n int i;\r\n struct data *dataStruct = (struct data*)data;\r\n int *arr = NULL;\r\n \r\n printf(\"In toPound\\n\");\r\n \r\n arr = malloc(sizeof(int) * dataStruct->qsize);\r\n for (i = 0; i < dataStruct->qsize; i++) {\r\n arr[i] = dataStruct->qsize - i;\r\n }\r\n qsort(arr, dataStruct->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(dataStruct->file1);\r\n \r\n \r\n \r\n for (i = 0; i < (int)strlen(dataStruct->data) - 1;\r\n i += dataStruct->inc_amount) \r\n {\r\n dataStruct->data[i] = '#'; \r\n }\r\n \r\n return NULL;\r\n}\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n pthread_t t0, t1;\r\n struct data *dataStruct = malloc(sizeof(struct data));\r\n char *morriston_desalinator = 0;\r\n jmp_buf indophilism_recitement;\r\n int anotia_cultirostres;\r\n int skywriting_episodical;\r\n char **homorganic_tsaritza = 0;\r\n char **amt_disquisiting = 0;\r\n int vivisecting_remaindered = 149;\r\n char *unopportuneness_illustriousness;\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&tauricornous_chancelled,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&unopportuneness_illustriousness,\"8119\",vivisecting_remaindered);\r\n if (unopportuneness_illustriousness != 0) {;\r\n skywriting_episodical = 1;\r\n homorganic_tsaritza = &unopportuneness_illustriousness;\r\n amt_disquisiting = ((char **)(((unsigned long )homorganic_tsaritza) * skywriting_episodical * skywriting_episodical)) + 5;\r\n anotia_cultirostres = setjmp(indophilism_recitement);\r\n if (anotia_cultirostres == 0) {\r\n longjmp(indophilism_recitement,1);\r\n }\r\n morriston_desalinator = ((char *)( *(amt_disquisiting - 5)));\r\n \r\n if (dataStruct) {\r\n dataStruct->inc_amount = 1;\r\n dataStruct->data = malloc(sizeof(char) * (strlen(morriston_desalinator) + 1));\r\n dataStruct->file1 = malloc(sizeof(char) * (strlen(morriston_desalinator) + 1));\r\n dataStruct->file2 = malloc(sizeof(char) * (strlen(morriston_desalinator) + 1));\r\n if (dataStruct->data) {\r\n if ((sscanf(morriston_desalinator, \"%d %s %s %s\",\r\n &(dataStruct->qsize),\r\n dataStruct->file1,\r\n dataStruct->file2,\r\n dataStruct->data) == 4) &&\r\n (strlen(dataStruct->data) != 0) &&\r\n (strlen(dataStruct->file1) != 0) &&\r\n (strlen(dataStruct->file2) != 0)) {\r\n \r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\r\n printf(\"Error initializing thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n }\r\n free(dataStruct->data);\r\n } else {\r\n \r\n printf(\"Error parsing data.\\n\");\r\n }\r\n free (dataStruct);\r\n } else {\r\n \r\n printf(\"Error malloc()ing space for struct.\\n\");\r\n }\r\n \r\n;\r\n if ( *(amt_disquisiting - 5) != 0) \r\n free(((char *)( *(amt_disquisiting - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n i += dataStruct->inc_amount) \n {\n dataStruct->data[i] = '#'; \n }\n```", "cwe": "820"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <sys/stat.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint ethnobotanic_pullup = 0;\r\n\r\nstruct syntechnic_prelabor \r\n{\r\n char *hee_manichee;\r\n double teethiest_pyrola;\r\n char *bohlen_tussy;\r\n char breeding_greater;\r\n int uncongratulate_jerl;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *farleigh_rosemaria);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid pupated_morrenian(struct syntechnic_prelabor *forlay_starful);\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForChange(char* file, char* sleepFile) {\r\n int fd;\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForChange\\n\");\r\n strcat(filename, file);\r\n strcat(filename, \".pid\");\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n \r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nint is_valid(char *path)\r\n{\r\n \r\n if(access(path, F_OK) != -1) {\r\n \r\n printf(\"Path is accessible\\n\");\r\n return 1;\r\n }\r\n \r\n printf(\"Path is not accessible\\n\");\r\n return 0;\r\n}\r\nint path_is_relative(char *path) {\r\n char *chr = 0;\r\n \r\n chr = strchr(path,'/');\r\n if (chr == 0) {\r\n printf(\"Path is relative\\n\");\r\n return 1;\r\n } else {\r\n printf(\"Path is not relative\\n\");\r\n return 0;\r\n }\r\n}\r\nchar * get_absolute_path(char * path) {\r\n char * abs_path = malloc (sizeof(char) * (strlen(\"/opt//workspace/testData/\") * strlen(path) + 1));\r\n \r\n if (abs_path == NULL) {\r\n \r\n printf(\"Cannot allocate memory for path\\n\");\r\n } else {\r\n printf(\"Creating absolute path\\n\");\r\n strcpy(abs_path, \"/opt//workspace/testData/\");\r\n \r\n strcat(abs_path, path);\r\n }\r\n return abs_path;\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&ethnobotanic_pullup,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\n\r\nvoid handle_taint(char *farleigh_rosemaria)\r\n{\r\n void (*streptocarpus_umpteenth)(struct syntechnic_prelabor *) = pupated_morrenian;\r\n int josser_sukkoth;\r\n struct syntechnic_prelabor *mulla_collotype = {0};\r\n struct syntechnic_prelabor *titleless_hugeous = {0};\r\n struct syntechnic_prelabor dishwiping_courtland;\r\n ++global_variable;;\r\n if (farleigh_rosemaria != 0) {;\r\n dishwiping_courtland . hee_manichee = ((char *)farleigh_rosemaria);\r\n josser_sukkoth = 1;\r\n mulla_collotype = &dishwiping_courtland;\r\n titleless_hugeous = ((struct syntechnic_prelabor *)(((unsigned long )mulla_collotype) * josser_sukkoth * josser_sukkoth)) + 5;\r\n streptocarpus_umpteenth(titleless_hugeous);\r\n }\r\n}\r\n\r\nvoid pupated_morrenian(struct syntechnic_prelabor *forlay_starful)\r\n{\r\n int size = 0;\r\n FILE *file = 0;\r\n char *buffer = 0;\r\n char *str = 0;\r\n char *abs_path = 0;\r\n char *sleep_file = 0;\r\n char *postcavae_polishing = 0;\r\n ++global_variable;;\r\n postcavae_polishing = ((char *)( *(forlay_starful - 5)) . hee_manichee);\r\n \r\n str = malloc(sizeof(char) * (strlen(postcavae_polishing) + 1));\r\n sleep_file = malloc(sizeof(char) * (strlen(postcavae_polishing) + 1));\r\n if (str != NULL && sleep_file != NULL &&\r\n (sscanf(postcavae_polishing, \"%s %s\",\r\n sleep_file,\r\n str) == 2) &&\r\n (strlen(str) != 0) &&\r\n (strlen(sleep_file) != 0))\r\n {\r\n \r\n \r\n if (path_is_relative(str)) {\r\n abs_path = get_absolute_path(str);\r\n if (abs_path != NULL) {\r\n if (is_valid(abs_path)) {\r\n \r\n \r\n waitForChange(abs_path, sleep_file);\r\n \r\n \r\n \r\n file = fopen(abs_path,\"rb\");\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\r\n if (buffer != NULL) {\r\n fread(buffer,sizeof(char ),size,file);\r\n buffer[size] = '\\0';\r\n printf(buffer);\r\n free(buffer);\r\n }\r\n \r\n fclose(file);\r\n }\r\n }\r\n free(abs_path);\r\n }\r\n free(str);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n;\r\n if (( *(forlay_starful - 5)) . hee_manichee != 0) \r\n free(((char *)( *(forlay_starful - 5)) . hee_manichee));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n file = fopen(abs_path,\"rb\");\n fseek(file,0,2);\n size = ftell(file);\n rewind(file);\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\n if (buffer != NULL) {\n fread(buffer,sizeof(char ),size,file);\n buffer[size] = '\\0';\n printf(buffer);\n free(buffer);\n }\n```", "cwe": "367"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint strockle_unneeded = 0;\r\nint global_variable;\r\ntypedef char *yarwhip_collutorium;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *occulting_arisaema = 0;\r\n yarwhip_collutorium blackies_nairn = 0;\r\n int *adelphoi_toponymist = 0;\r\n int disputatious_nonmathematic;\r\n yarwhip_collutorium prelectress_lysogen[10] = {0};\r\n yarwhip_collutorium hydromedusa_bangwaketsi = 0;\r\n int eurodollars_sepulchers = 30;\r\n char *laxifolious_kokaras;;\r\n if (__sync_bool_compare_and_swap(&strockle_unneeded,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&laxifolious_kokaras,\"6151\",eurodollars_sepulchers);\r\n if (laxifolious_kokaras != 0) {;\r\n hydromedusa_bangwaketsi = laxifolious_kokaras;\r\n prelectress_lysogen[5] = hydromedusa_bangwaketsi;\r\n disputatious_nonmathematic = 5;\r\n adelphoi_toponymist = &disputatious_nonmathematic;\r\n blackies_nairn = *(prelectress_lysogen + *adelphoi_toponymist);\r\n if (blackies_nairn != 0) {\r\n goto rheotrope_throngful;\r\n }\r\n ++global_variable;\r\n rheotrope_throngful:;\r\n occulting_arisaema = ((char *)blackies_nairn);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",occulting_arisaema);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (blackies_nairn != 0) \r\n free(((char *)blackies_nairn));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint noncongenital_levining = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid tipula_chinwag(char **overtill_bicolour);\r\nstruct data {\r\n int qsize;\r\n char *file1;\r\n char *file2;\r\n char *data;\r\n int data_size;\r\n};\r\npthread_t t0, t1;\r\nsem_t sem;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n}\r\nvoid *to1337(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int qsize;\r\n int random;\r\n char temp;\r\n char *temp_str;\r\n int i = 0;\r\n int *arr;\r\n int semValue = 0;\r\n \r\n printf(\"Entering to1337\\n\");\r\n \r\n arr = malloc(sizeof(int)*Data->qsize);\r\n if (arr != NULL) {\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free (arr);\r\n arr = NULL;\r\n }\r\n temp_str = malloc(sizeof(char)*(Data->data_size + 1));\r\n qsize = Data->qsize;\r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n sem_wait(&sem);\r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n random = (int)(rand() / (double)RAND_MAX + 0.5); \r\n switch(Data->data[i]) { \r\n case 'c':\r\n if (random == 0)\r\n temp = '<';\r\n else\r\n temp = 'c';\r\n break;\r\n case 'e':\r\n if (random == 0)\r\n temp = '3';\r\n else\r\n temp = 'e';\r\n break;\r\n case 'i':\r\n if (random == 0)\r\n temp = '1';\r\n else\r\n temp = 'i';\r\n break;\r\n case 'l':\r\n if (random == 0)\r\n temp = '1';\r\n else\r\n temp = 'l';\r\n break;\r\n case 'o':\r\n if (random == 0)\r\n temp = '0';\r\n else\r\n temp = 'o';\r\n break;\r\n case 's':\r\n if (random == 0)\r\n temp = '5';\r\n else\r\n temp = 's';\r\n break;\r\n case 't':\r\n if (random == 0)\r\n temp = '7';\r\n else\r\n temp = 't';\r\n break;\r\n default:\r\n temp = Data->data[i];\r\n break;\r\n }\r\n temp_str[i] = temp;\r\n i++;\r\n }\r\n temp_str[i] = '\\0';\r\n free(Data->data);\r\n Data->data = NULL; \r\n \r\n printf(\"Set ptr to null\\n\");\r\n \r\n \r\n readFile(Data->file2);\r\n \r\n printf(\"Set ptr to NON null\\n\");\r\n Data->data = temp_str;\r\n \r\n \r\n sem_post(&sem);\r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n return NULL;\r\n}\r\nvoid *reverseStr(void * data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n char *temp_str;\r\n int semValue = 0;\r\n \r\n printf(\"Entering reverseStr\\n\");\r\n \r\n readFile(Data->file1);\r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n sem_wait(&sem); \r\n \r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n temp_str = malloc(sizeof(char)* (Data->data_size + 1));\r\n \r\n \r\n for (i = 0; i < Data->data_size; i++) {\r\n \r\n printf(\"Dereferencing ptr\\n\");\r\n temp_str[Data->data_size - 1 - i] = Data->data[i]; \r\n }\r\n \r\n temp_str[Data->data_size] = '\\0';\r\n free(Data->data);\r\n Data->data = NULL;\r\n Data->data = temp_str;\r\n \r\n sem_post(&sem);\r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n return NULL;\r\n}\r\nvoid toLower (struct data * Data) {\r\n int i = 0;\r\n int semValue = 0;\r\n \r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n sem_wait(&sem);\r\n printf(\"Entering toLower\\n\");\r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n for (i = 0; i < strlen(Data->data) - 1; i++) { \r\n if (Data->data[i] >= 'A' &&\r\n Data->data[i] <= 'Z') {\r\n Data->data[i] += 32;\r\n }\r\n }\r\n \r\n sem_post(&sem);\r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n \r\n \r\n \r\n sem_post(&sem); \r\n sem_getvalue(&sem, &semValue);\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n void (*zodiacs_innocuously)(char **) = tipula_chinwag;\r\n char **quatenus_bullionist = 0;\r\n long woodhouse_drahthaar[10];\r\n char **cathectic_hitchproof[10] = {0};\r\n char *corpuscle_infraposition[98] = {0};\r\n char *malinois_reacquainting;;\r\n if (__sync_bool_compare_and_swap(&noncongenital_levining,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n malinois_reacquainting = getenv(\"NARES_FOOLISHNESSES\");\r\n if (malinois_reacquainting != 0) {;\r\n corpuscle_infraposition[44] = malinois_reacquainting;\r\n cathectic_hitchproof[5] = corpuscle_infraposition;\r\n woodhouse_drahthaar[1] = 5;\r\n quatenus_bullionist = *(cathectic_hitchproof + woodhouse_drahthaar[1]);\r\n zodiacs_innocuously(quatenus_bullionist);\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid tipula_chinwag(char **overtill_bicolour)\r\n{\r\n int hasCap = 0;\r\n int i = 0;\r\n struct data *Data;\r\n char *ramillie_soundheaded = 0;\r\n ++global_variable;;\r\n ramillie_soundheaded = ((char *)overtill_bicolour[44]);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(ramillie_soundheaded) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(ramillie_soundheaded) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(ramillie_soundheaded) + 1));\r\n if (Data->data) {\r\n if ((sscanf(ramillie_soundheaded, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n sem_init(&sem, 0, 1);\r\n Data->data_size = strlen(Data->data);\r\n while (Data->data[i] != '\\0') { \r\n if (Data->data[i] >= 'A' && \r\n Data->data[i] <= 'Z') { \r\n hasCap = 1;\r\n }\r\n i++;\r\n }\r\n \r\n if (hasCap == 1) {\r\n toLower(Data);\r\n }\r\n \r\n if (pthread_create(&t0, NULL, reverseStr, (void *)Data) != 0) {\r\n printf(\"Error creating thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, to1337, (void *)Data) != 0) {\r\n printf(\"Error creating thread 1.\");\r\n }\r\n \r\n \r\n pthread_join(t0, NULL);\r\n \r\n \r\n pthread_join(t1, NULL);\r\n \r\n \r\n \r\n \r\n \r\n \r\n printf(\"After joins.\\n\");\r\n printf(\"String: %s\\n\", Data->data);\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n } else {\r\n printf(\"Error parsing input.\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < Data->data_size; i++) {\n \n printf(\"Dereferencing ptr\\n\");\n temp_str[Data->data_size - 1 - i] = Data->data[i]; \n }\n```", "cwe": "765"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nint jailsco_balewa = 0;\r\nint global_variable;\r\n\r\nunion tonga_yojuane \r\n{\r\n char *cavern_subpool;\r\n double reabolition_dogmata;\r\n char *mtf_megadonty;\r\n char subtrahends_unrued;\r\n int mecurialism_untumidness;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid monk_defensor(union tonga_yojuane farmstead_henwile);\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n#define GOODMAN_PHLEBOGRAPH(x) monk_defensor((union tonga_yojuane) x)\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n union tonga_yojuane kelayres_geomagnetism;\r\n int himene_pur = 63;\r\n char *asclepin_labeled;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&jailsco_balewa,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&asclepin_labeled,\"9874\",himene_pur);\r\n if (asclepin_labeled != 0) {;\r\n kelayres_geomagnetism . cavern_subpool = asclepin_labeled;\r\n\tGOODMAN_PHLEBOGRAPH(kelayres_geomagnetism);\r\n }\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nvoid monk_defensor(union tonga_yojuane farmstead_henwile)\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *mischoice_feedway = 0;\r\n ++global_variable;;\r\n mischoice_feedway = ((char *)farmstead_henwile . cavern_subpool);\r\n \r\n while(isalnum(mischoice_feedway[size]) && size < strlen(mischoice_feedway)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(mischoice_feedway)) {\r\n mischoice_feedway = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,mischoice_feedway);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (farmstead_henwile . cavern_subpool != 0) \r\n free(((char *)farmstead_henwile . cavern_subpool));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,mischoice_feedway);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint paraproctitis_hydroxamic = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n int ss_i = 0;\r\n char stack_buff_64[64];\r\n int my_buff_size;\r\n char *bibliomancy_delftware = 0;\r\n char *muzz_inferiors = 0;\r\n int *cambogia_leku = 0;\r\n int diplosphenal_dramalogue;\r\n char *misadvantage_nontemporal[10] = {0};\r\n char *bakers_countersurprise;;\r\n if (__sync_bool_compare_and_swap(&paraproctitis_hydroxamic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&bakers_countersurprise,\"TRAYLIKE_FOOTINGS\");\r\n if (bakers_countersurprise != 0) {;\r\n diplosphenal_dramalogue = 5;\r\n cambogia_leku = &diplosphenal_dramalogue;\r\n misadvantage_nontemporal[ *cambogia_leku] = bakers_countersurprise;\r\n muzz_inferiors = misadvantage_nontemporal[ *cambogia_leku];\r\n bibliomancy_delftware = ((char *)muzz_inferiors);\r\n \r\n \r\n memset(stack_buff_64,'A',63);\r\n stack_buff_64[63] = '\\0';\r\n \r\n \r\n \r\n my_buff_size = ((int )(strlen(bibliomancy_delftware)));\r\n for (; ss_i < my_buff_size; ++ss_i){\r\n \r\n \r\n printf(\"%c\",stack_buff_64[ss_i]);\r\n }\r\n \r\n \r\n \r\n \r\n printf(\"\\n\");\r\n \r\n;\r\n if (muzz_inferiors != 0) \r\n free(((char *)muzz_inferiors));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` my_buff_size = ((int )(strlen(bibliomancy_delftware)));\n for (; ss_i < my_buff_size; ++ss_i){\n \n \n printf(\"%c\",stack_buff_64[ss_i]);\n }\n \n \n \n \n printf(\"\\n\");\n \n;\n if (muzz_inferiors != 0) \n free(((char *)muzz_inferiors));\nclose_printf_context();\n }\n }\n }\n ;\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avfilter_license()\n{\n#define LICENSE_PREFIX \"libavfilter license: \"\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\n}\n\nvoid ff_command_queue_pop(AVFilterContext *filter)\n{\n AVFilterCommand *c = filter -> command_queue;\n av_freep((&c -> arg));\n av_freep((&c -> command));\n filter -> command_queue = c -> next;\n av_free(c);\n}\n\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\n{\n unsigned int i;\n idx = (idx > *count? *count : idx);\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\n ( *links)[idx] = ((void *)0);\n ( *count)++;\n for (i = idx + 1; i < *count; i++) \n if ( *links[i]) {\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\n }\n}\n\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\n{\n AVFilterLink *link;\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\n return - 1;\n }\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\n return - 22;\n }\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\n link -> src = src;\n link -> dst = dst;\n link -> srcpad = &src -> output_pads[srcpad];\n link -> dstpad = &dst -> input_pads[dstpad];\n link -> type = src -> output_pads[srcpad] . type;\n do {\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\n abort();\n }\n }while (0);\n link -> format = - 1;\n return 0;\n}\n\nvoid avfilter_link_free(AVFilterLink **link)\n{\n if (!( *link)) {\n return ;\n }\n if (( *link) -> pool) {\n ff_free_pool(( *link) -> pool);\n }\n avfilter_unref_bufferp(&( *link) -> partial_buf);\n av_freep(link);\n}\n\nint avfilter_link_get_channels(AVFilterLink *link)\n{\n return link -> channels;\n}\n\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\n{\n link -> closed = closed;\n}\n\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\n{\n int ret;\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\n\n link -> dst -> inputs[dstpad_idx] = link;\n return ret;\n }\n\n link -> dst = filt;\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\n filt -> inputs[filt_srcpad_idx] = link;\n\n if (link -> out_formats) {\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\n }\n if (link -> out_samplerates) {\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\n }\n if (link -> out_channel_layouts) {\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\n }\n return 0;\n}\n\nint avfilter_config_links(AVFilterContext *filter)\n{\n int (*config_link)(AVFilterLink *);\n unsigned int i;\n int ret;\n for (i = 0; i < filter -> nb_inputs; i++) {\n AVFilterLink *link = filter -> inputs[i];\n AVFilterLink *inlink;\n if (!link) {\n continue; \n }\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\n link -> current_pts = ((int64_t )0x8000000000000000UL);\n switch(link -> init_state){\n case AVLINK_INIT:\n continue; \n case AVLINK_STARTINIT:\n{\n av_log(filter,32,\"circular filter chain detected\\n\");\n return 0;\n }\n case AVLINK_UNINIT:\n{\n link -> init_state = AVLINK_STARTINIT;\n if ((ret = avfilter_config_links(link -> src)) < 0) {\n return ret;\n }\n if (!(config_link = link -> srcpad -> config_props)) {\n if (link -> src -> nb_inputs != 1) {\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\n return - 22;\n }\n }\n else {\n if ((ret = config_link(link)) < 0) {\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\n return ret;\n }\n }\n switch(link -> type){\n case AVMEDIA_TYPE_VIDEO:\n{\n if (!link -> time_base . num && !link -> time_base . den) {\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\n }\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\n }\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\n link -> frame_rate = inlink -> frame_rate;\n }\n if (inlink) {\n if (!link -> w) {\n link -> w = inlink -> w;\n }\n if (!link -> h) {\n link -> h = inlink -> h;\n }\n }\n else {\n if (!link -> w || !link -> h) {\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\n return - 22;\n }\n }\n break; \n }\n case AVMEDIA_TYPE_AUDIO:\n{\n if (inlink) {\n if (!link -> time_base . num && !link -> time_base . den) {\n link -> time_base = inlink -> time_base;\n }\n }\n if (!link -> time_base . num && !link -> time_base . den) {\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\n }\n }\n }\n if (config_link = link -> dstpad -> config_props) {\n if ((ret = config_link(link)) < 0) {\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\n return ret;\n }\n }\n link -> init_state = AVLINK_INIT;\n }\n }\n }\n return 0;\n}\n\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\n{\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\n do {\n if (0) {\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\n }\n }while (0);\n }\n else {\n char buf[128];\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\n do {\n if (0) {\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\n }\n }while (0);\n }\n}\n\nint ff_request_frame(AVFilterLink *link)\n{\n int ret = - 1;\n do {\n if (0) {\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\n }\n }while (0);\n ff_tlog_link(((void *)0),link,1);\n if (link -> closed) {\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\n }\n if (link -> srcpad -> request_frame) {\n ret = ((link -> srcpad -> request_frame)(link));\n }\n else {\n if (link -> src -> inputs[0]) {\n ret = ff_request_frame(link -> src -> inputs[0]);\n }\n }\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\n AVFilterBufferRef *pbuf = link -> partial_buf;\n link -> partial_buf = ((void *)0);\n ff_filter_frame_framed(link,pbuf);\n return 0;\n }\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\n link -> closed = 1;\n }\n return ret;\n}\n\nint ff_poll_frame(AVFilterLink *link)\n{\n int i;\n int min = 2147483647;\n if (link -> srcpad -> poll_frame) {\n return (link -> srcpad -> poll_frame)(link);\n }\n for (i = 0; i < link -> src -> nb_inputs; i++) {\n int val;\n if (!link -> src -> inputs[i]) {\n return - 1;\n }\n val = ff_poll_frame(link -> src -> inputs[i]);\n min = (min > val?val : min);\n }\n return min;\n}\n\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\n{\n if (pts == ((int64_t )0x8000000000000000UL)) {\n return ;\n }\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\n\n if (link -> graph && link -> age_index >= 0) {\n ff_avfilter_graph_update_heap(link -> graph,link);\n }\n}\n\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\n{\n if (!strcmp(cmd,\"ping\")) {\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\n return 0;\n }\n else {\n if (filter -> filter -> process_command) {\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\n }\n }\n return - 38;\n}\n#define MAX_REGISTERED_AVFILTERS_NB 256\nstatic AVFilter *registered_avfilters[256 + 1];\nstatic int next_registered_avfilter_idx = 0;\n\nAVFilter *avfilter_get_by_name(const char *name)\n{\n int i;\n for (i = 0; registered_avfilters[i]; i++) \n if (!strcmp(registered_avfilters[i] -> name,name)) {\n return registered_avfilters[i];\n }\n return ((void *)0);\n}\n\nint avfilter_register(AVFilter *filter)\n{\n int i;\n if (next_registered_avfilter_idx == 256) {\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\n return - '\\f';\n }\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\n const AVFilterPad *input = &filter -> inputs[i];\n do {\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\n abort();\n }\n }while (0);\n }\n registered_avfilters[next_registered_avfilter_idx++] = filter;\n return 0;\n}\n\nAVFilter **av_filter_next(AVFilter **filter)\n{\n return filter?++filter : &registered_avfilters[0];\n}\n\nvoid avfilter_uninit()\n{\n memset(registered_avfilters,0,sizeof(registered_avfilters));\n next_registered_avfilter_idx = 0;\n}\n\nstatic int pad_count(const AVFilterPad *pads)\n{\n int count;\n if (!pads) {\n return 0;\n }\n for (count = 0; pads -> name; count++) \n pads++;\n return count;\n}\n\nstatic const char *default_filter_name(void *filter_ctx)\n{\n AVFilterContext *ctx = filter_ctx;\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\n}\n\nstatic void *filter_child_next(void *obj,void *prev)\n{\n AVFilterContext *ctx = obj;\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\n return ctx -> priv;\n }\n return (void *)0;\n}\n\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\n{\n AVFilter **filter_ptr = ((void *)0);\n\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\n if (( *filter_ptr) -> priv_class == prev) {\n break; \n }\n\n if (prev && !( *filter_ptr)) {\n return ((void *)0);\n }\n\n while( *(filter_ptr = av_filter_next(filter_ptr)))\n if (( *filter_ptr) -> priv_class) {\n return ( *filter_ptr) -> priv_class;\n }\n return ((void *)0);\n}\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\n\nconst AVClass *avfilter_get_class()\n{\n return &avfilter_class;\n}\n\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\n{\n AVFilterContext *ret;\n *filter_ctx = ((void *)0);\n if (!filter) {\n return - 22;\n }\n ret = (av_mallocz(sizeof(AVFilterContext )));\n if (!ret) {\n return - '\\f';\n }\n ret -> av_class = &avfilter_class;\n ret -> filter = filter;\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\n if (filter -> priv_size) {\n ret -> priv = av_mallocz((filter -> priv_size));\n if (!ret -> priv) {\n goto err;\n }\n }\n ret -> nb_inputs = (pad_count(filter -> inputs));\n if (ret -> nb_inputs) {\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\n if (!ret -> input_pads) {\n goto err;\n }\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\n if (!ret -> inputs) {\n goto err;\n }\n }\n ret -> nb_outputs = (pad_count(filter -> outputs));\n if (ret -> nb_outputs) {\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\n if (!ret -> output_pads) {\n goto err;\n }\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\n if (!ret -> outputs) {\n goto err;\n }\n }\n#if FF_API_FOO_COUNT\n ret -> output_count = ret -> nb_outputs;\n ret -> input_count = ret -> nb_inputs;\n#endif\n *filter_ctx = ret;\n return 0;\n err:\n av_freep((&ret -> inputs));\n av_freep((&ret -> input_pads));\n ret -> nb_inputs = 0;\n av_freep((&ret -> outputs));\n av_freep((&ret -> output_pads));\n ret -> nb_outputs = 0;\n av_freep((&ret -> priv));\n av_free(ret);\n return - '\\f';\n}\n\nvoid avfilter_free(AVFilterContext *filter)\n{\n int i;\n AVFilterLink *link;\n if (!filter) {\n return ;\n }\n if (filter -> filter -> uninit) {\n (filter -> filter -> uninit)(filter);\n }\n for (i = 0; i < filter -> nb_inputs; i++) {\n if (link = filter -> inputs[i]) {\n if (link -> src) {\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\n }\n ff_formats_unref(&link -> in_formats);\n ff_formats_unref(&link -> out_formats);\n ff_formats_unref(&link -> in_samplerates);\n ff_formats_unref(&link -> out_samplerates);\n ff_channel_layouts_unref(&link -> in_channel_layouts);\n ff_channel_layouts_unref(&link -> out_channel_layouts);\n }\n avfilter_link_free(&link);\n }\n for (i = 0; i < filter -> nb_outputs; i++) {\n if (link = filter -> outputs[i]) {\n if (link -> dst) {\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\n }\n ff_formats_unref(&link -> in_formats);\n ff_formats_unref(&link -> out_formats);\n ff_formats_unref(&link -> in_samplerates);\n ff_formats_unref(&link -> out_samplerates);\n ff_channel_layouts_unref(&link -> in_channel_layouts);\n ff_channel_layouts_unref(&link -> out_channel_layouts);\n }\n avfilter_link_free(&link);\n }\n av_freep((&filter -> name));\n av_freep((&filter -> input_pads));\n av_freep((&filter -> output_pads));\n av_freep((&filter -> inputs));\n av_freep((&filter -> outputs));\n av_freep((&filter -> priv));\n while(filter -> command_queue){\n ff_command_queue_pop(filter);\n }\n av_free(filter);\n}\n\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\n{\n int ret = 0;\n if (filter -> filter -> init_opaque) {\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\n }\n else {\n if (filter -> filter -> init) {\n ret = ((filter -> filter -> init)(filter,args));\n }\n }\n return ret;\n}\n\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\n{\n return pads[pad_idx] . name;\n}\n\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\n{\n return pads[pad_idx] . type;\n}\n\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\n{\n return ff_filter_frame(link -> dst -> outputs[0],frame);\n}\n\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\n{\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\n AVFilterPad *src = link -> srcpad;\n AVFilterPad *dst = link -> dstpad;\n AVFilterBufferRef *out;\n int perms;\n int ret;\n AVFilterCommand *cmd = link -> dst -> command_queue;\n int64_t pts;\n if (link -> closed) {\n avfilter_unref_buffer(frame);\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\n }\n if (!(filter_frame = dst -> filter_frame)) {\n filter_frame = default_filter_frame;\n }\n (void )0;\n frame -> perms &= ~src -> rej_perms;\n perms = frame -> perms;\n if (frame -> linesize[0] < 0) {\n perms |= 0x20;\n }\n\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\n\n switch(link -> type){\n case AVMEDIA_TYPE_VIDEO:\n{\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\n break; \n }\n case AVMEDIA_TYPE_AUDIO:\n{\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\n break; \n }\n default:\n return - 22;\n }\n if (!out) {\n avfilter_unref_buffer(frame);\n return - '\\f';\n }\n avfilter_copy_buffer_ref_props(out,frame);\n switch(link -> type){\n case AVMEDIA_TYPE_VIDEO:\n{\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\n break; \n }\n case AVMEDIA_TYPE_AUDIO:\n{\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\n break; \n }\n default:\n return - 22;\n }\n avfilter_unref_buffer(frame);\n }\n else {\n out = frame;\n }\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\n ff_command_queue_pop(link -> dst);\n cmd = link -> dst -> command_queue;\n }\n pts = out -> pts;\n ret = filter_frame(link,out);\n ff_update_link_current_pts(link,pts);\n return ret;\n}\n\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\n{\n int insamples = frame -> audio -> nb_samples;\n int inpos = 0;\n int nb_samples;\n AVFilterBufferRef *pbuf = link -> partial_buf;\n int nb_channels = frame -> audio -> channels;\n int ret = 0;\n\n while(insamples){\n if (!pbuf) {\n AVRational samples_tb = {(1), link -> sample_rate};\n int perms = link -> dstpad -> min_perms | 0x02;\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\n if (!pbuf) {\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\n return 0;\n }\n avfilter_copy_buffer_ref_props(pbuf,frame);\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\n pbuf -> audio -> nb_samples = 0;\n }\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\n inpos += nb_samples;\n insamples -= nb_samples;\n pbuf -> audio -> nb_samples += nb_samples;\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\n ret = ff_filter_frame_framed(link,pbuf);\n pbuf = ((void *)0);\n }\n }\n avfilter_unref_buffer(frame);\n link -> partial_buf = pbuf;\n return ret;\n}\n\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\n{\n do {\n if (0) {\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\n }\n }while (0);\n ff_tlog_link(((void *)0),link,1);\n do {\n if (0) {\n av_log(((void *)0),48,\" \");\n }\n }while (0);\n ff_tlog_ref(((void *)0),frame,1);\n\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\n (void )0;\n (void )0;\n (void )0;\n }\n }\n else {\n (void )0;\n (void )0;\n (void )0;\n (void )0;\n }\n\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\n return ff_filter_frame_needs_framing(link,frame);\n }\n else {\n return ff_filter_frame_framed(link,frame);\n }\n```", "cwe": "126"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint microfilaria_encyclical = 0;\r\nint global_variable;\r\ntypedef char *rask_ultralaborious;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nrask_ultralaborious townspeople_unpropriety(rask_ultralaborious bushwife_perceive);\r\nvoid unmanoeuvred_baboo(rask_ultralaborious rabbets_fumaria);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n void (*tholeite_pyxis)(rask_ultralaborious ) = unmanoeuvred_baboo;\r\n rask_ultralaborious nonvariably_geniture = 0;\r\n rask_ultralaborious frontier_redecimate = 0;\r\n char *multitude_quadrilaterals;;\r\n if (__sync_bool_compare_and_swap(&microfilaria_encyclical,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n multitude_quadrilaterals = getenv(\"CAULS_ICHTHYOFAUNAL\");\r\n if (multitude_quadrilaterals != 0) {;\r\n frontier_redecimate = multitude_quadrilaterals;\r\n nonvariably_geniture = townspeople_unpropriety(frontier_redecimate);\r\n tholeite_pyxis(nonvariably_geniture);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nrask_ultralaborious townspeople_unpropriety(rask_ultralaborious bushwife_perceive)\r\n{\r\n ++global_variable;\r\n return bushwife_perceive;\r\n}\r\n\r\nvoid unmanoeuvred_baboo(rask_ultralaborious rabbets_fumaria)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *dystocias_janker = 0;\r\n ++global_variable;;\r\n dystocias_janker = ((char *)rabbets_fumaria);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(dystocias_janker) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (dystocias_janker[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &dystocias_janker[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint indoors_ekpwele = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid revolutionizing_pelargonidin(int cytherea_visuometer,... );\r\nvoid msgmgt_serotonergic(void *diallists_bulak);\r\nstruct struct_data {\r\n char *buffer_member;\r\n unsigned short size_member;\r\n};\r\nstruct struct_data *init_data(long number_param)\r\n{\r\n \r\n struct struct_data *init_data_ptr = 0;\r\n init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\r\n if (init_data_ptr == 0)\r\n return 0;\r\n init_data_ptr -> size_member = 0;\r\n \r\n\r\n init_data_ptr -> size_member = number_param;\r\n init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\r\n \r\n \r\n \r\n if (init_data_ptr -> buffer_member == 0) {\r\n free(init_data_ptr);\r\n return 0;\r\n }\r\n memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\r\n init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\r\n return init_data_ptr;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n void *geminiani_philosophister = 0;\r\n char *medievalists_dux;;\r\n if (__sync_bool_compare_and_swap(&indoors_ekpwele,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&medievalists_dux,\"RESHAKEN_GWELO\");\r\n if (medievalists_dux != 0) {;\r\n geminiani_philosophister = ((void *)medievalists_dux);\r\n revolutionizing_pelargonidin(1,geminiani_philosophister);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid revolutionizing_pelargonidin(int cytherea_visuometer,... )\r\n{\r\n void (*anglings_vastah)(void *) = msgmgt_serotonergic;\r\n void *cahone_genuinely = 0;\r\n va_list unprimitiveness_hymnlike;\r\n ++global_variable;;\r\n if (cytherea_visuometer > 0) {\r\n __builtin_va_start(unprimitiveness_hymnlike,cytherea_visuometer);\r\n cahone_genuinely = (va_arg(unprimitiveness_hymnlike,void *));\r\n __builtin_va_end(unprimitiveness_hymnlike);\r\n }\r\n anglings_vastah(cahone_genuinely);\r\n}\r\n\r\nvoid msgmgt_serotonergic(void *diallists_bulak)\r\n{\r\n long number;\r\n struct struct_data *data = 0;\r\n char *flokatis_induces = 0;\r\n ++global_variable;;\r\n flokatis_induces = ((char *)((char *)diallists_bulak));\r\n \r\n number = strtol(flokatis_induces,0U,10);\r\n if (number > 0) {\r\n data = init_data(number);\r\n if (data != 0) {\r\n \r\n\r\n memset(data -> buffer_member, 98, number);\r\n \r\n data -> buffer_member[number - 1] = 0;\r\n printf(\"%s\\n\", data -> buffer_member);\r\n if (data -> buffer_member != 0U)\r\n free(data -> buffer_member);\r\n if (data != 0U)\r\n free(data);\r\n }\r\n } else {\r\n printf(\"Input is less than or equal to 0\\n\");\r\n }\r\n \r\n;\r\n if (((char *)diallists_bulak) != 0) \r\n free(((char *)((char *)diallists_bulak)));\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n memset(data -> buffer_member, 98, number);\n```", "cwe": "197"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <mongoose.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint nama_jewelle = 0;\r\ntypedef char *vouchsafer_appay;\r\nint global_variable;\r\nvoid handle_taint(char *salpingostomies_muller);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid unmortified_hests(int fruita_hotches,... );\r\nvoid isotria_skeed(int hemoglobinemia_disemburden,vouchsafer_appay dalliance_playactor);\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_mutex_t mutex_0, mutex_1;\r\npthread_t t0, t1;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *replace (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int *qsort_arr;\r\n int i = 0;\r\n \r\n \r\n printf(\"replace: entering function\\n\");\r\n \r\n qsort_arr = malloc(sizeof(int)*Data->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < Data->qsize; i++) {\r\n qsort_arr[i] = Data->qsize - i;\r\n }\r\n qsort(qsort_arr, Data->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(Data->file1);\r\n printf(\"replace: Attempting to grab lock 0\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n printf(\"replace: Grabbed lock 0\\n\");\r\n printf(\"replace: Attempting to grab lock 1\\n\");\r\n pthread_mutex_lock(&mutex_1); \r\n printf(\"replace: Grabbed lock 1\\n\");\r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n if (Data->data[i] == '_') {\r\n Data->data[i] = '-';\r\n }\r\n i++;\r\n }\r\n printf(\"replace: Releasing lock 1\\n\");\r\n pthread_mutex_unlock(&mutex_1);\r\n printf(\"replace: Releasing lock 0\\n\");\r\n pthread_mutex_unlock(&mutex_0);\r\n \r\n return NULL;\r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n \r\n printf(\"toCap: Entering function\\n\");\r\n printf(\"toCap: Attempting to grab lock 1\\n\");\r\n pthread_mutex_lock(&mutex_1);\r\n printf(\"toCap: Grabbed lock 1\\n\");\r\n readFile(Data->file2);\r\n \r\n \r\n printf(\"toCap: Attempting to grab lock 0\\n\");\r\n pthread_mutex_lock(&mutex_0); \r\n printf(\"toCap: Grabbed lock 0\\n\");\r\n \r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n if (Data->data[i] > 'a' && Data->data[i] < 'z') {\r\n Data->data[i] -= 'a' - 'A';\r\n }\r\n i++;\r\n }\r\n printf(\"toCap: Releasing lock 0\\n\");\r\n pthread_mutex_unlock(&mutex_0);\r\n printf(\"toCap: Releasing lock 1\\n\");\r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&nama_jewelle,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid handle_taint(char *salpingostomies_muller)\r\n{\r\n vouchsafer_appay malpighiaceous_coden = 0;\r\n ++global_variable;;\r\n if (salpingostomies_muller != 0) {;\r\n malpighiaceous_coden = salpingostomies_muller;\r\n unmortified_hests(1,malpighiaceous_coden);\r\n }\r\n}\r\n\r\nvoid unmortified_hests(int fruita_hotches,... )\r\n{\r\n int sympodial_subequally = 7;\r\n vouchsafer_appay foldage_anaesthetizing = 0;\r\n va_list furie_hydrozoal;\r\n ++global_variable;;\r\n if (fruita_hotches > 0) {\r\n __builtin_va_start(furie_hydrozoal,fruita_hotches);\r\n foldage_anaesthetizing = (va_arg(furie_hydrozoal,vouchsafer_appay ));\r\n __builtin_va_end(furie_hydrozoal);\r\n }\r\n isotria_skeed(sympodial_subequally,foldage_anaesthetizing);\r\n}\r\n\r\nvoid isotria_skeed(int hemoglobinemia_disemburden,vouchsafer_appay dalliance_playactor)\r\n{\r\n int hasUnderscores = 0;\r\n int i = 0;\r\n struct data* Data;\r\n char *rhamphosuchus_photostated = 0;\r\n ++global_variable;\r\n hemoglobinemia_disemburden--;\r\n if (hemoglobinemia_disemburden > 0) {\r\n isotria_skeed(hemoglobinemia_disemburden,dalliance_playactor);\r\n return ;\r\n }\r\n rhamphosuchus_photostated = ((char *)dalliance_playactor);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(rhamphosuchus_photostated) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(rhamphosuchus_photostated) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(rhamphosuchus_photostated) + 1));\r\n if (Data->data) {\r\n if ((sscanf(rhamphosuchus_photostated, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n while(Data->data[i] != '\\0') { \r\n if (Data->data[i++] == '_') { \r\n hasUnderscores = 1;\r\n }\r\n }\r\n \r\n if (pthread_create(&t0, NULL, toCap, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (hasUnderscores == 1) {\r\n \r\n if (pthread_create(&t1, NULL, replace, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n }\r\n pthread_join(t0, NULL);\r\n if (hasUnderscores == 1) {\r\n pthread_join(t1, NULL);\r\n }\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (dalliance_playactor != 0) \r\n free(((char *)dalliance_playactor));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n printf(\"toCap: Attempting to grab lock 0\\n\");\n pthread_mutex_lock(&mutex_0); \n printf(\"toCap: Grabbed lock 0\\n\");\n```", "cwe": "833"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint paristhmion_tribute = 0;\r\nint global_variable;\r\n\r\nunion recouping_mppd \r\n{\r\n char *racloir_antiburgher;\r\n double evilness_stopship;\r\n char *pennsylvania_beefishness;\r\n char undrivableness_deweyville;\r\n int capitative_prehardened;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid josee_thriftbox(union recouping_mppd *spearman_mingiest);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n#define ANTITARNISH_CLEARABLE(x) josee_thriftbox((union recouping_mppd *) x)\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n union recouping_mppd *entomologically_bohea = {0};\r\n union recouping_mppd *khalifat_burlie = {0};\r\n union recouping_mppd thermit_divariant;\r\n char *ascap_strifemonger;;\r\n if (__sync_bool_compare_and_swap(&paristhmion_tribute,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n ascap_strifemonger = getenv(\"TITHERIGHT_MULCTATIVE\");\r\n if (ascap_strifemonger != 0) {;\r\n thermit_divariant . racloir_antiburgher = ascap_strifemonger;\r\n entomologically_bohea = &thermit_divariant;\r\n khalifat_burlie = entomologically_bohea + 5;\r\n\tANTITARNISH_CLEARABLE(khalifat_burlie);\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid josee_thriftbox(union recouping_mppd *spearman_mingiest)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *apostolate_trenchermaking = 0;\r\n ++global_variable;;\r\n apostolate_trenchermaking = ((char *)( *(spearman_mingiest - 5)) . racloir_antiburgher);\r\n \r\n buffer_value = atoi(apostolate_trenchermaking);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(malloc_buffer,0,size_buffer);\n printf(\"Buffer size is %d\\n\", size_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint agglomerative_colonizations = 0;\r\nint global_variable;\r\nvoid handle_taint(char *irvingite_plumbosolvency);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid farmstead_marilynne(int apollonia_ceramicists,char **moralisms_nondegrading);\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&agglomerative_colonizations,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nvoid handle_taint(char *irvingite_plumbosolvency)\r\n{\r\n int footslogging_obscurity = 7;\r\n char **provenances_cranking = 0;\r\n int colormaker_lipoids = 0;\r\n char *mayologist_slightly = 0;\r\n ++global_variable;;\r\n if (irvingite_plumbosolvency != 0) {;\r\n colormaker_lipoids = ((int )(strlen(irvingite_plumbosolvency)));\r\n mayologist_slightly = ((char *)(malloc(colormaker_lipoids + 1)));\r\n if (mayologist_slightly == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(mayologist_slightly,0,colormaker_lipoids + 1);\r\n memcpy(mayologist_slightly,irvingite_plumbosolvency,colormaker_lipoids);\r\n if (irvingite_plumbosolvency != 0) \r\n free(((char *)irvingite_plumbosolvency));\r\n provenances_cranking = &mayologist_slightly;\r\n farmstead_marilynne(footslogging_obscurity,provenances_cranking);\r\n }\r\n}\r\n\r\nvoid farmstead_marilynne(int apollonia_ceramicists,char **moralisms_nondegrading)\r\n{\r\n FILE *csv = 0;\r\n FILE *temp = 0;\r\n char col1[80] = {0};\r\n char col2[80] = {0};\r\n char col3[80] = {0};\r\n char *cols[3] = {0};\r\n char *underthief_gurries = 0;\r\n ++global_variable;\r\n apollonia_ceramicists--;\r\n if (apollonia_ceramicists > 0) {\r\n farmstead_marilynne(apollonia_ceramicists,moralisms_nondegrading);\r\n return ;\r\n }\r\n underthief_gurries = ((char *)( *moralisms_nondegrading));\r\n \r\n \r\n csv = fopen(underthief_gurries,\"r\");\r\n if (csv != 0) {\r\n \r\n\r\n fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\r\n \r\n \r\n \r\n \r\n if (strlen(col1) > 0)\r\n cols[0] = col1;\r\n if (strlen(col2) > 0)\r\n cols[1] = col2;\r\n if (strlen(col3) > 0)\r\n cols[2] = col3;\r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n\r\n printf(\"VALUES=\\\"\");\r\n fputs(cols[0],temp);\r\n printf(cols[0]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[1],temp);\r\n printf(cols[1]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[2],temp);\r\n printf(cols[2]);\r\n \r\n printf(\"\\\"\\n\");\r\n fclose(temp);\r\n }\r\n }\r\n \r\n;\r\n if ( *moralisms_nondegrading != 0) \r\n free(((char *)( *moralisms_nondegrading)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n printf(\"VALUES=\\\"\");\n fputs(cols[0],temp);\n printf(cols[0]);\n printf(\"\\\",\\\"\");\n fputs(cols[1],temp);\n printf(cols[1]);\n printf(\"\\\",\\\"\");\n fputs(cols[2],temp);\n printf(cols[2]);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <mongoose.h> \r\n#include <string.h> \r\n#include <stdarg.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint chemicodynamic_thumblike = 0;\r\n\r\nstruct anharmonic_autodiffusion \r\n{\r\n char *aeriness_bumpering;\r\n double immingles_strontia;\r\n char *trochanteric_dialers;\r\n char letting_acetophenine;\r\n int plaiting_barrener;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *blindfoldly_unintermitted);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid pestilentially_chirl(int network_rehumiliate,... );\r\nvoid simiinae_spermatia(int camargo_ahuzzath,struct anharmonic_autodiffusion boylike_covet);\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&chemicodynamic_thumblike,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid handle_taint(char *blindfoldly_unintermitted)\r\n{\r\n struct anharmonic_autodiffusion arteriopressor_monandrous;\r\n ++global_variable;;\r\n if (blindfoldly_unintermitted != 0) {;\r\n arteriopressor_monandrous . aeriness_bumpering = ((char *)blindfoldly_unintermitted);\r\n pestilentially_chirl(1,arteriopressor_monandrous);\r\n }\r\n}\r\n\r\nvoid pestilentially_chirl(int network_rehumiliate,... )\r\n{\r\n int yod_echeneid = 7;\r\n struct anharmonic_autodiffusion usedness_fearfuller = {0};\r\n va_list snafu_clementis;\r\n ++global_variable;;\r\n if (network_rehumiliate > 0) {\r\n __builtin_va_start(snafu_clementis,network_rehumiliate);\r\n usedness_fearfuller = (va_arg(snafu_clementis,struct anharmonic_autodiffusion ));\r\n __builtin_va_end(snafu_clementis);\r\n }\r\n simiinae_spermatia(yod_echeneid,usedness_fearfuller);\r\n}\r\n\r\nvoid simiinae_spermatia(int camargo_ahuzzath,struct anharmonic_autodiffusion boylike_covet)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *dehydrant_cachot = 0;\r\n ++global_variable;\r\n camargo_ahuzzath--;\r\n if (camargo_ahuzzath > 0) {\r\n simiinae_spermatia(camargo_ahuzzath,boylike_covet);\r\n return ;\r\n }\r\n dehydrant_cachot = ((char *)boylike_covet . aeriness_bumpering);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",dehydrant_cachot);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (boylike_covet . aeriness_bumpering != 0) \r\n free(((char *)boylike_covet . aeriness_bumpering));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint targeting_reveres = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid outrail_resiliences(char **sepion_paragraphically);\r\nvoid uptuck_obscures(char **pharyngitic_knowledgably);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n char **pyramidic_tainting = 0;\r\n int **************************************************ureido_antidepressants = 0;\r\n int *************************************************villatic_goessel = 0;\r\n int ************************************************intersituating_forpine = 0;\r\n int ***********************************************unshown_minning = 0;\r\n int **********************************************treatabilities_archest = 0;\r\n int *********************************************euphorbiaceous_stucking = 0;\r\n int ********************************************uptrunk_tpo = 0;\r\n int *******************************************wheezer_jahrum = 0;\r\n int ******************************************biacetyls_groutnoll = 0;\r\n int *****************************************kitter_ethnolinguist = 0;\r\n int ****************************************oreotragine_archical = 0;\r\n int ***************************************aiello_nelle = 0;\r\n int **************************************ototoxic_underspliced = 0;\r\n int *************************************flummer_piroplasm = 0;\r\n int ************************************kettledrum_postsuppurative = 0;\r\n int ***********************************cryptogamic_morfound = 0;\r\n int **********************************ldinfo_diazoanhydride = 0;\r\n int *********************************filose_naturale = 0;\r\n int ********************************genetyllis_supervising = 0;\r\n int *******************************blendwater_kalispel = 0;\r\n int ******************************toothachy_liefer = 0;\r\n int *****************************obliviously_cfo = 0;\r\n int ****************************flocculate_bard = 0;\r\n int ***************************iodopsins_cherbourg = 0;\r\n int **************************kersey_interdentil = 0;\r\n int *************************spelunking_neurotomy = 0;\r\n int ************************baches_puntlatsh = 0;\r\n int ***********************monostomata_porte = 0;\r\n int **********************nogg_viraginous = 0;\r\n int *********************fishpool_nitrite = 0;\r\n int ********************underwitted_litanies = 0;\r\n int *******************wiborg_uncleanest = 0;\r\n int ******************india_abscess = 0;\r\n int *****************lwl_plasmocyte = 0;\r\n int ****************macaulay_tractarian = 0;\r\n int ***************mulm_suprajural = 0;\r\n int **************bhadgaon_trucidation = 0;\r\n int *************farant_stacked = 0;\r\n int ************spiel_panouchi = 0;\r\n int ***********outbreaker_succursale = 0;\r\n int **********larue_imbricated = 0;\r\n int *********wheyfaced_wilfully = 0;\r\n int ********stroller_aramanta = 0;\r\n int *******tintage_huelessness = 0;\r\n int ******scall_inhalent = 0;\r\n int *****thioacetic_hux = 0;\r\n int ****armrest_saxophone = 0;\r\n int ***tores_bulbonuclear = 0;\r\n int **burta_unnavigable = 0;\r\n int *brickel_typographia = 0;\r\n int nabathaean_threnodist;\r\n char **chrisse_pyorrhea[10] = {0};\r\n char *dere_whirrick[72] = {0};\r\n int idiospastic_farmership = 1024;\r\n char *tribrachs_inflicted;\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&targeting_reveres,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&tribrachs_inflicted,\"8967\",idiospastic_farmership);\r\n if (tribrachs_inflicted != 0) {;\r\n dere_whirrick[59] = tribrachs_inflicted;\r\n nabathaean_threnodist = 5;\r\n brickel_typographia = &nabathaean_threnodist;\r\n burta_unnavigable = &brickel_typographia;\r\n tores_bulbonuclear = &burta_unnavigable;\r\n armrest_saxophone = &tores_bulbonuclear;\r\n thioacetic_hux = &armrest_saxophone;\r\n scall_inhalent = &thioacetic_hux;\r\n tintage_huelessness = &scall_inhalent;\r\n stroller_aramanta = &tintage_huelessness;\r\n wheyfaced_wilfully = &stroller_aramanta;\r\n larue_imbricated = &wheyfaced_wilfully;\r\n outbreaker_succursale = &larue_imbricated;\r\n spiel_panouchi = &outbreaker_succursale;\r\n farant_stacked = &spiel_panouchi;\r\n bhadgaon_trucidation = &farant_stacked;\r\n mulm_suprajural = &bhadgaon_trucidation;\r\n macaulay_tractarian = &mulm_suprajural;\r\n lwl_plasmocyte = &macaulay_tractarian;\r\n india_abscess = &lwl_plasmocyte;\r\n wiborg_uncleanest = &india_abscess;\r\n underwitted_litanies = &wiborg_uncleanest;\r\n fishpool_nitrite = &underwitted_litanies;\r\n nogg_viraginous = &fishpool_nitrite;\r\n monostomata_porte = &nogg_viraginous;\r\n baches_puntlatsh = &monostomata_porte;\r\n spelunking_neurotomy = &baches_puntlatsh;\r\n kersey_interdentil = &spelunking_neurotomy;\r\n iodopsins_cherbourg = &kersey_interdentil;\r\n flocculate_bard = &iodopsins_cherbourg;\r\n obliviously_cfo = &flocculate_bard;\r\n toothachy_liefer = &obliviously_cfo;\r\n blendwater_kalispel = &toothachy_liefer;\r\n genetyllis_supervising = &blendwater_kalispel;\r\n filose_naturale = &genetyllis_supervising;\r\n ldinfo_diazoanhydride = &filose_naturale;\r\n cryptogamic_morfound = &ldinfo_diazoanhydride;\r\n kettledrum_postsuppurative = &cryptogamic_morfound;\r\n flummer_piroplasm = &kettledrum_postsuppurative;\r\n ototoxic_underspliced = &flummer_piroplasm;\r\n aiello_nelle = &ototoxic_underspliced;\r\n oreotragine_archical = &aiello_nelle;\r\n kitter_ethnolinguist = &oreotragine_archical;\r\n biacetyls_groutnoll = &kitter_ethnolinguist;\r\n wheezer_jahrum = &biacetyls_groutnoll;\r\n uptrunk_tpo = &wheezer_jahrum;\r\n euphorbiaceous_stucking = &uptrunk_tpo;\r\n treatabilities_archest = &euphorbiaceous_stucking;\r\n unshown_minning = &treatabilities_archest;\r\n intersituating_forpine = &unshown_minning;\r\n villatic_goessel = &intersituating_forpine;\r\n ureido_antidepressants = &villatic_goessel;\r\n chrisse_pyorrhea[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *ureido_antidepressants)))))))))))))))))))))))))))))))))))))))))))))))))] = dere_whirrick;\r\n pyramidic_tainting = chrisse_pyorrhea[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *ureido_antidepressants)))))))))))))))))))))))))))))))))))))))))))))))))];\r\n outrail_resiliences(pyramidic_tainting);\r\n }\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid outrail_resiliences(char **sepion_paragraphically)\r\n{\r\n ++global_variable;;\r\n uptuck_obscures(sepion_paragraphically);\r\n}\r\n\r\nvoid uptuck_obscures(char **pharyngitic_knowledgably)\r\n{\r\n int oc_i = 0;\r\n char buffer[8];\r\n char *obsidians_rookies = 0;\r\n ++global_variable;;\r\n obsidians_rookies = ((char *)pharyngitic_knowledgably[59]);\r\n \r\n \r\n \r\n \r\n \r\n \r\n strncpy(buffer,obsidians_rookies,strlen(obsidians_rookies) + 1);\r\n for (; oc_i < strlen(buffer); ++oc_i) {\r\n buffer[oc_i] = toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\",buffer);\r\n \r\n \r\n \r\n;\r\n if (pharyngitic_knowledgably[59] != 0) \r\n free(((char *)pharyngitic_knowledgably[59]));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n strncpy(buffer,obsidians_rookies,strlen(obsidians_rookies) + 1);\n for (; oc_i < strlen(buffer); ++oc_i) {\n buffer[oc_i] = toupper(buffer[oc_i]);\n }\n printf(\"%s\\n\",buffer);\n```", "cwe": "805"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <math.h> \r\n#include <signal.h> \r\nint rsr_findable = 0;\r\nint global_variable;\r\n\r\nunion hayfield_umbret \r\n{\r\n char *deluded_kraul;\r\n double nonaddress_semisoft;\r\n char *hayweed_postamniotic;\r\n char evenworthy_americas;\r\n int tibbu_buyable;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid yseulta_felonry(union hayfield_umbret quincuncially_immunity);\r\nvoid nike_boilinglike(union hayfield_umbret solidomind_devoiced);\r\nvoid sassoon_deidamia(union hayfield_umbret supraconscious_outweight);\r\nvoid meekhearted_ketway(union hayfield_umbret termor_cycadophyta);\r\nvoid anaplerotic_alc(union hayfield_umbret convocational_antefurcae);\r\nvoid wordishness_hums(union hayfield_umbret gharnao_unlocalising);\r\nvoid podites_neemba(union hayfield_umbret unfraternally_woodhouse);\r\nvoid ryegrasses_irreprovable(union hayfield_umbret nemalite_desterilize);\r\nvoid avouchable_unsloped(union hayfield_umbret leavings_orthocephaly);\r\nvoid hugeous_meanderer(union hayfield_umbret ccip_radiatics);\r\nint SIZE = 50;\r\nchar *playful_platypus;\r\nstruct data {\r\n char *data;\r\n};\r\nstruct data *Data;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid sig_handler (int sig) {\r\n printf(\"In sig_handler\\n\");\r\n \r\n \r\n \r\n \r\n \r\n if (playful_platypus[0] != '\\0') { \r\n printf(playful_platypus);\r\n }\r\n \r\n}\r\nvoid waitForSig(char *sleepFile) {\r\n int fd;\r\n char outStr[25] = {0};\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForSig\\n\");\r\n sprintf(outStr, \"%d.pid\", getpid());\r\n strcat(filename, \"/opt//workspace/testData/\");\r\n strcat(filename, outStr);\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n \r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n \r\n printf(\"Error writing to file.\");\r\n }\r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n \r\n readFile(sleepFile);\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n union hayfield_umbret stromatolite_aurify;\r\n int sideslipping_auctions = 119;\r\n char *endamoeba_warerooms;;\r\n if (__sync_bool_compare_and_swap(&rsr_findable,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&endamoeba_warerooms,\"9404\",sideslipping_auctions);\r\n if (endamoeba_warerooms != 0) {;\r\n stromatolite_aurify . deluded_kraul = endamoeba_warerooms;\r\n yseulta_felonry(stromatolite_aurify);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid yseulta_felonry(union hayfield_umbret quincuncially_immunity)\r\n{\r\n ++global_variable;;\r\n nike_boilinglike(quincuncially_immunity);\r\n}\r\n\r\nvoid nike_boilinglike(union hayfield_umbret solidomind_devoiced)\r\n{\r\n ++global_variable;;\r\n sassoon_deidamia(solidomind_devoiced);\r\n}\r\n\r\nvoid sassoon_deidamia(union hayfield_umbret supraconscious_outweight)\r\n{\r\n ++global_variable;;\r\n meekhearted_ketway(supraconscious_outweight);\r\n}\r\n\r\nvoid meekhearted_ketway(union hayfield_umbret termor_cycadophyta)\r\n{\r\n ++global_variable;;\r\n anaplerotic_alc(termor_cycadophyta);\r\n}\r\n\r\nvoid anaplerotic_alc(union hayfield_umbret convocational_antefurcae)\r\n{\r\n ++global_variable;;\r\n wordishness_hums(convocational_antefurcae);\r\n}\r\n\r\nvoid wordishness_hums(union hayfield_umbret gharnao_unlocalising)\r\n{\r\n ++global_variable;;\r\n podites_neemba(gharnao_unlocalising);\r\n}\r\n\r\nvoid podites_neemba(union hayfield_umbret unfraternally_woodhouse)\r\n{\r\n ++global_variable;;\r\n ryegrasses_irreprovable(unfraternally_woodhouse);\r\n}\r\n\r\nvoid ryegrasses_irreprovable(union hayfield_umbret nemalite_desterilize)\r\n{\r\n ++global_variable;;\r\n avouchable_unsloped(nemalite_desterilize);\r\n}\r\n\r\nvoid avouchable_unsloped(union hayfield_umbret leavings_orthocephaly)\r\n{\r\n ++global_variable;;\r\n hugeous_meanderer(leavings_orthocephaly);\r\n}\r\n\r\nvoid hugeous_meanderer(union hayfield_umbret ccip_radiatics)\r\n{\r\n int i;\r\n char *temp;\r\n char *sleepFile;\r\n char *sebacic_dyehouse = 0;\r\n ++global_variable;;\r\n sebacic_dyehouse = ((char *)ccip_radiatics . deluded_kraul);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n sleepFile = malloc(sizeof(char) * (strlen(sebacic_dyehouse) + 1));\r\n Data->data = malloc(sizeof(char) * (strlen(sebacic_dyehouse) + 1));\r\n if (Data->data) {\r\n if ((sscanf(sebacic_dyehouse, \"%s %s\",\r\n sleepFile,\r\n Data->data) == 2) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(sleepFile) != 0))\r\n {\r\n \r\n \r\n if (signal(SIGUSR1, sig_handler) == SIG_ERR) {\r\n \r\n printf (\"Error catching SIGNUSR1!\\n\");\r\n }\r\n playful_platypus = malloc(sizeof(char) * (SIZE + 1));\r\n i = 0;\r\n while (Data->data[i] != '\\0') { \r\n if (i < SIZE) {\r\n playful_platypus[i] = Data->data[i];\r\n i++;\r\n } else { \r\n playful_platypus[SIZE] = '\\0';\r\n \r\n \r\n SIZE *= 2;\r\n temp = malloc(sizeof(char) * SIZE);\r\n strcpy(temp, playful_platypus);\r\n free(playful_platypus);\r\n playful_platypus = NULL; \r\n \r\n waitForSig(sleepFile);\r\n \r\n playful_platypus = temp;\r\n \r\n }\r\n }\r\n free (playful_platypus);\r\n signal(SIGUSR1, SIG_IGN); \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free (Data);\r\n }\r\n \r\n;\r\n if (ccip_radiatics . deluded_kraul != 0) \r\n free(((char *)ccip_radiatics . deluded_kraul));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n if (playful_platypus[0] != '\\0') { \n printf(playful_platypus);\n }\n```", "cwe": "828"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint reseeing_abdication = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int ss_j;\r\n int ss_i;\r\n size_t taint_size;\r\n char **malloced_buff = 0;\r\n int trace_flag = 0;\r\n char *transudate_crotaloid = 0;\r\n int poisure_undoubtable;\r\n int ambari_amidoxyl;\r\n char *fideicommissor_educts = 0;\r\n int *reboundant_coddling = 0;\r\n int biramose_abstersion;\r\n char *parrah_perigastrular[10] = {0};\r\n int dyophysitism_belshazzar = 0;\r\n char *ulcery_pretoken = 0;\r\n char *absorptiometer_wittier;;\r\n if (__sync_bool_compare_and_swap(&reseeing_abdication,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n absorptiometer_wittier = getenv(\"ARMCHAIRED_RIDGELEY\");\r\n if (absorptiometer_wittier != 0) {;\r\n dyophysitism_belshazzar = ((int )(strlen(absorptiometer_wittier)));\r\n ulcery_pretoken = ((char *)(malloc(dyophysitism_belshazzar + 1)));\r\n if (ulcery_pretoken == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(ulcery_pretoken,0,dyophysitism_belshazzar + 1);\r\n memcpy(ulcery_pretoken,absorptiometer_wittier,dyophysitism_belshazzar);\r\n parrah_perigastrular[5] = ulcery_pretoken;\r\n biramose_abstersion = 5;\r\n reboundant_coddling = &biramose_abstersion;\r\n fideicommissor_educts = *(parrah_perigastrular + *reboundant_coddling);\r\n ambari_amidoxyl = 5;\r\n while(1 == 1){\r\n ambari_amidoxyl = ambari_amidoxyl * 2;\r\n ambari_amidoxyl = ambari_amidoxyl + 2;\r\n if (ambari_amidoxyl > 1000) {\r\n break; \r\n }\r\n }\r\n poisure_undoubtable = ambari_amidoxyl;\r\n transudate_crotaloid = ((char *)fideicommissor_educts);\r\n \r\n taint_size = strlen(transudate_crotaloid);\r\n \r\n if (taint_size >= 1600) {\r\n taint_size = 1599U;\r\n }\r\n malloced_buff = malloc(taint_size * sizeof(char *));\r\n \r\n \r\n if (malloced_buff != 0) {\r\n \r\n \r\n for (ss_i = 0; ss_i < taint_size; ++ss_i) {\r\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\r\n \r\n \r\n if (malloced_buff[ss_i] == 0 && errno == 12) {\r\n printf(\"Malloc error due to ulimit\\n\");\r\n if (trace_flag == 0) {\r\n \r\n \r\n trace_flag = 1;\r\n }\r\n }\r\n if (malloced_buff[ss_i] != 0) {\r\n for (ss_j = 0; ss_j < taint_size; ++ss_j) {\r\n memcpy(malloced_buff[ss_i] + ss_j * taint_size,transudate_crotaloid,taint_size);\r\n }\r\n }\r\n \r\n \r\n if (taint_size % 2 == 0) {\r\n if (malloced_buff[ss_i] != 0) {\r\n free(malloced_buff[ss_i]);\r\n \r\n }\r\n }\r\n }\r\n free(malloced_buff);\r\n \r\n }\r\n;\r\n if (fideicommissor_educts != 0) \r\n free(((char *)fideicommissor_educts));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n \n \n if (malloced_buff[ss_i] == 0 && errno == 12) {\n printf(\"Malloc error due to ulimit\\n\");\n if (trace_flag == 0) {\n \n```", "cwe": "401"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <unistd.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint afterage_falconries = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n int random_data;\r\n char fill_buff[50000];\r\n char file_path[50][31];\r\n int filedes;\r\n int count = 0;\r\n int taint_num;\r\n int ss_i = 0;\r\n char *weeviled_tuque = 0;\r\n void *uncunningness_stortz = 0;\r\n int *kabuki_gadsman = 0;\r\n int mlange_springeing;\r\n void *superuniversal_phegopteris[10] = {0};\r\n void *masterhood_predesirously = 0;\r\n int interolivary_hobbyists = 6;\r\n char *alkermes_asylabia;;\r\n if (__sync_bool_compare_and_swap(&afterage_falconries,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&alkermes_asylabia,\"4890\",interolivary_hobbyists);\r\n if (alkermes_asylabia != 0) {;\r\n masterhood_predesirously = ((void *)alkermes_asylabia);\r\n superuniversal_phegopteris[5] = masterhood_predesirously;\r\n mlange_springeing = 5;\r\n kabuki_gadsman = &mlange_springeing;\r\n uncunningness_stortz = *(superuniversal_phegopteris + *kabuki_gadsman);\r\n weeviled_tuque = ((char *)((char *)uncunningness_stortz));\r\n \r\n random_data = open(\"/dev/urandom\",0);\r\n read(random_data,fill_buff,49999U);\r\n close(random_data);\r\n fill_buff[49999] = '\\0';\r\n taint_num = atoi(weeviled_tuque);\r\n if (taint_num < 0) {\r\n taint_num = 0;\r\n }\r\n \r\n for (ss_i = 0; ss_i < taint_num; ++ss_i) {\r\n ++count;\r\n strncpy(file_path[ss_i % 50],\"/tmp/data_459-XXXXXX\",31);\r\n filedes = mkstemp(file_path[ss_i % 50]);\r\n write(filedes,fill_buff,sizeof(fill_buff));\r\n close(filedes);\r\n }\r\n \r\n \r\n for (ss_i = 0; ss_i < 50; ++ss_i){\r\n \r\n if (count == ss_i) {\r\n break;\r\n }\r\n \r\n unlink(file_path[ss_i]);\r\n }\r\n \r\n \r\n \r\n;\r\n if (((char *)uncunningness_stortz) != 0) \r\n free(((char *)((char *)uncunningness_stortz)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (ss_i = 0; ss_i < 50; ++ss_i){\n \n if (count == ss_i) {\n break;\n }\n \n unlink(file_path[ss_i]);\n }\n```", "cwe": "459"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint defection_totalistic = 0;\r\nint global_variable;\r\ntypedef char *hydromassage_twist;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid triphyllous_upridge(int billingsgate_overfrankness,hydromassage_twist shoed_tupuna);\r\nvoid fundamentalness_trip(int subcoat_forth,hydromassage_twist passsaging_unscourging);\r\n\r\nvoid ERR_load_BIO_strings()\r\n{\r\n int rehumble_siphonaria = 7;\r\n hydromassage_twist rustically_unphilosophical = 0;\r\n int *solemnly_polyommatous = 0;\r\n int divorcive_summits;\r\n hydromassage_twist saltier_dryades[10] = {0};\r\n hydromassage_twist chayma_puisne = 0;\r\n char *neth_supercharging;;\r\n if (__sync_bool_compare_and_swap(&defection_totalistic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&neth_supercharging,\"MICROPIPET_JUNKYARDS\");\r\n if (neth_supercharging != 0) {;\r\n chayma_puisne = neth_supercharging;\r\n divorcive_summits = 5;\r\n solemnly_polyommatous = &divorcive_summits;\r\n saltier_dryades[ *solemnly_polyommatous] = chayma_puisne;\r\n rustically_unphilosophical = saltier_dryades[ *solemnly_polyommatous];\r\n triphyllous_upridge(rehumble_siphonaria,rustically_unphilosophical);\r\n }\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid triphyllous_upridge(int billingsgate_overfrankness,hydromassage_twist shoed_tupuna)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *antimodernness_sicklemia = 0;\r\n ++global_variable;\r\n billingsgate_overfrankness--;\r\n if (billingsgate_overfrankness > 0) {\r\n fundamentalness_trip(billingsgate_overfrankness,shoed_tupuna);\r\n return ;\r\n }\r\n antimodernness_sicklemia = ((char *)shoed_tupuna);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(antimodernness_sicklemia) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (antimodernness_sicklemia[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &antimodernness_sicklemia[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\n if (shoed_tupuna != 0) \r\n free(((char *)shoed_tupuna));\r\nclose_printf_context();\r\n}\r\n\r\nvoid fundamentalness_trip(int subcoat_forth,hydromassage_twist passsaging_unscourging)\r\n{\r\n ++global_variable;\r\n triphyllous_upridge(subcoat_forth,passsaging_unscourging);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint burt_ametabola = 0;\r\nint global_variable;\r\nvoid handle_taint(char *kinrossshire_foulminded);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&burt_ametabola,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *kinrossshire_foulminded)\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *salvationism_subintroduction = 0;\r\n char **linearisation_quadripole = 0;\r\n char *haily_rankine[18] = {0};\r\n ++global_variable;;\r\n if (kinrossshire_foulminded != 0) {;\r\n haily_rankine[6] = kinrossshire_foulminded;\r\n linearisation_quadripole = haily_rankine;\r\n salvationism_subintroduction = ((char *)linearisation_quadripole[6]);\r\n \r\n while(isalnum(salvationism_subintroduction[size]) && size < strlen(salvationism_subintroduction)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(salvationism_subintroduction)) {\r\n salvationism_subintroduction = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,salvationism_subintroduction);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (linearisation_quadripole[6] != 0) \r\n free(((char *)linearisation_quadripole[6]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,salvationism_subintroduction);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
