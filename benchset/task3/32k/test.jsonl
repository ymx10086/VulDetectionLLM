{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint clubionidae_chrysidella = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid laft_amphore(int scissible_chromoplasm,char **upset_geniture);\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n int inconstancy_capacious = 7;\r\n int shanna_uses;\r\n char **pleonastic_botocudo = 0;\r\n char **bipyramidal_soothest = 0;\r\n char *hemicyclic_exacerbescence[84] = {0};\r\n char *spunkily_molopo;\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&clubionidae_chrysidella,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n spunkily_molopo = getenv(\"DYSPROSIUM_BIOFOG\");\r\n if (spunkily_molopo != 0) {;\r\n hemicyclic_exacerbescence[6] = spunkily_molopo;\r\n shanna_uses = 1;\r\n pleonastic_botocudo = hemicyclic_exacerbescence;\r\n bipyramidal_soothest = ((char **)(((unsigned long )pleonastic_botocudo) * shanna_uses * shanna_uses)) + 5;\r\n laft_amphore(inconstancy_capacious,bipyramidal_soothest);\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\n\r\nvoid laft_amphore(int scissible_chromoplasm,char **upset_geniture)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *duramens_counterfleury = 0;\r\n ++global_variable;\r\n scissible_chromoplasm--;\r\n if (scissible_chromoplasm > 0) {\r\n laft_amphore(scissible_chromoplasm,upset_geniture);\r\n return ;\r\n }\r\n duramens_counterfleury = ((char *)(upset_geniture - 5)[6]);\r\n \r\n if (strlen(duramens_counterfleury) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n snprintf(command_buffer, 1000, \"%s%s\",command_str,duramens_counterfleury);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint unforeign_vocationalism = 0;\r\nint global_variable;\r\ntypedef char *sesquiterpene_bridewain;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nsesquiterpene_bridewain piangendo_hectograph(sesquiterpene_bridewain archmonarchy_turlupin);\r\nvoid televising_nook(sesquiterpene_bridewain delegalized_fatbrained);\r\nvoid viritrate_saiff(sesquiterpene_bridewain nasiei_frankly);\r\nvoid protatically_tarrock(sesquiterpene_bridewain eumitosis_memphitic);\r\nvoid reimpress_vachette(sesquiterpene_bridewain supersensually_garages);\r\nvoid eremital_asians(sesquiterpene_bridewain demonstratively_tribunate);\r\nvoid hot_reedplot(sesquiterpene_bridewain outstair_peeving);\r\nvoid vetanda_exr(sesquiterpene_bridewain djailolo_laboured);\r\nvoid diplophonia_cynics(sesquiterpene_bridewain teays_byronics);\r\nvoid radicule_gymnoceratous(sesquiterpene_bridewain deste_ureterectomies);\r\nvoid but_macy(sesquiterpene_bridewain undebating_wasson);\r\nstruct struct {\r\n void (*function_ptr_1)();\r\n unsigned int input_num;\r\n void (*function_ptr_2)();\r\n};\r\nvoid function() {\r\n \r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{\r\n sesquiterpene_bridewain seed_dentalise = 0;\r\n sesquiterpene_bridewain harbour_thyroidean = 0;\r\n char *brucella_sphenomalar;;\r\n if (__sync_bool_compare_and_swap(&unforeign_vocationalism,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n brucella_sphenomalar = getenv(\"UNMUSICAL_AUTOREINFUSION\");\r\n if (brucella_sphenomalar != 0) {;\r\n harbour_thyroidean = brucella_sphenomalar;\r\n seed_dentalise = piangendo_hectograph(harbour_thyroidean);\r\n televising_nook(seed_dentalise);\r\n }\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nsesquiterpene_bridewain piangendo_hectograph(sesquiterpene_bridewain archmonarchy_turlupin)\r\n{\r\n ++global_variable;\r\n return archmonarchy_turlupin;\r\n}\r\n\r\nvoid televising_nook(sesquiterpene_bridewain delegalized_fatbrained)\r\n{\r\n ++global_variable;;\r\n viritrate_saiff(delegalized_fatbrained);\r\n}\r\n\r\nvoid viritrate_saiff(sesquiterpene_bridewain nasiei_frankly)\r\n{\r\n ++global_variable;;\r\n protatically_tarrock(nasiei_frankly);\r\n}\r\n\r\nvoid protatically_tarrock(sesquiterpene_bridewain eumitosis_memphitic)\r\n{\r\n ++global_variable;;\r\n reimpress_vachette(eumitosis_memphitic);\r\n}\r\n\r\nvoid reimpress_vachette(sesquiterpene_bridewain supersensually_garages)\r\n{\r\n ++global_variable;;\r\n eremital_asians(supersensually_garages);\r\n}\r\n\r\nvoid eremital_asians(sesquiterpene_bridewain demonstratively_tribunate)\r\n{\r\n ++global_variable;;\r\n hot_reedplot(demonstratively_tribunate);\r\n}\r\n\r\nvoid hot_reedplot(sesquiterpene_bridewain outstair_peeving)\r\n{\r\n ++global_variable;;\r\n vetanda_exr(outstair_peeving);\r\n}\r\n\r\nvoid vetanda_exr(sesquiterpene_bridewain djailolo_laboured)\r\n{\r\n ++global_variable;;\r\n diplophonia_cynics(djailolo_laboured);\r\n}\r\n\r\nvoid diplophonia_cynics(sesquiterpene_bridewain teays_byronics)\r\n{\r\n ++global_variable;;\r\n radicule_gymnoceratous(teays_byronics);\r\n}\r\n\r\nvoid radicule_gymnoceratous(sesquiterpene_bridewain deste_ureterectomies)\r\n{\r\n ++global_variable;;\r\n but_macy(deste_ureterectomies);\r\n}\r\n\r\nvoid but_macy(sesquiterpene_bridewain undebating_wasson)\r\n{\r\n char *byte_4 = 0;\r\n char *byte_3 = 0;\r\n unsigned int *ptr = 0;\r\n struct struct ssS;\r\n char *sweetnesses_frostbitten = 0;\r\n ++global_variable;;\r\n sweetnesses_frostbitten = ((char *)undebating_wasson);\r\n \r\n ssS.function_ptr_1 = function;\r\n ssS.function_ptr_2 = function;\r\n if (strlen(sweetnesses_frostbitten) >= 1 &&\r\n sweetnesses_frostbitten[0] != '-') {\r\n ssS.input_num = strtoul(sweetnesses_frostbitten,0U,16);\r\n ptr = &(ssS.input_num);\r\n if ( *ptr > 65535) {\r\n \r\n \r\n \r\n byte_3 = ((char *)(ptr + 2));\r\n byte_4 = ((char *)(ptr + 3));\r\n *byte_3 = 0;\r\n *byte_4 = 0;\r\n \r\n \r\n \r\n }\r\n \r\n \r\n ssS.function_ptr_2();\r\n \r\n printf(\"Value = %i\\n\", ssS.input_num);\r\n } else if (strlen(sweetnesses_frostbitten) == 0) {\r\n printf(\"Input is empty string\\n\");\r\n } else {\r\n printf(\"Input is negative number\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n ssS.function_ptr_2();\n```", "cwe": "682"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n#include <time.h> \r\n#include <sys/stat.h> \r\nint shul_norms = 0;\r\n\r\nstruct carrelli_dumpily \r\n{\r\n char *colt_transshaped;\r\n double encolden_deiope;\r\n char *tribespeople_heptastrophic;\r\n char exophthalmia_clover;\r\n int vidette_quadruplex;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *fissuriform_aurotellurite);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&shul_norms,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *fissuriform_aurotellurite)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *torchier_prehistoric = 0;\r\n struct carrelli_dumpily *should_antehistoric = {0};\r\n struct carrelli_dumpily minie_queenanne;\r\n ++global_variable;;\r\n if (fissuriform_aurotellurite != 0) {;\r\n minie_queenanne . colt_transshaped = ((char *)fissuriform_aurotellurite);\r\n should_antehistoric = &minie_queenanne;\r\n torchier_prehistoric = ((char *)( *should_antehistoric) . colt_transshaped);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, torchier_prehistoric);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (( *should_antehistoric) . colt_transshaped != 0) \r\n free(((char *)( *should_antehistoric) . colt_transshaped));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer)) {\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n } else {\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint erath_sublacustrine = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid philomythic_bronchotomy(int receiptless_unroasted,char **minsteryard_megadonty);\r\nvoid ficuses_hornswoggled(int polygene_mutable,char **modishly_knowableness);\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int faithbreach_warrigals = 7;\r\n char **overcherished_unprovide = 0;\r\n char **merribush_spraggs = 0;\r\n int townships_navete = 0;\r\n char *voltages_sjenicki = 0;\r\n char *electrotrephine_offend;;\r\n if (__sync_bool_compare_and_swap(&erath_sublacustrine,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n electrotrephine_offend = getenv(\"KAOHSIUNG_GRAUBUNDEN\");\r\n if (electrotrephine_offend != 0) {;\r\n townships_navete = ((int )(strlen(electrotrephine_offend)));\r\n voltages_sjenicki = ((char *)(malloc(townships_navete + 1)));\r\n if (voltages_sjenicki == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(voltages_sjenicki,0,townships_navete + 1);\r\n memcpy(voltages_sjenicki,electrotrephine_offend,townships_navete);\r\n overcherished_unprovide = &voltages_sjenicki;\r\n merribush_spraggs = overcherished_unprovide + 5;\r\n philomythic_bronchotomy(faithbreach_warrigals,merribush_spraggs);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid philomythic_bronchotomy(int receiptless_unroasted,char **minsteryard_megadonty)\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *posher_vitreouslike = 0;\r\n ++global_variable;\r\n receiptless_unroasted--;\r\n if (receiptless_unroasted > 0) {\r\n ficuses_hornswoggled(receiptless_unroasted,minsteryard_megadonty);\r\n return ;\r\n }\r\n posher_vitreouslike = ((char *)( *(minsteryard_megadonty - 5)));\r\n \r\n while(isalnum(posher_vitreouslike[size]) && size < strlen(posher_vitreouslike)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(posher_vitreouslike)) {\r\n posher_vitreouslike = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,posher_vitreouslike);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if ( *(minsteryard_megadonty - 5) != 0) \r\n free(((char *)( *(minsteryard_megadonty - 5))));\r\nclose_printf_context();\r\n}\r\n\r\nvoid ficuses_hornswoggled(int polygene_mutable,char **modishly_knowableness)\r\n{\r\n ++global_variable;\r\n philomythic_bronchotomy(polygene_mutable,modishly_knowableness);\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,posher_vitreouslike);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint salzhauer_nitwitted = 0;\r\nint global_variable;\r\nvoid woa_harped(char **compathy_cinemelodrama);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid ellington_electing(void (*subindicating_possesses)(char **));\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_t t0, t1;\r\npthread_mutex_t mutex_0, mutex_1;\r\nint dev_amount = 1;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcDevamount(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int qsize;\r\n \r\n printf(\"Inside calcDevAmount\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n \r\n \r\n dev_amount = Data->data[0] - 'A'; \r\n qsize = Data->qsize;\r\n if (dev_amount < 0) { \r\n dev_amount *= -1; \r\n }\r\n \r\n readFile(Data->file2);\r\n if (dev_amount == 0) { \r\n dev_amount += 1; \r\n }\r\n \r\n \r\n pthread_mutex_unlock(&mutex_0);\r\n return NULL;\r\n}\r\nvoid *devChar(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i;\r\n int i;\r\n int *arr = NULL;\r\n \r\n printf(\"Inside devChar\\n\");\r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n pthread_mutex_lock(&mutex_1);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n \r\n \r\n \r\n for (i = 0; i < strlen(Data->data); i++) { \r\n Data->data[i] /= dev_amount; \r\n }\r\n \r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&salzhauer_nitwitted,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n ellington_electing(woa_harped);\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid woa_harped(char **compathy_cinemelodrama)\r\n{\r\n char *analepses_glenellyn;\r\n ++global_variable;;\r\n setup_printf_context();\r\n analepses_glenellyn = getenv(\"UNAPPERCEPTIVE_SHERR\");\r\n if (analepses_glenellyn != 0) {;\r\n *compathy_cinemelodrama = analepses_glenellyn;\r\n }\r\n}\r\n\r\nvoid ellington_electing(void (*subindicating_possesses)(char **))\r\n{\r\n struct data* Data;\r\n char *scrams_unbishop = 0;\r\n char **leavittsburg_miscompute[3] = {0};\r\n int smethwick_haulmier;\r\n char **catholicise_blockholer = 0;\r\n char **ignitive_disorder = 0;\r\n ++global_variable;\r\n char *farmership_rebalanced = 0;\r\n subindicating_possesses(&farmership_rebalanced);\r\n if (farmership_rebalanced != 0) {;\r\n smethwick_haulmier = 1;\r\n catholicise_blockholer = &farmership_rebalanced;\r\n ignitive_disorder = ((char **)(((unsigned long )catholicise_blockholer) * smethwick_haulmier * smethwick_haulmier)) + 5;\r\n leavittsburg_miscompute[0] = ignitive_disorder;\r\n scrams_unbishop = ((char *)( *(leavittsburg_miscompute[0] - 5)));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(scrams_unbishop) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(scrams_unbishop) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(scrams_unbishop) + 1));\r\n if (Data->data) {\r\n if ((sscanf(scrams_unbishop, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n \r\n \r\n \r\n \r\n \r\n if (strlen(Data->data) > 50) { \r\n \r\n if (pthread_create(&t0, NULL, calcDevamount, Data) != 0) { \r\n printf(\"Error initializing thread 0.\");\r\n }\r\n }\r\n if (pthread_create(&t1, NULL, devChar, Data) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n if (strlen(Data->data) > 50) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n for (i = 0; i < strlen(Data->data); i++) { \n Data->data[i] /= dev_amount; \n }\n```", "cwe": "821"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint supergenual_stelliscript = 0;\r\ntypedef char *musit_dinner;\r\nint global_variable;\r\nvoid handle_taint(char *miliolite_nullity);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&supergenual_stelliscript,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid handle_taint(char *miliolite_nullity)\r\n{\r\n int i = 0;\r\n int buff_size = 63;\r\n int taint_len;\r\n char *heap_buff_64 = 0;\r\n char *butylation_meth = 0;\r\n musit_dinner petrovsk_upbrighten = 0;\r\n int **************************************************convoker_camletine = 0;\r\n int *************************************************basyl_charivan = 0;\r\n int ************************************************chromite_dehortatory = 0;\r\n int ***********************************************kiddingly_saltman = 0;\r\n int **********************************************constringed_precultivating = 0;\r\n int *********************************************disembitter_schroeder = 0;\r\n int ********************************************kinglihood_truanting = 0;\r\n int *******************************************tardily_gonidial = 0;\r\n int ******************************************dentinasal_hopples = 0;\r\n int *****************************************curucaneca_metrorrhagia = 0;\r\n int ****************************************markkaa_coadjudicator = 0;\r\n int ***************************************nymphos_rontgenized = 0;\r\n int **************************************goggan_elver = 0;\r\n int *************************************outbloomed_recontrolling = 0;\r\n int ************************************fertilize_antitorpedo = 0;\r\n int ***********************************dhamma_superalkalinity = 0;\r\n int **********************************enterotoxemia_pragmatizer = 0;\r\n int *********************************hogg_revengeless = 0;\r\n int ********************************overbaking_achievable = 0;\r\n int *******************************filigraned_mastosquamose = 0;\r\n int ******************************bootied_carlovingian = 0;\r\n int *****************************coat_tungus = 0;\r\n int ****************************smokish_doddle = 0;\r\n int ***************************jamesstore_yesima = 0;\r\n int **************************xanthene_cullionly = 0;\r\n int *************************bared_radicates = 0;\r\n int ************************chaunter_ocdm = 0;\r\n int ***********************caprylic_munific = 0;\r\n int **********************convertend_manganocalcite = 0;\r\n int *********************sassanid_eucrite = 0;\r\n int ********************bontocs_cardiokinetic = 0;\r\n int *******************superweapon_fivish = 0;\r\n int ******************rostrated_formalist = 0;\r\n int *****************illusorily_enviroment = 0;\r\n int ****************loses_stratochamber = 0;\r\n int ***************fairly_propagand = 0;\r\n int **************krameria_munificency = 0;\r\n int *************bedumbing_sunsuit = 0;\r\n int ************aeu_castora = 0;\r\n int ***********hanses_mundugumors = 0;\r\n int **********filibusterism_pleurobrachia = 0;\r\n int *********kweichow_ignatia = 0;\r\n int ********phenylcarbamic_centralistic = 0;\r\n int *******ringing_pin = 0;\r\n int ******sightliness_absorbs = 0;\r\n int *****doglegging_niris = 0;\r\n int ****stationing_incarcerate = 0;\r\n int ***urinator_fripperer = 0;\r\n int **cohog_lappish = 0;\r\n int *leckrone_ogham = 0;\r\n int chymify_fulvous;\r\n musit_dinner scriptural_acetophenine[10] = {0};\r\n musit_dinner familiarised_temperate = 0;\r\n ++global_variable;;\r\n if (miliolite_nullity != 0) {;\r\n familiarised_temperate = miliolite_nullity;\r\n chymify_fulvous = 5;\r\n leckrone_ogham = &chymify_fulvous;\r\n cohog_lappish = &leckrone_ogham;\r\n urinator_fripperer = &cohog_lappish;\r\n stationing_incarcerate = &urinator_fripperer;\r\n doglegging_niris = &stationing_incarcerate;\r\n sightliness_absorbs = &doglegging_niris;\r\n ringing_pin = &sightliness_absorbs;\r\n phenylcarbamic_centralistic = &ringing_pin;\r\n kweichow_ignatia = &phenylcarbamic_centralistic;\r\n filibusterism_pleurobrachia = &kweichow_ignatia;\r\n hanses_mundugumors = &filibusterism_pleurobrachia;\r\n aeu_castora = &hanses_mundugumors;\r\n bedumbing_sunsuit = &aeu_castora;\r\n krameria_munificency = &bedumbing_sunsuit;\r\n fairly_propagand = &krameria_munificency;\r\n loses_stratochamber = &fairly_propagand;\r\n illusorily_enviroment = &loses_stratochamber;\r\n rostrated_formalist = &illusorily_enviroment;\r\n superweapon_fivish = &rostrated_formalist;\r\n bontocs_cardiokinetic = &superweapon_fivish;\r\n sassanid_eucrite = &bontocs_cardiokinetic;\r\n convertend_manganocalcite = &sassanid_eucrite;\r\n caprylic_munific = &convertend_manganocalcite;\r\n chaunter_ocdm = &caprylic_munific;\r\n bared_radicates = &chaunter_ocdm;\r\n xanthene_cullionly = &bared_radicates;\r\n jamesstore_yesima = &xanthene_cullionly;\r\n smokish_doddle = &jamesstore_yesima;\r\n coat_tungus = &smokish_doddle;\r\n bootied_carlovingian = &coat_tungus;\r\n filigraned_mastosquamose = &bootied_carlovingian;\r\n overbaking_achievable = &filigraned_mastosquamose;\r\n hogg_revengeless = &overbaking_achievable;\r\n enterotoxemia_pragmatizer = &hogg_revengeless;\r\n dhamma_superalkalinity = &enterotoxemia_pragmatizer;\r\n fertilize_antitorpedo = &dhamma_superalkalinity;\r\n outbloomed_recontrolling = &fertilize_antitorpedo;\r\n goggan_elver = &outbloomed_recontrolling;\r\n nymphos_rontgenized = &goggan_elver;\r\n markkaa_coadjudicator = &nymphos_rontgenized;\r\n curucaneca_metrorrhagia = &markkaa_coadjudicator;\r\n dentinasal_hopples = &curucaneca_metrorrhagia;\r\n tardily_gonidial = &dentinasal_hopples;\r\n kinglihood_truanting = &tardily_gonidial;\r\n disembitter_schroeder = &kinglihood_truanting;\r\n constringed_precultivating = &disembitter_schroeder;\r\n kiddingly_saltman = &constringed_precultivating;\r\n chromite_dehortatory = &kiddingly_saltman;\r\n basyl_charivan = &chromite_dehortatory;\r\n convoker_camletine = &basyl_charivan;\r\n scriptural_acetophenine[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *convoker_camletine)))))))))))))))))))))))))))))))))))))))))))))))))] = familiarised_temperate;\r\n petrovsk_upbrighten = scriptural_acetophenine[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *convoker_camletine)))))))))))))))))))))))))))))))))))))))))))))))))];\r\n butylation_meth = ((char *)petrovsk_upbrighten);\r\n \r\n \r\n \r\n heap_buff_64 = (char*) malloc(64 * sizeof(char));\r\n if (heap_buff_64 != NULL) {\r\n memset(heap_buff_64, 'A' ,64);\r\n heap_buff_64[64 - 1] = '\\0';\r\n \r\n \r\n \r\n taint_len = ((int )(strlen(butylation_meth)));\r\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\r\n \r\n \r\n heap_buff_64[buff_size] = butylation_meth[taint_len];\r\n }\r\n \r\n for (; i < 64; ++i) {\r\n heap_buff_64[i] = toupper(heap_buff_64[i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",&(heap_buff_64[buff_size+1]));\r\n free(heap_buff_64);\r\n \r\n \r\n \r\n }\r\n;\r\n if (petrovsk_upbrighten != 0) \r\n free(((char *)petrovsk_upbrighten));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` taint_len = ((int )(strlen(butylation_meth)));\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\n \n \n heap_buff_64[buff_size] = butylation_meth[taint_len];\n }\n \n for (; i < 64; ++i) {\n heap_buff_64[i] = toupper(heap_buff_64[i]);\n }\n```", "cwe": "124"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint suppressors_modalize = 0;\r\nint global_variable;\r\n\r\nunion ureterostomies_patrizate \r\n{\r\n char *stromal_miseries;\r\n double pomiculture_groupoids;\r\n char *yolkiest_stronghurst;\r\n char trepanning_intentively;\r\n int homoplastically_interwreathed;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid regalvanization_palisado(union ureterostomies_patrizate *chalcis_uncaptived);\r\nvoid snippily_yarnell(union ureterostomies_patrizate *trimerite_tangibleness);\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n union ureterostomies_patrizate *weaver_recitement = {0};\r\n union ureterostomies_patrizate tomtit_hexathlon;\r\n char *klarika_loudlier;;\r\n if (__sync_bool_compare_and_swap(&suppressors_modalize,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n klarika_loudlier = getenv(\"MORTORIO_UNCURB\");\r\n if (klarika_loudlier != 0) {;\r\n tomtit_hexathlon . stromal_miseries = klarika_loudlier;\r\n weaver_recitement = &tomtit_hexathlon;\r\n regalvanization_palisado(weaver_recitement);\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid regalvanization_palisado(union ureterostomies_patrizate *chalcis_uncaptived)\r\n{\r\n ++global_variable;;\r\n snippily_yarnell(chalcis_uncaptived);\r\n}\r\n\r\nvoid snippily_yarnell(union ureterostomies_patrizate *trimerite_tangibleness)\r\n{\r\n int ss_j;\r\n int ss_i;\r\n size_t taint_size;\r\n char **malloced_buff = 0;\r\n int trace_flag = 0;\r\n char *oculary_popeyed = 0;\r\n ++global_variable;;\r\n oculary_popeyed = ((char *)( *trimerite_tangibleness) . stromal_miseries);\r\n \r\n taint_size = strlen(oculary_popeyed);\r\n \r\n if (taint_size >= 1600) {\r\n taint_size = 1599U;\r\n }\r\n malloced_buff = malloc(taint_size * sizeof(char *));\r\n \r\n \r\n if (malloced_buff != 0) {\r\n \r\n \r\n for (ss_i = 0; ss_i < taint_size; ++ss_i) {\r\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\r\n \r\n \r\n if (malloced_buff[ss_i] == 0 && errno == 12) {\r\n printf(\"Malloc error due to ulimit\\n\");\r\n if (trace_flag == 0) {\r\n \r\n \r\n trace_flag = 1;\r\n }\r\n }\r\n if (malloced_buff[ss_i] != 0) {\r\n for (ss_j = 0; ss_j < taint_size; ++ss_j) {\r\n memcpy(malloced_buff[ss_i] + ss_j * taint_size,oculary_popeyed,taint_size);\r\n }\r\n }\r\n \r\n \r\n if (taint_size % 2 == 0) {\r\n if (malloced_buff[ss_i] != 0) {\r\n free(malloced_buff[ss_i]);\r\n \r\n }\r\n }\r\n }\r\n free(malloced_buff);\r\n \r\n }\r\n;\r\nclose_printf_context();\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n \n \n if (malloced_buff[ss_i] == 0 && errno == 12) {\n printf(\"Malloc error due to ulimit\\n\");\n if (trace_flag == 0) {\n \n```", "cwe": "401"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\nint sloths_nonvirtuously = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid paraglossal_propleuron(int pompster_manganate,... );\r\nvoid encrinidae_choriambi(char *complish_orinasality);\r\nvoid insulinizing_uppiles(char *subattenuate_unzip);\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int dongola_usucaptible = 0;\r\n char *aweing_criseyde = 0;\r\n char *seminomas_neurosynapse;;\r\n if (__sync_bool_compare_and_swap(&sloths_nonvirtuously,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n seminomas_neurosynapse = getenv(\"UNENJOYABLENESS_GLUMALES\");\r\n if (seminomas_neurosynapse != 0) {;\r\n dongola_usucaptible = ((int )(strlen(seminomas_neurosynapse)));\r\n aweing_criseyde = ((char *)(malloc(dongola_usucaptible + 1)));\r\n if (aweing_criseyde == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(aweing_criseyde,0,dongola_usucaptible + 1);\r\n memcpy(aweing_criseyde,seminomas_neurosynapse,dongola_usucaptible);\r\n paraglossal_propleuron(1,aweing_criseyde);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid paraglossal_propleuron(int pompster_manganate,... )\r\n{\r\n char *seignories_radiologically = 0;\r\n va_list interleague_nondeductive;\r\n ++global_variable;;\r\n if (pompster_manganate > 0) {\r\n __builtin_va_start(interleague_nondeductive,pompster_manganate);\r\n seignories_radiologically = (va_arg(interleague_nondeductive,char *));\r\n __builtin_va_end(interleague_nondeductive);\r\n }\r\n encrinidae_choriambi(seignories_radiologically);\r\n}\r\n\r\nvoid encrinidae_choriambi(char *complish_orinasality)\r\n{\r\n ++global_variable;;\r\n insulinizing_uppiles(complish_orinasality);\r\n}\r\n\r\nvoid insulinizing_uppiles(char *subattenuate_unzip)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *sanctologist_nonlimitative = 0;\r\n ++global_variable;;\r\n sanctologist_nonlimitative = ((char *)subattenuate_unzip);\r\n \r\n len = strtol(sanctologist_nonlimitative,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (subattenuate_unzip != 0) \r\n free(((char *)subattenuate_unzip));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint gluons_bushlet = 0;\r\n\r\nunion sonsy_alocasia \r\n{\r\n char *frenatae_eneugh;\r\n double lecithins_kine;\r\n char *captions_abscess;\r\n char twalpennyworth_meisterstck;\r\n int stupider_spleenwort;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *adjective_diuron);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid laders_bashlyks(int brainlessness_unanalagous,union sonsy_alocasia *myatonic_ingross);\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&gluons_bushlet,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid handle_taint(char *adjective_diuron)\r\n{\r\n int disaugment_gwelo = 7;\r\n int clition_mesoplanktonic;\r\n union sonsy_alocasia *kinaesthetic_savors = {0};\r\n union sonsy_alocasia *trustees_unentreatable = {0};\r\n union sonsy_alocasia osterhus_sanidinic;\r\n ++global_variable;;\r\n if (adjective_diuron != 0) {;\r\n osterhus_sanidinic . frenatae_eneugh = adjective_diuron;\r\n clition_mesoplanktonic = 1;\r\n kinaesthetic_savors = &osterhus_sanidinic;\r\n trustees_unentreatable = ((union sonsy_alocasia *)(((unsigned long )kinaesthetic_savors) * clition_mesoplanktonic * clition_mesoplanktonic)) + 5;\r\n laders_bashlyks(disaugment_gwelo,trustees_unentreatable);\r\n }\r\n}\r\n\r\nvoid laders_bashlyks(int brainlessness_unanalagous,union sonsy_alocasia *myatonic_ingross)\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *spicer_insculptured = 0;\r\n ++global_variable;\r\n brainlessness_unanalagous--;\r\n if (brainlessness_unanalagous > 0) {\r\n laders_bashlyks(brainlessness_unanalagous,myatonic_ingross);\r\n return ;\r\n }\r\n spicer_insculptured = ((char *)( *(myatonic_ingross - 5)) . frenatae_eneugh);\r\n \r\n \r\n\r\n if (strlen(spicer_insculptured) < 63) {\r\n skip_malloc_buffer = malloc(strlen(spicer_insculptured + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,spicer_insculptured);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\n if (( *(myatonic_ingross - 5)) . frenatae_eneugh != 0) \r\n free(((char *)( *(myatonic_ingross - 5)) . frenatae_eneugh));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n strcpy(skip_malloc_buffer,spicer_insculptured);\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint kobo_schizophrene = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\nstruct struct {\r\n int (* before)(int);\r\n char buffer[64];\r\n int (* after)(int);\r\n};\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n int i = 0;\r\n struct struct* data = NULL;\r\n int buff_size = 63;\r\n int taint_len;\r\n char *eupathy_forsythia = 0;\r\n void *apex_diametrical = 0;\r\n long basaree_propylidene[10];\r\n void *biasing_conveying[10] = {0};\r\n void *crambes_seidule = 0;\r\n char *landladydom_drosky;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&kobo_schizophrene,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n landladydom_drosky = getenv(\"REPRESSOR_POMMELS\");\r\n if (landladydom_drosky != 0) {;\r\n crambes_seidule = ((void *)landladydom_drosky);\r\n biasing_conveying[5] = crambes_seidule;\r\n basaree_propylidene[1] = 5;\r\n apex_diametrical = *(biasing_conveying + basaree_propylidene[1]);\r\n if (((char *)apex_diametrical) != 0) {\r\n goto lusterlessness_monocarps;\r\n }\r\n ++global_variable;\r\n lusterlessness_monocarps:;\r\n eupathy_forsythia = ((char *)((char *)apex_diametrical));\r\n \r\n \r\n \r\n data = (struct struct*) malloc(sizeof(struct struct));\r\n if (data != NULL) {\r\n data->before = toupper;\r\n memset(data->buffer, 'A', 64);\r\n data->buffer[63] = '\\0';\r\n data->after = toupper;\r\n \r\n \r\n \r\n \r\n \r\n taint_len = ((int )(strlen(eupathy_forsythia)));\r\n \r\n \r\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\r\n data->buffer[buff_size] = eupathy_forsythia[taint_len];\r\n }\r\n \r\n for (i = 0; i < 64; ++i) {\r\n data->buffer[i] = toupper(data->buffer[i]);\r\n printf(\"%c\",data->before(data->buffer[i]));\r\n }\r\n \r\n \r\n printf(\"\\n\");\r\n free(data);\r\n \r\n \r\n \r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` taint_len = ((int )(strlen(eupathy_forsythia)));\n \n \n for (; taint_len >= 0; (--buff_size , --taint_len)) {\n data->buffer[buff_size] = eupathy_forsythia[taint_len];\n }\n \n for (i = 0; i < 64; ++i) {\n data->buffer[i] = toupper(data->buffer[i]);\n printf(\"%c\",data->before(data->buffer[i]));\n }\n```", "cwe": "124"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint endurability_devy = 0;\r\nint global_variable;\r\nvoid handle_taint(char *nullity_petre);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid mumruffin_caped(int convulsiveness_capitalizes,... );\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&endurability_devy,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *nullity_petre)\r\n{\r\n ++global_variable;;\r\n if (nullity_petre != 0) {;\r\n mumruffin_caped(1,nullity_petre);\r\n }\r\n}\r\n\r\nvoid mumruffin_caped(int convulsiveness_capitalizes,... )\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *zambezian_salicylanilide = 0;\r\n char *allochezia_kryska = 0;\r\n va_list skagen_mouthiness;\r\n ++global_variable;;\r\n if (convulsiveness_capitalizes > 0) {\r\n __builtin_va_start(skagen_mouthiness,convulsiveness_capitalizes);\r\n allochezia_kryska = (va_arg(skagen_mouthiness,char *));\r\n __builtin_va_end(skagen_mouthiness);\r\n }\r\n zambezian_salicylanilide = ((char *)allochezia_kryska);\r\n \r\n while(isalnum(zambezian_salicylanilide[size]) && size < strlen(zambezian_salicylanilide)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(zambezian_salicylanilide)) {\r\n zambezian_salicylanilide = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,zambezian_salicylanilide);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (allochezia_kryska != 0) \r\n free(((char *)allochezia_kryska));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,zambezian_salicylanilide);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <setjmp.h> \r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint genesco_bordar = 0;\r\ntypedef char *luminodynamist_risley;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n char buffer[80];\r\n FILE *pFile = 0;\r\n char *any_scuppering = 0;\r\n jmp_buf unproviding_sinuate;\r\n int nemichthys_medievalists;\r\n luminodynamist_risley belock_cointension = 0;\r\n long weka_spaits[10];\r\n luminodynamist_risley fast_opalocka[10] = {0};\r\n luminodynamist_risley temporization_tropicalih = 0;\r\n int underworlds_galosh = 45;\r\n char *nonpresentable_overinflating;\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&genesco_bordar,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&nonpresentable_overinflating,\"7106\",underworlds_galosh);\r\n if (nonpresentable_overinflating != 0) {;\r\n temporization_tropicalih = nonpresentable_overinflating;\r\n fast_opalocka[5] = temporization_tropicalih;\r\n weka_spaits[1] = 5;\r\n belock_cointension = *(fast_opalocka + weka_spaits[1]);\r\n nemichthys_medievalists = setjmp(unproviding_sinuate);\r\n if (nemichthys_medievalists == 0) {\r\n longjmp(unproviding_sinuate,1);\r\n }\r\n any_scuppering = ((char *)belock_cointension);\r\n \r\n \r\n\r\n pFile = fopen(any_scuppering,\"r\");\r\n buffer[0] = 0;\r\n \r\n \r\n \r\n\r\n fgets(buffer,79,pFile);\r\n printf(buffer);\r\n printf(\"\\n\");\r\n fclose(pFile);\r\n \r\n \r\n;\r\n if (belock_cointension != 0) \r\n free(((char *)belock_cointension));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n fgets(buffer,79,pFile);\n printf(buffer);\n printf(\"\\n\");\n fclose(pFile);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <openssl/evp.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <sys/types.h> \r\n#include <sys/wait.h> \r\n#include <unistd.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint valew_retiring = 0;\r\nint global_variable;\r\n\r\nstruct bankruptcies_arrester \r\n{\r\n char *nonprossing_predescend;\r\n double hydrocoralline_grosmark;\r\n char *exareolate_staggerwort;\r\n char leos_pseudoembryo;\r\n int jerry_linemen;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid unbereaven_cheapener(int nonremovable_irrationally,struct bankruptcies_arrester effluent_massiveness);\r\nvoid saprophytic_trainer(int ordinariness_brininess,struct bankruptcies_arrester protevangelion_subaggregative);\r\nvoid evp_hash(const char *algorithm_name,char *filename) {\r\n int ii = 0;\r\n FILE *file_stream = 0;\r\n char hash_print_val[129] = {0};\r\n unsigned char file_contents[1024];\r\n size_t file_contents_size = 1024;\r\n size_t file_contents_size_read = 0;\r\n const EVP_MD *md_engine = 0;\r\n unsigned char md_value[64];\r\n unsigned int md_value_len = 0;\r\n EVP_MD_CTX *md_context = 0;\r\n int hash_update_result = 0;\r\n \r\n memset(md_value,0,64);\r\n file_stream = fopen(filename,\"rb\");\r\n if (file_stream != 0) {\r\n md_engine = EVP_get_digestbyname(algorithm_name);\r\n if (md_engine != 0) {\r\n md_context = EVP_MD_CTX_create();\r\n if (md_context != 0) {\r\n if (EVP_DigestInit_ex(md_context,md_engine,0)) {\r\n \r\n while(!feof(file_stream)) {\r\n \r\n memset(file_contents,0,file_contents_size);\r\n file_contents_size_read = fread(file_contents,\r\n sizeof(unsigned char ),file_contents_size,file_stream);\r\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\r\n if (1 != hash_update_result) {\r\n break;\r\n }\r\n }\r\n \r\n if (1 == hash_update_result) {\r\n if (EVP_DigestFinal_ex(md_context,md_value,&md_value_len)) {\r\n for (ii = 0; ii < md_value_len; ++ii) {\r\n sprintf(&hash_print_val[ii * 2],\"%02x\",md_value[ii]);\r\n }\r\n printf(\"%s %s\\n\",hash_print_val,filename);\r\n } else {\r\n printf(\"Failure finalizing hash for file '%s' with algorithm '%s'.\\n\",\r\n filename,algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failure hashing file '%s' with algorithm '%s'.\\n\",filename,algorithm_name);\r\n }\r\n }\r\n EVP_MD_CTX_destroy(md_context);\r\n } else {\r\n printf(\"Could not create a context for hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Could not load hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failed to open file: '%s'\\n\",filename);\r\n }\r\n if (file_stream != 0) {\r\n fclose(file_stream);\r\n file_stream = 0;\r\n }\r\n}\r\nstruct pid_fd {\r\n pid_t pid;\r\n int fd_array[2];\r\n};\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?80 : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",80);\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n int homo_rifton = 7;\r\n struct bankruptcies_arrester heptastrophic_moralize = {0};\r\n int *warrigals_allumine = 0;\r\n int cludder_petiolus;\r\n struct bankruptcies_arrester wildling_coquettishness[10] = {0};\r\n struct bankruptcies_arrester mokamoka_forras;\r\n char *cephalanthus_microthyriaceae;;\r\n if (__sync_bool_compare_and_swap(&valew_retiring,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n cephalanthus_microthyriaceae = getenv(\"HOPE_SUPERMEDICINE\");\r\n if (cephalanthus_microthyriaceae != 0) {;\r\n mokamoka_forras . nonprossing_predescend = ((char *)cephalanthus_microthyriaceae);\r\n wildling_coquettishness[5] = mokamoka_forras;\r\n cludder_petiolus = 5;\r\n warrigals_allumine = &cludder_petiolus;\r\n heptastrophic_moralize = *(wildling_coquettishness + *warrigals_allumine);\r\n unbereaven_cheapener(homo_rifton,heptastrophic_moralize);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lcrypto -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid unbereaven_cheapener(int nonremovable_irrationally,struct bankruptcies_arrester effluent_massiveness)\r\n{\r\n int child_signal = 0;\r\n int child_pids_count = 21;\r\n pid_t child_pids[21];\r\n pid_t child_pid = -1;\r\n int ii = 0;\r\n int jj = 0;\r\n int algorithms_count = 7;\r\n const char *algorithms[7];\r\n struct pid_fd fd_array[21];\r\n int error = 0;\r\n int index = -1;\r\n char buf;\r\n char *knottiness_disklike = 0;\r\n ++global_variable;\r\n nonremovable_irrationally--;\r\n if (nonremovable_irrationally > 0) {\r\n saprophytic_trainer(nonremovable_irrationally,effluent_massiveness);\r\n return ;\r\n }\r\n knottiness_disklike = ((char *)effluent_massiveness . nonprossing_predescend);\r\n \r\n algorithms[0] = \"MD5\";\r\n algorithms[1] = \"SHA1\";\r\n algorithms[2] = \"SHA224\";\r\n algorithms[3] = \"SHA256\";\r\n algorithms[4] = \"SHA384\";\r\n algorithms[5] = \"SHA512\";\r\n algorithms[6] = \"RIPEMD160\";\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_pids[ii] = -1;\r\n }\r\n if (!error) {\r\n OPENSSL_add_all_algorithms_noconf();\r\n fflush(stdout);\r\n fflush(stdin);\r\n \r\n for (ii = 0; ii < 3; ++ii) {\r\n for (jj = 0; jj < algorithms_count; ++jj) {\r\n index = jj + ii * algorithms_count;\r\n if (pipe(fd_array[index].fd_array) == -1) {\r\n error = 1;\r\n printf(\"Error opening pipe\\n\");\r\n } else {\r\n child_pid = fork();\r\n if (child_pid >= 0) {\r\n if (child_pid == 0) {\r\n close(fd_array[index].fd_array[0]);\r\n dup2(fd_array[index].fd_array[1], STDOUT_FILENO);\r\n \r\n \r\n evp_hash(algorithms[jj], knottiness_disklike);\r\n \r\n close(fd_array[index].fd_array[1]);\r\n exit(0);\r\n } else {\r\n close(fd_array[index].fd_array[1]);\r\n fd_array[index].pid = child_pid;\r\n continue;\r\n }\r\n } else {\r\n \r\n printf(\"Failed to fork a child process.\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n }\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_signal = 0;\r\n if (fd_array[ii].pid < 1) {\r\n continue;\r\n }\r\n if (-1 == waitpid(fd_array[ii].pid, &child_signal, 0)) {\r\n \r\n printf(\"Failed to wait for child process: %d\\n\",child_signal);\r\n } else {\r\n if (WIFEXITED(child_signal)) {\r\n printf(\"Child process exited with status: %d\\n\",WEXITSTATUS(child_signal));\r\n } else if (WIFSIGNALED(child_signal)) {\r\n \r\n printf(\"Child process received signal: %d\\n\",WTERMSIG(child_signal));\r\n }\r\n while (read(fd_array[ii].fd_array[0], &buf, 1) > 0) {\r\n printf(\"%c\", buf);\r\n }\r\n close(fd_array[ii].fd_array[0]);\r\n }\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n\r\nvoid saprophytic_trainer(int ordinariness_brininess,struct bankruptcies_arrester protevangelion_subaggregative)\r\n{\r\n ++global_variable;\r\n unbereaven_cheapener(ordinariness_brininess,protevangelion_subaggregative);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(!feof(file_stream)) {\n \n memset(file_contents,0,file_contents_size);\n file_contents_size_read = fread(file_contents,\n sizeof(unsigned char ),file_contents_size,file_stream);\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\n if (1 != hash_update_result) {\n break;\n }\n }\n```", "cwe": "400"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint phosphene_campaigning = 0;\r\nint global_variable;\r\nvoid institory_rhinologic(char **flanneled_lability);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid informatus_underkind(void (*geiger_giblets)(char **));\r\nchar *devanagari_obes(char *repapers_shrived);\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&phosphene_campaigning,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n informatus_underkind(institory_rhinologic);\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid institory_rhinologic(char **flanneled_lability)\r\n{\r\n char *craw_finches;\r\n ++global_variable;;\r\n setup_printf_context();\r\n craw_finches = getenv(\"BACONY_WHITTERICK\");\r\n if (craw_finches != 0) {;\r\n *flanneled_lability = craw_finches;\r\n }\r\n}\r\n\r\nvoid informatus_underkind(void (*geiger_giblets)(char **))\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *polystichoid_aerobium = 0;\r\n char *bertha_exsert = 0;\r\n ++global_variable;\r\n char *anlage_svetlana = 0;\r\n geiger_giblets(&anlage_svetlana);\r\n if (anlage_svetlana != 0) {;\r\n bertha_exsert = devanagari_obes(anlage_svetlana);\r\n polystichoid_aerobium = ((char *)bertha_exsert);\r\n \r\n \r\n\r\n if (strlen(polystichoid_aerobium) < 63) {\r\n skip_malloc_buffer = malloc(strlen(polystichoid_aerobium + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,polystichoid_aerobium);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nchar *devanagari_obes(char *repapers_shrived)\r\n{\r\n ++global_variable;\r\n return repapers_shrived;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n strcpy(skip_malloc_buffer,polystichoid_aerobium);\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint armbruster_bisaxillary = 0;\r\nint global_variable;\r\ntypedef char *repreparing_boshbok;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nrepreparing_boshbok ketipate_enrolling(repreparing_boshbok agreat_coatimundi);\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n int ss_i = 0;\r\n char *subtaxon_exhaustions = 0;\r\n repreparing_boshbok recaution_yorick = 0;\r\n repreparing_boshbok uncaroled_foredoor = 0;\r\n char *organelles_dalhousie;\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&armbruster_bisaxillary,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&organelles_dalhousie,\"UNCONTEMPTIBLE_PLURISY\");\r\n if (organelles_dalhousie != 0) {;\r\n uncaroled_foredoor = organelles_dalhousie;\r\n recaution_yorick = ketipate_enrolling(uncaroled_foredoor);\r\n if (recaution_yorick != 0) {\r\n goto durax_unauthorized;\r\n }\r\n ++global_variable;\r\n durax_unauthorized:;\r\n subtaxon_exhaustions = ((char *)recaution_yorick);\r\n \r\n printf(\"checking input\\n\");\r\n \r\n \r\n \r\n while(ss_i < strlen(subtaxon_exhaustions)){\r\n \r\n if (subtaxon_exhaustions[ss_i] >= 48) {\r\n \r\n ++ss_i;\r\n }\r\n }\r\n \r\n \r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\n if (recaution_yorick != 0) \r\n free(((char *)recaution_yorick));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\n\r\nrepreparing_boshbok ketipate_enrolling(repreparing_boshbok agreat_coatimundi)\r\n{\r\n ++global_variable;\r\n return agreat_coatimundi;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while(ss_i < strlen(subtaxon_exhaustions)){\n \n if (subtaxon_exhaustions[ss_i] >= 48) {\n \n ++ss_i;\n }\n }\n```", "cwe": "835"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint preponderances_furrily = 0;\r\nint global_variable;\r\nvoid handle_taint(char *isn_animalism);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&preponderances_furrily,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid handle_taint(char *isn_animalism)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *scutel_algedo = 0;\r\n jmp_buf enlister_mulberry;\r\n int comicography_undersuck;\r\n void *tonishness_preliberation = 0;\r\n ++global_variable;;\r\n if (isn_animalism != 0) {;\r\n tonishness_preliberation = ((void *)isn_animalism);\r\n comicography_undersuck = setjmp(enlister_mulberry);\r\n if (comicography_undersuck == 0) {\r\n longjmp(enlister_mulberry,1);\r\n }\r\n scutel_algedo = ((char *)((char *)tonishness_preliberation));\r\n \r\n buffer_value = atoi(scutel_algedo);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\n if (((char *)tonishness_preliberation) != 0) \r\n free(((char *)((char *)tonishness_preliberation)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(malloc_buffer,0,size_buffer);\n printf(\"Buffer size is %d\\n\", size_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <unistd.h> \r\nint poplesie_below = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid acquests_teratomatous(char *const contriturate_paralgesia);\r\nvoid witwall_tsinghai(char *trigonometry_smoulder);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int humorless_iroko = 0;\r\n char *enouncement_ambaris = 0;\r\n int predifferent_unroll = 20;\r\n char *overnumerously_accoutres;;\r\n if (__sync_bool_compare_and_swap(&poplesie_below,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&overnumerously_accoutres,\"5475\",predifferent_unroll);\r\n if (overnumerously_accoutres != 0) {;\r\n humorless_iroko = ((int )(strlen(overnumerously_accoutres)));\r\n enouncement_ambaris = ((char *)(malloc(humorless_iroko + 1)));\r\n if (enouncement_ambaris == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(enouncement_ambaris,0,humorless_iroko + 1);\r\n memcpy(enouncement_ambaris,overnumerously_accoutres,humorless_iroko);\r\n if (overnumerously_accoutres != 0) \r\n free(((char *)overnumerously_accoutres));\r\n acquests_teratomatous(enouncement_ambaris);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n#define BEMIRED_EPIPHYSITIS(x) witwall_tsinghai((char *) x)\r\n\r\nvoid acquests_teratomatous(char *const contriturate_paralgesia)\r\n{\r\n ++global_variable;;\r\n\tBEMIRED_EPIPHYSITIS(contriturate_paralgesia);\r\n}\r\n\r\nvoid witwall_tsinghai(char *trigonometry_smoulder)\r\n{\r\n int oc_i = 0;\r\n int opt_var;\r\n char *acetabuliferous_altropathy = 0;\r\n ++global_variable;;\r\n acetabuliferous_altropathy = ((char *)((char *)trigonometry_smoulder));\r\n \r\n size_t (*canary_pointer[1])(const char *);\r\n char base_path[20];\r\n if (strlen(acetabuliferous_altropathy) < 20) {\r\n canary_pointer[0] = strlen;\r\n memset(base_path,0,20);\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n realpath(acetabuliferous_altropathy,base_path);\r\n opt_var = canary_pointer[0](base_path);\r\n \r\n for (; oc_i < opt_var; ++oc_i) {\r\n base_path[oc_i] = toupper(base_path[oc_i]);\r\n }\r\n printf(\"%s\\n\",base_path);\r\n \r\n \r\n }\r\n \r\n;\r\n if (((char *)trigonometry_smoulder) != 0) \r\n free(((char *)((char *)trigonometry_smoulder)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n realpath(acetabuliferous_altropathy,base_path);\n opt_var = canary_pointer[0](base_path);\n \n for (; oc_i < opt_var; ++oc_i) {\n base_path[oc_i] = toupper(base_path[oc_i]);\n }\n printf(\"%s\\n\",base_path);\n```", "cwe": "785"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint fayre_laicizing = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid marelya_owlish(char *ethylin_polymerically);\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n void (*octoid_plotting)(char *) = marelya_owlish;\r\n char *potentilla_souderton = 0;\r\n long noropianic_gairfowl[10];\r\n char *cockermeg_mesoscapula[10] = {0};\r\n char *unfloored_protovum;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&fayre_laicizing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&unfloored_protovum,\"DEMIHAKE_LUTAYO\");\r\n if (unfloored_protovum != 0) {;\r\n cockermeg_mesoscapula[5] = unfloored_protovum;\r\n noropianic_gairfowl[1] = 5;\r\n potentilla_souderton = *(cockermeg_mesoscapula + noropianic_gairfowl[1]);\r\n octoid_plotting(potentilla_souderton);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid marelya_owlish(char *ethylin_polymerically)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *siricoidea_geotaxis = 0;\r\n ++global_variable;;\r\n siricoidea_geotaxis = ((char *)ethylin_polymerically);\r\n \r\n if (strlen(siricoidea_geotaxis) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(siricoidea_geotaxis) == 1) {\r\n parsed_input = malloc((strlen(siricoidea_geotaxis)+1) * sizeof(char));\r\n urlDecode(siricoidea_geotaxis, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if (ethylin_polymerically != 0) \r\n free(((char *)ethylin_polymerically));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint stranglement_piecings = 0;\r\nint global_variable;\r\nvoid handle_taint(char *calmed_phillada);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&stranglement_piecings,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *calmed_phillada)\r\n{\r\n long long check_val = 2LL;\r\n long long in_val;\r\n int prime = 1;\r\n char *webworn_sectarianism = 0;\r\n int divorcible_threadle;\r\n int contractional_taxgathering;\r\n char **laders_paquito = 0;\r\n long tintinnabulous_certifications[10];\r\n char **gauffer_thruway[10] = {0};\r\n char *gos_cursoriness[87] = {0};\r\n ++global_variable;;\r\n if (calmed_phillada != 0) {;\r\n gos_cursoriness[5] = calmed_phillada;\r\n gauffer_thruway[5] = gos_cursoriness;\r\n tintinnabulous_certifications[1] = 5;\r\n laders_paquito = *(gauffer_thruway + tintinnabulous_certifications[1]);\r\n contractional_taxgathering = 5;\r\n while(1 == 1){\r\n contractional_taxgathering = contractional_taxgathering * 2;\r\n contractional_taxgathering = contractional_taxgathering + 2;\r\n if (contractional_taxgathering > 1000) {\r\n break; \r\n }\r\n }\r\n divorcible_threadle = contractional_taxgathering;\r\n webworn_sectarianism = ((char *)laders_paquito[5]);\r\n \r\n in_val = atoll(webworn_sectarianism);\r\n if (in_val > 1) {\r\n printf(\"Checking for primality\\n\");\r\n \r\n \r\n \r\n for (; check_val <= in_val - 1; ++check_val){\r\n \r\n \r\n if (in_val % check_val == 0) {\r\n prime = 0;\r\n break;\r\n }\r\n }\r\n \r\n \r\n if (prime) {\r\n printf(\"%lld is prime\\n\", in_val);\r\n } else {\r\n printf(\"%lld is composite\\n\", in_val);\r\n }\r\n } else {\r\n printf(\"Input value is less than or equal to 1\\n\");\r\n }\r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\n if (laders_paquito[5] != 0) \r\n free(((char *)laders_paquito[5]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (; check_val <= in_val - 1; ++check_val){\n \n \n if (in_val % check_val == 0) {\n prime = 0;\n break;\n }\n }\n```", "cwe": "834"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint unconfidently_austroasiatic = 0;\r\nint global_variable;\r\n\r\nstruct doxologizing_nonsympathy \r\n{\r\n char *wittall_diallists;\r\n double buraq_remasticating;\r\n char *filister_kosos;\r\n char chevrotin_cicad;\r\n int clough_synalgic;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid kirmew_placoderm(struct doxologizing_nonsympathy *knoppy_unrepentingly);\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n#define READOPT_BITTERSWEETS(x) kirmew_placoderm((struct doxologizing_nonsympathy *) x)\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n struct doxologizing_nonsympathy *ferrety_gasser = {0};\r\n struct doxologizing_nonsympathy *weaken_thiobacillus = {0};\r\n struct doxologizing_nonsympathy demotist_dilatedly;\r\n char *procosmopolitan_hechshers;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&unconfidently_austroasiatic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&procosmopolitan_hechshers,\"MICROCOLUMNAR_RECOVERING\");\r\n if (procosmopolitan_hechshers != 0) {;\r\n demotist_dilatedly . wittall_diallists = ((char *)procosmopolitan_hechshers);\r\n ferrety_gasser = &demotist_dilatedly;\r\n weaken_thiobacillus = ferrety_gasser + 5;\r\n\tREADOPT_BITTERSWEETS(weaken_thiobacillus);\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid kirmew_placoderm(struct doxologizing_nonsympathy *knoppy_unrepentingly)\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *abstractional_wind = 0;\r\n ++global_variable;;\r\n abstractional_wind = ((char *)( *(knoppy_unrepentingly - 5)) . wittall_diallists);\r\n \r\n while(isalnum(abstractional_wind[size]) && size < strlen(abstractional_wind)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(abstractional_wind)) {\r\n abstractional_wind = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,abstractional_wind);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (( *(knoppy_unrepentingly - 5)) . wittall_diallists != 0) \r\n free(((char *)( *(knoppy_unrepentingly - 5)) . wittall_diallists));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,abstractional_wind);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint polemicize_tormentedly = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *lao_alethoscope = 0;\r\n char ***************************************************unsalvability_daubing = 0;\r\n char **************************************************nonconformable_unviolent = 0;\r\n char *************************************************autographed_sanatoriums = 0;\r\n char ************************************************rechallenging_toploftily = 0;\r\n char ***********************************************implacental_cooeys = 0;\r\n char **********************************************nomos_paeanize = 0;\r\n char *********************************************debs_codeinas = 0;\r\n char ********************************************waterage_raffled = 0;\r\n char *******************************************dygal_shieldmaker = 0;\r\n char ******************************************dodecahedron_filigreed = 0;\r\n char *****************************************semipause_sokols = 0;\r\n char ****************************************galer_mislaid = 0;\r\n char ***************************************polymastigous_situs = 0;\r\n char **************************************heteropterous_unfertilisable = 0;\r\n char *************************************clactonian_theosophic = 0;\r\n char ************************************overpayments_engineerings = 0;\r\n char ***********************************stickmen_shuzo = 0;\r\n char **********************************annadiana_unsophisticated = 0;\r\n char *********************************headmaster_jillions = 0;\r\n char ********************************strongpoint_spolium = 0;\r\n char *******************************coesite_amyelous = 0;\r\n char ******************************borderism_democratizing = 0;\r\n char *****************************cannonades_voltize = 0;\r\n char ****************************usphs_introverse = 0;\r\n char ***************************baresarks_amphigoric = 0;\r\n char **************************overbrag_eau = 0;\r\n char *************************pleopod_nipponize = 0;\r\n char ************************jaghatai_bumpier = 0;\r\n char ***********************imm_overfatigue = 0;\r\n char **********************starboard_wastrife = 0;\r\n char *********************zalucki_indraught = 0;\r\n char ********************compactedly_reengraving = 0;\r\n char *******************bosque_vinegarist = 0;\r\n char ******************newberg_filum = 0;\r\n char *****************unobtrusiveness_dutymonger = 0;\r\n char ****************droghlin_pasquillic = 0;\r\n char ***************contrabandist_liomyofibroma = 0;\r\n char **************antarctical_chrysophyll = 0;\r\n char *************cadee_linos = 0;\r\n char ************underpressure_steaded = 0;\r\n char ***********semishrubby_outtrick = 0;\r\n char **********admixing_inefficient = 0;\r\n char *********microcosms_lainer = 0;\r\n char ********misogynistic_forbborne = 0;\r\n char *******noncontagiously_poucey = 0;\r\n char ******unfilched_forensics = 0;\r\n char *****turnovers_lechuguillas = 0;\r\n char ****unpromoted_fuselage = 0;\r\n char ***overshepherd_laymen = 0;\r\n char **hayesville_uncoarse = 0;\r\n char *sexily_appert = 0;\r\n int reload_dilatedly = 0;\r\n char *bellyached_prototypic = 0;\r\n char *herzel_overlit;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&polemicize_tormentedly,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&herzel_overlit,\"TUBEROSE_CANIONED\");\r\n if (herzel_overlit != 0) {;\r\n reload_dilatedly = ((int )(strlen(herzel_overlit)));\r\n bellyached_prototypic = ((char *)(malloc(reload_dilatedly + 1)));\r\n if (bellyached_prototypic == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(bellyached_prototypic,0,reload_dilatedly + 1);\r\n memcpy(bellyached_prototypic,herzel_overlit,reload_dilatedly);\r\n if (herzel_overlit != 0) \r\n free(((char *)herzel_overlit));\r\n hayesville_uncoarse = &bellyached_prototypic;\r\n overshepherd_laymen = &hayesville_uncoarse;\r\n unpromoted_fuselage = &overshepherd_laymen;\r\n turnovers_lechuguillas = &unpromoted_fuselage;\r\n unfilched_forensics = &turnovers_lechuguillas;\r\n noncontagiously_poucey = &unfilched_forensics;\r\n misogynistic_forbborne = &noncontagiously_poucey;\r\n microcosms_lainer = &misogynistic_forbborne;\r\n admixing_inefficient = &microcosms_lainer;\r\n semishrubby_outtrick = &admixing_inefficient;\r\n underpressure_steaded = &semishrubby_outtrick;\r\n cadee_linos = &underpressure_steaded;\r\n antarctical_chrysophyll = &cadee_linos;\r\n contrabandist_liomyofibroma = &antarctical_chrysophyll;\r\n droghlin_pasquillic = &contrabandist_liomyofibroma;\r\n unobtrusiveness_dutymonger = &droghlin_pasquillic;\r\n newberg_filum = &unobtrusiveness_dutymonger;\r\n bosque_vinegarist = &newberg_filum;\r\n compactedly_reengraving = &bosque_vinegarist;\r\n zalucki_indraught = &compactedly_reengraving;\r\n starboard_wastrife = &zalucki_indraught;\r\n imm_overfatigue = &starboard_wastrife;\r\n jaghatai_bumpier = &imm_overfatigue;\r\n pleopod_nipponize = &jaghatai_bumpier;\r\n overbrag_eau = &pleopod_nipponize;\r\n baresarks_amphigoric = &overbrag_eau;\r\n usphs_introverse = &baresarks_amphigoric;\r\n cannonades_voltize = &usphs_introverse;\r\n borderism_democratizing = &cannonades_voltize;\r\n coesite_amyelous = &borderism_democratizing;\r\n strongpoint_spolium = &coesite_amyelous;\r\n headmaster_jillions = &strongpoint_spolium;\r\n annadiana_unsophisticated = &headmaster_jillions;\r\n stickmen_shuzo = &annadiana_unsophisticated;\r\n overpayments_engineerings = &stickmen_shuzo;\r\n clactonian_theosophic = &overpayments_engineerings;\r\n heteropterous_unfertilisable = &clactonian_theosophic;\r\n polymastigous_situs = &heteropterous_unfertilisable;\r\n galer_mislaid = &polymastigous_situs;\r\n semipause_sokols = &galer_mislaid;\r\n dodecahedron_filigreed = &semipause_sokols;\r\n dygal_shieldmaker = &dodecahedron_filigreed;\r\n waterage_raffled = &dygal_shieldmaker;\r\n debs_codeinas = &waterage_raffled;\r\n nomos_paeanize = &debs_codeinas;\r\n implacental_cooeys = &nomos_paeanize;\r\n rechallenging_toploftily = &implacental_cooeys;\r\n autographed_sanatoriums = &rechallenging_toploftily;\r\n nonconformable_unviolent = &autographed_sanatoriums;\r\n unsalvability_daubing = &nonconformable_unviolent;\r\n if ( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unsalvability_daubing))))))))))))))))))))))))))))))))))))))))))))))))) != 0) {\r\n goto psychoclinical_banuyo;\r\n }\r\n ++global_variable;\r\n psychoclinical_banuyo:;\r\n lao_alethoscope = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unsalvability_daubing)))))))))))))))))))))))))))))))))))))))))))))))))));\r\n \r\n len = strtol(lao_alethoscope,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if ( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unsalvability_daubing))))))))))))))))))))))))))))))))))))))))))))))))) != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unsalvability_daubing))))))))))))))))))))))))))))))))))))))))))))))))))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint bunyah_nuda = 0;\r\nint global_variable;\r\ntypedef char *deterministic_woolfells;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid misbelieve_diplosphenal(deterministic_woolfells folles_idealize);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n#define UNSUBMERSIBLE_KALIL(x) misbelieve_diplosphenal((deterministic_woolfells) x)\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n deterministic_woolfells domino_humidifies = 0;\r\n long superficial_triandria[10];\r\n deterministic_woolfells intercommuner_familial[10] = {0};\r\n deterministic_woolfells proslaveryism_demanganization = 0;\r\n char *animalculae_airmailed;;\r\n if (__sync_bool_compare_and_swap(&bunyah_nuda,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&animalculae_airmailed,\"TOLLER_POXVIRUSES\");\r\n if (animalculae_airmailed != 0) {;\r\n proslaveryism_demanganization = animalculae_airmailed;\r\n intercommuner_familial[5] = proslaveryism_demanganization;\r\n superficial_triandria[1] = 5;\r\n domino_humidifies = *(intercommuner_familial + superficial_triandria[1]);\r\n\tUNSUBMERSIBLE_KALIL(domino_humidifies);\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid misbelieve_diplosphenal(deterministic_woolfells folles_idealize)\r\n{\r\n char *buffer = 0U;\r\n int len;\r\n char *lenger_kerin = 0;\r\n ++global_variable;;\r\n lenger_kerin = ((char *)folles_idealize);\r\n \r\n len = atoi(lenger_kerin);\r\n \r\n\r\n if (len < 4096) {\r\n buffer = ((char *)(malloc(4096 * sizeof(char ))));\r\n if (buffer != 0) {\r\n memset(buffer,'a',4096);\r\n \r\n \r\n\r\n memset(&buffer[len],'b',4096 - len);\r\n \r\n buffer[4095] = 0;\r\n printf(\"%s\\n\",buffer);\r\n free(buffer);\r\n }\r\n } else {\r\n printf(\"Number is too large to use\\n\");\r\n }\r\n \r\n \r\n;\r\n if (folles_idealize != 0) \r\n free(((char *)folles_idealize));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(&buffer[len],'b',4096 - len);\n```", "cwe": "839"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint defection_totalistic = 0;\r\nint global_variable;\r\ntypedef char *hydromassage_twist;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid triphyllous_upridge(int billingsgate_overfrankness,hydromassage_twist shoed_tupuna);\r\nvoid fundamentalness_trip(int subcoat_forth,hydromassage_twist passsaging_unscourging);\r\n\r\nvoid ERR_load_BIO_strings()\r\n{\r\n int rehumble_siphonaria = 7;\r\n hydromassage_twist rustically_unphilosophical = 0;\r\n int *solemnly_polyommatous = 0;\r\n int divorcive_summits;\r\n hydromassage_twist saltier_dryades[10] = {0};\r\n hydromassage_twist chayma_puisne = 0;\r\n char *neth_supercharging;;\r\n if (__sync_bool_compare_and_swap(&defection_totalistic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&neth_supercharging,\"MICROPIPET_JUNKYARDS\");\r\n if (neth_supercharging != 0) {;\r\n chayma_puisne = neth_supercharging;\r\n divorcive_summits = 5;\r\n solemnly_polyommatous = &divorcive_summits;\r\n saltier_dryades[ *solemnly_polyommatous] = chayma_puisne;\r\n rustically_unphilosophical = saltier_dryades[ *solemnly_polyommatous];\r\n triphyllous_upridge(rehumble_siphonaria,rustically_unphilosophical);\r\n }\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid triphyllous_upridge(int billingsgate_overfrankness,hydromassage_twist shoed_tupuna)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *antimodernness_sicklemia = 0;\r\n ++global_variable;\r\n billingsgate_overfrankness--;\r\n if (billingsgate_overfrankness > 0) {\r\n fundamentalness_trip(billingsgate_overfrankness,shoed_tupuna);\r\n return ;\r\n }\r\n antimodernness_sicklemia = ((char *)shoed_tupuna);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(antimodernness_sicklemia) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (antimodernness_sicklemia[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &antimodernness_sicklemia[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\n if (shoed_tupuna != 0) \r\n free(((char *)shoed_tupuna));\r\nclose_printf_context();\r\n}\r\n\r\nvoid fundamentalness_trip(int subcoat_forth,hydromassage_twist passsaging_unscourging)\r\n{\r\n ++global_variable;\r\n triphyllous_upridge(subcoat_forth,passsaging_unscourging);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint inbreathed_upcurved = 0;\r\n\r\nstruct butylic_spoilsports \r\n{\r\n char *camphor_swiftliest;\r\n double bioscope_antebath;\r\n char *subrident_cheltenham;\r\n char cuculiform_aul;\r\n int territus_kraul;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n char buffer_stack[128] = {0};\r\n char *reluct_mrsr = 0;\r\n struct butylic_spoilsports trapezes_alcmaon = {0};\r\n int *unbronzed_doneck = 0;\r\n int outwrestled_preachier;\r\n struct butylic_spoilsports quaternionist_stockman[10] = {0};\r\n struct butylic_spoilsports superarbitrary_brookes;\r\n char *negritos_ekpwele;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&inbreathed_upcurved,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n negritos_ekpwele = getenv(\"OFFSHOOTS_PERIDIASTOLE\");\r\n if (negritos_ekpwele != 0) {;\r\n superarbitrary_brookes . camphor_swiftliest = ((char *)negritos_ekpwele);\r\n quaternionist_stockman[5] = superarbitrary_brookes;\r\n outwrestled_preachier = 5;\r\n unbronzed_doneck = &outwrestled_preachier;\r\n trapezes_alcmaon = *(quaternionist_stockman + *unbronzed_doneck);\r\n reluct_mrsr = ((char *)trapezes_alcmaon . camphor_swiftliest);\r\n \r\n \r\n \r\n \r\n \r\n sprintf(buffer_stack,reluct_mrsr);\r\n \r\n printf(\"%s\\n\",buffer_stack);\r\n \r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` \n \n sprintf(buffer_stack,reluct_mrsr);\n \n printf(\"%s\\n\",buffer_stack);\n```", "cwe": "134"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint stunning_blanchi = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int oc_i = 0;\r\n int buf_ptr_len;\r\n char *new_input = \"new test input\";\r\n const int MAXLEN = 16;\r\n char *osi_tires = 0;\r\n int rebred_folsom;\r\n int prediminishment_tharp;\r\n void *gourdine_favillous = 0;\r\n int cardialgia_collineation = 50;\r\n char *shelman_biophysiology;;\r\n if (__sync_bool_compare_and_swap(&stunning_blanchi,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&shelman_biophysiology,\"5761\",cardialgia_collineation);\r\n if (shelman_biophysiology != 0) {;\r\n gourdine_favillous = ((void *)shelman_biophysiology);\r\n prediminishment_tharp = 5;\r\n while(1 == 1){\r\n prediminishment_tharp = prediminishment_tharp * 2;\r\n prediminishment_tharp = prediminishment_tharp + 2;\r\n if (prediminishment_tharp > 1000) {\r\n break; \r\n }\r\n }\r\n rebred_folsom = prediminishment_tharp;\r\n osi_tires = ((char *)((char *)gourdine_favillous));\r\n \r\n int file_desc;\r\n char input_buf[MAXLEN];\r\n char **buf_ptr = 0;\r\n char *path_buf = 0;\r\n path_buf = malloc(sizeof(char ) * 64);\r\n if (path_buf == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n buf_ptr = malloc(sizeof(char *));\r\n if (buf_ptr == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n *buf_ptr = path_buf;\r\n memset(input_buf,0,16);\r\n memset(path_buf,'a',64);\r\n path_buf[63] = 0;\r\n file_desc = open(osi_tires,0);\r\n if (file_desc > -1) {\r\n read(file_desc,input_buf,MAXLEN);\r\n close(file_desc);\r\n \r\n \r\n strncpy(path_buf,input_buf,MAXLEN);\r\n \r\n \r\n \r\n strcat(path_buf,new_input);\r\n buf_ptr_len = strlen( *buf_ptr);\r\n for (; oc_i < buf_ptr_len; ++oc_i) {\r\n path_buf[oc_i] = toupper(path_buf[oc_i]);\r\n }\r\n \r\n printf(\"%s\\n\",path_buf);\r\n \r\n }\r\n if (path_buf != 0) {\r\n free(path_buf);\r\n }\r\n if (buf_ptr != 0) {\r\n free(buf_ptr);\r\n }\r\n;\r\n if (((char *)gourdine_favillous) != 0) \r\n free(((char *)((char *)gourdine_favillous)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n strcat(path_buf,new_input);\n buf_ptr_len = strlen( *buf_ptr);\n for (; oc_i < buf_ptr_len; ++oc_i) {\n path_buf[oc_i] = toupper(path_buf[oc_i]);\n }\n \n printf(\"%s\\n\",path_buf);\n```", "cwe": "170"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint academie_pigeonweed = 0;\r\nint global_variable;\r\n\r\nstruct unmistakingly_polypragmonist \r\n{\r\n char *donaldsonville_underdresses;\r\n double strippers_virgilio;\r\n char *fizgig_dermatoplasm;\r\n char firn_dermestes;\r\n int felsophyre_uncursing;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *bidarkee_squashberry = 0;\r\n int osi_digit;\r\n struct unmistakingly_polypragmonist *sab_paedagogy = {0};\r\n struct unmistakingly_polypragmonist *tabletted_unparcelled = {0};\r\n struct unmistakingly_polypragmonist shebang_pommelion;\r\n int reversible_millepunctate = 22;\r\n char *unpicketed_cupolaman;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&academie_pigeonweed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&unpicketed_cupolaman,\"4301\",reversible_millepunctate);\r\n if (unpicketed_cupolaman != 0) {;\r\n shebang_pommelion . donaldsonville_underdresses = ((char *)unpicketed_cupolaman);\r\n osi_digit = 1;\r\n sab_paedagogy = &shebang_pommelion;\r\n tabletted_unparcelled = ((struct unmistakingly_polypragmonist *)(((unsigned long )sab_paedagogy) * osi_digit * osi_digit)) + 5;\r\n if (( *(tabletted_unparcelled - 5)) . donaldsonville_underdresses != 0) {\r\n goto gastroadynamic_afterage;\r\n }\r\n ++global_variable;\r\n gastroadynamic_afterage:;\r\n bidarkee_squashberry = ((char *)( *(tabletted_unparcelled - 5)) . donaldsonville_underdresses);\r\n \r\n len = strtol(bidarkee_squashberry,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (( *(tabletted_unparcelled - 5)) . donaldsonville_underdresses != 0) \r\n free(((char *)( *(tabletted_unparcelled - 5)) . donaldsonville_underdresses));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint unbolts_huntington = 0;\r\n\r\nstruct quadrigae_lindsley \r\n{\r\n char *kilter_anisodactyl;\r\n double uncoordinated_kallitype;\r\n char *braggiest_satable;\r\n char addibility_flayers;\r\n int acromion_nonscarcities;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *barmecidal_mantle);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nunsigned int get_size(char *ss_tainted)\r\n{\r\n \r\n unsigned long uns_int = 0UL;\r\n uns_int = strtoul(ss_tainted,0,0);\r\n if (uns_int > ((unsigned long )4294967295U) ||\r\n uns_int == 0)\r\n uns_int = 1U;\r\n return (unsigned int )uns_int;\r\n}\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&unbolts_huntington,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nvoid handle_taint(char *barmecidal_mantle)\r\n{\r\n char *other_buff = 0;\r\n int size = 0;\r\n int num = 0;\r\n char buff[200] = {0};\r\n int output_counter = 0;\r\n char *vinegarer_binominated = 0;\r\n struct quadrigae_lindsley *idism_cerebriformly = {0};\r\n struct quadrigae_lindsley raynold_gravers;\r\n ++global_variable;;\r\n if (barmecidal_mantle != 0) {;\r\n raynold_gravers . kilter_anisodactyl = ((char *)barmecidal_mantle);\r\n idism_cerebriformly = &raynold_gravers;\r\n vinegarer_binominated = ((char *)( *idism_cerebriformly) . kilter_anisodactyl);\r\n \r\n if (strlen(vinegarer_binominated) > 0 &&\r\n vinegarer_binominated[0] == '-') {\r\n printf(\"Negative number given as input\\n\");\r\n } else {\r\n \r\n \r\n num = get_size(vinegarer_binominated);\r\n other_buff = getenv(\"SS_BUFF\");\r\n \r\n \r\n \r\n if (other_buff != 0) {\r\n strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\r\n size = ((int )(strlen(buff)));\r\n \r\n \r\n while (num < size) {\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n if (num > 0)\r\n ++num;\r\n }\r\n \r\n } else {\r\n printf(\"Missing value for other_buff\\n\");\r\n }\r\n printf(\"finished evaluating\\n\");\r\n }\r\n \r\n;\r\n if (( *idism_cerebriformly) . kilter_anisodactyl != 0) \r\n free(((char *)( *idism_cerebriformly) . kilter_anisodactyl));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while (num < size) {\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n if (num > 0)\n ++num;\n }\n```", "cwe": "196"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint encodement_forecastleman = 0;\r\n\r\nunion thorough_cavit \r\n{\r\n char *fleam_stickball;\r\n double depilatory_pseudoethically;\r\n char *sprayfully_underlinemen;\r\n char belgravian_buddleias;\r\n int misrepresents_confection;\r\n}\r\n;\r\nint global_variable;\r\nvoid bend_godded(union thorough_cavit *belugite_parnellite);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid opisthodont_cyanin(void (*message_zygopterous)(union thorough_cavit *));\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_t t0, t1;\r\npthread_mutex_t mutex_0, mutex_1;\r\nint dev_amount = 1;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcDevamount(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int qsize;\r\n \r\n printf(\"Inside calcDevAmount\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n \r\n \r\n dev_amount = Data->data[0] - 'A'; \r\n qsize = Data->qsize;\r\n if (dev_amount < 0) { \r\n dev_amount *= -1; \r\n }\r\n \r\n readFile(Data->file2);\r\n if (dev_amount == 0) { \r\n dev_amount += 1; \r\n }\r\n \r\n \r\n pthread_mutex_unlock(&mutex_0);\r\n return NULL;\r\n}\r\nvoid *devChar(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i;\r\n int i;\r\n int *arr = NULL;\r\n \r\n printf(\"Inside devChar\\n\");\r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n pthread_mutex_lock(&mutex_1);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n \r\n \r\n \r\n for (i = 0; i < strlen(Data->data); i++) { \r\n Data->data[i] /= dev_amount; \r\n }\r\n \r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&encodement_forecastleman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n opisthodont_cyanin(bend_godded);\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid bend_godded(union thorough_cavit *belugite_parnellite)\r\n{\r\n union thorough_cavit trainways_superinduction;\r\n char *dulsea_cupriferous;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&dulsea_cupriferous,\"MATRICULATING_WADESTOWN\");\r\n if (dulsea_cupriferous != 0) {;\r\n trainways_superinduction . fleam_stickball = dulsea_cupriferous;\r\n *belugite_parnellite = trainways_superinduction;\r\n }\r\n}\r\n\r\nvoid opisthodont_cyanin(void (*message_zygopterous)(union thorough_cavit *))\r\n{\r\n struct data* Data;\r\n char *airmail_masculineness = 0;\r\n union thorough_cavit melammdim_chaffinch = {0};\r\n int *subprostatic_honora = 0;\r\n int indistinctly_enthusiasm;\r\n union thorough_cavit hyperite_gonium[10] = {0};\r\n ++global_variable;\r\n union thorough_cavit venison_elasticate = {0};\r\n message_zygopterous(&venison_elasticate);\r\n if (venison_elasticate . fleam_stickball != 0) {;\r\n hyperite_gonium[5] = venison_elasticate;\r\n indistinctly_enthusiasm = 5;\r\n subprostatic_honora = &indistinctly_enthusiasm;\r\n melammdim_chaffinch = *(hyperite_gonium + *subprostatic_honora);\r\n airmail_masculineness = ((char *)melammdim_chaffinch . fleam_stickball);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n if (Data->data) {\r\n if ((sscanf(airmail_masculineness, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n \r\n \r\n \r\n \r\n \r\n if (strlen(Data->data) > 50) { \r\n \r\n if (pthread_create(&t0, NULL, calcDevamount, Data) != 0) { \r\n printf(\"Error initializing thread 0.\");\r\n }\r\n }\r\n if (pthread_create(&t1, NULL, devChar, Data) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n if (strlen(Data->data) > 50) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (melammdim_chaffinch . fleam_stickball != 0) \r\n free(((char *)melammdim_chaffinch . fleam_stickball));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n for (i = 0; i < strlen(Data->data); i++) { \n Data->data[i] /= dev_amount; \n }\n```", "cwe": "821"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n\r\n#include \"cryptlib.h\"\r\n#include <openssl/safestack.h>\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n#include <sys/stat.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n\r\nstruct stack_st_CRYPTO_dynlock \r\n{\r\n _STACK stack;\r\n}\r\n;\r\n\r\nstatic const char *const lock_names[41] = {(\"<<ERROR>>\"), (\"err\"), (\"ex_data\"), (\"x509\"), (\"x509_info\"), (\"x509_pkey\"), (\"x509_crl\"), (\"x509_req\"), (\"dsa\"), (\"rsa\"), (\"evp_pkey\"), (\"x509_store\"), (\"ssl_ctx\"), (\"ssl_cert\"), (\"ssl_session\"), (\"ssl_sess_cert\"), (\"ssl\"), (\"ssl_method\"), (\"rand\"), (\"rand2\"), (\"debug_malloc\"), (\"BIO\"), (\"gethostbyname\"), (\"getservbyname\"), (\"readdir\"), (\"RSA_blinding\"), (\"dh\"), (\"debug_malloc2\"), (\"dso\"), (\"dynlock\"), (\"engine\"), (\"ui\"), (\"ecdsa\"), (\"ec\"), (\"ecdh\"), (\"bn\"), (\"ec_pre_comp\"), (\"store\"), (\"comp\"), (\"fips\"), (\"fips2\")\r\n#if CRYPTO_NUM_LOCKS != 41\r\n# error \"Inconsistency between crypto.h and cryptlib.c\"\r\n#endif\r\n};\r\n\r\nstatic struct stack_st_OPENSSL_STRING *app_locks = ((void *)0);\r\n\r\nstatic struct stack_st_CRYPTO_dynlock *dyn_locks = ((void *)0);\r\nstatic void (*locking_callback)(int , int , const char *, int ) = 0;\r\nstatic int (*add_lock_callback)(int *, int , int , const char *, int ) = 0;\r\n#ifndef OPENSSL_NO_DEPRECATED\r\nstatic unsigned long (*id_callback)() = 0;\r\n#endif\r\nstatic void (*threadid_callback)(CRYPTO_THREADID *) = 0;\r\nstatic struct CRYPTO_dynlock_value *(*dynlock_create_callback)(const char *, int ) = 0;\r\nstatic void (*dynlock_lock_callback)(int , struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nstatic void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *, const char *, int ) = 0;\r\nint enumerators_coccygomorph = 0;\r\nint global_variable;\r\ntypedef char *subtlest_buckling;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid grubstreet_transpeciate(int unreined_inhonest,... );\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint CRYPTO_get_new_lockid(char *name)\r\n{\r\n char *str;\r\n int i;\r\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\r\n\r\n#endif\r\n if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",215);\r\n return 0;\r\n }\r\n if ((str = BUF_strdup(name)) == ((void *)0)) {\r\n ERR_put_error(15,101,1 | 64,\"cryptlib.c\",220);\r\n return 0;\r\n }\r\n i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));\r\n if (!i) {\r\n CRYPTO_free(str);\r\n }\r\n else {\r\n\r\n i += 41;\r\n }\r\n return i;\r\n}\r\n\r\nint CRYPTO_num_locks()\r\n{\r\n return 41;\r\n}\r\n\r\nint CRYPTO_get_new_dynlockid()\r\n{\r\n int i = 0;\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (dynlock_create_callback == ((void *)0)) {\r\n ERR_put_error(15,103,100,\"cryptlib.c\",243);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",246);\r\n if (dyn_locks == ((void *)0) && (dyn_locks = ((struct stack_st_CRYPTO_dynlock *)(sk_new_null()))) == ((void *)0)) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",250);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",251);\r\n return 0;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",254);\r\n pointer = ((CRYPTO_dynlock *)(CRYPTO_malloc(((int )(sizeof(CRYPTO_dynlock ))),\"cryptlib.c\",256)));\r\n if (pointer == ((void *)0)) {\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",259);\r\n return 0;\r\n }\r\n pointer -> references = 1;\r\n pointer -> data = dynlock_create_callback(\"cryptlib.c\",263);\r\n if (pointer -> data == ((void *)0)) {\r\n CRYPTO_free(pointer);\r\n ERR_put_error(15,103,1 | 64,\"cryptlib.c\",267);\r\n return 0;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",271);\r\n\r\n i = sk_find(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n\r\n if (i == - 1) {\r\n\r\n i = sk_push(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),((void *)((1?pointer : ((CRYPTO_dynlock *)0))))) - 1;\r\n }\r\n else {\r\n\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?pointer : ((CRYPTO_dynlock *)0)))));\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",285);\r\n if (i == - 1) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",289);\r\n CRYPTO_free(pointer);\r\n }\r\n else {\r\n\r\n i += 1;\r\n }\r\n return -i;\r\n}\r\n\r\nvoid CRYPTO_destroy_dynlockid(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n if (dynlock_destroy_callback == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",305);\r\n if (dyn_locks == ((void *)0) || i >= sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",309);\r\n return ;\r\n }\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n if (pointer != ((void *)0)) {\r\n --pointer -> references;\r\n#ifdef REF_CHECK\r\n#endif\r\n if (pointer -> references <= 0) {\r\n (void )(sk_set(((_STACK *)(1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0))),i,((void *)(1?((void *)0) : ((CRYPTO_dynlock *)0)))));\r\n }\r\n else {\r\n pointer = ((void *)0);\r\n }\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",331);\r\n if (pointer) {\r\n dynlock_destroy_callback(pointer -> data,\"cryptlib.c\",335);\r\n CRYPTO_free(pointer);\r\n }\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\r\n{\r\n CRYPTO_dynlock *pointer = ((void *)0);\r\n if (i) {\r\n i = -i - 1;\r\n }\r\n CRYPTO_lock(1 | 8,29,\"cryptlib.c\",346);\r\n if (dyn_locks != ((void *)0) && i < sk_num(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))))) {\r\n pointer = ((CRYPTO_dynlock *)(sk_value(((_STACK *)((1?dyn_locks : ((struct stack_st_CRYPTO_dynlock *)0)))),i)));\r\n }\r\n if (pointer) {\r\n pointer -> references++;\r\n }\r\n CRYPTO_lock(2 | 8,29,\"cryptlib.c\",353);\r\n if (pointer) {\r\n return pointer -> data;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstruct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback())(const char *, int )\r\n{\r\n return dynlock_create_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_lock_callback())(int , struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_lock_callback;\r\n}\r\n\r\nvoid (*CRYPTO_get_dynlock_destroy_callback())(struct CRYPTO_dynlock_value *, const char *, int )\r\n{\r\n return dynlock_destroy_callback;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)(const char *, int ))\r\n{\r\n dynlock_create_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int , struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_lock_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)(struct CRYPTO_dynlock_value *, const char *, int ))\r\n{\r\n dynlock_destroy_callback = func;\r\n}\r\n\r\nvoid (*CRYPTO_get_locking_callback())(int , int , const char *, int )\r\n{\r\n return locking_callback;\r\n}\r\n\r\nint (*CRYPTO_get_add_lock_callback())(int *, int , int , const char *, int )\r\n{\r\n return add_lock_callback;\r\n}\r\n\r\nvoid CRYPTO_set_locking_callback(void (*func)(int , int , const char *, int ))\r\n{\r\n\r\n OPENSSL_init();\r\n locking_callback = func;\r\n}\r\n\r\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *, int , int , const char *, int ))\r\n{\r\n add_lock_callback = func;\r\n}\r\n\r\n\r\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id,unsigned long val)\r\n{\r\n memset(id,0,sizeof(( *id)));\r\n id -> val = val;\r\n}\r\nstatic const unsigned char hash_coeffs[] = {(3), (5), (7), (11), (13), (17), (19), (23)};\r\n\r\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id,void *ptr)\r\n{\r\n unsigned char *dest = ((void *)(&id -> val));\r\n unsigned int accum = 0;\r\n unsigned char dnum = (sizeof(id -> val));\r\n memset(id,0,sizeof(( *id)));\r\n id -> ptr = ptr;\r\n if (sizeof(id -> val) >= sizeof(id -> ptr)) {\r\n\r\n id -> val = ((unsigned long )(id -> ptr));\r\n return ;\r\n }\r\n\r\n while(dnum--){\r\n const unsigned char *src = ((void *)(&id -> ptr));\r\n unsigned char snum = (sizeof(id -> ptr));\r\n while(snum--)\r\n accum += (( *(src++)) * hash_coeffs[snum + dnum & 7]);\r\n accum += dnum;\r\n *(dest++) = (accum & 255);\r\n }\r\n}\r\n\r\nint CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))\r\n{\r\n if (threadid_callback) {\r\n return 0;\r\n }\r\n threadid_callback = func;\r\n return 1;\r\n}\r\n\r\nvoid (*CRYPTO_THREADID_get_callback())(CRYPTO_THREADID *)\r\n{\r\n return threadid_callback;\r\n}\r\n\r\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\r\n{\r\n if (threadid_callback) {\r\n threadid_callback(id);\r\n return ;\r\n }\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\n if (id_callback) {\r\n CRYPTO_THREADID_set_numeric(id,id_callback());\r\n return ;\r\n }\r\n#endif\r\n\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n\r\n CRYPTO_THREADID_set_pointer(id,((void *)(__errno_location())));\r\n#endif\r\n}\r\n\r\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,const CRYPTO_THREADID *b)\r\n{\r\n return memcmp(a,b,sizeof(( *a)));\r\n}\r\n\r\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,const CRYPTO_THREADID *src)\r\n{\r\n memcpy(dest,src,sizeof(( *src)));\r\n}\r\n\r\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\r\n{\r\n return id -> val;\r\n}\r\n#ifndef OPENSSL_NO_DEPRECATED\r\n\r\nunsigned long (*CRYPTO_get_id_callback())()\r\n{\r\n return id_callback;\r\n}\r\n\r\nvoid CRYPTO_set_id_callback(unsigned long (*func)())\r\n{\r\n id_callback = func;\r\n}\r\n\r\nunsigned long CRYPTO_thread_id()\r\n{\r\n unsigned long ret = 0;\r\n if (id_callback == ((void *)0)) {\r\n#ifdef OPENSSL_SYS_WIN16\r\n#elif defined(OPENSSL_SYS_WIN32)\r\n#elif defined(GETPID_IS_MEANINGLESS)\r\n#elif defined(OPENSSL_SYS_BEOS)\r\n#else\r\n ret = ((unsigned long )(getpid()));\r\n#endif\r\n }\r\n else {\r\n ret = id_callback();\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nvoid CRYPTO_lock(int mode,int type,const char *file,int line)\r\n{\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n if (type < 0) {\r\n if (dynlock_lock_callback != ((void *)0)) {\r\n struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);\r\n (void )(pointer != ((void *)0)?0 : ((OpenSSLDie(\"cryptlib.c\",595,\"pointer != NULL\") , 1)));\r\n dynlock_lock_callback(mode,pointer,file,line);\r\n CRYPTO_destroy_dynlockid(type);\r\n }\r\n }\r\n else {\r\n if (locking_callback != ((void *)0)) {\r\n locking_callback(mode,type,file,line);\r\n }\r\n }\r\n}\r\n\r\nint CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)\r\n{\r\n subtlest_buckling pleurothotonus_fury = 0;\r\n char *paulette_umbilicaria;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&enumerators_coccygomorph,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&paulette_umbilicaria,\"ARTEFAC_TROGLODYTES\");\r\n if (paulette_umbilicaria != 0) {;\r\n pleurothotonus_fury = paulette_umbilicaria;\r\n grubstreet_transpeciate(1,pleurothotonus_fury);\r\n }\r\n }\r\n }\r\n if (add_lock_callback != ((void *)0)) {\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n ret = add_lock_callback(pointer,amount,type,file,line);\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n }\r\n else {\r\n CRYPTO_lock(1 | 8,type,file,line);\r\n ret = *pointer + amount;\r\n#ifdef LOCK_DEBUG\r\n#endif\r\n *pointer = ret;\r\n CRYPTO_lock(2 | 8,type,file,line);\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *CRYPTO_get_lock_name(int type)\r\n{\r\n if (type < 0) {\r\n return \"dynamic\";\r\n }\r\n else {\r\n if (type < 41) {\r\n return lock_names[type];\r\n }\r\n else {\r\n if (type - 41 > sk_num(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))))) {\r\n return \"ERROR\";\r\n }\r\n else {\r\n return ((OPENSSL_STRING )(sk_value(((_STACK *)(1?app_locks : ((struct stack_st_OPENSSL_STRING *)0))),type - 41)));\r\n }\r\n }\r\n }\r\n}\r\n#if\tdefined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\r\n\tdefined(__INTEL__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)\r\nunsigned int OPENSSL_ia32cap_P[2];\r\n\r\nunsigned long *OPENSSL_ia32cap_loc()\r\n{\r\n if (sizeof(long ) == 4) {\r\n\r\n OPENSSL_ia32cap_P[1] = 0;\r\n }\r\n return (unsigned long *)OPENSSL_ia32cap_P;\r\n}\r\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)\r\n#define OPENSSL_CPUID_SETUP\r\n#if defined(_WIN32)\r\n#else\r\ntypedef unsigned long long IA32CAP;\r\n#endif\r\n\r\nvoid OPENSSL_cpuid_setup()\r\n{\r\n static int trigger = 0;\r\n extern IA32CAP OPENSSL_ia32_cpuid();\r\n IA32CAP vec;\r\n char *env;\r\n if (trigger) {\r\n return ;\r\n }\r\n trigger = 1;\r\n if (env = getenv(\"OPENSSL_ia32cap\")) {\r\n int off = env[0] == '~'?1 : 0;\r\n#if defined(_WIN32)\r\n#else\r\n if (!sscanf((env + off),\"%lli\",((long long *)(&vec)))) {\r\n vec = (strtoul((env + off),((void *)0),0));\r\n }\r\n#endif\r\n if (off) {\r\n vec = OPENSSL_ia32_cpuid() & ~vec;\r\n }\r\n }\r\n else {\r\n vec = OPENSSL_ia32_cpuid();\r\n }\r\n\r\n OPENSSL_ia32cap_P[0] = ((unsigned int )vec) | (1 << 10);\r\n OPENSSL_ia32cap_P[1] = ((unsigned int )(vec >> 32));\r\n}\r\n#endif\r\n#else\r\n#endif\r\nint OPENSSL_NONPIC_relocated = 0;\r\n#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)\r\n#endif\r\n#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)\r\n#ifdef __CYGWIN__\r\n\r\n#include <windows.h>\r\n\r\n#endif\r\n\r\n#if defined(_WIN32_WINNT)\r\n#endif\r\n#endif\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n#include <tchar.h>\r\n#include <signal.h>\r\n#ifdef __WATCOMC__\r\n#if defined(_UNICODE) || defined(__UNICODE__)\r\n#define _vsntprintf _vsnwprintf\r\n#else\r\n#define _vsntprintf _vsnprintf\r\n#endif\r\n#endif\r\n#ifdef _MSC_VER\r\n#define alloca _alloca\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\n\r\n#else\r\n\r\n#endif\r\n#else\r\n#endif\r\n#ifdef STD_ERROR_HANDLE\t\r\n\r\n#endif\r\n#ifndef OPENSSL_NO_MULTIBYTE\r\n#endif\r\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\r\n\r\n#endif\r\n#else\r\n\r\nvoid OPENSSL_showfatal(const char *fmta,... )\r\n{\r\n va_list ap;\r\n __builtin_va_start(ap,fmta);\r\n vfprintf(stderr,fmta,ap);\r\n __builtin_va_end(ap);\r\n}\r\n\r\nint OPENSSL_isservice()\r\n{\r\n return 0;\r\n}\r\n#endif\r\n\r\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\r\n{\r\n OPENSSL_showfatal(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",file,line,assertion);\r\n#if !defined(_WIN32) || defined(__CYGWIN__)\r\n abort();\r\n#else\r\n\r\n#endif\r\n}\r\n\r\nvoid *OPENSSL_stderr()\r\n{\r\n return stderr;\r\n}\r\n\r\nint CRYPTO_memcmp(const void *in_a,const void *in_b,size_t len)\r\n{\r\n size_t i;\r\n const unsigned char *a = in_a;\r\n const unsigned char *b = in_b;\r\n unsigned char x = 0;\r\n for (i = 0; i < len; i++) \r\n x |= a[i] ^ b[i];\r\n return x;\r\n}\r\n\r\nvoid grubstreet_transpeciate(int unreined_inhonest,... )\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *countys_aminated = 0;\r\n subtlest_buckling karsha_tariff = 0;\r\n va_list ipse_puton;\r\n ++global_variable;;\r\n if (unreined_inhonest > 0) {\r\n __builtin_va_start(ipse_puton,unreined_inhonest);\r\n karsha_tariff = (va_arg(ipse_puton,subtlest_buckling ));\r\n __builtin_va_end(ipse_puton);\r\n }\r\n countys_aminated = ((char *)karsha_tariff);\r\n \r\n while(isalnum(countys_aminated[size]) && size < strlen(countys_aminated)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(countys_aminated)) {\r\n countys_aminated = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,countys_aminated);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (karsha_tariff != 0) \r\n free(((char *)karsha_tariff));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,countys_aminated);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint bout_goneoclinic = 0;\r\nint global_variable;\r\n\r\nstruct plushlike_fatigated \r\n{\r\n char *riving_alshain;\r\n double rpo_borings;\r\n char *spatting_rolandson;\r\n char stonebow_nanny;\r\n int uninvestigable_prepurpose;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid trinitration_conspissate(const struct plushlike_fatigated look_overpay);\r\nvoid featured_ostentous(int stifledly_tanta,struct plushlike_fatigated mingie_clyman);\r\nvoid gwynfa_colonizable(int taliage_rachelle,struct plushlike_fatigated neckyoke_that);\r\nint search(char *str_param,char c_param)\r\n{\r\n if ( *str_param == c_param) {\r\n return 1;\r\n } else if ( *str_param == 0) {\r\n \r\n \r\n return search(&str_param[0],c_param);\r\n } else {\r\n return search(&str_param[1],c_param);\r\n }\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n struct plushlike_fatigated repulverize_admissible;\r\n int wallpiece_decorability = 31;\r\n char *palmerdale_semiproselyte;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&bout_goneoclinic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&palmerdale_semiproselyte,\"6971\",wallpiece_decorability);\r\n if (palmerdale_semiproselyte != 0) {;\r\n repulverize_admissible . riving_alshain = ((char *)palmerdale_semiproselyte);\r\n trinitration_conspissate(repulverize_admissible);\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid trinitration_conspissate(const struct plushlike_fatigated look_overpay)\r\n{\r\n int heterotricha_waine = 7;\r\n ++global_variable;;\r\n featured_ostentous(heterotricha_waine,look_overpay);\r\n}\r\n\r\nvoid featured_ostentous(int stifledly_tanta,struct plushlike_fatigated mingie_clyman)\r\n{\r\n int found;\r\n char *conundrum_burna = 0;\r\n ++global_variable;\r\n stifledly_tanta--;\r\n if (stifledly_tanta > 0) {\r\n gwynfa_colonizable(stifledly_tanta,mingie_clyman);\r\n return ;\r\n }\r\n conundrum_burna = ((char *)((struct plushlike_fatigated )mingie_clyman) . riving_alshain);\r\n \r\n \r\n \r\n found = search(&conundrum_burna[1],conundrum_burna[0]);\r\n \r\n \r\n \r\n;\r\n if (((struct plushlike_fatigated )mingie_clyman) . riving_alshain != 0) \r\n free(((char *)((struct plushlike_fatigated )mingie_clyman) . riving_alshain));\r\nclose_printf_context();\r\n}\r\n\r\nvoid gwynfa_colonizable(int taliage_rachelle,struct plushlike_fatigated neckyoke_that)\r\n{\r\n ++global_variable;\r\n featured_ostentous(taliage_rachelle,neckyoke_that);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` found = search(&conundrum_burna[1],conundrum_burna[0]);\n```", "cwe": "674"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint nonreasonably_poticary = 0;\r\nint global_variable;\r\n\r\nstruct hungriest_antisplitting \r\n{\r\n char *coarb_tridynamous;\r\n double orthocarbonic_axiate;\r\n char *duplation_reptiliousness;\r\n char mismarks_spinder;\r\n int bai_upshifts;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid intimate_gadsman(const struct hungriest_antisplitting detailism_witchingly);\r\ntypedef int (*fptr)();\r\nint modulus_function1 (char *modulus_param_str) {\r\n \r\n return modulus_param_str[0] % 2;\r\n}\r\nint modulus_function2 (char *modulus_param_str) {\r\n \r\n return modulus_param_str[1] % 2;\r\n}\r\nvoid get_function(int len, fptr * modulus_function) {\r\n \r\n \r\n if (len > 10) {\r\n *modulus_function = modulus_function1;\r\n \r\n }\r\n if (len < 10) {\r\n *modulus_function = modulus_function2;\r\n \r\n }\r\n \r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n struct hungriest_antisplitting trench_sulfonating;\r\n char *californians_cellarmen;\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&nonreasonably_poticary,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n californians_cellarmen = getenv(\"TRIDUUM_UNREPREHENDED\");\r\n if (californians_cellarmen != 0) {;\r\n trench_sulfonating . coarb_tridynamous = ((char *)californians_cellarmen);\r\n intimate_gadsman(trench_sulfonating);\r\n }\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid intimate_gadsman(const struct hungriest_antisplitting detailism_witchingly)\r\n{\r\n int input_len = 0;\r\n int result = 0;\r\n fptr* function_ptr = 0;\r\n char *locum_babelish = 0;\r\n jmp_buf durneder_vendean;\r\n int bevilled_trollop;\r\n ++global_variable;;\r\n bevilled_trollop = setjmp(durneder_vendean);\r\n if (bevilled_trollop == 0) {\r\n longjmp(durneder_vendean,1);\r\n }\r\n locum_babelish = ((char *)((struct hungriest_antisplitting )detailism_witchingly) . coarb_tridynamous);\r\n \r\n input_len = strlen(locum_babelish);\r\n if (input_len < 2) {\r\n printf(\"String is too short to test\\n\");\r\n } else {\r\n function_ptr = malloc(sizeof(void *));\r\n if (function_ptr == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n get_function(input_len, function_ptr);\r\n \r\n \r\n result = ( *function_ptr)(locum_babelish);\r\n \r\n if (result == 0)\r\n printf(\"mod is true\\n\");\r\n else\r\n printf(\"mod is false\\n\");\r\n if (function_ptr != 0) {\r\n free(function_ptr);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n result = ( *function_ptr)(locum_babelish);\n```", "cwe": "824"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint forestation_sparmannia = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n char buffer[80];\r\n FILE *pFile = 0;\r\n char *amenorrho_tragopan = 0;\r\n char **gauffer_hexanchidae = 0;\r\n int antigrowth_beshrewing = 0;\r\n char *misers_clavis = 0;\r\n int whatsoever_schoolma = 45;\r\n char *deprecators_bloomery;;\r\n if (__sync_bool_compare_and_swap(&forestation_sparmannia,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&deprecators_bloomery,\"3498\",whatsoever_schoolma);\r\n if (deprecators_bloomery != 0) {;\r\n antigrowth_beshrewing = ((int )(strlen(deprecators_bloomery)));\r\n misers_clavis = ((char *)(malloc(antigrowth_beshrewing + 1)));\r\n if (misers_clavis == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(misers_clavis,0,antigrowth_beshrewing + 1);\r\n memcpy(misers_clavis,deprecators_bloomery,antigrowth_beshrewing);\r\n if (deprecators_bloomery != 0) \r\n free(((char *)deprecators_bloomery));\r\n gauffer_hexanchidae = &misers_clavis;\r\n if ( *gauffer_hexanchidae != 0) {\r\n goto blasdell_intorsion;\r\n }\r\n ++global_variable;\r\n blasdell_intorsion:;\r\n amenorrho_tragopan = ((char *)( *gauffer_hexanchidae));\r\n \r\n \r\n\r\n pFile = fopen(amenorrho_tragopan,\"r\");\r\n buffer[0] = 0;\r\n \r\n \r\n \r\n\r\n fgets(buffer,79,pFile);\r\n printf(buffer);\r\n printf(\"\\n\");\r\n fclose(pFile);\r\n \r\n \r\n;\r\n if ( *gauffer_hexanchidae != 0) \r\n free(((char *)( *gauffer_hexanchidae)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n fgets(buffer,79,pFile);\n printf(buffer);\n printf(\"\\n\");\n fclose(pFile);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nint jailsco_balewa = 0;\r\nint global_variable;\r\n\r\nunion tonga_yojuane \r\n{\r\n char *cavern_subpool;\r\n double reabolition_dogmata;\r\n char *mtf_megadonty;\r\n char subtrahends_unrued;\r\n int mecurialism_untumidness;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid monk_defensor(union tonga_yojuane farmstead_henwile);\r\nint 476_global_variable = 0;\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n#define GOODMAN_PHLEBOGRAPH(x) monk_defensor((union tonga_yojuane) x)\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n union tonga_yojuane kelayres_geomagnetism;\r\n int himene_pur = 63;\r\n char *asclepin_labeled;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&jailsco_balewa,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&asclepin_labeled,\"9874\",himene_pur);\r\n if (asclepin_labeled != 0) {;\r\n kelayres_geomagnetism . cavern_subpool = asclepin_labeled;\r\n\tGOODMAN_PHLEBOGRAPH(kelayres_geomagnetism);\r\n }\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nvoid monk_defensor(union tonga_yojuane farmstead_henwile)\r\n{\r\n char *second_buff = 0;\r\n int size = 0;\r\n char *mischoice_feedway = 0;\r\n ++global_variable;;\r\n mischoice_feedway = ((char *)farmstead_henwile . cavern_subpool);\r\n \r\n while(isalnum(mischoice_feedway[size]) && size < strlen(mischoice_feedway)){\r\n ++size;\r\n }\r\n \r\n\r\n if (size != strlen(mischoice_feedway)) {\r\n mischoice_feedway = 0;\r\n }\r\n \r\n \r\n second_buff = malloc((size + 1) * sizeof(char ));\r\n if (second_buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n\r\n strcpy(second_buff,mischoice_feedway);\r\n 476_global_variable = strlen(second_buff);\r\n \r\n ++476_global_variable;\r\n if (second_buff != 0) {\r\n free(second_buff);\r\n }\r\n printf(\"String contains only alpha numeric characters\\n\");\r\n \r\n;\r\n if (farmstead_henwile . cavern_subpool != 0) \r\n free(((char *)farmstead_henwile . cavern_subpool));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n strcpy(second_buff,mischoice_feedway);\n 476_global_variable = strlen(second_buff);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include <setjmp.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <time.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint matfellon_potestative = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n char *result = 0;\r\n int random_int = 0;\r\n char *donnelsville_demipesade = 0;\r\n jmp_buf philodendra_choller;\r\n int bracey_wettable;\r\n char **appendicularian_dysgenical = 0;\r\n char **khedivial_matlo = 0;\r\n int trapstick_unexaggerating = 0;\r\n char *karole_adhering = 0;\r\n char *coalesces_nonahydrate;;\r\n if (__sync_bool_compare_and_swap(&matfellon_potestative,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n coalesces_nonahydrate = getenv(\"CHORISOS_DERMATOGRAPHY\");\r\n if (coalesces_nonahydrate != 0) {;\r\n trapstick_unexaggerating = ((int )(strlen(coalesces_nonahydrate)));\r\n karole_adhering = ((char *)(malloc(trapstick_unexaggerating + 1)));\r\n if (karole_adhering == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(karole_adhering,0,trapstick_unexaggerating + 1);\r\n memcpy(karole_adhering,coalesces_nonahydrate,trapstick_unexaggerating);\r\n appendicularian_dysgenical = &karole_adhering;\r\n khedivial_matlo = appendicularian_dysgenical + 5;\r\n bracey_wettable = setjmp(philodendra_choller);\r\n if (bracey_wettable == 0) {\r\n longjmp(philodendra_choller,1);\r\n }\r\n donnelsville_demipesade = ((char *)( *(khedivial_matlo - 5)));\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, donnelsville_demipesade);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != PGRES_COMMAND_OK) {\r\n \r\n printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n result = PQcmdTuples(res);\r\n printf(\"Query OK, %s rows affected\\n\",result);\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\n if ( *(khedivial_matlo - 5) != 0) \r\n free(((char *)( *(khedivial_matlo - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n res = PQexec(conn,query);\n if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n \n printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n PQclear(res);\n PQfinish(conn);\n exit(1);\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint strengthfulness_victorianly = 0;\r\nint global_variable;\r\nvoid handle_taint(char *cockieleekie_opalotype);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid maselin_becomingness(void **menologies_incrassating);\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&strengthfulness_victorianly,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid handle_taint(char *cockieleekie_opalotype)\r\n{\r\n void (*genitalic_linolein)(void **) = maselin_becomingness;\r\n void **physicomorphic_superhistoric = 0;\r\n void **sarrazin_estrado = 0;\r\n void *candied_osterhus = 0;\r\n ++global_variable;;\r\n if (cockieleekie_opalotype != 0) {;\r\n candied_osterhus = ((void *)cockieleekie_opalotype);\r\n physicomorphic_superhistoric = &candied_osterhus;\r\n sarrazin_estrado = physicomorphic_superhistoric + 5;\r\n genitalic_linolein(sarrazin_estrado);\r\n }\r\n}\r\n\r\nvoid maselin_becomingness(void **menologies_incrassating)\r\n{\r\n int ss_j;\r\n int ss_i;\r\n size_t taint_size;\r\n char **malloced_buff = 0;\r\n int trace_flag = 0;\r\n char *feasibly_babelish = 0;\r\n ++global_variable;;\r\n feasibly_babelish = ((char *)((char *)( *(menologies_incrassating - 5))));\r\n \r\n taint_size = strlen(feasibly_babelish);\r\n \r\n if (taint_size >= 1600) {\r\n taint_size = 1599U;\r\n }\r\n malloced_buff = malloc(taint_size * sizeof(char *));\r\n \r\n \r\n if (malloced_buff != 0) {\r\n \r\n \r\n for (ss_i = 0; ss_i < taint_size; ++ss_i) {\r\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\r\n \r\n \r\n if (malloced_buff[ss_i] == 0 && errno == 12) {\r\n printf(\"Malloc error due to ulimit\\n\");\r\n if (trace_flag == 0) {\r\n \r\n \r\n trace_flag = 1;\r\n }\r\n }\r\n if (malloced_buff[ss_i] != 0) {\r\n for (ss_j = 0; ss_j < taint_size; ++ss_j) {\r\n memcpy(malloced_buff[ss_i] + ss_j * taint_size,feasibly_babelish,taint_size);\r\n }\r\n }\r\n \r\n \r\n if (taint_size % 2 == 0) {\r\n if (malloced_buff[ss_i] != 0) {\r\n free(malloced_buff[ss_i]);\r\n \r\n }\r\n }\r\n }\r\n free(malloced_buff);\r\n \r\n }\r\n;\r\n if (((char *)( *(menologies_incrassating - 5))) != 0) \r\n free(((char *)((char *)( *(menologies_incrassating - 5)))));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n \n \n if (malloced_buff[ss_i] == 0 && errno == 12) {\n printf(\"Malloc error due to ulimit\\n\");\n if (trace_flag == 0) {\n \n```", "cwe": "401"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <stdio.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint peshitta_endoscopically = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar *crispin_boused(char *subtransversal_hepatopexia);\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *malemiut_mot = 0;\r\n jmp_buf yugoslav_ahq;\r\n int capsuligerous_trichopathic;\r\n char *organogel_contours = 0;\r\n int grimstead_foreslow = 0;\r\n char *classico_umbered = 0;\r\n int camorra_replait = 35;\r\n char *overemulate_eightling;;\r\n if (__sync_bool_compare_and_swap(&peshitta_endoscopically,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&overemulate_eightling,\"4789\",camorra_replait);\r\n if (overemulate_eightling != 0) {;\r\n grimstead_foreslow = ((int )(strlen(overemulate_eightling)));\r\n classico_umbered = ((char *)(malloc(grimstead_foreslow + 1)));\r\n if (classico_umbered == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(classico_umbered,0,grimstead_foreslow + 1);\r\n memcpy(classico_umbered,overemulate_eightling,grimstead_foreslow);\r\n if (overemulate_eightling != 0) \r\n free(((char *)overemulate_eightling));\r\n organogel_contours = crispin_boused(classico_umbered);\r\n capsuligerous_trichopathic = setjmp(yugoslav_ahq);\r\n if (capsuligerous_trichopathic == 0) {\r\n longjmp(yugoslav_ahq,1);\r\n }\r\n malemiut_mot = ((char *)organogel_contours);\r\n \r\n if (strlen(malemiut_mot) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(malemiut_mot) == 1) {\r\n parsed_input = malloc((strlen(malemiut_mot)+1) * sizeof(char));\r\n urlDecode(malemiut_mot, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if (organogel_contours != 0) \r\n free(((char *)organogel_contours));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nchar *crispin_boused(char *subtransversal_hepatopexia)\r\n{\r\n ++global_variable;\r\n return subtransversal_hepatopexia;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint futz_quinitol = 0;\r\n\r\nstruct sniffable_working \r\n{\r\n char *swagger_unporousness;\r\n double hydatina_gastronomies;\r\n char *shoq_acy;\r\n char factitively_skirling;\r\n int predisposition_neighbour;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *lunarium_rubie);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct sniffable_working phaethonic_tilton(struct sniffable_working contribution_swigart);\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&futz_quinitol,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid handle_taint(char *lunarium_rubie)\r\n{\r\n FILE *csv = 0;\r\n FILE *temp = 0;\r\n char col1[80] = {0};\r\n char col2[80] = {0};\r\n char col3[80] = {0};\r\n char *cols[3] = {0};\r\n char *sciroccos_nonelliptic = 0;\r\n jmp_buf shroffed_unrelieved;\r\n int addis_anilinophile;\r\n struct sniffable_working mammifera_undeviable = {0};\r\n struct sniffable_working ancodont_dipware;\r\n ++global_variable;;\r\n if (lunarium_rubie != 0) {;\r\n ancodont_dipware . swagger_unporousness = ((char *)lunarium_rubie);\r\n mammifera_undeviable = phaethonic_tilton(ancodont_dipware);\r\n addis_anilinophile = setjmp(shroffed_unrelieved);\r\n if (addis_anilinophile == 0) {\r\n longjmp(shroffed_unrelieved,1);\r\n }\r\n sciroccos_nonelliptic = ((char *)mammifera_undeviable . swagger_unporousness);\r\n \r\n \r\n csv = fopen(sciroccos_nonelliptic,\"r\");\r\n if (csv != 0) {\r\n \r\n\r\n fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\r\n \r\n \r\n \r\n \r\n if (strlen(col1) > 0)\r\n cols[0] = col1;\r\n if (strlen(col2) > 0)\r\n cols[1] = col2;\r\n if (strlen(col3) > 0)\r\n cols[2] = col3;\r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n\r\n printf(\"VALUES=\\\"\");\r\n fputs(cols[0],temp);\r\n printf(cols[0]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[1],temp);\r\n printf(cols[1]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[2],temp);\r\n printf(cols[2]);\r\n \r\n printf(\"\\\"\\n\");\r\n fclose(temp);\r\n }\r\n }\r\n \r\n;\r\n if (mammifera_undeviable . swagger_unporousness != 0) \r\n free(((char *)mammifera_undeviable . swagger_unporousness));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nstruct sniffable_working phaethonic_tilton(struct sniffable_working contribution_swigart)\r\n{\r\n ++global_variable;\r\n return contribution_swigart;\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "```\n printf(\"VALUES=\\\"\");\n fputs(cols[0],temp);\n printf(cols[0]);\n printf(\"\\\",\\\"\");\n fputs(cols[1],temp);\n printf(cols[1]);\n printf(\"\\\",\\\"\");\n fputs(cols[2],temp);\n printf(cols[2]);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n#include <time.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint stumor_crimpier = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nchar *meeter_escalator(char *acervate_lurdans);\r\nvoid palpicornia_woodcockize(char *dermestes_melchite);\r\n\r\nvoid ERR_load_BIO_strings()\r\n{\r\n void (*tachyauxetic_florette)(char *) = palpicornia_woodcockize;\r\n char *yucaipa_facetiousness = 0;\r\n char *bastile_otoscopies;;\r\n if (__sync_bool_compare_and_swap(&stumor_crimpier,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n bastile_otoscopies = getenv(\"OUTVICTOR_CLERKDOM\");\r\n if (bastile_otoscopies != 0) {;\r\n yucaipa_facetiousness = meeter_escalator(bastile_otoscopies);\r\n tachyauxetic_florette(yucaipa_facetiousness);\r\n }\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nchar *meeter_escalator(char *acervate_lurdans)\r\n{\r\n ++global_variable;\r\n return acervate_lurdans;\r\n}\r\n\r\nvoid palpicornia_woodcockize(char *dermestes_melchite)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *thurgood_wimpling = 0;\r\n ++global_variable;;\r\n thurgood_wimpling = ((char *)dermestes_melchite);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, thurgood_wimpling);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer)) {\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n } else {\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint tubinares_shelffellow = 0;\r\nint global_variable;\r\nvoid handle_taint(char *hepsiba_armond);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nchar *mls_philosophastry(char *antiricin_wheedler);\r\nvoid pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly);\r\nvoid catface_conduciveness(int predeclaration_arguing,char *triunity_kremlin);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\nstruct struct {\r\n int (* before)(int);\r\n char buffer[64];\r\n int (* after)(int);\r\n};\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&tubinares_shelffellow,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid handle_taint(char *hepsiba_armond)\r\n{\r\n int herbicidal_monospermal = 7;\r\n char *jear_nonretired = 0;\r\n int cavaliero_chuchchis = 0;\r\n char *overtechnical_mediately = 0;\r\n ++global_variable;;\r\n if (hepsiba_armond != 0) {;\r\n cavaliero_chuchchis = ((int )(strlen(hepsiba_armond)));\r\n overtechnical_mediately = ((char *)(malloc(cavaliero_chuchchis + 1)));\r\n if (overtechnical_mediately == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(overtechnical_mediately,0,cavaliero_chuchchis + 1);\r\n memcpy(overtechnical_mediately,hepsiba_armond,cavaliero_chuchchis);\r\n if (hepsiba_armond != 0) \r\n free(((char *)hepsiba_armond));\r\n jear_nonretired = mls_philosophastry(overtechnical_mediately);\r\n pulvilli_agpaite(herbicidal_monospermal,jear_nonretired);\r\n }\r\n}\r\n\r\nchar *mls_philosophastry(char *antiricin_wheedler)\r\n{\r\n ++global_variable;\r\n return antiricin_wheedler;\r\n}\r\n\r\nvoid pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly)\r\n{\r\n int i = 0;\r\n struct struct data;\r\n int buff_size = 63;\r\n int taint_len;\r\n char *shenstone_cobalamin = 0;\r\n ++global_variable;\r\n galloglass_panipat--;\r\n if (galloglass_panipat > 0) {\r\n catface_conduciveness(galloglass_panipat,autoreinfusion_jerkingly);\r\n return ;\r\n }\r\n shenstone_cobalamin = ((char *)autoreinfusion_jerkingly);\r\n \r\n \r\n \r\n data.before = toupper;\r\n for (i = 0; i < 64; i++) {\r\n data.buffer[i] = 'A';\r\n }\r\n data.buffer[63] = '\\0';\r\n data.after = toupper;\r\n \r\n \r\n \r\n \r\n \r\n taint_len = ((int )(strlen(shenstone_cobalamin)));\r\n\r\n\r\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\r\n data.buffer[buff_size] = shenstone_cobalamin[taint_len];\r\n }\r\n \r\n for (i = 0; i < 64; ++i) {\r\n data.buffer[i] = toupper(data.buffer[i]);\r\n printf(\"%c\",data.before(data.buffer[i]));\r\n }\r\n \r\n \r\n printf(\"\\n\");\r\n \r\n \r\n \r\n;\r\n if (autoreinfusion_jerkingly != 0) \r\n free(((char *)autoreinfusion_jerkingly));\r\nclose_printf_context();\r\n}\r\n\r\nvoid catface_conduciveness(int predeclaration_arguing,char *triunity_kremlin)\r\n{\r\n ++global_variable;\r\n pulvilli_agpaite(predeclaration_arguing,triunity_kremlin);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` taint_len = ((int )(strlen(shenstone_cobalamin)));\n\n\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\n data.buffer[buff_size] = shenstone_cobalamin[taint_len];\n }\n \n for (i = 0; i < 64; ++i) {\n data.buffer[i] = toupper(data.buffer[i]);\n printf(\"%c\",data.before(data.buffer[i]));\n }\n```", "cwe": "124"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint undecennial_gulfed = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n int oc_i = 0;\r\n char buffer[8];\r\n char *virulented_bantry = 0;\r\n int pillmaking_sabin;\r\n int aquilinity_solemnization;\r\n char **heartsomeness_tranks = 0;\r\n long springling_beachie[10];\r\n char **crane_snipy[10] = {0};\r\n char *antiphlogistin_erythron[5] = {0};\r\n char *bluntishness_fibiger;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&undecennial_gulfed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&bluntishness_fibiger,\"PLUTEUS_VALLECULA\");\r\n if (bluntishness_fibiger != 0) {;\r\n antiphlogistin_erythron[3] = bluntishness_fibiger;\r\n crane_snipy[5] = antiphlogistin_erythron;\r\n springling_beachie[1] = 5;\r\n heartsomeness_tranks = *(crane_snipy + springling_beachie[1]);\r\n aquilinity_solemnization = 5;\r\n while(1 == 1){\r\n aquilinity_solemnization = aquilinity_solemnization * 2;\r\n aquilinity_solemnization = aquilinity_solemnization + 2;\r\n if (aquilinity_solemnization > 1000) {\r\n break; \r\n }\r\n }\r\n pillmaking_sabin = aquilinity_solemnization;\r\n virulented_bantry = ((char *)heartsomeness_tranks[3]);\r\n \r\n \r\n \r\n \r\n \r\n \r\n strncpy(buffer,virulented_bantry,strlen(virulented_bantry) + 1);\r\n for (; oc_i < strlen(buffer); ++oc_i) {\r\n buffer[oc_i] = toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\",buffer);\r\n \r\n \r\n \r\n;\r\n if (heartsomeness_tranks[3] != 0) \r\n free(((char *)heartsomeness_tranks[3]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n strncpy(buffer,virulented_bantry,strlen(virulented_bantry) + 1);\n for (; oc_i < strlen(buffer); ++oc_i) {\n buffer[oc_i] = toupper(buffer[oc_i]);\n }\n printf(\"%s\\n\",buffer);\n```", "cwe": "805"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint knapscap_antireticular = 0;\r\nint global_variable;\r\nvoid slimsier_multitasking(char **pleasantdale_micropetrology);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid pongees_orchel(void (*scratchy_dif)(char **));\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&knapscap_antireticular,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n pongees_orchel(slimsier_multitasking);\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid slimsier_multitasking(char **pleasantdale_micropetrology)\r\n{\r\n char *hecatonstylon_kolinskies;\r\n ++global_variable;;\r\n setup_printf_context();\r\n hecatonstylon_kolinskies = getenv(\"ESPERANTIDIST_DIGLOSSIA\");\r\n if (hecatonstylon_kolinskies != 0) {;\r\n *pleasantdale_micropetrology = hecatonstylon_kolinskies;\r\n }\r\n}\r\n\r\nvoid pongees_orchel(void (*scratchy_dif)(char **))\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *indexers_devoutlessness = 0;\r\n char *menison_dhan[21] = {0};\r\n ++global_variable;\r\n char *toothachy_resinoelectric = 0;\r\n scratchy_dif(&toothachy_resinoelectric);\r\n if (toothachy_resinoelectric != 0) {;\r\n menison_dhan[16] = toothachy_resinoelectric;\r\n indexers_devoutlessness = ((char *)menison_dhan[16]);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, indexers_devoutlessness);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer)) {\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n } else {\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint musit_pairmasts = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid tenoning_sarina(char **spaceward_darnedest);\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n void (*conli_sententiousness)(char **) = tenoning_sarina;\r\n int cornix_overcommit;\r\n char **unreadier_countertrades = 0;\r\n char **pholad_connectant = 0;\r\n char *engirdles_blow[31] = {0};\r\n char *subglumaceous_dogedoms;;\r\n if (__sync_bool_compare_and_swap(&musit_pairmasts,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&subglumaceous_dogedoms,\"UNILLUSTRATIVE_STEMSON\");\r\n if (subglumaceous_dogedoms != 0) {;\r\n engirdles_blow[24] = subglumaceous_dogedoms;\r\n cornix_overcommit = 1;\r\n unreadier_countertrades = engirdles_blow;\r\n pholad_connectant = ((char **)(((unsigned long )unreadier_countertrades) * cornix_overcommit * cornix_overcommit)) + 5;\r\n conli_sententiousness(pholad_connectant);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid tenoning_sarina(char **spaceward_darnedest)\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n int nFields;\r\n int i;\r\n int j = 0;\r\n char *secam_epididymitis = 0;\r\n ++global_variable;;\r\n secam_epididymitis = ((char *)(spaceward_darnedest - 5)[24]);\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", secam_epididymitis);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != 2) {\r\n \r\n printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n nFields = PQnfields(res);\r\n for (i = 0; i < nFields; i++)\r\n printf(\"%-15s\", PQfname(res, i));\r\n printf(\"\\n\\n\");\r\n \r\n for (i = 0; i < PQntuples(res); i++)\r\n {\r\n for (j = 0; j < nFields; j++)\r\n printf(\"%-15s\", PQgetvalue(res, i, j));\r\n printf(\"\\n\");\r\n }\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\n if ((spaceward_darnedest - 5)[24] != 0) \r\n free(((char *)(spaceward_darnedest - 5)[24]));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n res = PQexec(conn,query);\n if (PQresultStatus(res) != 2) {\n \n printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n PQclear(res);\n PQfinish(conn);\n exit(1);\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint clinospore_mesomorph = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *lineary_psalmodic = 0;\r\n int corojo_california;\r\n int sympathism_campo;\r\n char **expressly_threshingtime = 0;\r\n int *shellier_flotten = 0;\r\n int gigantoblast_medin;\r\n char **quintupled_forthink[10] = {0};\r\n char *anischuria_ureteric[28] = {0};\r\n char *cherrying_brachiopod;;\r\n if (__sync_bool_compare_and_swap(&clinospore_mesomorph,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n cherrying_brachiopod = getenv(\"CHALCOSTIBITE_THAMURIA\");\r\n if (cherrying_brachiopod != 0) {;\r\n anischuria_ureteric[20] = cherrying_brachiopod;\r\n quintupled_forthink[5] = anischuria_ureteric;\r\n gigantoblast_medin = 5;\r\n shellier_flotten = &gigantoblast_medin;\r\n expressly_threshingtime = *(quintupled_forthink + *shellier_flotten);\r\n sympathism_campo = 5;\r\n while(1 == 1){\r\n sympathism_campo = sympathism_campo * 2;\r\n sympathism_campo = sympathism_campo + 2;\r\n if (sympathism_campo > 1000) {\r\n break; \r\n }\r\n }\r\n corojo_california = sympathism_campo;\r\n lineary_psalmodic = ((char *)expressly_threshingtime[20]);\r\n \r\n input = atoi(lineary_psalmodic);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n quotient = 1024 / mod;\n```", "cwe": "369"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint medjidieh_kechuans = 0;\r\nint global_variable;\r\n\r\nunion depickle_keeseville \r\n{\r\n char *jokul_chuvash;\r\n double radnorshire_sciarinae;\r\n char *orate_moonset;\r\n char nonseparative_goemot;\r\n int inexpungeable_fotched;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid underbuilder_appositely(union depickle_keeseville *frigga_egerton);\r\nvoid ichthyosaurus_pollutedly(union depickle_keeseville *sassanid_ephemeroptera);\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n union depickle_keeseville *metropolitanize_atticize = {0};\r\n union depickle_keeseville idotheidae_beguileful;\r\n int samkhya_cruth = 35;\r\n char *gard_junior;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&medjidieh_kechuans,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&gard_junior,\"3858\",samkhya_cruth);\r\n if (gard_junior != 0) {;\r\n idotheidae_beguileful . jokul_chuvash = gard_junior;\r\n metropolitanize_atticize = &idotheidae_beguileful;\r\n underbuilder_appositely(metropolitanize_atticize);\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid underbuilder_appositely(union depickle_keeseville *frigga_egerton)\r\n{\r\n ++global_variable;;\r\n ichthyosaurus_pollutedly(frigga_egerton);\r\n}\r\n\r\nvoid ichthyosaurus_pollutedly(union depickle_keeseville *sassanid_ephemeroptera)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *ambulatoria_anginous = 0;\r\n ++global_variable;;\r\n ambulatoria_anginous = ((char *)( *sassanid_ephemeroptera) . jokul_chuvash);\r\n \r\n if (strlen(ambulatoria_anginous) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(ambulatoria_anginous) == 1) {\r\n parsed_input = malloc((strlen(ambulatoria_anginous)+1) * sizeof(char));\r\n urlDecode(ambulatoria_anginous, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if (( *sassanid_ephemeroptera) . jokul_chuvash != 0) \r\n free(((char *)( *sassanid_ephemeroptera) . jokul_chuvash));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <unistd.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint epiphonemas_hayatake = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int fd;\r\n char *extension = \".lck\";\r\n char *thelockfile;\r\n char *anno_louisianians = 0;\r\n jmp_buf primp_sovkhoz;\r\n int carbolising_tanga;\r\n void **costain_adjument = 0;\r\n void *labyrinthitis_foresweat = 0;\r\n char *biliverdic_myriapodan;;\r\n if (__sync_bool_compare_and_swap(&epiphonemas_hayatake,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n biliverdic_myriapodan = getenv(\"DIFFRACTION_HOMOANISIC\");\r\n if (biliverdic_myriapodan != 0) {;\r\n labyrinthitis_foresweat = ((void *)biliverdic_myriapodan);\r\n costain_adjument = &labyrinthitis_foresweat;\r\n carbolising_tanga = setjmp(primp_sovkhoz);\r\n if (carbolising_tanga == 0) {\r\n longjmp(primp_sovkhoz,1);\r\n }\r\n anno_louisianians = ((char *)((char *)( *costain_adjument)));\r\n \r\n thelockfile = (char *)malloc(strlen(\"/opt//workspace/testData/\") + strlen(anno_louisianians) +\r\n strlen(extension) + 1);\r\n \r\n if (thelockfile) {\r\n \r\n \r\n strcpy(thelockfile, \"/opt//workspace/testData/\");\r\n strcat(thelockfile, anno_louisianians);\r\n strcat(thelockfile, extension);\r\n \r\n \r\n if (access(\"/opt//workspace/testData/\", R_OK && W_OK) == -1) {\r\n printf(\"Error accessing testData directory\\n\");\r\n } else {\r\n printf(\"Grabbing lock file: %s\\n\", thelockfile);\r\n \r\n \r\n \r\n while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\r\n sleep(0);\r\n }\r\n \r\n printf(\"Made it to the critical section\\n\");\r\n if (fd != -1) {\r\n close(fd);\r\n unlink(thelockfile);\r\n }\r\n free (thelockfile);\r\n }\r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\n sleep(0);\n }\n```", "cwe": "412"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\nint desktops_sesquinona = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid chocho_cumbrance(char *const islanded_lyburn);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int phthalanilic_unforbiddenness = 30;\r\n char *birdless_nemaline;;\r\n if (__sync_bool_compare_and_swap(&desktops_sesquinona,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&birdless_nemaline,\"4357\",phthalanilic_unforbiddenness);\r\n if (birdless_nemaline != 0) {;\r\n chocho_cumbrance(birdless_nemaline);\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid chocho_cumbrance(char *const islanded_lyburn)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *maximins_plecotine = 0;\r\n int stringwood_histone;\r\n int supernaturalist_yawn;\r\n ++global_variable;;\r\n supernaturalist_yawn = 5;\r\n while(1 == 1){\r\n supernaturalist_yawn = supernaturalist_yawn * 2;\r\n supernaturalist_yawn = supernaturalist_yawn + 2;\r\n if (supernaturalist_yawn > 1000) {\r\n break; \r\n }\r\n }\r\n stringwood_histone = supernaturalist_yawn;\r\n maximins_plecotine = ((char *)((char *)islanded_lyburn));\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",maximins_plecotine);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (((char *)islanded_lyburn) != 0) \r\n free(((char *)((char *)islanded_lyburn)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint coronatorial_totality = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar **waff_entree(char **minim_osler);\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *recouper_nazdrowie = 0;\r\n jmp_buf protocolist_substraction;\r\n int handloomed_toasters;\r\n char **biclinia_olympionic = 0;\r\n char *endrin_precondition[80] = {0};\r\n char *unruled_terraciform;\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&coronatorial_totality,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&unruled_terraciform,\"DBRN_HYALESCENT\");\r\n if (unruled_terraciform != 0) {;\r\n endrin_precondition[32] = unruled_terraciform;\r\n biclinia_olympionic = waff_entree(endrin_precondition);\r\n handloomed_toasters = setjmp(protocolist_substraction);\r\n if (handloomed_toasters == 0) {\r\n longjmp(protocolist_substraction,1);\r\n }\r\n recouper_nazdrowie = ((char *)biclinia_olympionic[32]);\r\n \r\n len = strtol(recouper_nazdrowie,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (biclinia_olympionic[32] != 0) \r\n free(((char *)biclinia_olympionic[32]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nchar **waff_entree(char **minim_osler)\r\n{\r\n ++global_variable;\r\n return minim_osler;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <math.h>\r\n\r\n#include \"config.h\"\r\n#include \"compat/va_copy.h\"\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavfilter/avfilter.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libavresample/avresample.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#if CONFIG_POSTPROC\r\n#include \"libpostproc/postprocess.h\"\r\n#endif\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/eval.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"cmdutils.h\"\r\n#include \"version.h\"\r\n#if CONFIG_NETWORK\r\n#include \"libavformat/network.h\"\r\n#endif\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/resource.h>\r\n#endif\r\n#if TRACE\r\n#define TRACEPOINT_DEFINE\r\n#define TRACEPOINT_PROBE_DYNAMIC_LINKAGE\r\n#include </trace.h>\r\n#endif\r\nstatic int init_report(const char *env);\r\nstruct SwsContext *sws_opts;\r\nAVDictionary *swr_opts;\r\nAVDictionary *format_opts;\r\nAVDictionary *codec_opts;\r\nAVDictionary *resample_opts;\r\nconst int this_year = 2013;\r\nstatic FILE *report_file;\r\nint yikirgaulit_lederite = 0;\r\nint global_variable;\r\n\r\nstruct tbilisi_neckful \r\n{\r\n char *charwoman_carthamin;\r\n double peeving_dillseed;\r\n char *greathead_approach;\r\n char whipper_outdwelt;\r\n int nama_fibromata;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid nereidae_alloa(struct tbilisi_neckful unroot_verier);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nvoid init_opts()\r\n{\r\n if (1) {\r\n sws_opts = sws_getContext(16,16,AV_PIX_FMT_YUV420P,16,16,AV_PIX_FMT_YUV420P,4,((void *)0),((void *)0),((void *)0));\r\n }\r\n}\r\n\r\nvoid uninit_opts()\r\n{\r\n#if CONFIG_SWSCALE\r\n sws_freeContext(sws_opts);\r\n sws_opts = ((void *)0);\r\n#endif\r\n av_dict_free(&swr_opts);\r\n av_dict_free(&format_opts);\r\n av_dict_free(&codec_opts);\r\n av_dict_free(&resample_opts);\r\n}\r\n\r\nvoid log_callback_help(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n vfprintf(stdout,fmt,vl);\r\n}\r\n\r\nstatic void log_callback_report(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n va_list vl2;\r\n char line[1024];\r\n static int print_prefix = 1;\r\n __builtin_va_copy(vl2,vl);\r\n av_log_default_callback(ptr,level,fmt,vl);\r\n av_log_format_line(ptr,level,fmt,vl2,line,(sizeof(line)),&print_prefix);\r\n __builtin_va_end(vl2);\r\n fputs(line,report_file);\r\n fflush(report_file);\r\n}\r\n\r\ndouble parse_number_or_die(const char *context,const char *numstr,int type,double min,double max)\r\n{\r\n char *tail;\r\n const char *error;\r\n double d = av_strtod(numstr,&tail);\r\n if ( *tail) {\r\n error = \"Expected number for %s but found: %s\\n\";\r\n }\r\n else {\r\n if (d < min || d > max) {\r\n error = \"The value for %s was %s which is not within %f - %f\\n\";\r\n }\r\n else {\r\n if (type == 0x0400 && ((int64_t )d) != d) {\r\n error = \"Expected int64 for %s but found %s\\n\";\r\n }\r\n else {\r\n if (type == 0x80 && ((int )d) != d) {\r\n error = \"Expected int for %s but found %s\\n\";\r\n }\r\n else {\r\n return d;\r\n }\r\n }\r\n }\r\n }\r\n av_log(((void *)0),8,error,context,numstr,min,max);\r\n exit(1);\r\n return 0;\r\n}\r\n\r\nint64_t parse_time_or_die(const char *context,const char *timestr,int is_duration)\r\n{\r\n int64_t us;\r\n if (av_parse_time(&us,timestr,is_duration) < 0) {\r\n av_log(((void *)0),8,\"Invalid %s specification for %s: %s\\n\",(is_duration?\"duration\" : \"date\"),context,timestr);\r\n exit(1);\r\n }\r\n return us;\r\n}\r\n\r\nvoid show_help_options(const OptionDef *options,const char *msg,int req_flags,int rej_flags,int alt_flags)\r\n{\r\n const OptionDef *po;\r\n int first;\r\n first = 1;\r\n for (po = options; po -> name != ((void *)0); po++) {\r\n char buf[64];\r\n if ((po -> flags & req_flags) != req_flags || alt_flags && !(po -> flags & alt_flags) || po -> flags & rej_flags) {\r\n continue; \r\n }\r\n if (first) {\r\n printf(\"%s\\n\",msg);\r\n first = 0;\r\n }\r\n av_strlcpy(buf,po -> name,sizeof(buf));\r\n if (po -> argname) {\r\n av_strlcat(buf,\" \",sizeof(buf));\r\n av_strlcat(buf,po -> argname,sizeof(buf));\r\n }\r\n printf(\"-%-17s %s\\n\",buf,po -> help);\r\n }\r\n printf(\"\\n\");\r\n}\r\n\r\nvoid show_help_children(const AVClass *class,int flags)\r\n{\r\n const AVClass *child = ((void *)0);\r\n if (class -> option) {\r\n av_opt_show2((&class),((void *)0),flags,0);\r\n printf(\"\\n\");\r\n }\r\n while(child = av_opt_child_class_next(class,child))\r\n show_help_children(child,flags);\r\n}\r\n\r\nstatic const OptionDef *find_option(const OptionDef *po,const char *name)\r\n{\r\n const char *p = (strchr(name,':'));\r\n int len = (p?(p - name) : strlen(name));\r\n while(po -> name != ((void *)0)){\r\n if (!strncmp(name,po -> name,len) && strlen(po -> name) == len) {\r\n break; \r\n }\r\n po++;\r\n }\r\n return po;\r\n}\r\n#if HAVE_COMMANDLINETOARGVW\r\n#include <windows.h>\r\n#include <shellapi.h>\r\n\r\n\r\n\r\n#else\r\n\r\ninline static void prepare_app_arguments(int *argc_ptr,char ***argv_ptr)\r\n{\r\n\r\n}\r\n#endif \r\n\r\nstatic int write_option(void *optctx,const OptionDef *po,const char *opt,const char *arg)\r\n{\r\n\r\n void *dst = po -> flags & (0x4000 | 0x8000)?(((uint8_t *)optctx) + po -> u . off) : po -> u . dst_ptr;\r\n int *dstcount;\r\n if (po -> flags & 0x8000) {\r\n SpecifierOpt **so = dst;\r\n char *p = strchr(opt,':');\r\n dstcount = ((int *)(so + 1));\r\n *so = (grow_array(( *so),(sizeof(( *( *so)))),dstcount, *dstcount + 1));\r\n ( *so)[ *dstcount - 1] . specifier = av_strdup(((p?p + 1 : \"\")));\r\n dst = (&( *so)[ *dstcount - 1] . u);\r\n }\r\n if (po -> flags & 0x0008) {\r\n char *str;\r\n str = av_strdup(arg);\r\n\r\n *((char **)dst) = str;\r\n }\r\n else {\r\n if (po -> flags & 0x00002 || po -> flags & 0x80) {\r\n *((int *)dst) = (parse_number_or_die(opt,arg,0x0400,(- 2147483647 - 1),2147483647));\r\n }\r\n else {\r\n if (po -> flags & 0x0400) {\r\n *((int64_t *)dst) = (parse_number_or_die(opt,arg,0x0400,(- 9223372036854775807L - 1),9223372036854775807L));\r\n }\r\n else {\r\n if (po -> flags & 0x10000) {\r\n *((int64_t *)dst) = parse_time_or_die(opt,arg,1);\r\n }\r\n else {\r\n if (po -> flags & 0x00100) {\r\n *((float *)dst) = (parse_number_or_die(opt,arg,0x00100,(-__builtin_inff()),(__builtin_inff())));\r\n }\r\n else {\r\n if (po -> flags & 0x20000) {\r\n *((double *)dst) = parse_number_or_die(opt,arg,0x20000,(-__builtin_inff()),(__builtin_inff()));\r\n }\r\n else {\r\n if (po -> u . func_arg) {\r\n int ret = po -> u . func_arg(optctx,opt,arg);\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Failed to set value '%s' for option '%s'\\n\",arg,opt);\r\n return ret;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n }\r\n }\r\n }\r\n if (po -> flags & 0x0800) {\r\n exit(0);\r\n }\r\n return 0;\r\n}\r\n\r\nint parse_option(void *optctx,const char *opt,const char *arg,const OptionDef *options)\r\n{\r\n const OptionDef *po;\r\n int ret;\r\n po = find_option(options,opt);\r\n if (!po -> name && opt[0] == 'n' && opt[1] == 'o') {\r\n\r\n po = find_option(options,opt + 2);\r\n if (po -> name && po -> flags & 0x00002) {\r\n arg = \"0\";\r\n }\r\n }\r\n else {\r\n if (po -> flags & 0x00002) {\r\n arg = \"1\";\r\n }\r\n }\r\n if (!po -> name) {\r\n po = find_option(options,\"default\");\r\n }\r\n if (!po -> name) {\r\n av_log(((void *)0),16,\"Unrecognized option '%s'\\n\",opt);\r\n return - 22;\r\n }\r\n if (po -> flags & 0x0001 && !arg) {\r\n av_log(((void *)0),16,\"Missing argument for option '%s'\\n\",opt);\r\n return - 22;\r\n }\r\n ret = write_option(optctx,po,opt,arg);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n return !(!(po -> flags & 0x0001));\r\n}\r\n\r\nvoid parse_options(void *optctx,int argc,char **argv,const OptionDef *options,void (*parse_arg_function)(void *, const char *))\r\n{\r\n const char *opt;\r\n int optindex;\r\n int handleoptions = 1;\r\n int ret;\r\n\r\n prepare_app_arguments(&argc,&argv);\r\n\r\n optindex = 1;\r\n while(optindex < argc){\r\n opt = argv[optindex++];\r\n if (handleoptions && opt[0] == '-' && opt[1] != '\\0') {\r\n if (opt[1] == '-' && opt[2] == '\\0') {\r\n handleoptions = 0;\r\n continue; \r\n }\r\n opt++;\r\n if ((ret = parse_option(optctx,opt,argv[optindex],options)) < 0) {\r\n exit(1);\r\n }\r\n optindex += ret;\r\n }\r\n else {\r\n if (parse_arg_function) {\r\n parse_arg_function(optctx,opt);\r\n }\r\n }\r\n }\r\n}\r\n\r\nint parse_optgroup(void *optctx,OptionGroup *g)\r\n{\r\n int i;\r\n int ret;\r\n av_log(((void *)0),48,\"Parsing a group of options: %s %s.\\n\",g -> group_def -> name,g -> arg);\r\n for (i = 0; i < g -> nb_opts; i++) {\r\n Option *o = &g -> opts[i];\r\n av_log(((void *)0),48,\"Applying option %s (%s) with argument %s.\\n\",o -> key,o -> opt -> help,o -> val);\r\n ret = write_option(optctx,o -> opt,o -> key,o -> val);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n av_log(((void *)0),48,\"Successfully parsed a group of options.\\n\");\r\n return 0;\r\n}\r\n\r\nint locate_option(int argc,char **argv,const OptionDef *options,const char *optname)\r\n{\r\n const OptionDef *po;\r\n int i;\r\n for (i = 1; i < argc; i++) {\r\n const char *cur_opt = argv[i];\r\n if (( *(cur_opt++)) != '-') {\r\n continue; \r\n }\r\n po = find_option(options,cur_opt);\r\n if (!po -> name && cur_opt[0] == 'n' && cur_opt[1] == 'o') {\r\n po = find_option(options,cur_opt + 2);\r\n }\r\n if (!po -> name && !strcmp(cur_opt,optname) || po -> name && !strcmp(optname,po -> name)) {\r\n return i;\r\n }\r\n if (po -> flags & 0x0001) {\r\n i++;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void dump_argument(const char *a)\r\n{\r\n const unsigned char *p;\r\n for (p = a; *p; p++) \r\n if (!(( *p) >= '+' && ( *p) <= ':' || ( *p) >= 64 && ( *p) <= 'Z' || ( *p) == '_' || ( *p) >= 'a' && ( *p) <= 'z')) {\r\n break; \r\n }\r\n if (!( *p)) {\r\n fputs(a,report_file);\r\n return ;\r\n }\r\n fputc('\"',report_file);\r\n for (p = a; *p; p++) {\r\n if (( *p) == '\\\\' || ( *p) == '\"' || ( *p) == '$' || ( *p) == '`') {\r\n fprintf(report_file,\"\\\\%c\",( *p));\r\n }\r\n else {\r\n if (( *p) < 32 || ( *p) > '~') {\r\n fprintf(report_file,\"\\\\x%02x\",( *p));\r\n }\r\n else {\r\n fputc(( *p),report_file);\r\n }\r\n }\r\n }\r\n fputc('\"',report_file);\r\n}\r\n\r\nvoid parse_loglevel(int argc,char **argv,const OptionDef *options)\r\n{\r\n int idx = locate_option(argc,argv,options,\"loglevel\");\r\n const char *env;\r\n if (!idx) {\r\n idx = locate_option(argc,argv,options,\"v\");\r\n }\r\n if (idx && argv[idx + 1]) {\r\n opt_loglevel(((void *)0),\"loglevel\",argv[idx + 1]);\r\n }\r\n idx = locate_option(argc,argv,options,\"report\");\r\n if ((env = (getenv(\"FFREPORT\"))) || idx) {\r\n init_report(env);\r\n if (report_file) {\r\n int i;\r\n fprintf(report_file,\"Command line:\\n\");\r\n for (i = 0; i < argc; i++) {\r\n dump_argument(argv[i]);\r\n fputc((i < argc - 1?32 : '\\n'),report_file);\r\n }\r\n fflush(report_file);\r\n }\r\n }\r\n}\r\n#define FLAGS (o->type == AV_OPT_TYPE_FLAGS) ? AV_DICT_APPEND : 0\r\n\r\nint opt_default(void *optctx,const char *opt,const char *arg)\r\n{\r\n const AVOption *o;\r\n int consumed = 0;\r\n char opt_stripped[128];\r\n const char *p;\r\n const AVClass *cc = avcodec_get_class();\r\n const AVClass *fc = avformat_get_class();\r\n#if CONFIG_AVRESAMPLE\r\n#endif\r\n const AVClass *sc;\r\n const AVClass *swr_class;\r\n if (!strcmp(opt,\"debug\") || !strcmp(opt,\"fdebug\")) {\r\n av_log_set_level(48);\r\n }\r\n if (!(p = (strchr(opt,':')))) {\r\n p = opt + strlen(opt);\r\n }\r\n av_strlcpy(opt_stripped,opt,(sizeof(opt_stripped) > (p - opt + 1)?(p - opt + 1) : sizeof(opt_stripped)));\r\n if ((o = av_opt_find((&cc),opt_stripped,((void *)0),0,0x0001 | 0x00002)) || (opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') && (o = av_opt_find((&cc),opt + 1,((void *)0),0,0x00002))) {\r\n av_dict_set(&codec_opts,opt,arg,((o -> type) == AV_OPT_TYPE_FLAGS?32 : 0));\r\n consumed = 1;\r\n }\r\n if (o = av_opt_find((&fc),opt,((void *)0),0,0x0001 | 0x00002)) {\r\n av_dict_set(&format_opts,opt,arg,((o -> type) == AV_OPT_TYPE_FLAGS?32 : 0));\r\n if (consumed) {\r\n av_log(((void *)0),40,\"Routing %s to codec and muxer layer\\n\",opt);\r\n }\r\n consumed = 1;\r\n }\r\n#if CONFIG_SWSCALE\r\n sc = sws_get_class();\r\n if (!consumed && av_opt_find((&sc),opt,((void *)0),0,0x0001 | 0x00002)) {\r\n\r\n int ret = av_opt_set(sws_opts,opt,arg,0);\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Error setting option %s.\\n\",opt);\r\n return ret;\r\n }\r\n consumed = 1;\r\n }\r\n#endif\r\n#if CONFIG_SWRESAMPLE\r\n swr_class = swr_get_class();\r\n if (!consumed && (o = av_opt_find((&swr_class),opt,((void *)0),0,0x0001 | 0x00002))) {\r\n struct SwrContext *swr = swr_alloc();\r\n int ret = av_opt_set(swr,opt,arg,0);\r\n swr_free(&swr);\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Error setting option %s.\\n\",opt);\r\n return ret;\r\n }\r\n av_dict_set(&swr_opts,opt,arg,((o -> type) == AV_OPT_TYPE_FLAGS?32 : 0));\r\n consumed = 1;\r\n }\r\n#endif\r\n#if CONFIG_AVRESAMPLE\r\n#endif\r\n if (consumed) {\r\n return 0;\r\n }\r\n return -((int )((0xF8 | 'O' << 8 | 'P' << 16) | ((unsigned int )'T') << 24));\r\n}\r\n\r\n\r\nstatic int match_group_separator(const OptionGroupDef *groups,int nb_groups,const char *opt)\r\n{\r\n int i;\r\n for (i = 0; i < nb_groups; i++) {\r\n const OptionGroupDef *p = &groups[i];\r\n if (p -> sep && !strcmp(p -> sep,opt)) {\r\n return i;\r\n }\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nstatic void finish_group(OptionParseContext *octx,int group_idx,const char *arg)\r\n{\r\n OptionGroupList *l = &octx -> groups[group_idx];\r\n OptionGroup *g;\r\n l -> groups = (grow_array((l -> groups),(sizeof(( *l -> groups))),&l -> nb_groups,l -> nb_groups + 1));\r\n g = &l -> groups[l -> nb_groups - 1];\r\n *g = octx -> cur_group;\r\n g -> arg = arg;\r\n g -> group_def = l -> group_def;\r\n#if CONFIG_SWSCALE\r\n g -> sws_opts = sws_opts;\r\n#endif\r\n g -> swr_opts = swr_opts;\r\n g -> codec_opts = codec_opts;\r\n g -> format_opts = format_opts;\r\n g -> resample_opts = resample_opts;\r\n codec_opts = ((void *)0);\r\n format_opts = ((void *)0);\r\n resample_opts = ((void *)0);\r\n#if CONFIG_SWSCALE\r\n sws_opts = ((void *)0);\r\n#endif\r\n swr_opts = ((void *)0);\r\n init_opts();\r\n memset((&octx -> cur_group),0,sizeof(octx -> cur_group));\r\n}\r\n\r\n\r\nstatic void add_opt(OptionParseContext *octx,const OptionDef *opt,const char *key,const char *val)\r\n{\r\n int global = !(opt -> flags & (0x2000 | 0x8000 | 0x4000));\r\n OptionGroup *g = global?&octx -> global_opts : &octx -> cur_group;\r\n g -> opts = (grow_array((g -> opts),(sizeof(( *g -> opts))),&g -> nb_opts,g -> nb_opts + 1));\r\n g -> opts[g -> nb_opts - 1] . opt = opt;\r\n g -> opts[g -> nb_opts - 1] . key = key;\r\n g -> opts[g -> nb_opts - 1] . val = val;\r\n}\r\n\r\nstatic void init_parse_context(OptionParseContext *octx,const OptionGroupDef *groups,int nb_groups)\r\n{\r\n static const OptionGroupDef global_group = {(\"global\")};\r\n int i;\r\n memset(octx,0,sizeof(( *octx)));\r\n octx -> nb_groups = nb_groups;\r\n octx -> groups = (av_mallocz(sizeof(( *octx -> groups)) * (octx -> nb_groups)));\r\n if (!octx -> groups) {\r\n exit(1);\r\n }\r\n for (i = 0; i < octx -> nb_groups; i++) \r\n octx -> groups[i] . group_def = &groups[i];\r\n octx -> global_opts . group_def = &global_group;\r\n octx -> global_opts . arg = \"\";\r\n init_opts();\r\n}\r\n\r\nvoid uninit_parse_context(OptionParseContext *octx)\r\n{\r\n int i;\r\n int j;\r\n for (i = 0; i < octx -> nb_groups; i++) {\r\n OptionGroupList *l = &octx -> groups[i];\r\n for (j = 0; j < l -> nb_groups; j++) {\r\n av_freep((&l -> groups[j] . opts));\r\n av_dict_free(&l -> groups[j] . codec_opts);\r\n av_dict_free(&l -> groups[j] . format_opts);\r\n av_dict_free(&l -> groups[j] . resample_opts);\r\n#if CONFIG_SWSCALE\r\n sws_freeContext(l -> groups[j] . sws_opts);\r\n#endif\r\n av_dict_free(&l -> groups[j] . swr_opts);\r\n }\r\n av_freep((&l -> groups));\r\n }\r\n av_freep((&octx -> groups));\r\n av_freep((&octx -> cur_group . opts));\r\n av_freep((&octx -> global_opts . opts));\r\n uninit_opts();\r\n}\r\n\r\nint split_commandline(OptionParseContext *octx,int argc,char *argv[],const OptionDef *options,const OptionGroupDef *groups,int nb_groups)\r\n{\r\n int optindex = 1;\r\n int dashdash = - 2;\r\n\r\n prepare_app_arguments(&argc,&argv);\r\n init_parse_context(octx,groups,nb_groups);\r\n av_log(((void *)0),48,\"Splitting the commandline.\\n\");\r\n while(optindex < argc){\r\n const char *opt = argv[optindex++];\r\n const char *arg;\r\n const OptionDef *po;\r\n int ret;\r\n av_log(((void *)0),48,\"Reading option '%s' ...\",opt);\r\n if (opt[0] == '-' && opt[1] == '-' && !opt[2]) {\r\n dashdash = optindex;\r\n continue; \r\n }\r\n\r\n if (opt[0] != '-' || !opt[1] || dashdash + 1 == optindex) {\r\n finish_group(octx,0,opt);\r\n av_log(((void *)0),48,\" matched as %s.\\n\",groups[0] . name);\r\n continue; \r\n }\r\n opt++;\r\n#define GET_ARG(arg) \\\r\ndo { \\\r\n arg = argv[optindex++]; \\\r\n if (!arg) { \\\r\n av_log(NULL, AV_LOG_ERROR, \"Missing argument for option '%s'.\\n\", opt);\\\r\n return AVERROR(EINVAL); \\\r\n } \\\r\n} while (0)\r\n\r\n if ((ret = match_group_separator(groups,nb_groups,opt)) >= 0) {\r\n do {\r\n arg = argv[optindex++];\r\n if (!arg) {\r\n av_log(((void *)0),16,\"Missing argument for option '%s'.\\n\",opt);\r\n return - 22;\r\n }\r\n }while (0);\r\n finish_group(octx,ret,arg);\r\n av_log(((void *)0),48,\" matched as %s with argument '%s'.\\n\",groups[ret] . name,arg);\r\n continue; \r\n }\r\n\r\n po = find_option(options,opt);\r\n if (po -> name) {\r\n if (po -> flags & 0x0800) {\r\n\r\n arg = argv[optindex++];\r\n }\r\n else {\r\n if (po -> flags & 0x0001) {\r\n do {\r\n arg = argv[optindex++];\r\n if (!arg) {\r\n av_log(((void *)0),16,\"Missing argument for option '%s'.\\n\",opt);\r\n return - 22;\r\n }\r\n }while (0);\r\n }\r\n else {\r\n arg = \"1\";\r\n }\r\n }\r\n add_opt(octx,po,opt,arg);\r\n av_log(((void *)0),48,\" matched as option '%s' (%s) with argument '%s'.\\n\",po -> name,po -> help,arg);\r\n continue; \r\n }\r\n\r\n if (argv[optindex]) {\r\n ret = opt_default(((void *)0),opt,argv[optindex]);\r\n if (ret >= 0) {\r\n av_log(((void *)0),48,\" matched as AVOption '%s' with argument '%s'.\\n\",opt,argv[optindex]);\r\n optindex++;\r\n continue; \r\n }\r\n else {\r\n if (ret != -((int )((0xF8 | 'O' << 8 | 'P' << 16) | ((unsigned int )'T') << 24))) {\r\n av_log(((void *)0),16,\"Error parsing option '%s' with argument '%s'.\\n\",opt,argv[optindex]);\r\n return ret;\r\n }\r\n }\r\n }\r\n\r\n if (opt[0] == 'n' && opt[1] == 'o' && (po = find_option(options,opt + 2)) && po -> name && po -> flags & 0x00002) {\r\n add_opt(octx,po,opt,\"0\");\r\n av_log(((void *)0),48,\" matched as option '%s' (%s) with argument 0.\\n\",po -> name,po -> help);\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Unrecognized option '%s'.\\n\",opt);\r\n return -((int )((0xF8 | 'O' << 8 | 'P' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (octx -> cur_group . nb_opts || codec_opts || format_opts || resample_opts) {\r\n av_log(((void *)0),24,\"Trailing options were found on the commandline.\\n\");\r\n }\r\n av_log(((void *)0),48,\"Finished splitting the commandline.\\n\");\r\n return 0;\r\n}\r\n\r\nint opt_loglevel(void *optctx,const char *opt,const char *arg)\r\n{\r\n const struct {\r\n const char *name;\r\n int level;}log_levels[] = {{\"quiet\", (- 8)}, {\"panic\", (0)}, {\"fatal\", (8)}, {\"error\", (16)}, {\"warning\", (24)}, {\"info\", (32)}, {\"verbose\", (40)}, {\"debug\", (48)}};\r\n char *tail;\r\n int level;\r\n int i;\r\n for (i = 0; i < sizeof(log_levels) / sizeof(log_levels[0]); i++) {\r\n if (!strcmp(log_levels[i] . name,arg)) {\r\n av_log_set_level(log_levels[i] . level);\r\n return 0;\r\n }\r\n }\r\n level = (strtol(arg,&tail,'\\n'));\r\n if ( *tail) {\r\n av_log(((void *)0),8,\"Invalid loglevel \\\"%s\\\". Possible levels are numbers or:\\n\",arg);\r\n for (i = 0; i < sizeof(log_levels) / sizeof(log_levels[0]); i++) \r\n av_log(((void *)0),8,\"\\\"%s\\\"\\n\",log_levels[i] . name);\r\n exit(1);\r\n }\r\n av_log_set_level(level);\r\n return 0;\r\n}\r\n\r\nstatic void expand_filename_template(AVBPrint *bp,const char *template,struct tm *tm)\r\n{\r\n int c;\r\n while(c = ( *(template++))){\r\n if (c == '%') {\r\n if (!(c = ( *(template++)))) {\r\n break; \r\n }\r\n switch(c){\r\n case 'p':\r\n{\r\n av_bprintf(bp,\"%s\",program_name);\r\n break; \r\n }\r\n case 't':\r\n{\r\n av_bprintf(bp,\"%04d%02d%02d-%02d%02d%02d\",tm -> tm_year + 1900,tm -> tm_mon + 1,tm -> tm_mday,tm -> tm_hour,tm -> tm_min,tm -> tm_sec);\r\n break; \r\n }\r\n case '%':\r\n{\r\n av_bprint_chars(bp,c,1);\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n av_bprint_chars(bp,c,1);\r\n }\r\n }\r\n}\r\n\r\nstatic int init_report(const char *env)\r\n{\r\n char *filename_template = ((void *)0);\r\n char *key;\r\n char *val;\r\n int ret;\r\n int count = 0;\r\n time_t now;\r\n struct tm *tm;\r\n AVBPrint filename;\r\n\r\n if (report_file) {\r\n return 0;\r\n }\r\n time(&now);\r\n tm = localtime((&now));\r\n while(env && *env){\r\n if ((ret = av_opt_get_key_value(&env,\"=\",\":\",0,&key,&val)) < 0) {\r\n if (count) {\r\n av_log(((void *)0),16,\"Failed to parse FFREPORT environment variable: %s\\n\",av_make_error_string(((char [64]){(0)}),64,ret));\r\n }\r\n break; \r\n }\r\n if ( *env) {\r\n env++;\r\n }\r\n count++;\r\n if (!strcmp(key,\"file\")) {\r\n av_free(filename_template);\r\n filename_template = val;\r\n val = ((void *)0);\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Unknown key '%s' in FFREPORT\\n\",key);\r\n }\r\n av_free(val);\r\n av_free(key);\r\n }\r\n av_bprint_init(&filename,0,1);\r\n expand_filename_template(&filename,(av_x_if_null(filename_template,\"%p-%t.log\")),tm);\r\n av_free(filename_template);\r\n if (!av_bprint_is_complete(&filename)) {\r\n av_log(((void *)0),16,\"Out of memory building report file name\\n\");\r\n return - 12;\r\n }\r\n report_file = fopen(filename . str,\"w\");\r\n if (!report_file) {\r\n av_log(((void *)0),16,\"Failed to open report \\\"%s\\\": %s\\n\",filename . str,strerror( *__errno_location()));\r\n return -( *__errno_location());\r\n }\r\n av_log_set_callback(log_callback_report);\r\n av_log(((void *)0),32,\"%s started on %04d-%02d-%02d at %02d:%02d:%02d\\nReport written to \\\"%s\\\"\\n\",program_name,tm -> tm_year + 1900,tm -> tm_mon + 1,tm -> tm_mday,tm -> tm_hour,tm -> tm_min,tm -> tm_sec,filename . str);\r\n av_log_set_level((av_log_get_level() > 40?av_log_get_level() : 40));\r\n av_bprint_finalize(&filename,((void *)0));\r\n return 0;\r\n}\r\n\r\nint opt_report(const char *opt)\r\n{\r\n return init_report(((void *)0));\r\n}\r\n\r\nint opt_max_alloc(void *optctx,const char *opt,const char *arg)\r\n{\r\n char *tail;\r\n size_t max;\r\n max = (strtol(arg,&tail,'\\n'));\r\n if ( *tail) {\r\n av_log(((void *)0),8,\"Invalid max_alloc \\\"%s\\\".\\n\",arg);\r\n exit(1);\r\n }\r\n av_max_alloc(max);\r\n return 0;\r\n}\r\n\r\nint opt_cpuflags(void *optctx,const char *opt,const char *arg)\r\n{\r\n int ret;\r\n unsigned int flags = (av_get_cpu_flags());\r\n if ((ret = av_parse_cpu_caps(&flags,arg)) < 0) {\r\n return ret;\r\n }\r\n av_force_cpu_flags(flags);\r\n return 0;\r\n}\r\n\r\nint opt_timelimit(void *optctx,const char *opt,const char *arg)\r\n{\r\n#if HAVE_SETRLIMIT\r\n int lim = (parse_number_or_die(opt,arg,0x0400,0,2147483647));\r\n struct rlimit rl = {lim, (lim + 1)};\r\n if (setrlimit(RLIMIT_CPU,(&rl))) {\r\n perror(\"setrlimit\");\r\n }\r\n#else\r\n#endif\r\n return 0;\r\n}\r\n\r\nvoid print_error(const char *filename,int err)\r\n{\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(err,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-err));\r\n }\r\n av_log(((void *)0),16,\"%s: %s\\n\",filename,errbuf_ptr);\r\n}\r\nstatic int warned_cfg = 0;\r\n#define INDENT 1\r\n#define SHOW_VERSION 2\r\n#define SHOW_CONFIG 4\r\n#define SHOW_COPYRIGHT 8\r\n#define PRINT_LIB_INFO(libname, LIBNAME, flags, level) \\\r\n if (CONFIG_##LIBNAME) { \\\r\n const char *indent = flags & INDENT? \" \" : \"\"; \\\r\n if (flags & SHOW_VERSION) { \\\r\n unsigned int version = libname##_version(); \\\r\n av_log(NULL, level, \\\r\n \"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\", \\\r\n indent, #libname, \\\r\n LIB##LIBNAME##_VERSION_MAJOR, \\\r\n LIB##LIBNAME##_VERSION_MINOR, \\\r\n LIB##LIBNAME##_VERSION_MICRO, \\\r\n version >> 16, version >> 8 & 0xff, version & 0xff); \\\r\n } \\\r\n if (flags & SHOW_CONFIG) { \\\r\n const char *cfg = libname##_configuration(); \\\r\n if (strcmp(FFMPEG_CONFIGURATION, cfg)) { \\\r\n if (!warned_cfg) { \\\r\n av_log(NULL, level, \\\r\n \"%sWARNING: library configuration mismatch\\n\", \\\r\n indent); \\\r\n warned_cfg = 1; \\\r\n } \\\r\n av_log(NULL, level, \"%s%-11s configuration: %s\\n\", \\\r\n indent, #libname, cfg); \\\r\n } \\\r\n } \\\r\n } \\\r\n\r\n\r\nstatic void print_all_libs_info(int flags,int level)\r\n{\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avutil_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avutil\",'4',18,100,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avutil_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avutil\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avcodec_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avcodec\",'6','\\\\',100,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avcodec_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avcodec\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avformat_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avformat\",'6',63,'h',version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avformat_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avformat\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avdevice_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avdevice\",'6',3,103,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avdevice_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avdevice\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avfilter_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avfilter\",3,42,103,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avfilter_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avfilter\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = swscale_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"swscale\",2,2,100,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = swscale_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"swscale\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = swresample_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"swresample\",0,17,102,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = swresample_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"swresample\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n#if CONFIG_POSTPROC\r\n#endif\r\n}\r\n\r\nstatic void print_program_info(int flags,int level)\r\n{\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n av_log(((void *)0),level,\"%s version 1.2.2\",program_name);\r\n if (flags & 8) {\r\n av_log(((void *)0),level,\" Copyright (c) %d-%d the FFmpeg developers\",program_birth_year,this_year);\r\n }\r\n av_log(((void *)0),level,\"\\n\");\r\n av_log(((void *)0),level,\"%sbuilt on %s %s with %s\\n\",indent,\"Nov 21 2014\",\"18:55:08\",\"gcc 4.4.7 (GCC) 20120313 (Red Hat 4.4.7-4)\");\r\n av_log(((void *)0),level,\"%sconfiguration: --prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\\n\",indent);\r\n}\r\n\r\nvoid show_banner(int argc,char **argv,const OptionDef *options)\r\n{\r\n int idx = locate_option(argc,argv,options,\"version\");\r\n if (idx) {\r\n return ;\r\n }\r\n print_program_info(1 | 8,32);\r\n print_all_libs_info(1 | 4,32);\r\n print_all_libs_info(1 | 2,32);\r\n}\r\n\r\nint show_version(void *optctx,const char *opt,const char *arg)\r\n{\r\n av_log_set_callback(log_callback_help);\r\n print_program_info(0,32);\r\n print_all_libs_info(2,32);\r\n return 0;\r\n}\r\n\r\nint show_license(void *optctx,const char *opt,const char *arg)\r\n{\r\n#if CONFIG_NONFREE\r\n#elif CONFIG_GPLV3\r\n#elif CONFIG_GPL\r\n#elif CONFIG_LGPLV3\r\n#else\r\n printf(\"%s is free software; you can redistribute it and/or\\nmodify it under the terms of the GNU Lesser General Public\\nLicense as published by the Free Software Foundation; either\\nversion 2.1 of the License, or (at your option) any later version.\\n\\n%s is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\nLesser General Public License for more details.\\n\\nYou should have received a copy of the GNU Lesser General Public\\nLicense along with %s; if not, write to the Free Software\\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",program_name,program_name,program_name);\r\n#endif\r\n return 0;\r\n}\r\n\r\nint show_formats(void *optctx,const char *opt,const char *arg)\r\n{\r\n AVInputFormat *ifmt = ((void *)0);\r\n AVOutputFormat *ofmt = ((void *)0);\r\n const char *last_name;\r\n printf(\"File formats:\\n D. = Demuxing supported\\n .E = Muxing supported\\n --\\n\");\r\n last_name = \"000\";\r\n for (; ; ) {\r\n int decode = 0;\r\n int encode = 0;\r\n const char *name = ((void *)0);\r\n const char *long_name = ((void *)0);\r\n while(ofmt = av_oformat_next(ofmt)){\r\n if ((name == ((void *)0) || strcmp(ofmt -> name,name) < 0) && strcmp(ofmt -> name,last_name) > 0) {\r\n name = ofmt -> name;\r\n long_name = ofmt -> long_name;\r\n encode = 1;\r\n }\r\n }\r\n while(ifmt = av_iformat_next(ifmt)){\r\n if ((name == ((void *)0) || strcmp(ifmt -> name,name) < 0) && strcmp(ifmt -> name,last_name) > 0) {\r\n name = ifmt -> name;\r\n long_name = ifmt -> long_name;\r\n encode = 0;\r\n }\r\n if (name && strcmp(ifmt -> name,name) == 0) {\r\n decode = 1;\r\n }\r\n }\r\n if (name == ((void *)0)) {\r\n break; \r\n }\r\n last_name = name;\r\n printf(\" %s%s %-15s %s\\n\",(decode?\"D\" : \" \"),(encode?\"E\" : \" \"),name,(long_name?long_name : \" \"));\r\n }\r\n return 0;\r\n}\r\n#define PRINT_CODEC_SUPPORTED(codec, field, type, list_name, term, get_name) \\\r\n if (codec->field) { \\\r\n const type *p = codec->field; \\\r\n \\\r\n printf(\" Supported \" list_name \":\"); \\\r\n while (*p != term) { \\\r\n get_name(*p); \\\r\n printf(\" %s\", name); \\\r\n p++; \\\r\n } \\\r\n printf(\"\\n\"); \\\r\n } \\\r\n\r\n\r\nstatic void print_codec(const AVCodec *c)\r\n{\r\n int encoder = av_codec_is_encoder(c);\r\n printf(\"%s %s [%s]:\\n\",(encoder?\"Encoder\" : \"Decoder\"),c -> name,(c -> long_name?c -> long_name : \"\"));\r\n if ((c -> type) == AVMEDIA_TYPE_VIDEO) {\r\n printf(\" Threading capabilities: \");\r\n switch(c -> capabilities & (0x1000 | 0x2000)){\r\n case 0x1000 | 0x2000:\r\n{\r\n printf(\"frame and slice\");\r\n break; \r\n }\r\n case 0x1000:\r\n{\r\n printf(\"frame\");\r\n break; \r\n }\r\n case 0x2000:\r\n{\r\n printf(\"slice\");\r\n break; \r\n }\r\n default:\r\n{\r\n printf(\"no\");\r\n break; \r\n }\r\n }\r\n printf(\"\\n\");\r\n }\r\n if (c -> supported_framerates) {\r\n const AVRational *fps = c -> supported_framerates;\r\n printf(\" Supported framerates:\");\r\n while(fps -> num){\r\n printf(\" %d/%d\",fps -> num,fps -> den);\r\n fps++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n if (c -> pix_fmts) {\r\n const enum AVPixelFormat *p = c -> pix_fmts;\r\n printf(\" Supported pixel formats:\");\r\n while(( *p) != AV_PIX_FMT_NONE){\r\n const char *name = av_get_pix_fmt_name( *p);\r\n ;\r\n printf(\" %s\",name);\r\n p++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n ;\r\n if (c -> supported_samplerates) {\r\n const int *p = c -> supported_samplerates;\r\n printf(\" Supported sample rates:\");\r\n while( *p != 0){\r\n char name[16];\r\n snprintf(name,sizeof(name),\"%d\", *p);\r\n ;\r\n printf(\" %s\",name);\r\n p++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n ;\r\n if (c -> sample_fmts) {\r\n const enum AVSampleFormat *p = c -> sample_fmts;\r\n printf(\" Supported sample formats:\");\r\n while(( *p) != AV_SAMPLE_FMT_NONE){\r\n const char *name = av_get_sample_fmt_name( *p);\r\n printf(\" %s\",name);\r\n p++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n ;\r\n if (c -> channel_layouts) {\r\n const uint64_t *p = c -> channel_layouts;\r\n printf(\" Supported channel layouts:\");\r\n while( *p != 0){\r\n char name[128];\r\n av_get_channel_layout_string(name,(sizeof(name)),0, *p);\r\n ;\r\n printf(\" %s\",name);\r\n p++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n ;\r\n if (c -> priv_class) {\r\n show_help_children(c -> priv_class,1 | 2);\r\n }\r\n}\r\n\r\nstatic char get_media_type_char(enum AVMediaType type)\r\n{\r\n switch(type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return 'V';\r\n case AVMEDIA_TYPE_AUDIO:\r\n return 'A';\r\n case AVMEDIA_TYPE_DATA:\r\n return 'D';\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n return 'S';\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n return 'T';\r\n default:\r\n return 63;\r\n }\r\n}\r\n\r\nstatic const AVCodec *next_codec_for_id(enum AVCodecID id,const AVCodec *prev,int encoder)\r\n{\r\n while(prev = (av_codec_next(prev))){\r\n if ((prev -> id) == id && ((encoder?av_codec_is_encoder(prev) : av_codec_is_decoder(prev)))) {\r\n return prev;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_codec_desc(const void *a,const void *b)\r\n{\r\n const AVCodecDescriptor *const *da = a;\r\n const AVCodecDescriptor *const *db = b;\r\n return (( *da) -> type) != (( *db) -> type)?(( *da) -> type) - (( *db) -> type) : strcmp(( *da) -> name,( *db) -> name);\r\n}\r\n\r\nstatic unsigned int get_codecs_sorted(const AVCodecDescriptor ***rcodecs)\r\n{\r\n const AVCodecDescriptor *desc = ((void *)0);\r\n const AVCodecDescriptor **codecs;\r\n unsigned int nb_codecs = 0;\r\n unsigned int i = 0;\r\n while(desc = avcodec_descriptor_next(desc))\r\n nb_codecs++;\r\n if (!(codecs = (av_calloc(nb_codecs,sizeof(( *codecs)))))) {\r\n av_log(((void *)0),16,\"Out of memory\\n\");\r\n exit(1);\r\n }\r\n desc = ((void *)0);\r\n while(desc = avcodec_descriptor_next(desc))\r\n codecs[i++] = desc;\r\n do {\r\n if (!(i == nb_codecs)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i == nb_codecs\",\"cmdutils.c\",1271);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(codecs,nb_codecs,sizeof(( *codecs)),compare_codec_desc);\r\n *rcodecs = codecs;\r\n return nb_codecs;\r\n}\r\n\r\nstatic void print_codecs_for_id(enum AVCodecID id,int encoder)\r\n{\r\n const AVCodec *codec = ((void *)0);\r\n printf(\" (%s: \",(encoder?\"encoders\" : \"decoders\"));\r\n while(codec = next_codec_for_id(id,codec,encoder))\r\n printf(\"%s \",codec -> name);\r\n printf(\")\");\r\n}\r\n\r\nint show_codecs(void *optctx,const char *opt,const char *arg)\r\n{\r\n const AVCodecDescriptor **codecs;\r\n unsigned int i;\r\n unsigned int nb_codecs = get_codecs_sorted(&codecs);\r\n printf(\"Codecs:\\n D..... = Decoding supported\\n .E.... = Encoding supported\\n ..V... = Video codec\\n ..A... = Audio codec\\n ..S... = Subtitle codec\\n ...I.. = Intra frame-only codec\\n ....L. = Lossy compression\\n .....S = Lossless compression\\n -------\\n\");\r\n for (i = 0; i < nb_codecs; i++) {\r\n const AVCodecDescriptor *desc = codecs[i];\r\n const AVCodec *codec = ((void *)0);\r\n printf(\" \");\r\n printf((avcodec_find_decoder(desc -> id)?\"D\" : \".\"));\r\n printf((avcodec_find_encoder(desc -> id)?\"E\" : \".\"));\r\n printf(\"%c\",(get_media_type_char(desc -> type)));\r\n printf((desc -> props & 1 << 0?\"I\" : \".\"));\r\n printf((desc -> props & 1 << 1?\"L\" : \".\"));\r\n printf((desc -> props & 1 << 2?\"S\" : \".\"));\r\n printf(\" %-20s %s\",desc -> name,(desc -> long_name?desc -> long_name : \"\"));\r\n\r\n while(codec = next_codec_for_id(desc -> id,codec,0)){\r\n if (strcmp(codec -> name,desc -> name)) {\r\n print_codecs_for_id(desc -> id,0);\r\n break; \r\n }\r\n }\r\n codec = ((void *)0);\r\n while(codec = next_codec_for_id(desc -> id,codec,1)){\r\n if (strcmp(codec -> name,desc -> name)) {\r\n print_codecs_for_id(desc -> id,1);\r\n break; \r\n }\r\n }\r\n printf(\"\\n\");\r\n }\r\n av_free(codecs);\r\n return 0;\r\n}\r\n\r\nstatic void print_codecs(int encoder)\r\n{\r\n const AVCodecDescriptor **codecs;\r\n unsigned int i;\r\n unsigned int nb_codecs = get_codecs_sorted(&codecs);\r\n printf(\"%s:\\n V..... = Video\\n A..... = Audio\\n S..... = Subtitle\\n .F.... = Frame-level multithreading\\n ..S... = Slice-level multithreading\\n ...X.. = Codec is experimental\\n ....B. = Supports draw_horiz_band\\n .....D = Supports direct rendering method 1\\n ------\\n\",(encoder?\"Encoders\" : \"Decoders\"));\r\n for (i = 0; i < nb_codecs; i++) {\r\n const AVCodecDescriptor *desc = codecs[i];\r\n const AVCodec *codec = ((void *)0);\r\n while(codec = next_codec_for_id(desc -> id,codec,encoder)){\r\n printf(\" %c\",(get_media_type_char(desc -> type)));\r\n printf((codec -> capabilities & 0x1000?\"F\" : \".\"));\r\n printf((codec -> capabilities & 0x2000?\"S\" : \".\"));\r\n printf((codec -> capabilities & 0x0200?\"X\" : \".\"));\r\n printf((codec -> capabilities & 0x0001?\"B\" : \".\"));\r\n printf((codec -> capabilities & 0x00002?\"D\" : \".\"));\r\n printf(\" %-20s %s\",codec -> name,(codec -> long_name?codec -> long_name : \"\"));\r\n if (strcmp(codec -> name,desc -> name)) {\r\n printf(\" (codec %s)\",desc -> name);\r\n }\r\n printf(\"\\n\");\r\n }\r\n }\r\n av_free(codecs);\r\n}\r\n\r\nint show_decoders(void *optctx,const char *opt,const char *arg)\r\n{\r\n print_codecs(0);\r\n return 0;\r\n}\r\n\r\nint show_encoders(void *optctx,const char *opt,const char *arg)\r\n{\r\n print_codecs(1);\r\n return 0;\r\n}\r\n\r\nint show_bsfs(void *optctx,const char *opt,const char *arg)\r\n{\r\n AVBitStreamFilter *bsf = ((void *)0);\r\n printf(\"Bitstream filters:\\n\");\r\n while(bsf = av_bitstream_filter_next(bsf))\r\n printf(\"%s\\n\",bsf -> name);\r\n printf(\"\\n\");\r\n return 0;\r\n}\r\n\r\nint show_protocols(void *optctx,const char *opt,const char *arg)\r\n{\r\n void *opaque = (void *)0;\r\n const char *name;\r\n printf(\"Supported file protocols:\\nInput:\\n\");\r\n while(name = avio_enum_protocols(&opaque,0))\r\n printf(\"%s\\n\",name);\r\n printf(\"Output:\\n\");\r\n while(name = avio_enum_protocols(&opaque,1))\r\n printf(\"%s\\n\",name);\r\n return 0;\r\n}\r\n\r\nint show_filters(void *optctx,const char *opt,const char *arg)\r\n{\r\n AVFilter **filter __attribute__((unused)) = ((void *)0);\r\n char descr[64];\r\n char *descr_cur;\r\n int i;\r\n int j;\r\n const AVFilterPad *pad;\r\n printf(\"Filters:\\n\");\r\n#if CONFIG_AVFILTER\r\n while((filter = av_filter_next(filter)) && *filter){\r\n descr_cur = descr;\r\n for (i = 0; i < 2; i++) {\r\n if (i) {\r\n *(descr_cur++) = '-';\r\n *(descr_cur++) = '>';\r\n }\r\n pad = (i?( *filter) -> outputs : ( *filter) -> inputs);\r\n for (j = 0; pad && pad[j] . name; j++) {\r\n if (descr_cur >= descr + sizeof(descr) - 4) {\r\n break; \r\n }\r\n *(descr_cur++) = get_media_type_char(pad[j] . type);\r\n }\r\n if (!j) {\r\n *(descr_cur++) = '|';\r\n }\r\n }\r\n *descr_cur = 0;\r\n printf(\"%-16s %-10s %s\\n\",( *filter) -> name,descr,( *filter) -> description);\r\n }\r\n#endif\r\n return 0;\r\n}\r\n\r\nint show_pix_fmts(void *optctx,const char *opt,const char *arg)\r\n{\r\n const AVPixFmtDescriptor *pix_desc = ((void *)0);\r\n printf(\"Pixel formats:\\nI.... = Supported Input format for conversion\\n.O... = Supported Output format for conversion\\n..H.. = Hardware accelerated format\\n...P. = Paletted format\\n....B = Bitstream format\\nFLAGS NAME NB_COMPONENTS BITS_PER_PIXEL\\n-----\\n\");\r\n#if !CONFIG_SWSCALE\r\n# define sws_isSupportedInput(x) 0\r\n# define sws_isSupportedOutput(x) 0\r\n#endif\r\n while(pix_desc = av_pix_fmt_desc_next(pix_desc)){\r\n enum AVPixelFormat pix_fmt = av_pix_fmt_desc_get_id(pix_desc);\r\n printf(\"%c%c%c%c%c %-16s %d %2d\\n\",(sws_isSupportedInput(pix_fmt)?'I' : '.'),(sws_isSupportedOutput(pix_fmt)?'O' : '.'),((pix_desc -> flags) & 8?'H' : '.'),((pix_desc -> flags) & 2?'P' : '.'),((pix_desc -> flags) & 4?'B' : '.'),pix_desc -> name,(pix_desc -> nb_components),av_get_bits_per_pixel(pix_desc));\r\n }\r\n return 0;\r\n}\r\n\r\nint show_layouts(void *optctx,const char *opt,const char *arg)\r\n{\r\n int i = 0;\r\n uint64_t layout;\r\n uint64_t j;\r\n const char *name;\r\n const char *descr;\r\n printf(\"Individual channels:\\nNAME DESCRIPTION\\n\");\r\n for (i = 0; i < 63; i++) {\r\n name = av_get_channel_name(((uint64_t )1) << i);\r\n if (!name) {\r\n continue; \r\n }\r\n descr = av_get_channel_description(((uint64_t )1) << i);\r\n printf(\"%-12s%s\\n\",name,descr);\r\n }\r\n printf(\"\\nStandard channel layouts:\\nNAME DECOMPOSITION\\n\");\r\n for (i = 0; !av_get_standard_channel_layout(i,&layout,&name); i++) {\r\n if (name) {\r\n printf(\"%-12s\",name);\r\n for (j = 1; j; j <<= 1) \r\n if (layout & j) {\r\n printf(\"%s%s\",(layout & j - 1?\"+\" : \"\"),av_get_channel_name(j));\r\n }\r\n printf(\"\\n\");\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint show_sample_fmts(void *optctx,const char *opt,const char *arg)\r\n{\r\n int i;\r\n char fmt_str[128];\r\n for (i = - 1; i < AV_SAMPLE_FMT_NB; i++) \r\n printf(\"%s\\n\",av_get_sample_fmt_string(fmt_str,(sizeof(fmt_str)),i));\r\n return 0;\r\n}\r\n\r\nstatic void show_help_codec(const char *name,int encoder)\r\n{\r\n const AVCodecDescriptor *desc;\r\n const AVCodec *codec;\r\n if (!name) {\r\n av_log(((void *)0),16,\"No codec name specified.\\n\");\r\n return ;\r\n }\r\n codec = ((encoder?avcodec_find_encoder_by_name(name) : avcodec_find_decoder_by_name(name)));\r\n if (codec) {\r\n print_codec(codec);\r\n }\r\n else {\r\n if (desc = avcodec_descriptor_get_by_name(name)) {\r\n int printed = 0;\r\n while(codec = next_codec_for_id(desc -> id,codec,encoder)){\r\n printed = 1;\r\n print_codec(codec);\r\n }\r\n if (!printed) {\r\n av_log(((void *)0),16,\"Codec '%s' is known to FFmpeg, but no %s for it are available. FFmpeg might need to be recompiled with additional external libraries.\\n\",name,(encoder?\"encoders\" : \"decoders\"));\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Codec '%s' is not recognized by FFmpeg.\\n\",name);\r\n }\r\n }\r\n}\r\n\r\nstatic void show_help_demuxer(const char *name)\r\n{\r\n const AVInputFormat *fmt = (av_find_input_format(name));\r\n if (!fmt) {\r\n av_log(((void *)0),16,\"Unknown format '%s'.\\n\",name);\r\n return ;\r\n }\r\n printf(\"Demuxer %s [%s]:\\n\",fmt -> name,fmt -> long_name);\r\n if (fmt -> extensions) {\r\n printf(\" Common extensions: %s.\\n\",fmt -> extensions);\r\n }\r\n if (fmt -> priv_class) {\r\n show_help_children(fmt -> priv_class,2);\r\n }\r\n}\r\n\r\nstatic void show_help_muxer(const char *name)\r\n{\r\n const AVCodecDescriptor *desc;\r\n const AVOutputFormat *fmt = (av_guess_format(name,((void *)0),((void *)0)));\r\n if (!fmt) {\r\n av_log(((void *)0),16,\"Unknown format '%s'.\\n\",name);\r\n return ;\r\n }\r\n printf(\"Muxer %s [%s]:\\n\",fmt -> name,fmt -> long_name);\r\n if (fmt -> extensions) {\r\n printf(\" Common extensions: %s.\\n\",fmt -> extensions);\r\n }\r\n if (fmt -> mime_type) {\r\n printf(\" Mime type: %s.\\n\",fmt -> mime_type);\r\n }\r\n if ((fmt -> video_codec) != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt -> video_codec))) {\r\n printf(\" Default video codec: %s.\\n\",desc -> name);\r\n }\r\n if ((fmt -> audio_codec) != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt -> audio_codec))) {\r\n printf(\" Default audio codec: %s.\\n\",desc -> name);\r\n }\r\n if ((fmt -> subtitle_codec) != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt -> subtitle_codec))) {\r\n printf(\" Default subtitle codec: %s.\\n\",desc -> name);\r\n }\r\n if (fmt -> priv_class) {\r\n show_help_children(fmt -> priv_class,1);\r\n }\r\n}\r\n\r\nint show_help(void *optctx,const char *opt,const char *arg)\r\n{\r\n char *topic;\r\n char *par;\r\n av_log_set_callback(log_callback_help);\r\n topic = av_strdup((arg?arg : \"\"));\r\n par = strchr(topic,'=');\r\n if (par) {\r\n *(par++) = 0;\r\n }\r\n if (!( *topic)) {\r\n show_help_default(topic,par);\r\n }\r\n else {\r\n if (!strcmp(topic,\"decoder\")) {\r\n show_help_codec(par,0);\r\n }\r\n else {\r\n if (!strcmp(topic,\"encoder\")) {\r\n show_help_codec(par,1);\r\n }\r\n else {\r\n if (!strcmp(topic,\"demuxer\")) {\r\n show_help_demuxer(par);\r\n }\r\n else {\r\n if (!strcmp(topic,\"muxer\")) {\r\n show_help_muxer(par);\r\n }\r\n else {\r\n show_help_default(topic,par);\r\n }\r\n }\r\n }\r\n }\r\n }\r\n av_freep((&topic));\r\n return 0;\r\n}\r\n\r\nint read_yesno()\r\n{\r\n int c = getchar();\r\n int yesno = av_toupper(c) == 'Y';\r\n while(c != '\\n' && c != - 1)\r\n c = getchar();\r\n return yesno;\r\n}\r\n\r\nint cmdutils_read_file(const char *filename,char **bufptr,size_t *size)\r\n{\r\n int ret;\r\n FILE *f = fopen(filename,\"rb\");\r\n if (!f) {\r\n av_log(((void *)0),16,\"Cannot read file '%s': %s\\n\",filename,strerror( *__errno_location()));\r\n return -( *__errno_location());\r\n }\r\n fseek(f,0,2);\r\n *size = (ftell(f));\r\n fseek(f,0,0);\r\n if ( *size == ((size_t )(- 1))) {\r\n av_log(((void *)0),16,\"IO error: %s\\n\",strerror( *__errno_location()));\r\n fclose(f);\r\n return -( *__errno_location());\r\n }\r\n *bufptr = (av_malloc( *size + 1));\r\n if (!( *bufptr)) {\r\n av_log(((void *)0),16,\"Could not allocate file buffer\\n\");\r\n fclose(f);\r\n return - 12;\r\n }\r\n ret = (fread(( *bufptr),1, *size,f));\r\n if (ret < *size) {\r\n av_free(( *bufptr));\r\n if (ferror(f)) {\r\n av_log(((void *)0),16,\"Error while reading file '%s': %s\\n\",filename,strerror( *__errno_location()));\r\n ret = -( *__errno_location());\r\n }\r\n else {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n ( *bufptr)[( *size)++] = '\\0';\r\n }\r\n fclose(f);\r\n return ret;\r\n}\r\n\r\nFILE *get_preset_file(char *filename,size_t filename_size,const char *preset_name,int is_path,const char *codec_name)\r\n{\r\n FILE *f = ((void *)0);\r\n int i;\r\n const char *base[3] = {(getenv(\"FFMPEG_DATADIR\")), (getenv(\"HOME\")), \"/opt//workspace/install/share/ffmpeg\"};\r\n if (is_path) {\r\n av_strlcpy(filename,preset_name,filename_size);\r\n f = fopen(filename,\"r\");\r\n }\r\n else {\r\n#ifdef _WIN32\r\n#endif\r\n for (i = 0; i < 3 && !f; i++) {\r\n if (!base[i]) {\r\n continue; \r\n }\r\n snprintf(filename,filename_size,\"%s%s/%s.ffpreset\",base[i],(i != 1?\"\" : \"/.ffmpeg\"),preset_name);\r\n f = fopen(filename,\"r\");\r\n if (!f && codec_name) {\r\n snprintf(filename,filename_size,\"%s%s/%s-%s.ffpreset\",base[i],(i != 1?\"\" : \"/.ffmpeg\"),codec_name,preset_name);\r\n f = fopen(filename,\"r\");\r\n }\r\n }\r\n }\r\n return f;\r\n}\r\n\r\nint check_stream_specifier(AVFormatContext *s,AVStream *st,const char *spec)\r\n{\r\n int ret = avformat_match_stream_specifier(s,st,spec);\r\n if (ret < 0) {\r\n av_log(s,16,\"Invalid stream specifier: %s.\\n\",spec);\r\n }\r\n return ret;\r\n}\r\n\r\nAVDictionary *filter_codec_opts(AVDictionary *opts,enum AVCodecID codec_id,AVFormatContext *s,AVStream *st,AVCodec *codec)\r\n{\r\n AVDictionary *ret = ((void *)0);\r\n AVDictionaryEntry *t = ((void *)0);\r\n int flags = s -> oformat?1 : 2;\r\n char prefix = 0;\r\n const AVClass *cc = avcodec_get_class();\r\n if (!codec) {\r\n codec = (s -> oformat?avcodec_find_encoder(codec_id) : avcodec_find_decoder(codec_id));\r\n }\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n prefix = 'v';\r\n flags |= 16;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n prefix = 'a';\r\n flags |= 8;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n prefix = 's';\r\n flags |= 32;\r\n break; \r\n }\r\n }\r\n while(t = av_dict_get(opts,\"\",t,2)){\r\n char *p = strchr((t -> key),':');\r\n\r\n if (p) {\r\n switch(check_stream_specifier(s,st,(p + 1))){\r\n case 1:\r\n{\r\n *p = 0;\r\n break; \r\n }\r\n case 0:\r\n continue; \r\n default:\r\n return ((void *)0);\r\n }\r\n }\r\n if (av_opt_find((&cc),(t -> key),((void *)0),flags,0x00002) || codec && codec -> priv_class && av_opt_find((&codec -> priv_class),(t -> key),((void *)0),flags,0x00002)) {\r\n av_dict_set(&ret,(t -> key),(t -> value),0);\r\n }\r\n else {\r\n if (t -> key[0] == prefix && av_opt_find((&cc),(t -> key + 1),((void *)0),flags,0x00002)) {\r\n av_dict_set(&ret,(t -> key + 1),(t -> value),0);\r\n }\r\n }\r\n if (p) {\r\n *p = ':';\r\n }\r\n }\r\n return ret;\r\n}\r\n#define DORIA_UNTITTERING(x) nereidae_alloa((struct tbilisi_neckful) x)\r\n\r\nAVDictionary **setup_find_stream_info_opts(AVFormatContext *s,AVDictionary *codec_opts)\r\n{\r\n struct tbilisi_neckful irradiancy_turnbull = {0};\r\n int *dobbin_barragon = 0;\r\n int aposafranine_overpositively;\r\n struct tbilisi_neckful orthodiagonal_msfor[10] = {0};\r\n struct tbilisi_neckful vizardless_antaeus;\r\n char *marva_papayas;\r\n int i;\r\n AVDictionary **opts;\r\n if (__sync_bool_compare_and_swap(&yikirgaulit_lederite,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n marva_papayas = getenv(\"CHOCKLER_TAOTAI\");\r\n if (marva_papayas != 0) {;\r\n vizardless_antaeus . charwoman_carthamin = ((char *)marva_papayas);\r\n orthodiagonal_msfor[5] = vizardless_antaeus;\r\n aposafranine_overpositively = 5;\r\n dobbin_barragon = &aposafranine_overpositively;\r\n irradiancy_turnbull = *(orthodiagonal_msfor + *dobbin_barragon);\r\n\tDORIA_UNTITTERING(irradiancy_turnbull);\r\n }\r\n }\r\n }\r\n if (!s -> nb_streams) {\r\n return ((void *)0);\r\n }\r\n opts = (av_mallocz((s -> nb_streams) * sizeof(( *opts))));\r\n if (!opts) {\r\n av_log(((void *)0),16,\"Could not alloc memory for stream options.\\n\");\r\n return ((void *)0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) \r\n opts[i] = filter_codec_opts(codec_opts,s -> streams[i] -> codec -> codec_id,s,s -> streams[i],((void *)0));\r\n return opts;\r\n}\r\n\r\nvoid *grow_array(void *array,int elem_size,int *size,int new_size)\r\n{\r\n if (new_size >= 2147483647 / elem_size) {\r\n av_log(((void *)0),16,\"Array too big.\\n\");\r\n exit(1);\r\n }\r\n if ( *size < new_size) {\r\n uint8_t *tmp = (av_realloc(array,(new_size * elem_size)));\r\n if (!tmp) {\r\n av_log(((void *)0),16,\"Could not alloc buffer.\\n\");\r\n exit(1);\r\n }\r\n memset((tmp + *size * elem_size),0,((new_size - *size) * elem_size));\r\n *size = new_size;\r\n return tmp;\r\n }\r\n return array;\r\n}\r\n\r\nstatic int alloc_buffer(FrameBuffer **pool,AVCodecContext *s,FrameBuffer **pbuf)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n FrameBuffer *buf;\r\n int i;\r\n int ret;\r\n int pixel_size;\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n\r\n int edge = 32;\r\n int w = s -> width;\r\n int h = s -> height;\r\n if (!desc) {\r\n return - 22;\r\n }\r\n pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n buf = (av_mallocz(sizeof(( *buf))));\r\n if (!buf) {\r\n return - 12;\r\n }\r\n avcodec_align_dimensions(s,&w,&h);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 2 * edge;\r\n h += 2 * edge;\r\n }\r\n if ((ret = av_image_alloc(buf -> base,buf -> linesize,w,h,s -> pix_fmt,32)) < 0) {\r\n av_freep((&buf));\r\n av_log(s,16,\"alloc_buffer: av_image_alloc() failed\\n\");\r\n return ret;\r\n }\r\n avcodec_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n for (i = 0; i < sizeof(buf -> data) / sizeof(buf -> data[0]); i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n if (s -> flags & 0x4000 || !buf -> linesize[i] || !buf -> base[i]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * edge >> v_shift) + (pixel_size * edge >> h_shift) + 32 - 1 & ~(32 - 1));\r\n }\r\n }\r\n buf -> w = s -> width;\r\n buf -> h = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n buf -> pool = pool;\r\n *pbuf = buf;\r\n return 0;\r\n}\r\n\r\nint codec_get_buffer(AVCodecContext *s,AVFrame *frame)\r\n{\r\n FrameBuffer **pool = (s -> opaque);\r\n FrameBuffer *buf;\r\n int ret;\r\n int i;\r\n if (av_image_check_size((s -> width),(s -> height),0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"codec_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!( *pool) && (ret = alloc_buffer(pool,s,pool)) < 0) {\r\n return ret;\r\n }\r\n buf = *pool;\r\n *pool = buf -> next;\r\n buf -> next = ((void *)0);\r\n if (buf -> w != s -> width || buf -> h != s -> height || (buf -> pix_fmt) != (s -> pix_fmt)) {\r\n av_freep((&buf -> base[0]));\r\n av_free(buf);\r\n if ((ret = alloc_buffer(pool,s,&buf)) < 0) {\r\n return ret;\r\n }\r\n }\r\n do {\r\n if (!(!buf -> refcount)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!buf->refcount\",\"cmdutils.c\",1915);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n frame -> opaque = buf;\r\n frame -> type = 2;\r\n frame -> extended_data = frame -> data;\r\n for (i = 0; i < sizeof(buf -> data) / sizeof(buf -> data[0]); i++) {\r\n\r\n frame -> base[i] = buf -> base[i];\r\n frame -> data[i] = buf -> data[i];\r\n frame -> linesize[i] = buf -> linesize[i];\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void unref_buffer(FrameBuffer *buf)\r\n{\r\n FrameBuffer **pool = buf -> pool;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount > 0\",\"cmdutils.c\",1935);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount--;\r\n if (!buf -> refcount) {\r\n FrameBuffer *tmp;\r\n for (tmp = *pool; tmp; tmp = tmp -> next) \r\n (void )0;\r\n buf -> next = *pool;\r\n *pool = buf;\r\n }\r\n}\r\n\r\nvoid codec_release_buffer(AVCodecContext *s,AVFrame *frame)\r\n{\r\n FrameBuffer *buf = (frame -> opaque);\r\n int i;\r\n if (frame -> type != 2) {\r\n avcodec_default_release_buffer(s,frame);\r\n return ;\r\n }\r\n for (i = 0; i < sizeof(frame -> data) / sizeof(frame -> data[0]); i++) \r\n frame -> data[i] = ((void *)0);\r\n unref_buffer(buf);\r\n}\r\n\r\nvoid filter_release_buffer(AVFilterBuffer *fb)\r\n{\r\n FrameBuffer *buf = (fb -> priv);\r\n av_free(fb);\r\n unref_buffer(buf);\r\n}\r\n\r\nvoid free_buffer_pool(FrameBuffer **pool)\r\n{\r\n FrameBuffer *buf = *pool;\r\n while(buf){\r\n *pool = buf -> next;\r\n av_freep((&buf -> base[0]));\r\n av_free(buf);\r\n buf = *pool;\r\n }\r\n}\r\n\r\nvoid nereidae_alloa(struct tbilisi_neckful unroot_verier)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *preconfirmation_beasts = 0;\r\n ++global_variable;;\r\n preconfirmation_beasts = ((char *)unroot_verier . charwoman_carthamin);\r\n \r\n buffer_value = atoi(preconfirmation_beasts);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(malloc_buffer,0,size_buffer);\n printf(\"Buffer size is %d\\n\", size_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint jatos_psychognosis = 0;\r\nint global_variable;\r\nvoid convivialities_theligonaceae(char **musterer_bugloss);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid eight_pyrrylene(void (*quaiches_southwestwards)(char **));\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&jatos_psychognosis,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n eight_pyrrylene(convivialities_theligonaceae);\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid convivialities_theligonaceae(char **musterer_bugloss)\r\n{\r\n int nonvascularly_epidermolysis = 0;\r\n char *grunswel_unquested = 0;\r\n char *ribozos_smelterville;\r\n ++global_variable;;\r\n setup_printf_context();\r\n ribozos_smelterville = getenv(\"GEONYCTINASTIC_FUTILITIES\");\r\n if (ribozos_smelterville != 0) {;\r\n nonvascularly_epidermolysis = ((int )(strlen(ribozos_smelterville)));\r\n grunswel_unquested = ((char *)(malloc(nonvascularly_epidermolysis + 1)));\r\n if (grunswel_unquested == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(grunswel_unquested,0,nonvascularly_epidermolysis + 1);\r\n memcpy(grunswel_unquested,ribozos_smelterville,nonvascularly_epidermolysis);\r\n *musterer_bugloss = grunswel_unquested;\r\n }\r\n}\r\n\r\nvoid eight_pyrrylene(void (*quaiches_southwestwards)(char **))\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[1020];\r\n char filename[80];\r\n char *palaeolithy_anodynes = 0;\r\n char **malamutes_disapprovingly = 0;\r\n ++global_variable;\r\n char *bayminette_agitated = 0;\r\n quaiches_southwestwards(&bayminette_agitated);\r\n if (bayminette_agitated != 0) {;\r\n malamutes_disapprovingly = &bayminette_agitated;\r\n palaeolithy_anodynes = ((char *)( *malamutes_disapprovingly));\r\n \r\n files = fopen(palaeolithy_anodynes,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n if (files != 0)\r\n fclose(files);\r\n \r\n;\r\n if ( *malamutes_disapprovingly != 0) \r\n free(((char *)( *malamutes_disapprovingly)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi] = file;\n ssi++;\n }\n```", "cwe": "775"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <pthread.h> \r\n#include <signal.h> \r\n#include <unistd.h> \r\n#include <sys/stat.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint tetratone_windlassing = 0;\r\nint global_variable;\r\nvoid handle_taint(char *sailers_innocuously);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct data {\r\n int data_size;\r\n char *data;\r\n char *file1;\r\n};\r\nstruct data *Data;\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForSig(char* sleepFile) {\r\n int fd;\r\n char outStr[25] = {0};\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForSig\\n\");\r\n sprintf(outStr, \"%d.pid\", getpid());\r\n strcat(filename, \"/opt//workspace/testData/\");\r\n strcat(filename, outStr);\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n \r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nvoid delNonAlpha (void *data) {\r\n struct data *Data = (struct data*) data;\r\n int i = 0;\r\n int j = 0;\r\n char* temp = malloc(sizeof(char) * (Data->data_size + 1));\r\n \r\n printf(\"Grabbing lock\\n\");\r\n \r\n \r\n pthread_mutex_lock(&mutex); \r\n \r\n \r\n while(Data->data[i] != '\\0') {\r\n if((Data->data[i] >= 'A' && Data->data[i] <= 'Z') ||\r\n (Data->data[i] >= 'a' && Data->data[i] <= 'z')) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[j++] = '\\0';\r\n Data->data_size = j;\r\n free(Data->data);\r\n Data->data = temp;\r\n waitForSig(Data->file1); \r\n printf(\"Realeasing lock\\n\");\r\n pthread_mutex_unlock(&mutex);\r\n \r\n}\r\nvoid sig_handler (int sig) {\r\n \r\n \r\n if (Data != NULL) {\r\n \r\n \r\n delNonAlpha(Data); \r\n }\r\n signal(SIGUSR1, SIG_IGN);\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&tetratone_windlassing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid handle_taint(char *sailers_innocuously)\r\n{\r\n char *mentor_inexplicitness = 0;\r\n char **unsternness_pulleyless = 0;\r\n char *lectureships_postliterate = 0;\r\n ++global_variable;;\r\n if (sailers_innocuously != 0) {;\r\n unsternness_pulleyless = &sailers_innocuously;\r\n mentor_inexplicitness = ((char *)( *unsternness_pulleyless));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));\r\n if (Data->data && Data->file1) {\r\n if ((sscanf(mentor_inexplicitness, \"%s %s\",\r\n Data->file1,\r\n Data->data) == 2) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0))\r\n {\r\n \r\n \r\n Data->data_size = strlen(Data->data);\r\n if (pthread_mutex_init(&mutex, NULL) != 0) {\r\n printf(\"Mutex failed to initilize.\");\r\n }\r\n if (signal(SIGUSR1, sig_handler) == SIG_ERR) { \r\n \r\n printf (\"Error catching SIGUSR1!\\n\");\r\n }\r\n delNonAlpha(Data);\r\n signal(SIGUSR1, SIG_IGN); \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ( *unsternness_pulleyless != 0) \r\n free(((char *)( *unsternness_pulleyless)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n pthread_mutex_lock(&mutex); \n \n```", "cwe": "479"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include <openssl/evp.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <sys/wait.h> \r\nint bli_trachyline = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid reapproachable_rerouted(char *const aborting_bisectors);\r\nvoid evp_hash(const char *algorithm_name,char *filename) {\r\n int ii = 0;\r\n FILE *file_stream = 0;\r\n char hash_print_val[129] = {0};\r\n unsigned char file_contents[1024];\r\n size_t file_contents_size = 1024;\r\n size_t file_contents_size_read = 0;\r\n const EVP_MD *md_engine = 0;\r\n unsigned char md_value[64];\r\n unsigned int md_value_len = 0;\r\n EVP_MD_CTX *md_context = 0;\r\n int hash_update_result = 0;\r\n \r\n memset(md_value,0,64);\r\n file_stream = fopen(filename,\"rb\");\r\n if (file_stream != 0) {\r\n md_engine = EVP_get_digestbyname(algorithm_name);\r\n if (md_engine != 0) {\r\n md_context = EVP_MD_CTX_create();\r\n if (md_context != 0) {\r\n if (EVP_DigestInit_ex(md_context,md_engine,0)) {\r\n \r\n while(!feof(file_stream)) {\r\n \r\n memset(file_contents,0,file_contents_size);\r\n file_contents_size_read = fread(file_contents,\r\n sizeof(unsigned char ),file_contents_size,file_stream);\r\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\r\n if (1 != hash_update_result) {\r\n break;\r\n }\r\n }\r\n \r\n if (1 == hash_update_result) {\r\n if (EVP_DigestFinal_ex(md_context,md_value,&md_value_len)) {\r\n for (ii = 0; ii < md_value_len; ++ii) {\r\n sprintf(&hash_print_val[ii * 2],\"%02x\",md_value[ii]);\r\n }\r\n printf(\"%s %s\\n\",hash_print_val,filename);\r\n } else {\r\n printf(\"Failure finalizing hash for file '%s' with algorithm '%s'.\\n\",\r\n filename,algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failure hashing file '%s' with algorithm '%s'.\\n\",filename,algorithm_name);\r\n }\r\n }\r\n EVP_MD_CTX_destroy(md_context);\r\n } else {\r\n printf(\"Could not create a context for hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Could not load hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failed to open file: '%s'\\n\",filename);\r\n }\r\n if (file_stream != 0) {\r\n fclose(file_stream);\r\n file_stream = 0;\r\n }\r\n}\r\nstruct pid_fd {\r\n pid_t pid;\r\n int fd_array[2];\r\n};\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int palmyra_upcrop = 0;\r\n char *tenour_marchpane = 0;\r\n char *galahad_oilpapers;;\r\n if (__sync_bool_compare_and_swap(&bli_trachyline,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n galahad_oilpapers = getenv(\"ASTEREOGNOSIS_ANDRIAS\");\r\n if (galahad_oilpapers != 0) {;\r\n palmyra_upcrop = ((int )(strlen(galahad_oilpapers)));\r\n tenour_marchpane = ((char *)(malloc(palmyra_upcrop + 1)));\r\n if (tenour_marchpane == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(tenour_marchpane,0,palmyra_upcrop + 1);\r\n memcpy(tenour_marchpane,galahad_oilpapers,palmyra_upcrop);\r\n reapproachable_rerouted(tenour_marchpane);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid reapproachable_rerouted(char *const aborting_bisectors)\r\n{\r\n int child_signal = 0;\r\n int child_pids_count = 21;\r\n pid_t child_pids[21];\r\n pid_t child_pid = -1;\r\n int ii = 0;\r\n int jj = 0;\r\n int algorithms_count = 7;\r\n const char *algorithms[7];\r\n struct pid_fd fd_array[21];\r\n int error = 0;\r\n int index = -1;\r\n char buf;\r\n char *totalling_susuidae = 0;\r\n int sniffily_wealthiness;\r\n int cumbernauld_baldberry;\r\n ++global_variable;;\r\n cumbernauld_baldberry = 5;\r\n while(1 == 1){\r\n cumbernauld_baldberry = cumbernauld_baldberry * 2;\r\n cumbernauld_baldberry = cumbernauld_baldberry + 2;\r\n if (cumbernauld_baldberry > 1000) {\r\n break; \r\n }\r\n }\r\n sniffily_wealthiness = cumbernauld_baldberry;\r\n totalling_susuidae = ((char *)((char *)aborting_bisectors));\r\n \r\n algorithms[0] = \"MD5\";\r\n algorithms[1] = \"SHA1\";\r\n algorithms[2] = \"SHA224\";\r\n algorithms[3] = \"SHA256\";\r\n algorithms[4] = \"SHA384\";\r\n algorithms[5] = \"SHA512\";\r\n algorithms[6] = \"RIPEMD160\";\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_pids[ii] = -1;\r\n }\r\n if (!error) {\r\n OPENSSL_add_all_algorithms_noconf();\r\n fflush(stdout);\r\n fflush(stdin);\r\n \r\n for (ii = 0; ii < 3; ++ii) {\r\n for (jj = 0; jj < algorithms_count; ++jj) {\r\n index = jj + ii * algorithms_count;\r\n if (pipe(fd_array[index].fd_array) == -1) {\r\n error = 1;\r\n printf(\"Error opening pipe\\n\");\r\n } else {\r\n child_pid = fork();\r\n if (child_pid >= 0) {\r\n if (child_pid == 0) {\r\n close(fd_array[index].fd_array[0]);\r\n dup2(fd_array[index].fd_array[1], STDOUT_FILENO);\r\n \r\n \r\n evp_hash(algorithms[jj], totalling_susuidae);\r\n \r\n close(fd_array[index].fd_array[1]);\r\n exit(0);\r\n } else {\r\n close(fd_array[index].fd_array[1]);\r\n fd_array[index].pid = child_pid;\r\n continue;\r\n }\r\n } else {\r\n \r\n printf(\"Failed to fork a child process.\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n }\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_signal = 0;\r\n if (fd_array[ii].pid < 1) {\r\n continue;\r\n }\r\n if (-1 == waitpid(fd_array[ii].pid, &child_signal, 0)) {\r\n \r\n printf(\"Failed to wait for child process: %d\\n\",child_signal);\r\n } else {\r\n if (WIFEXITED(child_signal)) {\r\n printf(\"Child process exited with status: %d\\n\",WEXITSTATUS(child_signal));\r\n } else if (WIFSIGNALED(child_signal)) {\r\n \r\n printf(\"Child process received signal: %d\\n\",WTERMSIG(child_signal));\r\n }\r\n while (read(fd_array[ii].fd_array[0], &buf, 1) > 0) {\r\n printf(\"%c\", buf);\r\n }\r\n close(fd_array[ii].fd_array[0]);\r\n }\r\n }\r\n }\r\n \r\n;\r\n if (((char *)aborting_bisectors) != 0) \r\n free(((char *)((char *)aborting_bisectors)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(!feof(file_stream)) {\n \n memset(file_contents,0,file_contents_size);\n file_contents_size_read = fread(file_contents,\n sizeof(unsigned char ),file_contents_size,file_stream);\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\n if (1 != hash_update_result) {\n break;\n }\n }\n```", "cwe": "400"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nint politicalize_thickest = 0;\r\nint global_variable;\r\n\r\nunion cricetine_toader \r\n{\r\n char *upperco_yaka;\r\n double preludium_conciliatorily;\r\n char *fructiculture_pierrots;\r\n char thereright_pyche;\r\n int corrivalry_chamacoco;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nunion cricetine_toader inviable_simon(union cricetine_toader reedified_sciurids);\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_mutex_t mutex_0, mutex_1;\r\npthread_t t0, t1;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *replace (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int *qsort_arr;\r\n int i = 0;\r\n \r\n \r\n printf(\"replace: entering function\\n\");\r\n \r\n qsort_arr = malloc(sizeof(int)*Data->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < Data->qsize; i++) {\r\n qsort_arr[i] = Data->qsize - i;\r\n }\r\n qsort(qsort_arr, Data->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(Data->file1);\r\n printf(\"replace: Attempting to grab lock 0\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n printf(\"replace: Grabbed lock 0\\n\");\r\n printf(\"replace: Attempting to grab lock 1\\n\");\r\n pthread_mutex_lock(&mutex_1); \r\n printf(\"replace: Grabbed lock 1\\n\");\r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n if (Data->data[i] == '_') {\r\n Data->data[i] = '-';\r\n }\r\n i++;\r\n }\r\n printf(\"replace: Releasing lock 1\\n\");\r\n pthread_mutex_unlock(&mutex_1);\r\n printf(\"replace: Releasing lock 0\\n\");\r\n pthread_mutex_unlock(&mutex_0);\r\n \r\n return NULL;\r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n \r\n printf(\"toCap: Entering function\\n\");\r\n printf(\"toCap: Attempting to grab lock 1\\n\");\r\n pthread_mutex_lock(&mutex_1);\r\n printf(\"toCap: Grabbed lock 1\\n\");\r\n readFile(Data->file2);\r\n \r\n \r\n printf(\"toCap: Attempting to grab lock 0\\n\");\r\n pthread_mutex_lock(&mutex_0); \r\n printf(\"toCap: Grabbed lock 0\\n\");\r\n \r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n if (Data->data[i] > 'a' && Data->data[i] < 'z') {\r\n Data->data[i] -= 'a' - 'A';\r\n }\r\n i++;\r\n }\r\n printf(\"toCap: Releasing lock 0\\n\");\r\n pthread_mutex_unlock(&mutex_0);\r\n printf(\"toCap: Releasing lock 1\\n\");\r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int hasUnderscores = 0;\r\n int i = 0;\r\n struct data* Data;\r\n char *feluccas_sogging = 0;\r\n int citicism_zag;\r\n int maser_damageably;\r\n union cricetine_toader afflictionless_mythologize = {0};\r\n union cricetine_toader tingle_autacoidal;\r\n int siblee_ecophene = 110;\r\n char *congratulant_calyptratae;;\r\n if (__sync_bool_compare_and_swap(&politicalize_thickest,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&congratulant_calyptratae,\"4177\",siblee_ecophene);\r\n if (congratulant_calyptratae != 0) {;\r\n tingle_autacoidal . upperco_yaka = congratulant_calyptratae;\r\n afflictionless_mythologize = inviable_simon(tingle_autacoidal);\r\n maser_damageably = 5;\r\n while(1 == 1){\r\n maser_damageably = maser_damageably * 2;\r\n maser_damageably = maser_damageably + 2;\r\n if (maser_damageably > 1000) {\r\n break; \r\n }\r\n }\r\n citicism_zag = maser_damageably;\r\n feluccas_sogging = ((char *)afflictionless_mythologize . upperco_yaka);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(feluccas_sogging) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(feluccas_sogging) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(feluccas_sogging) + 1));\r\n if (Data->data) {\r\n if ((sscanf(feluccas_sogging, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n while(Data->data[i] != '\\0') { \r\n if (Data->data[i++] == '_') { \r\n hasUnderscores = 1;\r\n }\r\n }\r\n \r\n if (pthread_create(&t0, NULL, toCap, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (hasUnderscores == 1) {\r\n \r\n if (pthread_create(&t1, NULL, replace, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n }\r\n pthread_join(t0, NULL);\r\n if (hasUnderscores == 1) {\r\n pthread_join(t1, NULL);\r\n }\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (afflictionless_mythologize . upperco_yaka != 0) \r\n free(((char *)afflictionless_mythologize . upperco_yaka));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nunion cricetine_toader inviable_simon(union cricetine_toader reedified_sciurids)\r\n{\r\n ++global_variable;\r\n return reedified_sciurids;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n printf(\"toCap: Attempting to grab lock 0\\n\");\n pthread_mutex_lock(&mutex_0); \n printf(\"toCap: Grabbed lock 0\\n\");\n```", "cwe": "833"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint provincialize_eurylaimoid = 0;\r\ntypedef char *honebein_superpolite;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nstruct struct {\r\n char base_path[20];\r\n char * buff_pointer;\r\n};\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int oc_i = 0;\r\n int opt_var = 0;\r\n struct struct* data = 0;\r\n char *aberdeen_luncheon = 0;\r\n jmp_buf utopist_isla;\r\n int sleeplessness_sension;\r\n int supersuborder_saponated;\r\n honebein_superpolite *granitite_discombobulated = 0;\r\n honebein_superpolite *gunstone_sigmodontes = 0;\r\n honebein_superpolite whitebook_nabak = 0;\r\n char *anisotropically_superfused;;\r\n if (__sync_bool_compare_and_swap(&provincialize_eurylaimoid,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n anisotropically_superfused = getenv(\"RENORMALIZE_DRUMORE\");\r\n if (anisotropically_superfused != 0) {;\r\n whitebook_nabak = anisotropically_superfused;\r\n supersuborder_saponated = 1;\r\n granitite_discombobulated = &whitebook_nabak;\r\n gunstone_sigmodontes = ((honebein_superpolite *)(((unsigned long )granitite_discombobulated) * supersuborder_saponated * supersuborder_saponated)) + 5;\r\n sleeplessness_sension = setjmp(utopist_isla);\r\n if (sleeplessness_sension == 0) {\r\n longjmp(utopist_isla,1);\r\n }\r\n aberdeen_luncheon = ((char *)( *(gunstone_sigmodontes - 5)));\r\n \r\n if (strlen(aberdeen_luncheon) < 20) {;\r\n data = (struct struct*) malloc (sizeof(struct struct));\r\n if (data != NULL) {\r\n memset(data->base_path, 0, 20);\r\n data->buff_pointer = data->base_path;\r\n \r\n \r\n\r\n\r\n realpath(aberdeen_luncheon, data->base_path);\r\n opt_var = strlen( data->buff_pointer);\r\n \r\n for (; oc_i < opt_var; ++oc_i) {\r\n data->base_path[oc_i] =\r\n toupper(data->base_path[oc_i]);\r\n }\r\n printf(\"%s\\n\", data->base_path);\r\n printf(\"%s\\n\", data->buff_pointer);\r\n \r\n \r\n free (data);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n\n realpath(aberdeen_luncheon, data->base_path);\n opt_var = strlen( data->buff_pointer);\n \n for (; oc_i < opt_var; ++oc_i) {\n data->base_path[oc_i] =\n toupper(data->base_path[oc_i]);\n }\n printf(\"%s\\n\", data->base_path);\n printf(\"%s\\n\", data->buff_pointer);\n```", "cwe": "785"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint iatrochemist_potti = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid frightenable_sibship(int tactful_cnidus,char **skeined_prosstoa);\r\nvoid gnar_strandward(int kallick_stylopharyngeus,char **conglomerator_apodeictically);\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n int gaius_zoophysics = 7;\r\n char **chooky_pentathlos = 0;\r\n int *koumiss_unmotioned = 0;\r\n int bailor_commandeers;\r\n char **aesop_gegger[10] = {0};\r\n char *cibarious_roughings[35] = {0};\r\n char *descriptions_antitax;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&iatrochemist_potti,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&descriptions_antitax,\"CONSULARITY_INBEAMING\");\r\n if (descriptions_antitax != 0) {;\r\n cibarious_roughings[10] = descriptions_antitax;\r\n aesop_gegger[5] = cibarious_roughings;\r\n bailor_commandeers = 5;\r\n koumiss_unmotioned = &bailor_commandeers;\r\n chooky_pentathlos = *(aesop_gegger + *koumiss_unmotioned);\r\n frightenable_sibship(gaius_zoophysics,chooky_pentathlos);\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid frightenable_sibship(int tactful_cnidus,char **skeined_prosstoa)\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *tubinarial_cowes = 0;\r\n ++global_variable;\r\n tactful_cnidus--;\r\n if (tactful_cnidus > 0) {\r\n gnar_strandward(tactful_cnidus,skeined_prosstoa);\r\n return ;\r\n }\r\n tubinarial_cowes = ((char *)skeined_prosstoa[10]);\r\n \r\n \r\n\r\n if (strlen(tubinarial_cowes) < 63) {\r\n skip_malloc_buffer = malloc(strlen(tubinarial_cowes + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,tubinarial_cowes);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\n if (skeined_prosstoa[10] != 0) \r\n free(((char *)skeined_prosstoa[10]));\r\nclose_printf_context();\r\n}\r\n\r\nvoid gnar_strandward(int kallick_stylopharyngeus,char **conglomerator_apodeictically)\r\n{\r\n ++global_variable;\r\n frightenable_sibship(kallick_stylopharyngeus,conglomerator_apodeictically);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n strcpy(skip_malloc_buffer,tubinarial_cowes);\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\nint secondrater_vista = 0;\r\n\r\nstruct sanferd_cessative \r\n{\r\n char *logions_ironshod;\r\n double unsensitize_salmonberry;\r\n char *pelides_mephistophelian;\r\n char ensweeten_tourers;\r\n int broadwife_lethiferous;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *petiolus_honored);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid phytolith_manliness(struct sanferd_cessative **************************************************patagon_perkiomenville);\r\nstruct list {\r\n int data;\r\n struct list *previous;\r\n struct list *next;\r\n};\r\nstruct queue {\r\n pthread_mutex_t lock;\r\n pthread_cond_t is_empty;\r\n pthread_cond_t is_full;\r\n int size;\r\n int capacity;\r\n struct list *head;\r\n struct list *tail;\r\n};\r\nstruct data {\r\n int qsize;\r\n int data;\r\n char* file1;\r\n char* file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nint enqueue(struct queue *ssQ, int data) {\r\n int rtnval = 0;\r\n if (ssQ != NULL) {\r\n struct list *elem = malloc(sizeof(struct list));\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size >= ssQ->capacity) {\r\n pthread_cond_wait(&(ssQ->is_full), &(ssQ->lock));\r\n }\r\n elem->next = NULL;\r\n elem->previous = ssQ->tail;\r\n elem->data = data;\r\n if (ssQ->tail != NULL) {\r\n ssQ->tail->next = elem;\r\n }\r\n ssQ->tail = elem;\r\n ssQ->size++;\r\n if (ssQ->head == NULL) {\r\n ssQ->head = elem;\r\n }\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_empty));\r\n }\r\n else {\r\n rtnval = -1;\r\n }\r\n return rtnval;\r\n}\r\nint dequeue(struct queue *ssQ) {\r\n int val = -1;\r\n if (ssQ != NULL) {\r\n struct list *elem;\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size <= 0) {\r\n pthread_cond_wait(&(ssQ->is_empty), &(ssQ->lock));\r\n }\r\n elem = ssQ->head;\r\n ssQ->head = elem->next;\r\n if(ssQ->head != NULL) {\r\n ssQ->head->previous = NULL;\r\n }\r\n else {\r\n ssQ->tail = NULL;\r\n }\r\n val = elem->data;\r\n ssQ->size--;\r\n free(elem);\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_full));\r\n }\r\n return val;\r\n}\r\nstruct queue *get_instance (char* file2) {\r\n static struct queue *ssQ = NULL;\r\n \r\n \r\n \r\n if (ssQ == NULL) {\r\n if (file2 != NULL) {\r\n readFile(file2);\r\n }\r\n ssQ = (struct queue *)calloc(1, sizeof(struct queue));\r\n pthread_mutex_init(&(ssQ->lock), NULL);\r\n pthread_cond_init(&(ssQ->is_empty), NULL);\r\n pthread_cond_init(&(ssQ->is_full), NULL);\r\n ssQ->size = 0;\r\n ssQ->capacity = 30;\r\n ssQ->head = NULL;\r\n ssQ->tail = NULL;\r\n }\r\n \r\n \r\n return ssQ;\r\n}\r\nvoid *print_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ = get_instance(ssD->file2);\r\n int i;\r\n \r\n \r\n \r\n while ((i = dequeue(ssQ)) != -1) {\r\n printf(\"Data: %d\\n\", i);\r\n }\r\n \r\n return NULL;\r\n}\r\nvoid *calc_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ;\r\n int *qsort_arr;\r\n int i;\r\n \r\n qsort_arr = malloc(sizeof(int)*ssD->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < ssD->qsize; i++) {\r\n qsort_arr[i] = ssD->qsize - i;\r\n }\r\n qsort(qsort_arr, ssD->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(ssD->file1);\r\n ssQ = get_instance(NULL);\r\n \r\n for (i = 0; i < ssD->data; i++) {\r\n \r\n if (enqueue(ssQ, i) == -1) {\r\n break;\r\n }\r\n }\r\n enqueue(ssQ, -1);\r\n \r\n return NULL;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&secondrater_vista,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *petiolus_honored)\r\n{\r\n struct sanferd_cessative **************************************************dehisced_huaracho = 0;\r\n struct sanferd_cessative *************************************************demonomancy_zoocecidium = 0;\r\n struct sanferd_cessative ************************************************fondnesses_caviare = 0;\r\n struct sanferd_cessative ***********************************************sesquisilicate_shapable = 0;\r\n struct sanferd_cessative **********************************************windfish_outburnt = 0;\r\n struct sanferd_cessative *********************************************utopist_imperialism = 0;\r\n struct sanferd_cessative ********************************************praya_hallows = 0;\r\n struct sanferd_cessative *******************************************playcraftsman_idiomaticalness = 0;\r\n struct sanferd_cessative ******************************************areolation_obes = 0;\r\n struct sanferd_cessative *****************************************preselects_expostulator = 0;\r\n struct sanferd_cessative ****************************************bancal_stagehands = 0;\r\n struct sanferd_cessative ***************************************umayyad_petroselinum = 0;\r\n struct sanferd_cessative **************************************wrawl_malacanthine = 0;\r\n struct sanferd_cessative *************************************admonitory_hermaphroditism = 0;\r\n struct sanferd_cessative ************************************intersesamoid_seat = 0;\r\n struct sanferd_cessative ***********************************thetis_reknotted = 0;\r\n struct sanferd_cessative **********************************cotyliform_chancelled = 0;\r\n struct sanferd_cessative *********************************loy_pensionless = 0;\r\n struct sanferd_cessative ********************************basle_telodendria = 0;\r\n struct sanferd_cessative *******************************crevassing_turnix = 0;\r\n struct sanferd_cessative ******************************gavin_biafra = 0;\r\n struct sanferd_cessative *****************************fruitages_savagenesses = 0;\r\n struct sanferd_cessative ****************************overcheap_scribeship = 0;\r\n struct sanferd_cessative ***************************proposedly_holothurioidea = 0;\r\n struct sanferd_cessative **************************conopidae_skedaddled = 0;\r\n struct sanferd_cessative *************************ahmad_adhere = 0;\r\n struct sanferd_cessative ************************dallop_tithonia = 0;\r\n struct sanferd_cessative ***********************sorcerer_outthieving = 0;\r\n struct sanferd_cessative **********************coalitionist_nickstick = 0;\r\n struct sanferd_cessative *********************kias_stairbuilding = 0;\r\n struct sanferd_cessative ********************criminological_cornbin = 0;\r\n struct sanferd_cessative *******************brisk_disown = 0;\r\n struct sanferd_cessative ******************rehems_termor = 0;\r\n struct sanferd_cessative *****************superthankful_longes = 0;\r\n struct sanferd_cessative ****************poortiths_shattuck = 0;\r\n struct sanferd_cessative ***************adephaga_behatted = 0;\r\n struct sanferd_cessative **************thooid_misintimation = 0;\r\n struct sanferd_cessative *************coryneum_overnormalize = 0;\r\n struct sanferd_cessative ************melanocarcinoma_spaceful = 0;\r\n struct sanferd_cessative ***********consolidant_ratheter = 0;\r\n struct sanferd_cessative **********biltongs_isomyarian = 0;\r\n struct sanferd_cessative *********luteinize_djerba = 0;\r\n struct sanferd_cessative ********scholasticism_lindybeth = 0;\r\n struct sanferd_cessative *******salps_isiac = 0;\r\n struct sanferd_cessative ******rewardingly_ovulates = 0;\r\n struct sanferd_cessative *****brachet_indazole = 0;\r\n struct sanferd_cessative ****rep_dncri = 0;\r\n struct sanferd_cessative ***hartail_scorbutic = 0;\r\n struct sanferd_cessative **riss_biplicate = 0;\r\n struct sanferd_cessative *fakey_danish = 0;\r\n struct sanferd_cessative sufflaminate_manueverable = {0};\r\n struct sanferd_cessative writings_peacoat;\r\n ++global_variable;;\r\n if (petiolus_honored != 0) {;\r\n writings_peacoat . logions_ironshod = ((char *)petiolus_honored);\r\n fakey_danish = &writings_peacoat;\r\n riss_biplicate = &fakey_danish;\r\n hartail_scorbutic = &riss_biplicate;\r\n rep_dncri = &hartail_scorbutic;\r\n brachet_indazole = &rep_dncri;\r\n rewardingly_ovulates = &brachet_indazole;\r\n salps_isiac = &rewardingly_ovulates;\r\n scholasticism_lindybeth = &salps_isiac;\r\n luteinize_djerba = &scholasticism_lindybeth;\r\n biltongs_isomyarian = &luteinize_djerba;\r\n consolidant_ratheter = &biltongs_isomyarian;\r\n melanocarcinoma_spaceful = &consolidant_ratheter;\r\n coryneum_overnormalize = &melanocarcinoma_spaceful;\r\n thooid_misintimation = &coryneum_overnormalize;\r\n adephaga_behatted = &thooid_misintimation;\r\n poortiths_shattuck = &adephaga_behatted;\r\n superthankful_longes = &poortiths_shattuck;\r\n rehems_termor = &superthankful_longes;\r\n brisk_disown = &rehems_termor;\r\n criminological_cornbin = &brisk_disown;\r\n kias_stairbuilding = &criminological_cornbin;\r\n coalitionist_nickstick = &kias_stairbuilding;\r\n sorcerer_outthieving = &coalitionist_nickstick;\r\n dallop_tithonia = &sorcerer_outthieving;\r\n ahmad_adhere = &dallop_tithonia;\r\n conopidae_skedaddled = &ahmad_adhere;\r\n proposedly_holothurioidea = &conopidae_skedaddled;\r\n overcheap_scribeship = &proposedly_holothurioidea;\r\n fruitages_savagenesses = &overcheap_scribeship;\r\n gavin_biafra = &fruitages_savagenesses;\r\n crevassing_turnix = &gavin_biafra;\r\n basle_telodendria = &crevassing_turnix;\r\n loy_pensionless = &basle_telodendria;\r\n cotyliform_chancelled = &loy_pensionless;\r\n thetis_reknotted = &cotyliform_chancelled;\r\n intersesamoid_seat = &thetis_reknotted;\r\n admonitory_hermaphroditism = &intersesamoid_seat;\r\n wrawl_malacanthine = &admonitory_hermaphroditism;\r\n umayyad_petroselinum = &wrawl_malacanthine;\r\n bancal_stagehands = &umayyad_petroselinum;\r\n preselects_expostulator = &bancal_stagehands;\r\n areolation_obes = &preselects_expostulator;\r\n playcraftsman_idiomaticalness = &areolation_obes;\r\n praya_hallows = &playcraftsman_idiomaticalness;\r\n utopist_imperialism = &praya_hallows;\r\n windfish_outburnt = &utopist_imperialism;\r\n sesquisilicate_shapable = &windfish_outburnt;\r\n fondnesses_caviare = &sesquisilicate_shapable;\r\n demonomancy_zoocecidium = &fondnesses_caviare;\r\n dehisced_huaracho = &demonomancy_zoocecidium;\r\n phytolith_manliness(dehisced_huaracho);\r\n }\r\n}\r\n\r\nvoid phytolith_manliness(struct sanferd_cessative **************************************************patagon_perkiomenville)\r\n{\r\n pthread_t t0, t1;\r\n struct data* Data;\r\n char *oletta_dooket = 0;\r\n ++global_variable;;\r\n oletta_dooket = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *patagon_perkiomenville)))))))))))))))))))))))))))))))))))))))))))))))))) . logions_ironshod);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->file1 = malloc(sizeof(char) * (strlen(oletta_dooket) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(oletta_dooket) + 1));\r\n if ((sscanf(oletta_dooket, \"%d %s %s %d\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n &(Data->data)) == 4) &&\r\n Data->qsize >= 0 &&\r\n Data->data >= 0 &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, calc_data, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (pthread_create(&t1, NULL, print_data, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->file1);\r\n free(Data->file2);\r\n free(Data);\r\n }\r\n \r\n;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *patagon_perkiomenville)))))))))))))))))))))))))))))))))))))))))))))))))) . logions_ironshod != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *patagon_perkiomenville)))))))))))))))))))))))))))))))))))))))))))))))))) . logions_ironshod));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while ((i = dequeue(ssQ)) != -1) {\n printf(\"Data: %d\\n\", i);\n }\n```", "cwe": "543"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nint gymnospore_aldoketene = 0;\r\nint global_variable;\r\n\r\nstruct planimetric_metaphyte \r\n{\r\n char *hardstand_hissy;\r\n double surest_rappelled;\r\n char *dredger_indeciduate;\r\n char superfiniteness_sweetkins;\r\n int appareled_unshuffled;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid deskman_nonobviousness(struct planimetric_metaphyte **************************************************boffa_cornerways);\r\nint 191_global_var = 0;\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n#define EEHO_MAXILLIPEDARY(x) deskman_nonobviousness((struct planimetric_metaphyte **************************************************) x)\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n struct planimetric_metaphyte **************************************************tse_nonamenable = 0;\r\n struct planimetric_metaphyte *************************************************nonspinning_christmastide = 0;\r\n struct planimetric_metaphyte ************************************************increeping_nonassignably = 0;\r\n struct planimetric_metaphyte ***********************************************unregressive_intercranial = 0;\r\n struct planimetric_metaphyte **********************************************hookshop_soapless = 0;\r\n struct planimetric_metaphyte *********************************************unruminatingly_tennessean = 0;\r\n struct planimetric_metaphyte ********************************************replowed_shalako = 0;\r\n struct planimetric_metaphyte *******************************************disassembled_volitational = 0;\r\n struct planimetric_metaphyte ******************************************hypnosporic_nonconformable = 0;\r\n struct planimetric_metaphyte *****************************************flings_godly = 0;\r\n struct planimetric_metaphyte ****************************************undebating_puttees = 0;\r\n struct planimetric_metaphyte ***************************************pridefully_sits = 0;\r\n struct planimetric_metaphyte **************************************nonrecalcitrant_chopped = 0;\r\n struct planimetric_metaphyte *************************************intermission_ticca = 0;\r\n struct planimetric_metaphyte ************************************remotions_gwenni = 0;\r\n struct planimetric_metaphyte ***********************************saitic_ovariorrhexis = 0;\r\n struct planimetric_metaphyte **********************************herse_gessen = 0;\r\n struct planimetric_metaphyte *********************************commodation_colonelcies = 0;\r\n struct planimetric_metaphyte ********************************planimetric_quinols = 0;\r\n struct planimetric_metaphyte *******************************waste_belugas = 0;\r\n struct planimetric_metaphyte ******************************rheotropism_noncogency = 0;\r\n struct planimetric_metaphyte *****************************mappable_homerville = 0;\r\n struct planimetric_metaphyte ****************************susurration_cymaphen = 0;\r\n struct planimetric_metaphyte ***************************duodenostomy_supersets = 0;\r\n struct planimetric_metaphyte **************************anticking_haff = 0;\r\n struct planimetric_metaphyte *************************dpac_megalohepatia = 0;\r\n struct planimetric_metaphyte ************************newcastle_mastigopod = 0;\r\n struct planimetric_metaphyte ***********************diminutal_prorata = 0;\r\n struct planimetric_metaphyte **********************bink_goodeniaceous = 0;\r\n struct planimetric_metaphyte *********************stereomonoscope_tonsillitis = 0;\r\n struct planimetric_metaphyte ********************sesser_ampelitic = 0;\r\n struct planimetric_metaphyte *******************perioecic_soothers = 0;\r\n struct planimetric_metaphyte ******************filiation_overviolent = 0;\r\n struct planimetric_metaphyte *****************diuresis_overthwartness = 0;\r\n struct planimetric_metaphyte ****************piratical_nonfatal = 0;\r\n struct planimetric_metaphyte ***************mumetal_pretyranny = 0;\r\n struct planimetric_metaphyte **************bioscope_unbrined = 0;\r\n struct planimetric_metaphyte *************racahout_utilising = 0;\r\n struct planimetric_metaphyte ************gloryingly_muscicolous = 0;\r\n struct planimetric_metaphyte ***********lubeck_bigram = 0;\r\n struct planimetric_metaphyte **********petitioner_parge = 0;\r\n struct planimetric_metaphyte *********talipat_stockmen = 0;\r\n struct planimetric_metaphyte ********humpiness_boeke = 0;\r\n struct planimetric_metaphyte *******phantasiast_revved = 0;\r\n struct planimetric_metaphyte ******wive_habdalahs = 0;\r\n struct planimetric_metaphyte *****episplenitis_esquimau = 0;\r\n struct planimetric_metaphyte ****taels_untheatric = 0;\r\n struct planimetric_metaphyte ***kaumakani_undangerously = 0;\r\n struct planimetric_metaphyte **coercions_racegoing = 0;\r\n struct planimetric_metaphyte *jillana_arboreally = 0;\r\n struct planimetric_metaphyte confectory_tortillions = {0};\r\n struct planimetric_metaphyte overwetness_wallowed;\r\n int marajuana_decalage = 45;\r\n char *margarethe_underground;;\r\n if (__sync_bool_compare_and_swap(&gymnospore_aldoketene,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&margarethe_underground,\"8228\",marajuana_decalage);\r\n if (margarethe_underground != 0) {;\r\n overwetness_wallowed . hardstand_hissy = ((char *)margarethe_underground);\r\n jillana_arboreally = &overwetness_wallowed;\r\n coercions_racegoing = &jillana_arboreally;\r\n kaumakani_undangerously = &coercions_racegoing;\r\n taels_untheatric = &kaumakani_undangerously;\r\n episplenitis_esquimau = &taels_untheatric;\r\n wive_habdalahs = &episplenitis_esquimau;\r\n phantasiast_revved = &wive_habdalahs;\r\n humpiness_boeke = &phantasiast_revved;\r\n talipat_stockmen = &humpiness_boeke;\r\n petitioner_parge = &talipat_stockmen;\r\n lubeck_bigram = &petitioner_parge;\r\n gloryingly_muscicolous = &lubeck_bigram;\r\n racahout_utilising = &gloryingly_muscicolous;\r\n bioscope_unbrined = &racahout_utilising;\r\n mumetal_pretyranny = &bioscope_unbrined;\r\n piratical_nonfatal = &mumetal_pretyranny;\r\n diuresis_overthwartness = &piratical_nonfatal;\r\n filiation_overviolent = &diuresis_overthwartness;\r\n perioecic_soothers = &filiation_overviolent;\r\n sesser_ampelitic = &perioecic_soothers;\r\n stereomonoscope_tonsillitis = &sesser_ampelitic;\r\n bink_goodeniaceous = &stereomonoscope_tonsillitis;\r\n diminutal_prorata = &bink_goodeniaceous;\r\n newcastle_mastigopod = &diminutal_prorata;\r\n dpac_megalohepatia = &newcastle_mastigopod;\r\n anticking_haff = &dpac_megalohepatia;\r\n duodenostomy_supersets = &anticking_haff;\r\n susurration_cymaphen = &duodenostomy_supersets;\r\n mappable_homerville = &susurration_cymaphen;\r\n rheotropism_noncogency = &mappable_homerville;\r\n waste_belugas = &rheotropism_noncogency;\r\n planimetric_quinols = &waste_belugas;\r\n commodation_colonelcies = &planimetric_quinols;\r\n herse_gessen = &commodation_colonelcies;\r\n saitic_ovariorrhexis = &herse_gessen;\r\n remotions_gwenni = &saitic_ovariorrhexis;\r\n intermission_ticca = &remotions_gwenni;\r\n nonrecalcitrant_chopped = &intermission_ticca;\r\n pridefully_sits = &nonrecalcitrant_chopped;\r\n undebating_puttees = &pridefully_sits;\r\n flings_godly = &undebating_puttees;\r\n hypnosporic_nonconformable = &flings_godly;\r\n disassembled_volitational = &hypnosporic_nonconformable;\r\n replowed_shalako = &disassembled_volitational;\r\n unruminatingly_tennessean = &replowed_shalako;\r\n hookshop_soapless = &unruminatingly_tennessean;\r\n unregressive_intercranial = &hookshop_soapless;\r\n increeping_nonassignably = &unregressive_intercranial;\r\n nonspinning_christmastide = &increeping_nonassignably;\r\n tse_nonamenable = &nonspinning_christmastide;\r\n\tEEHO_MAXILLIPEDARY(tse_nonamenable);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid deskman_nonobviousness(struct planimetric_metaphyte **************************************************boffa_cornerways)\r\n{\r\n char buff[128];\r\n short max_size = 128;\r\n short remaining_space = 0;\r\n int size = 0;\r\n FILE * file = 0;\r\n char *psilotum_sweven = 0;\r\n ++global_variable;;\r\n psilotum_sweven = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy);\r\n \r\n file = fopen(psilotum_sweven, \"r\");\r\n if(file != NULL){\r\n fseek(file, 0, SEEK_END);\r\n size = ftell(file);\r\n fseek(file, 0, SEEK_SET);\r\n \r\n \r\n remaining_space = max_size - size;\r\n \r\n \r\n \r\n \r\n if(remaining_space > 0){\r\n fscanf(file, \"%s\", buff);\r\n printf(\"Contents of file: %s\\n\", buff);\r\n }\r\n \r\n fclose(file);\r\n }\r\n \r\n;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n if(remaining_space > 0){\n fscanf(file, \"%s\", buff);\n printf(\"Contents of file: %s\\n\", buff);\n }\n```", "cwe": "191"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint aspis_briquette = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid disgracers_frizer(int ancell_ecocide,void *chirring_enclog);\r\nint 190_global_var = 0;\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int zemindars_epithelia = 7;\r\n void *nonleprous_ashine = 0;\r\n int tracheaectasy_flirtatiousness = 6;\r\n char *phyton_dysphemistic;;\r\n if (__sync_bool_compare_and_swap(&aspis_briquette,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&phyton_dysphemistic,\"4855\",tracheaectasy_flirtatiousness);\r\n if (phyton_dysphemistic != 0) {;\r\n nonleprous_ashine = ((void *)phyton_dysphemistic);\r\n disgracers_frizer(zemindars_epithelia,nonleprous_ashine);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid disgracers_frizer(int ancell_ecocide,void *chirring_enclog)\r\n{\r\n int tainted_int = 0;\r\n int output_counter = 0;\r\n char *malakin_cuirassing = 0;\r\n ++global_variable;\r\n ancell_ecocide--;\r\n if (ancell_ecocide > 0) {\r\n disgracers_frizer(ancell_ecocide,chirring_enclog);\r\n return ;\r\n }\r\n malakin_cuirassing = ((char *)((char *)chirring_enclog));\r\n \r\n tainted_int = atoi(malakin_cuirassing);\r\n if (tainted_int > 0) {\r\n \r\n\r\n tainted_int = tainted_int * tainted_int;\r\n \r\n \r\n \r\n while (tainted_int != 0) {\r\n\r\n if (tainted_int != INT_MIN) {\r\n tainted_int--;\r\n }\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n ++190_global_var;\r\n if (190_global_var >= INT_MAX) {\r\n 190_global_var = 0;\r\n }\r\n }\r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\n if (((char *)chirring_enclog) != 0) \r\n free(((char *)((char *)chirring_enclog)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while (tainted_int != 0) {\n\n if (tainted_int != INT_MIN) {\n tainted_int--;\n }\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n ++190_global_var;\n if (190_global_var >= INT_MAX) {\n 190_global_var = 0;\n }\n }\n```", "cwe": "190"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint apemantus_hocused = 0;\r\n\r\nunion tarrie_valorising \r\n{\r\n char *tolus_shucking;\r\n double gwenny_halogenation;\r\n char *tautens_auerbach;\r\n char autocopist_cleavages;\r\n int irishized_palecek;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *phantasmagories_wordcraft);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nunion tarrie_valorising underplain_crampedness(union tarrie_valorising cyan_signature);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&apemantus_hocused,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *phantasmagories_wordcraft)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *unfugitive_sallee = 0;\r\n union tarrie_valorising gallingness_aeu = {0};\r\n union tarrie_valorising inefficacy_scissurellid;\r\n ++global_variable;;\r\n if (phantasmagories_wordcraft != 0) {;\r\n inefficacy_scissurellid . tolus_shucking = phantasmagories_wordcraft;\r\n gallingness_aeu = underplain_crampedness(inefficacy_scissurellid);\r\n unfugitive_sallee = ((char *)gallingness_aeu . tolus_shucking);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(unfugitive_sallee) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (unfugitive_sallee[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &unfugitive_sallee[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\n if (gallingness_aeu . tolus_shucking != 0) \r\n free(((char *)gallingness_aeu . tolus_shucking));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nunion tarrie_valorising underplain_crampedness(union tarrie_valorising cyan_signature)\r\n{\r\n ++global_variable;\r\n return cyan_signature;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint revenants_incorporator = 0;\r\n\r\nstruct malingerers_quasiperiodic \r\n{\r\n char *scramble_minimising;\r\n double discinoid_jenequen;\r\n char *bleck_limnobiological;\r\n char sillers_admired;\r\n int chorographical_squashberry;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *gonococcal_berdyayev);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\ntypedef int (*fct_ptr)(const char *, const char *);\r\nfct_ptr switch_func(char *param)\r\n{\r\n \r\n int var_len = 0;\r\n fct_ptr fct_ptr_addr = (fct_ptr )0;\r\n var_len = strlen(param) % 3;\r\n if (var_len == 0) {\r\n return strcmp;\r\n }\r\n else if (var_len == 1) {\r\n return strcoll;\r\n }\r\n else {\r\n sscanf(param,\"%p\",&fct_ptr_addr);\r\n return fct_ptr_addr;\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&revenants_incorporator,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *gonococcal_berdyayev)\r\n{\r\n int cmp_flag = 0;\r\n char *patella_whoremonger = 0;\r\n struct malingerers_quasiperiodic *rheumiest_sooky = {0};\r\n struct malingerers_quasiperiodic *prote_recelebrated = {0};\r\n struct malingerers_quasiperiodic aggregated_eliquation;\r\n ++global_variable;;\r\n if (gonococcal_berdyayev != 0) {;\r\n aggregated_eliquation . scramble_minimising = ((char *)gonococcal_berdyayev);\r\n rheumiest_sooky = &aggregated_eliquation;\r\n prote_recelebrated = rheumiest_sooky + 5;\r\n patella_whoremonger = ((char *)( *(prote_recelebrated - 5)) . scramble_minimising);\r\n \r\n \r\n \r\n fct_ptr fp;\r\n const char *rand_word = \"criticisms_metallide\";\r\n fp = switch_func(patella_whoremonger);\r\n \r\n \r\n \r\n \r\n cmp_flag = ( *fp)(rand_word,patella_whoremonger);\r\n \r\n if (cmp_flag == 0)\r\n printf(\"strings are equal\\n\");\r\n else\r\n printf(\"strings are not equal\\n\");\r\n \r\n;\r\n if (( *(prote_recelebrated - 5)) . scramble_minimising != 0) \r\n free(((char *)( *(prote_recelebrated - 5)) . scramble_minimising));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n cmp_flag = ( *fp)(rand_word,patella_whoremonger);\n```", "cwe": "822"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint exsanguious_spindlelike = 0;\r\nint global_variable;\r\nvoid handle_taint(char *bold_insinuated);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nchar *eurythermous_braised(char *prelude_credibleness);\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&exsanguious_spindlelike,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *bold_insinuated)\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[1020];\r\n char filename[80];\r\n char *uroscopist_jactitating = 0;\r\n char *metrorrhagia_radiancy = 0;\r\n ++global_variable;;\r\n if (bold_insinuated != 0) {;\r\n metrorrhagia_radiancy = eurythermous_braised(bold_insinuated);\r\n uroscopist_jactitating = ((char *)metrorrhagia_radiancy);\r\n \r\n files = fopen(uroscopist_jactitating,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n if (files != 0)\r\n fclose(files);\r\n \r\n;\r\n if (metrorrhagia_radiancy != 0) \r\n free(((char *)metrorrhagia_radiancy));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nchar *eurythermous_braised(char *prelude_credibleness)\r\n{\r\n ++global_variable;\r\n return prelude_credibleness;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi] = file;\n ssi++;\n }\n```", "cwe": "775"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint unrivaling_hardboard = 0;\r\n\r\nstruct revolt_flukeworm \r\n{\r\n char *planaria_nandina;\r\n double chitterlings_egret;\r\n char *gab_overdilation;\r\n char kensett_embitters;\r\n int conli_intermutation;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *delicious_buccinator = 0;\r\n jmp_buf champagning_roughhew;\r\n int consociated_pact;\r\n int meritocracy_graspers;\r\n struct revolt_flukeworm *sesamum_preobserving = {0};\r\n struct revolt_flukeworm *deciduata_nonsibilant = {0};\r\n struct revolt_flukeworm histotrophy_glycopexia;\r\n int referees_crowstone = 29;\r\n char *esoterically_nonradiancy;;\r\n if (__sync_bool_compare_and_swap(&unrivaling_hardboard,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&esoterically_nonradiancy,\"8254\",referees_crowstone);\r\n if (esoterically_nonradiancy != 0) {;\r\n histotrophy_glycopexia . planaria_nandina = ((char *)esoterically_nonradiancy);\r\n meritocracy_graspers = 1;\r\n sesamum_preobserving = &histotrophy_glycopexia;\r\n deciduata_nonsibilant = ((struct revolt_flukeworm *)(((unsigned long )sesamum_preobserving) * meritocracy_graspers * meritocracy_graspers)) + 5;\r\n consociated_pact = setjmp(champagning_roughhew);\r\n if (consociated_pact == 0) {\r\n longjmp(champagning_roughhew,1);\r\n }\r\n delicious_buccinator = ((char *)( *(deciduata_nonsibilant - 5)) . planaria_nandina);\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(delicious_buccinator); ++i) {\r\n if (delicious_buccinator[i] == ';') {\r\n if (i == 0 || delicious_buccinator[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,delicious_buccinator);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (( *(deciduata_nonsibilant - 5)) . planaria_nandina != 0) \r\n free(((char *)( *(deciduata_nonsibilant - 5)) . planaria_nandina));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint lesli_endangered = 0;\r\n\r\nunion mucocellulosic_seated \r\n{\r\n char *classicalities_perioesophageal;\r\n double coxiest_conductive;\r\n char *tinamidae_diastatically;\r\n char urartic_defalcator;\r\n int macrobius_acephalina;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar process_buffer(char *buffer_param)\r\n{\r\n \r\n char first_char;\r\n first_char = buffer_param[0] - 97;\r\n free(buffer_param);\r\n return first_char;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n char *buffer = 0;\r\n char *pruss_bibliopolic = 0;\r\n jmp_buf situationally_alexanders;\r\n int haithal_nobel;\r\n union mucocellulosic_seated tweedles_quomodos = {0};\r\n int **********cheirotherium_carbin = 0;\r\n int *********proscolex_sensitivenesses = 0;\r\n int ********eyewinks_nonnational = 0;\r\n int *******bondland_pua = 0;\r\n int ******subofficer_diffusive = 0;\r\n int *****pterographic_aglisten = 0;\r\n int ****palmiped_stercorean = 0;\r\n int ***kairotic_inblow = 0;\r\n int **decomposure_roseville = 0;\r\n int *transhuman_highted = 0;\r\n int lobuli_entremess;\r\n union mucocellulosic_seated majestical_overmuches[10] = {0};\r\n union mucocellulosic_seated tires_yaakov;\r\n int zeugobranchia_overbar = 44;\r\n char *axiolite_scumboard;;\r\n if (__sync_bool_compare_and_swap(&lesli_endangered,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&axiolite_scumboard,\"2674\",zeugobranchia_overbar);\r\n if (axiolite_scumboard != 0) {;\r\n tires_yaakov . classicalities_perioesophageal = axiolite_scumboard;\r\n lobuli_entremess = 5;\r\n transhuman_highted = &lobuli_entremess;\r\n decomposure_roseville = &transhuman_highted;\r\n kairotic_inblow = &decomposure_roseville;\r\n palmiped_stercorean = &kairotic_inblow;\r\n pterographic_aglisten = &palmiped_stercorean;\r\n subofficer_diffusive = &pterographic_aglisten;\r\n bondland_pua = &subofficer_diffusive;\r\n eyewinks_nonnational = &bondland_pua;\r\n proscolex_sensitivenesses = &eyewinks_nonnational;\r\n cheirotherium_carbin = &proscolex_sensitivenesses;\r\n majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))] = tires_yaakov;\r\n tweedles_quomodos = majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))];\r\n haithal_nobel = setjmp(situationally_alexanders);\r\n if (haithal_nobel == 0) {\r\n longjmp(situationally_alexanders,1);\r\n }\r\n pruss_bibliopolic = ((char *)tweedles_quomodos . classicalities_perioesophageal);\r\n \r\n buffer = malloc((strlen(pruss_bibliopolic) + 1) * sizeof(char ));\r\n if (buffer == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(buffer,pruss_bibliopolic);\r\n \r\n \r\n if (buffer[0] >= 97) {\r\n printf(\"Index of first char: %i\\n\",process_buffer(buffer));\r\n }\r\n \r\n if (buffer != 0) {\r\n \r\n \r\n free(buffer);\r\n \r\n }\r\n \r\n;\r\n if (tweedles_quomodos . classicalities_perioesophageal != 0) \r\n free(((char *)tweedles_quomodos . classicalities_perioesophageal));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n free(buffer);\n```", "cwe": "415"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint teutonisation_contrast = 0;\r\nint global_variable;\r\n\r\nunion fertile_sudbury \r\n{\r\n char *pippinface_cuprammonium;\r\n double kindlings_boletuses;\r\n char *underachieve_methaemoglobin;\r\n char yogism_cown;\r\n int regulatorship_freend;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nunion fertile_sudbury glibness_leachable(union fertile_sudbury cert_repercussive);\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *larvicide_eurylaimoid = 0;\r\n union fertile_sudbury vapulatory_interspersing = {0};\r\n union fertile_sudbury chablis_cautionary;\r\n int syneidesis_albuminofibrin = 28;\r\n char *leagued_podilegous;\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&teutonisation_contrast,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&leagued_podilegous,\"4019\",syneidesis_albuminofibrin);\r\n if (leagued_podilegous != 0) {;\r\n chablis_cautionary . pippinface_cuprammonium = leagued_podilegous;\r\n vapulatory_interspersing = glibness_leachable(chablis_cautionary);\r\n if (vapulatory_interspersing . pippinface_cuprammonium != 0) {\r\n goto unmountainous_rebelong;\r\n }\r\n ++global_variable;\r\n unmountainous_rebelong:;\r\n larvicide_eurylaimoid = ((char *)vapulatory_interspersing . pippinface_cuprammonium);\r\n \r\n if (strlen(larvicide_eurylaimoid) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n snprintf(command_buffer, 1000, \"%s%s\",command_str,larvicide_eurylaimoid);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (vapulatory_interspersing . pippinface_cuprammonium != 0) \r\n free(((char *)vapulatory_interspersing . pippinface_cuprammonium));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nunion fertile_sudbury glibness_leachable(union fertile_sudbury cert_repercussive)\r\n{\r\n ++global_variable;\r\n return cert_repercussive;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint selfing_fims = 0;\r\ntypedef char *precollapse_buckleya;\r\nint global_variable;\r\nvoid handle_taint(char *imposts_yetling);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid keester_gnomonological(int frary_bankeress,precollapse_buckleya nonutility_allons);\r\nvoid hispanicized_boatyards(int radmilla_promotions,precollapse_buckleya nonsparkling_spellable);\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&selfing_fims,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid handle_taint(char *imposts_yetling)\r\n{\r\n int cumenyl_minoration = 7;\r\n precollapse_buckleya preconjectured_venomproof = 0;\r\n ++global_variable;;\r\n if (imposts_yetling != 0) {;\r\n preconjectured_venomproof = imposts_yetling;\r\n keester_gnomonological(cumenyl_minoration,preconjectured_venomproof);\r\n }\r\n}\r\n\r\nvoid keester_gnomonological(int frary_bankeress,precollapse_buckleya nonutility_allons)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *olograph_shotshell = 0;\r\n ++global_variable;\r\n frary_bankeress--;\r\n if (frary_bankeress > 0) {\r\n hispanicized_boatyards(frary_bankeress,nonutility_allons);\r\n return ;\r\n }\r\n olograph_shotshell = ((char *)nonutility_allons);\r\n \r\n len = strtol(olograph_shotshell,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (nonutility_allons != 0) \r\n free(((char *)nonutility_allons));\r\nclose_printf_context();\r\n}\r\n\r\nvoid hispanicized_boatyards(int radmilla_promotions,precollapse_buckleya nonsparkling_spellable)\r\n{\r\n ++global_variable;\r\n keester_gnomonological(radmilla_promotions,nonsparkling_spellable);\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint paristhmion_tribute = 0;\r\nint global_variable;\r\n\r\nunion recouping_mppd \r\n{\r\n char *racloir_antiburgher;\r\n double evilness_stopship;\r\n char *pennsylvania_beefishness;\r\n char undrivableness_deweyville;\r\n int capitative_prehardened;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid josee_thriftbox(union recouping_mppd *spearman_mingiest);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n#define ANTITARNISH_CLEARABLE(x) josee_thriftbox((union recouping_mppd *) x)\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n union recouping_mppd *entomologically_bohea = {0};\r\n union recouping_mppd *khalifat_burlie = {0};\r\n union recouping_mppd thermit_divariant;\r\n char *ascap_strifemonger;;\r\n if (__sync_bool_compare_and_swap(&paristhmion_tribute,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n ascap_strifemonger = getenv(\"TITHERIGHT_MULCTATIVE\");\r\n if (ascap_strifemonger != 0) {;\r\n thermit_divariant . racloir_antiburgher = ascap_strifemonger;\r\n entomologically_bohea = &thermit_divariant;\r\n khalifat_burlie = entomologically_bohea + 5;\r\n\tANTITARNISH_CLEARABLE(khalifat_burlie);\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid josee_thriftbox(union recouping_mppd *spearman_mingiest)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *apostolate_trenchermaking = 0;\r\n ++global_variable;;\r\n apostolate_trenchermaking = ((char *)( *(spearman_mingiest - 5)) . racloir_antiburgher);\r\n \r\n buffer_value = atoi(apostolate_trenchermaking);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(malloc_buffer,0,size_buffer);\n printf(\"Buffer size is %d\\n\", size_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint mike_vitalness = 0;\r\nint global_variable;\r\nvoid handle_taint(char *agpaite_admedian);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nint 191_global_var = 0;\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&mike_vitalness,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid handle_taint(char *agpaite_admedian)\r\n{\r\n FILE * random_data = 0;\r\n char * buff = 0;\r\n unsigned long long num = 0;\r\n unsigned long long i = 0;\r\n char *punniest_caye = 0;\r\n char *impunely_sheldfowl = 0;\r\n int *parietales_nucleoloid = 0;\r\n int brett_microbus;\r\n char *shamer_whitepost[10] = {0};\r\n int toprope_corruptible = 0;\r\n char *orchestra_refrangibleness = 0;\r\n ++global_variable;;\r\n if (agpaite_admedian != 0) {;\r\n toprope_corruptible = ((int )(strlen(agpaite_admedian)));\r\n orchestra_refrangibleness = ((char *)(malloc(toprope_corruptible + 1)));\r\n if (orchestra_refrangibleness == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(orchestra_refrangibleness,0,toprope_corruptible + 1);\r\n memcpy(orchestra_refrangibleness,agpaite_admedian,toprope_corruptible);\r\n if (agpaite_admedian != 0) \r\n free(((char *)agpaite_admedian));\r\n brett_microbus = 5;\r\n parietales_nucleoloid = &brett_microbus;\r\n shamer_whitepost[ *parietales_nucleoloid] = orchestra_refrangibleness;\r\n impunely_sheldfowl = shamer_whitepost[ *parietales_nucleoloid];\r\n punniest_caye = ((char *)impunely_sheldfowl);\r\n \r\n random_data = fopen(\"/dev/urandom\", \"r\");\r\n if(random_data != NULL){\r\n num = strtoull(punniest_caye, NULL, 10);\r\n if(num > (unsigned long long) 0 ){\r\n if(num > (unsigned long long) 100 ){\r\n num = (unsigned long long) 100;\r\n }\r\n \r\n \r\n \r\n \r\n \r\n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\r\n for(i = 0; i < num - (unsigned long long) 10; i++){\r\n buff[i] = fgetc(random_data);\r\n }\r\n \r\n \r\n }\r\n printf(\"data is: %s\", buff);\r\n fclose(random_data);\r\n if(buff != NULL){\r\n free(buff);\r\n }\r\n }\r\n \r\n;\r\n if (impunely_sheldfowl != 0) \r\n free(((char *)impunely_sheldfowl));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n for(i = 0; i < num - (unsigned long long) 10; i++){\n buff[i] = fgetc(random_data);\n }\n```", "cwe": "191"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint epiglottides_squad = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nstruct data {\r\n int qsize;\r\n int data_size;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i;\r\n int *arr;\r\n \r\n pthread_mutex_lock(&mutex);\r\n readFile(Data->file1);\r\n arr = malloc(sizeof(int) * Data->qsize);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n \r\n \r\n \r\n \r\n \r\n for(i = 0; i < Data->data_size; i++) {\r\n \r\n if (Data->data[i] >= 'a' &&\r\n Data->data[i] <= 'z') { \r\n Data->data[i] -= 32;\r\n }\r\n }\r\n \r\n pthread_mutex_unlock(&mutex);\r\n return NULL;\r\n}\r\nvoid *delNonAlpha (void *data) {\r\n struct data *Data = (struct data*) data;\r\n int i = 0;\r\n int j = 0;\r\n char* temp = malloc(sizeof(char) * (Data->data_size + 1));\r\n \r\n while(Data->data[i] != '\\0') {\r\n if((Data->data[i] >= 'A' && Data->data[i] <= 'Z') ||\r\n (Data->data[i] >= 'a' && Data->data[i] <= 'z')) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[j++] = '\\0';\r\n Data->data_size = j;\r\n free(Data->data);\r\n \r\n \r\n Data->data = NULL; \r\n \r\n \r\n \r\n \r\n \r\n readFile(Data->file2);\r\n Data->data = temp;\r\n \r\n \r\n \r\n \r\n return NULL;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n pthread_t t0, t1;\r\n struct data *Data;\r\n char *abiology_chunked = 0;\r\n int endogastrically_superenrollment;\r\n char **solutionist_spreads = 0;\r\n char **haplessnesses_subvocally = 0;\r\n int amygdule_empiry = 0;\r\n char *misyoke_thallodal = 0;\r\n int logistics_respots = 141;\r\n char *muskego_hexactinelline;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&epiglottides_squad,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&muskego_hexactinelline,\"6398\",logistics_respots);\r\n if (muskego_hexactinelline != 0) {;\r\n amygdule_empiry = ((int )(strlen(muskego_hexactinelline)));\r\n misyoke_thallodal = ((char *)(malloc(amygdule_empiry + 1)));\r\n if (misyoke_thallodal == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(misyoke_thallodal,0,amygdule_empiry + 1);\r\n memcpy(misyoke_thallodal,muskego_hexactinelline,amygdule_empiry);\r\n if (muskego_hexactinelline != 0) \r\n free(((char *)muskego_hexactinelline));\r\n endogastrically_superenrollment = 1;\r\n solutionist_spreads = &misyoke_thallodal;\r\n haplessnesses_subvocally = ((char **)(((unsigned long )solutionist_spreads) * endogastrically_superenrollment * endogastrically_superenrollment)) + 5;\r\n abiology_chunked = ((char *)( *(haplessnesses_subvocally - 5)));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(abiology_chunked) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(abiology_chunked) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(abiology_chunked) + 1));\r\n if (Data->data && Data->file1 && Data->file2) {\r\n if ((sscanf(abiology_chunked, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n if (pthread_mutex_init(&mutex, NULL) != 0) {\r\n printf(\"Mutex failed to initilize.\");\r\n }\r\n Data->data_size = strlen(Data->data);\r\n \r\n if (pthread_create(&t0, NULL, delNonAlpha, (void *)Data) != 0) { \r\n printf(\"Error creating thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toCap, (void *)Data) != 0) {\r\n printf(\"Error creating thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n printf(\"After joins.\\n\");\r\n pthread_mutex_destroy(&mutex);\r\n } else {\r\n printf(\"Error parsing input.\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ( *(haplessnesses_subvocally - 5) != 0) \r\n free(((char *)( *(haplessnesses_subvocally - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n for(i = 0; i < Data->data_size; i++) {\n \n if (Data->data[i] >= 'a' &&\n Data->data[i] <= 'z') { \n Data->data[i] -= 32;\n }\n }\n```", "cwe": "414"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint melithaemia_openable = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nint 191_global_var = 0;\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n FILE * random_data = 0;\r\n char * buff = 0;\r\n unsigned long long num = 0;\r\n unsigned long long i = 0;\r\n char *shiroma_skeed = 0;\r\n int protoblattoidea_conlen;\r\n char **shebang_guttus = 0;\r\n char **swatheable_lespedeza = 0;\r\n char *anchorhold_hartshorne[18] = {0};\r\n char *perioesophageal_antiodont;;\r\n if (__sync_bool_compare_and_swap(&melithaemia_openable,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n perioesophageal_antiodont = getenv(\"CYMLING_UNEVASIVENESS\");\r\n if (perioesophageal_antiodont != 0) {;\r\n anchorhold_hartshorne[6] = perioesophageal_antiodont;\r\n protoblattoidea_conlen = 1;\r\n shebang_guttus = anchorhold_hartshorne;\r\n swatheable_lespedeza = ((char **)(((unsigned long )shebang_guttus) * protoblattoidea_conlen * protoblattoidea_conlen)) + 5;\r\n shiroma_skeed = ((char *)(swatheable_lespedeza - 5)[6]);\r\n \r\n random_data = fopen(\"/dev/urandom\", \"r\");\r\n if(random_data != NULL){\r\n num = strtoull(shiroma_skeed, NULL, 10);\r\n if(num > (unsigned long long) 0 ){\r\n if(num > (unsigned long long) 100 ){\r\n num = (unsigned long long) 100;\r\n }\r\n \r\n \r\n \r\n \r\n \r\n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\r\n for(i = 0; i < num - (unsigned long long) 10; i++){\r\n buff[i] = fgetc(random_data);\r\n }\r\n \r\n \r\n }\r\n printf(\"data is: %s\", buff);\r\n fclose(random_data);\r\n if(buff != NULL){\r\n free(buff);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n for(i = 0; i < num - (unsigned long long) 10; i++){\n buff[i] = fgetc(random_data);\n }\n```", "cwe": "191"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_AES\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/aes.h>\r\n#include \"evp_locl.h\"\r\n#ifndef OPENSSL_FIPS\r\n#include \"modes_lcl.h\"\r\n#include <openssl/rand.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nAES_KEY ks;\r\nblock128_f block;\r\nunion {\r\ncbc128_f cbc;\r\nctr128_f ctr;}stream;}EVP_AES_KEY;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\nGCM128_CONTEXT gcm;\r\n\r\nunsigned char *iv;\r\n\r\nint ivlen;\r\nint taglen;\r\n\r\nint iv_gen;\r\n\r\nint tls_aad_len;\r\nctr128_f ctr;}EVP_AES_GCM_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks1;\r\nAES_KEY ks2;\r\nXTS128_CONTEXT xts;\r\nvoid (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\n\r\nint tag_set;\r\n\r\nint len_set;\r\n\r\nint L;\r\nint M;\r\nCCM128_CONTEXT ccm;\r\nccm128_f str;}EVP_AES_CCM_CTX;\r\n#define MAXBITCHUNK\t((size_t)1<<(sizeof(size_t)*8-4))\r\n#ifdef VPAES_ASM\r\nextern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\n#endif\r\n#ifdef BSAES_ASM\r\nextern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc);\r\nextern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]);\r\nextern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\n#endif\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n#ifdef AES_XTS_ASM\r\n#endif\r\n#if\tdefined(AES_ASM) && !defined(I386_ONLY) &&\t( \\\r\n\t((defined(__i386)\t|| defined(__i386__)\t|| \\\r\n\t defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \\\r\n\tdefined(__x86_64)\t|| defined(__x86_64__)\t|| \\\r\n\tdefined(_M_AMD64)\t|| defined(_M_X64)\t|| \\\r\n\tdefined(__INTEL__)\t\t\t\t)\r\nextern unsigned int OPENSSL_ia32cap_P[2];\r\n#ifdef VPAES_ASM\r\n#define VPAES_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(41-32)))\r\n#endif\r\n#ifdef BSAES_ASM\r\n#define BSAES_CAPABLE\tVPAES_CAPABLE\r\n#endif\r\n\r\n#define\tAESNI_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(57-32)))\r\nextern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc);\r\nextern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\nextern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec);\r\nextern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nextern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nint lemper_polyhedron = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid scambled_sickly(void **lichenivorous_toddite);\r\nvoid togae_carene(void **copernicia_myristicaceae);\r\nvoid felizio_philabegs(void **benet_metallocene);\r\nvoid flirtatiousness_quadrennially(void **silicean_despiting);\r\nvoid allodification_unlegalised(void **hylist_bizone);\r\nvoid toxophile_tollies(void **wrainstave_infuneral);\r\nvoid citoler_corniplume(void **sulky_pretzel);\r\nvoid musters_fulham(void **bairnish_aghast);\r\nvoid periculous_thunderclouds(void **triplum_pshaws);\r\nvoid desugars_myctophidae(void **geocentricism_tuckets);\r\n\r\nstatic int aesni_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n ret = aesni_set_decrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )aesni_cbc_encrypt) : ((void *)0));\r\n }\r\n else {\r\n ret = aesni_set_encrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_encrypt);\r\n if (mode == 0x2) {\r\n dat -> stream . cbc = ((cbc128_f )aesni_cbc_encrypt);\r\n }\r\n else {\r\n if (mode == 0x5) {\r\n dat -> stream . ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n dat -> stream . cbc = ((void *)0);\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,165,143,\"e_aes.c\",258);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n aesni_cbc_encrypt(in,out,len,(ctx -> cipher_data),ctx -> iv,ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n aesni_ecb_encrypt(in,out,len,(ctx -> cipher_data),ctx -> encrypt);\r\n return 1;\r\n}\r\n#define aesni_ofb_cipher aes_ofb_cipher\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb_cipher aes_cfb_cipher\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb8_cipher aes_cfb8_cipher\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb1_cipher aes_cfb1_cipher\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_ctr_cipher aes_ctr_cipher\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )aesni_encrypt));\r\n gctx -> ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n#define aesni_gcm_cipher aes_gcm_cipher\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n\r\n if (enc) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_encrypt);\r\n xctx -> stream = aesni_xts_encrypt;\r\n }\r\n else {\r\n aesni_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_decrypt);\r\n xctx -> stream = aesni_xts_decrypt;\r\n }\r\n aesni_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )aesni_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n#define aesni_xts_cipher aes_xts_cipher\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )aesni_encrypt));\r\n cctx -> str = (enc?((ccm128_f )aesni_ccm64_encrypt_blocks) : ((ccm128_f )aesni_ccm64_decrypt_blocks));\r\n cctx -> key_set = 1;\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n#define aesni_ccm_cipher aes_ccm_cipher\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_init_key,\t\t\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,\t\\\r\n\tkeylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_##mode##_init_key,\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#else\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#endif\r\n#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)\t\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)\r\n\r\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x2) {\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = ((cbc128_f )bsaes_cbc_encrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n }\r\n }\r\n }\r\n else {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x5) {\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,133,143,\"e_aes.c\",567);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . cbc) {\r\n ( *dat -> stream . cbc)(in,out,len,(&dat -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n else {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n size_t i;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n for ((i = 0 , len -= bl); i <= len; i += bl) \r\n ( *dat -> block)(in + i,out + i,(&dat -> ks));\r\n return 1;\r\n}\r\n\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_ofb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_8_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (ctx -> flags & 0x2000) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n }\r\n while(len >= ((size_t )1) << sizeof(size_t ) * 8 - 4){\r\n CRYPTO_cfb128_1_encrypt(in,out,(((size_t )1) << sizeof(size_t ) * 8 - 4) * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n len -= ((size_t )1) << sizeof(size_t ) * 8 - 4;\r\n }\r\n if (len) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n unsigned int num = (ctx -> num);\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . ctr) {\r\n CRYPTO_ctr128_encrypt_ctr32(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> stream . ctr);\r\n }\r\n else {\r\n CRYPTO_ctr128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> block);\r\n }\r\n ctx -> num = ((size_t )num);\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cbc : &aes_128_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ecb : &aes_128_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ofb : &aes_128_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb : &aes_128_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb1 : &aes_128_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb8 : &aes_128_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ctr : &aes_128_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cbc : &aes_192_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ecb : &aes_192_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ofb : &aes_192_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb : &aes_192_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb1 : &aes_192_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb8()\r\n{\r\n void **mouillure_freest = 0;\r\n void **nonsurgical_subjudge = 0;\r\n void *skeily_telexed = 0;\r\n int foilsmen_ringle = 22;\r\n char *yds_relisting;;\r\n if (__sync_bool_compare_and_swap(&lemper_polyhedron,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&yds_relisting,\"7881\",foilsmen_ringle);\r\n if (yds_relisting != 0) {;\r\n skeily_telexed = ((void *)yds_relisting);\r\n mouillure_freest = &skeily_telexed;\r\n nonsurgical_subjudge = mouillure_freest + 5;\r\n scambled_sickly(nonsurgical_subjudge);\r\n }\r\n }\r\n }\r\n ;\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb8 : &aes_192_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ctr : &aes_192_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cbc : &aes_256_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ecb : &aes_256_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ofb : &aes_256_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb : &aes_256_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb1 : &aes_256_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb8 : &aes_256_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ctr : &aes_256_ctr;\r\n}\r\n\r\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n OPENSSL_cleanse((&gctx -> gcm),sizeof(gctx -> gcm));\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic void ctr64_inc(unsigned char *counter)\r\n{\r\n int n = 8;\r\n unsigned char c;\r\n do {\r\n --n;\r\n c = counter[n];\r\n ++c;\r\n counter[n] = c;\r\n if (c) {\r\n return ;\r\n }\r\n }while (n);\r\n}\r\n\r\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n gctx -> key_set = 0;\r\n gctx -> iv_set = 0;\r\n gctx -> ivlen = c -> cipher -> iv_len;\r\n gctx -> iv = c -> iv;\r\n gctx -> taglen = - 1;\r\n gctx -> iv_gen = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return 1;\r\n }\r\n case 0x9:\r\n{\r\n if (arg <= 0) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n#endif\r\n\r\n if (arg > 16 && arg > gctx -> ivlen) {\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n gctx -> iv = (CRYPTO_malloc(((int )arg),\"e_aes.c\",728));\r\n if (!gctx -> iv) {\r\n return 0;\r\n }\r\n }\r\n gctx -> ivlen = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg <= 0 || arg > 16 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> taglen = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (arg <= 0 || arg > 16 || !c -> encrypt || gctx -> taglen < 0) {\r\n return 0;\r\n }\r\n memcpy(ptr,(c -> buf),arg);\r\n return 1;\r\n }\r\n case 0x12:\r\n{\r\n\r\n if (arg == - 1) {\r\n memcpy((gctx -> iv),ptr,(gctx -> ivlen));\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n\r\n if (arg < 4 || gctx -> ivlen - arg < 8) {\r\n return 0;\r\n }\r\n if (arg) {\r\n memcpy((gctx -> iv),ptr,arg);\r\n }\r\n if (c -> encrypt && RAND_bytes(gctx -> iv + arg,gctx -> ivlen - arg) <= 0) {\r\n return 0;\r\n }\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n case 0x13:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0) {\r\n return 0;\r\n }\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n if (arg <= 0 || arg > gctx -> ivlen) {\r\n arg = gctx -> ivlen;\r\n }\r\n memcpy(ptr,(gctx -> iv + gctx -> ivlen - arg),arg);\r\n\r\n ctr64_inc(gctx -> iv + gctx -> ivlen - 8);\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x18:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((gctx -> iv + gctx -> ivlen - arg),ptr,arg);\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x16:\r\n{\r\n\r\n if (arg != 13) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> tls_aad_len = arg;\r\n{\r\n unsigned int len = (c -> buf[arg - 2] << 8 | c -> buf[arg - 1]);\r\n\r\n len -= 8;\r\n\r\n if (!c -> encrypt) {\r\n len -= 16;\r\n }\r\n c -> buf[arg - 2] = (len >> 8);\r\n c -> buf[arg - 1] = (len & 0xff);\r\n }\r\n\r\n return 16;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n gctx -> ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n break; \r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )vpaes_encrypt));\r\n gctx -> ctr = ((void *)0);\r\n break; \r\n }\r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n#ifdef AES_CTR_ASM\r\n#else\r\n gctx -> ctr = ((void *)0);\r\n#endif\r\n }while (0);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n int rv = - 1;\r\n\r\n if (out != in || len < (8 + 16)) {\r\n return - 1;\r\n }\r\n\r\n if (EVP_CIPHER_CTX_ctrl(ctx,(ctx -> encrypt?0x13 : 0x18),8,out) <= 0) {\r\n goto err;\r\n }\r\n\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,(ctx -> buf),(gctx -> tls_aad_len))) {\r\n goto err;\r\n }\r\n\r\n in += 8;\r\n out += 8;\r\n len -= (8 + 16);\r\n if (ctx -> encrypt) {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n out += len;\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,out,16);\r\n rv = (len + 8 + 16);\r\n }\r\n else {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n\r\n if (memcmp((ctx -> buf),(in + len),16)) {\r\n OPENSSL_cleanse(out,len);\r\n goto err;\r\n }\r\n rv = len;\r\n }\r\n err:\r\n gctx -> iv_set = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return rv;\r\n}\r\n\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n\r\n if (!gctx -> key_set) {\r\n return - 1;\r\n }\r\n if (gctx -> tls_aad_len >= 0) {\r\n return aes_gcm_tls_cipher(ctx,out,in,len);\r\n }\r\n if (!gctx -> iv_set) {\r\n return - 1;\r\n }\r\n if (in) {\r\n if (out == ((void *)0)) {\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,in,len)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n else {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n }\r\n return len;\r\n }\r\n else {\r\n if (!ctx -> encrypt) {\r\n if (gctx -> taglen < 0) {\r\n return - 1;\r\n }\r\n if (CRYPTO_gcm128_finish(&gctx -> gcm,(ctx -> buf),(gctx -> taglen)) != 0) {\r\n return - 1;\r\n }\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n gctx -> taglen = 16;\r\n\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n}\r\n#define CUSTOM_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 \\\r\n\t\t| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\\r\n\t\t| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_gcm : &aes_128_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_gcm : &aes_192_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_gcm : &aes_256_gcm;\r\n}\r\n\r\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (c -> cipher_data);\r\n if (type != 0) {\r\n return - 1;\r\n }\r\n\r\n xctx -> xts . key1 = ((void *)0);\r\n xctx -> xts . key2 = ((void *)0);\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef AES_XTS_ASM\r\n#else\r\n xctx -> stream = ((void *)0);\r\n#endif\r\n\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n xctx -> stream = (enc?bsaes_xts_encrypt : bsaes_xts_decrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n if (enc) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_encrypt);\r\n }\r\n else {\r\n vpaes_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_decrypt);\r\n }\r\n vpaes_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )vpaes_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n break; \r\n }\r\n }\r\n#endif\r\n if (enc) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_encrypt);\r\n }\r\n else {\r\n AES_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_decrypt);\r\n }\r\n AES_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )AES_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }while (0);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!xctx -> xts . key1 || !xctx -> xts . key2) {\r\n return 0;\r\n }\r\n if (!out || !in || len < 16) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n\r\n#endif\r\n if (xctx -> stream) {\r\n ( *xctx -> stream)(in,out,len,xctx -> xts . key1,xctx -> xts . key2,(ctx -> iv));\r\n }\r\n else {\r\n if (CRYPTO_xts128_encrypt((&xctx -> xts),(ctx -> iv),in,out,len,ctx -> encrypt)) {\r\n return 0;\r\n }\r\n }\r\n return 1;\r\n}\r\n#define aes_xts_cleanup NULL\r\n#define XTS_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\\r\n\t\t\t | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_xts : &aes_128_xts;\r\n}\r\nstatic const EVP_CIPHER aesni_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_xts : &aes_256_xts;\r\n}\r\n\r\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n cctx -> key_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> L = 8;\r\n cctx -> M = 12;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n case 0x9:\r\n arg = 15 - arg;\r\n case 0x14:\r\n{\r\n if (arg < 2 || arg > 8) {\r\n return 0;\r\n }\r\n cctx -> L = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg & 1 || arg < 4 || arg > 16) {\r\n return 0;\r\n }\r\n if (c -> encrypt && ptr || !c -> encrypt && !ptr) {\r\n return 0;\r\n }\r\n if (ptr) {\r\n cctx -> tag_set = 1;\r\n memcpy((c -> buf),ptr,arg);\r\n }\r\n cctx -> M = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (!c -> encrypt || !cctx -> tag_set) {\r\n return 0;\r\n }\r\n if (!CRYPTO_ccm128_tag(&cctx -> ccm,ptr,((size_t )arg))) {\r\n return 0;\r\n }\r\n cctx -> tag_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )vpaes_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n break; \r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )AES_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n }while (0);\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n CCM128_CONTEXT *ccm = &cctx -> ccm;\r\n\r\n if (!cctx -> iv_set && !cctx -> key_set) {\r\n return - 1;\r\n }\r\n if (!ctx -> encrypt && !cctx -> tag_set) {\r\n return - 1;\r\n }\r\n if (!out) {\r\n if (!in) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n return len;\r\n }\r\n\r\n if (!cctx -> len_set && len) {\r\n return - 1;\r\n }\r\n CRYPTO_ccm128_aad(ccm,in,len);\r\n return len;\r\n }\r\n\r\n if (!in) {\r\n return 0;\r\n }\r\n\r\n if (!cctx -> len_set) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n }\r\n if (ctx -> encrypt) {\r\n if (cctx -> str?CRYPTO_ccm128_encrypt_ccm64(ccm,in,out,len,cctx -> str) : CRYPTO_ccm128_encrypt(ccm,in,out,len)) {\r\n return - 1;\r\n }\r\n cctx -> tag_set = 1;\r\n return len;\r\n }\r\n else {\r\n int rv = - 1;\r\n if (cctx -> str?!CRYPTO_ccm128_decrypt_ccm64(ccm,in,out,len,cctx -> str) : !CRYPTO_ccm128_decrypt(ccm,in,out,len)) {\r\n unsigned char tag[16];\r\n if (CRYPTO_ccm128_tag(ccm,tag,(cctx -> M))) {\r\n if (!memcmp(tag,(ctx -> buf),(cctx -> M))) {\r\n rv = len;\r\n }\r\n }\r\n }\r\n if (rv == - 1) {\r\n OPENSSL_cleanse(out,len);\r\n }\r\n cctx -> iv_set = 0;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return rv;\r\n }\r\n}\r\n#define aes_ccm_cleanup NULL\r\nstatic const EVP_CIPHER aesni_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ccm : &aes_128_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ccm : &aes_192_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ccm : &aes_256_ccm;\r\n}\r\n\r\nvoid scambled_sickly(void **lichenivorous_toddite)\r\n{\r\n ++global_variable;;\r\n togae_carene(lichenivorous_toddite);\r\n}\r\n\r\nvoid togae_carene(void **copernicia_myristicaceae)\r\n{\r\n ++global_variable;;\r\n felizio_philabegs(copernicia_myristicaceae);\r\n}\r\n\r\nvoid felizio_philabegs(void **benet_metallocene)\r\n{\r\n ++global_variable;;\r\n flirtatiousness_quadrennially(benet_metallocene);\r\n}\r\n\r\nvoid flirtatiousness_quadrennially(void **silicean_despiting)\r\n{\r\n ++global_variable;;\r\n allodification_unlegalised(silicean_despiting);\r\n}\r\n\r\nvoid allodification_unlegalised(void **hylist_bizone)\r\n{\r\n ++global_variable;;\r\n toxophile_tollies(hylist_bizone);\r\n}\r\n\r\nvoid toxophile_tollies(void **wrainstave_infuneral)\r\n{\r\n ++global_variable;;\r\n citoler_corniplume(wrainstave_infuneral);\r\n}\r\n\r\nvoid citoler_corniplume(void **sulky_pretzel)\r\n{\r\n ++global_variable;;\r\n musters_fulham(sulky_pretzel);\r\n}\r\n\r\nvoid musters_fulham(void **bairnish_aghast)\r\n{\r\n ++global_variable;;\r\n periculous_thunderclouds(bairnish_aghast);\r\n}\r\n\r\nvoid periculous_thunderclouds(void **triplum_pshaws)\r\n{\r\n ++global_variable;;\r\n desugars_myctophidae(triplum_pshaws);\r\n}\r\n\r\nvoid desugars_myctophidae(void **geocentricism_tuckets)\r\n{\r\n FILE *temp = 0;\r\n int i;\r\n char **values;\r\n int len;\r\n char temp_str[80];\r\n char *endptr;\r\n char *dispiriting_enteralgia = 0;\r\n ++global_variable;;\r\n dispiriting_enteralgia = ((char *)((char *)( *(geocentricism_tuckets - 5))));\r\n \r\n len = strtol(dispiriting_enteralgia,&endptr,10);\r\n if (len > 0 && len < 1000) {\r\n values = malloc(len * sizeof(char *));\r\n if (values == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (i = 0; i < len; ++i)\r\n values[i] = 0;\r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n if (sscanf(endptr,\" %79s\",temp_str) == 1) {\r\n values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\r\n if (values[i] == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(values[i],temp_str);\r\n endptr += (strlen(temp_str) + 1) * sizeof(char );\r\n }\r\n }\r\n \r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n \r\n for (i = 0; i < len; ++i) {\r\n\r\n \r\n fputs(values[i],temp);\r\n printf(values[i]);\r\n }\r\n \r\n fclose(temp);\r\n }\r\n printf(\"\\n\");\r\n for (i = 0; i < len; ++i)\r\n if (values[i] != 0) {\r\n free(values[i]);\r\n }\r\n if (values != 0) {\r\n free(values);\r\n }\r\n }\r\n \r\n;\r\n if (((char *)( *(geocentricism_tuckets - 5))) != 0) \r\n free(((char *)((char *)( *(geocentricism_tuckets - 5)))));\r\nclose_printf_context();\r\n}\r\n#endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (i = 0; i < len; ++i) {\n\n \n fputs(values[i],temp);\n printf(values[i]);\n }\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint steeves_ashman = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint single_global_variable = 0;\r\nint canary_function_1()\r\n{\r\n \r\n ++single_global_variable;\r\n return 1;\r\n}\r\nint canary_function_2()\r\n{\r\n \r\n ++single_global_variable;\r\n return 2;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int i = 0;\r\n int index;\r\n int (*after_ptr[1])();\r\n unsigned char count[62];\r\n int (*before_ptr[1])();\r\n char str_buf[40] = {0};\r\n char *medjidieh_parava = 0;\r\n int negritising_twinborn;\r\n int sensomobile_industrialness;\r\n char **patand_cytophysics = 0;\r\n int *nonrevocation_marylyn = 0;\r\n int wadai_undissuadably;\r\n char **fieldale_riflescope[10] = {0};\r\n char *mockup_drugeteria[94] = {0};\r\n char *dogbush_sornari;;\r\n if (__sync_bool_compare_and_swap(&steeves_ashman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&dogbush_sornari,\"MACROBIUS_DEBITED\");\r\n if (dogbush_sornari != 0) {;\r\n mockup_drugeteria[27] = dogbush_sornari;\r\n wadai_undissuadably = 5;\r\n nonrevocation_marylyn = &wadai_undissuadably;\r\n fieldale_riflescope[ *nonrevocation_marylyn] = mockup_drugeteria;\r\n patand_cytophysics = fieldale_riflescope[ *nonrevocation_marylyn];\r\n sensomobile_industrialness = 5;\r\n while(1 == 1){\r\n sensomobile_industrialness = sensomobile_industrialness * 2;\r\n sensomobile_industrialness = sensomobile_industrialness + 2;\r\n if (sensomobile_industrialness > 1000) {\r\n break; \r\n }\r\n }\r\n negritising_twinborn = sensomobile_industrialness;\r\n medjidieh_parava = ((char *)patand_cytophysics[27]);\r\n \r\n strncpy(str_buf,medjidieh_parava,39);\r\n str_buf[39] = 0;\r\n for (i = 0; i < 62; i++) {\r\n count[i] = 0;\r\n }\r\n if (strlen(str_buf) > 1 && str_buf[0] > 'a') {\r\n before_ptr[0] = canary_function_1;\r\n after_ptr[0] = canary_function_1;\r\n }\r\n else {\r\n before_ptr[0] = canary_function_2;\r\n after_ptr[0] = canary_function_2;\r\n }\r\n \r\n \r\n for (i = 0; i < strlen(str_buf); i++)\r\n \r\n \r\n {\r\n if (str_buf[i] > 96) {\r\n index = str_buf[i] - 'a' + 36;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else if (str_buf[i] < 58) {\r\n index = str_buf[i] - 48;\r\n \r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else {\r\n index = str_buf[i] - 'A' + 10;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n }\r\n \r\n \r\n for (i = 0; i < 62; i++) {\r\n printf(\"index %d: %d\\n\",i,count[i]);\r\n }\r\n printf(\"%d\\n\",before_ptr[0]());\r\n printf(\"%d\\n\",after_ptr[0]());\r\n \r\n;\r\n if (patand_cytophysics[27] != 0) \r\n free(((char *)patand_cytophysics[27]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (i = 0; i < strlen(str_buf); i++)\n \n \n {\n if (str_buf[i] > 96) {\n index = str_buf[i] - 'a' + 36;\n if (count[index] < 255)\n count[index]++;\n }\n else if (str_buf[i] < 58) {\n index = str_buf[i] - 48;\n \n if (count[index] < 255)\n count[index]++;\n }\n else {\n index = str_buf[i] - 'A' + 10;\n if (count[index] < 255)\n count[index]++;\n }\n }\n```", "cwe": "129"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint likened_simon = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *esthetes_tdr = 0;\r\n jmp_buf elisa_gra;\r\n int saccharulmin_entackle;\r\n char **stringently_urochromogen = 0;\r\n char **malconstruction_unlitigiously = 0;\r\n int waldglas_nonrescissory = 0;\r\n char *whimsies_vincents = 0;\r\n int bowk_dodecasyllable = 5;\r\n char *mushrooming_pleuronectidae;;\r\n if (__sync_bool_compare_and_swap(&likened_simon,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&mushrooming_pleuronectidae,\"3164\",bowk_dodecasyllable);\r\n if (mushrooming_pleuronectidae != 0) {;\r\n waldglas_nonrescissory = ((int )(strlen(mushrooming_pleuronectidae)));\r\n whimsies_vincents = ((char *)(malloc(waldglas_nonrescissory + 1)));\r\n if (whimsies_vincents == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(whimsies_vincents,0,waldglas_nonrescissory + 1);\r\n memcpy(whimsies_vincents,mushrooming_pleuronectidae,waldglas_nonrescissory);\r\n if (mushrooming_pleuronectidae != 0) \r\n free(((char *)mushrooming_pleuronectidae));\r\n stringently_urochromogen = &whimsies_vincents;\r\n malconstruction_unlitigiously = stringently_urochromogen + 5;\r\n saccharulmin_entackle = setjmp(elisa_gra);\r\n if (saccharulmin_entackle == 0) {\r\n longjmp(elisa_gra,1);\r\n }\r\n esthetes_tdr = ((char *)( *(malconstruction_unlitigiously - 5)));\r\n \r\n input = atoi(esthetes_tdr);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\n if ( *(malconstruction_unlitigiously - 5) != 0) \r\n free(((char *)( *(malconstruction_unlitigiously - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n quotient = 1024 / mod;\n```", "cwe": "369"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint scriver_canstick = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid glycyl_undeludedly(char *apepsy_preindemnifying);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n void (*bescourge_mids)(char *) = glycyl_undeludedly;\r\n char *assam_gorhen;;\r\n if (__sync_bool_compare_and_swap(&scriver_canstick,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n assam_gorhen = getenv(\"LYCANTHROPOUS_CARBOLXYLOL\");\r\n if (assam_gorhen != 0) {;\r\n bescourge_mids(assam_gorhen);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid glycyl_undeludedly(char *apepsy_preindemnifying)\r\n{\r\n int oc_i = 0;\r\n char buff[64];\r\n char source[1024];\r\n char *octometer_saucemen = 0;\r\n ++global_variable;;\r\n octometer_saucemen = ((char *)apepsy_preindemnifying);\r\n \r\n memset(buff, 65, 64);\r\n buff[63] = '\\0';\r\n memset(source,0,1024);\r\n strncpy(source,octometer_saucemen,sizeof(source));\r\n source[1023] = 0;\r\n if (strlen(source) + 1 <= sizeof(buff)) {\r\n \r\n \r\n \r\n \r\n \r\n \r\n strncpy(buff,source,sizeof(source));\r\n \r\n \r\n }\r\n for (; oc_i < strlen(buff); ++oc_i) {\r\n buff[oc_i] = toupper(buff[oc_i]);\r\n }\r\n printf(\"%s\\n\",buff);\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n strncpy(buff,source,sizeof(source));\n```", "cwe": "806"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <sys/stat.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint unimped_who = 0;\r\nint global_variable;\r\n\r\nunion chevise_furtwler \r\n{\r\n char *nondetailed_micrography;\r\n double entocnemial_scotograph;\r\n char *neurochitin_marled;\r\n char vivacity_penalosa;\r\n int talker_locale;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid yamshik_qabbala(int interior_mythmaker,union chevise_furtwler costectomies_padge);\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{\r\n int outfieldsmen_undefiledly = 7;\r\n union chevise_furtwler hyracothere_attain = {0};\r\n int **********trisoctahedral_uncunning = 0;\r\n int *********tipstock_ignatia = 0;\r\n int ********taeniform_rinaldo = 0;\r\n int *******omnipresently_spatterware = 0;\r\n int ******ceratiidae_nathanil = 0;\r\n int *****saponification_ominously = 0;\r\n int ****pocono_colubrina = 0;\r\n int ***occidentalised_sokul = 0;\r\n int **unepicurean_extenders = 0;\r\n int *arctician_tableaus = 0;\r\n int amberoid_unnymphal;\r\n union chevise_furtwler rememberability_cosing[10] = {0};\r\n union chevise_furtwler recurved_unoverpowered;\r\n char *unimplicated_properdin;;\r\n if (__sync_bool_compare_and_swap(&unimped_who,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n unimplicated_properdin = getenv(\"LYNDE_PHONOGRAPHS\");\r\n if (unimplicated_properdin != 0) {;\r\n recurved_unoverpowered . nondetailed_micrography = unimplicated_properdin;\r\n amberoid_unnymphal = 5;\r\n arctician_tableaus = &amberoid_unnymphal;\r\n unepicurean_extenders = &arctician_tableaus;\r\n occidentalised_sokul = &unepicurean_extenders;\r\n pocono_colubrina = &occidentalised_sokul;\r\n saponification_ominously = &pocono_colubrina;\r\n ceratiidae_nathanil = &saponification_ominously;\r\n omnipresently_spatterware = &ceratiidae_nathanil;\r\n taeniform_rinaldo = &omnipresently_spatterware;\r\n tipstock_ignatia = &taeniform_rinaldo;\r\n trisoctahedral_uncunning = &tipstock_ignatia;\r\n rememberability_cosing[ *( *( *( *( *( *( *( *( *( *trisoctahedral_uncunning)))))))))] = recurved_unoverpowered;\r\n hyracothere_attain = rememberability_cosing[ *( *( *( *( *( *( *( *( *( *trisoctahedral_uncunning)))))))))];\r\n yamshik_qabbala(outfieldsmen_undefiledly,hyracothere_attain);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lmysqlclient -lssl -ldl'\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid yamshik_qabbala(int interior_mythmaker,union chevise_furtwler costectomies_padge)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *cornuting_prefocussed = 0;\r\n ++global_variable;\r\n interior_mythmaker--;\r\n if (interior_mythmaker > 0) {\r\n yamshik_qabbala(interior_mythmaker,costectomies_padge);\r\n return ;\r\n }\r\n cornuting_prefocussed = ((char *)costectomies_padge . nondetailed_micrography);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",cornuting_prefocussed);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint meridel_berskin = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid cleanup(FILE **ptrs,int size)\r\n{\r\n int i = 0;\r\n \r\n for (i = 0; i < size; i++) {\r\n if (ptrs[i] != 0) {\r\n fclose(ptrs[i]);\r\n }\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[10];\r\n char filename[80];\r\n char *sweetkins_ischar = 0;\r\n int unenshrined_spearman;\r\n void **anamnesis_cantboard = 0;\r\n void **usrc_sigrim = 0;\r\n void *elaterometer_nonaccentually = 0;\r\n char *gargler_waukesha;;\r\n if (__sync_bool_compare_and_swap(&meridel_berskin,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&gargler_waukesha,\"ETYMA_POLYSYMMETRICAL\");\r\n if (gargler_waukesha != 0) {;\r\n elaterometer_nonaccentually = ((void *)gargler_waukesha);\r\n unenshrined_spearman = 1;\r\n anamnesis_cantboard = &elaterometer_nonaccentually;\r\n usrc_sigrim = ((void **)(((unsigned long )anamnesis_cantboard) * unenshrined_spearman * unenshrined_spearman)) + 5;\r\n sweetkins_ischar = ((char *)((char *)( *(usrc_sigrim - 5))));\r\n \r\n files = fopen(sweetkins_ischar,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0) {\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n }\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi % 10] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n if (files != 0)\r\n fclose(files);\r\n cleanup(file_list, ((ssi-1)%10)+1);\r\n \r\n;\r\n if (((char *)( *(usrc_sigrim - 5))) != 0) \r\n free(((char *)((char *)( *(usrc_sigrim - 5)))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0) {\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n }\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi % 10] = file;\n ssi++;\n }\n```", "cwe": "773"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint phonetic_irresolvable = 0;\r\ntypedef char *tuyeres_portfolios;\r\nint global_variable;\r\nvoid handle_taint(char *goldurn_realizing);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid antinovelist_principal(tuyeres_portfolios teretipronator_diastasis);\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&phonetic_irresolvable,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid handle_taint(char *goldurn_realizing)\r\n{\r\n void (*gomulka_acclamator)(tuyeres_portfolios ) = antinovelist_principal;\r\n tuyeres_portfolios roploch_antispirochetic = 0;\r\n long macule_tackify[10];\r\n tuyeres_portfolios tacketed_tyrannisingly[10] = {0};\r\n tuyeres_portfolios agrostography_antiopiumist = 0;\r\n ++global_variable;;\r\n if (goldurn_realizing != 0) {;\r\n agrostography_antiopiumist = goldurn_realizing;\r\n tacketed_tyrannisingly[5] = agrostography_antiopiumist;\r\n macule_tackify[1] = 5;\r\n roploch_antispirochetic = *(tacketed_tyrannisingly + macule_tackify[1]);\r\n gomulka_acclamator(roploch_antispirochetic);\r\n }\r\n}\r\n\r\nvoid antinovelist_principal(tuyeres_portfolios teretipronator_diastasis)\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *rassled_receptible = 0;\r\n ++global_variable;;\r\n rassled_receptible = ((char *)teretipronator_diastasis);\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(rassled_receptible); ++i) {\r\n if (rassled_receptible[i] == ';') {\r\n if (i == 0 || rassled_receptible[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,rassled_receptible);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (teretipronator_diastasis != 0) \r\n free(((char *)teretipronator_diastasis));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint teonanacatl_interloli = 0;\r\nint global_variable;\r\nvoid handle_taint(char *trodi_pickett);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&teonanacatl_interloli,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid handle_taint(char *trodi_pickett)\r\n{\r\n int ss_j;\r\n int ss_i;\r\n size_t taint_size;\r\n char **malloced_buff = 0;\r\n int trace_flag = 0;\r\n char *crevassing_duvetyns = 0;\r\n jmp_buf incelebrity_neotenies;\r\n int beinked_pippy;\r\n void **smudges_pythonissa = 0;\r\n void **coursey_fernas = 0;\r\n void *appetibleness_carunculated = 0;\r\n ++global_variable;;\r\n if (trodi_pickett != 0) {;\r\n appetibleness_carunculated = ((void *)trodi_pickett);\r\n smudges_pythonissa = &appetibleness_carunculated;\r\n coursey_fernas = smudges_pythonissa + 5;\r\n beinked_pippy = setjmp(incelebrity_neotenies);\r\n if (beinked_pippy == 0) {\r\n longjmp(incelebrity_neotenies,1);\r\n }\r\n crevassing_duvetyns = ((char *)((char *)( *(coursey_fernas - 5))));\r\n \r\n taint_size = strlen(crevassing_duvetyns);\r\n \r\n if (taint_size >= 1600) {\r\n taint_size = 1599U;\r\n }\r\n malloced_buff = malloc(taint_size * sizeof(char *));\r\n \r\n \r\n if (malloced_buff != 0) {\r\n \r\n \r\n for (ss_i = 0; ss_i < taint_size; ++ss_i) {\r\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\r\n \r\n \r\n if (malloced_buff[ss_i] == 0 && errno == 12) {\r\n printf(\"Malloc error due to ulimit\\n\");\r\n if (trace_flag == 0) {\r\n \r\n \r\n trace_flag = 1;\r\n }\r\n }\r\n if (malloced_buff[ss_i] != 0) {\r\n for (ss_j = 0; ss_j < taint_size; ++ss_j) {\r\n memcpy(malloced_buff[ss_i] + ss_j * taint_size,crevassing_duvetyns,taint_size);\r\n }\r\n }\r\n \r\n \r\n if (taint_size % 2 == 0) {\r\n if (malloced_buff[ss_i] != 0) {\r\n free(malloced_buff[ss_i]);\r\n \r\n }\r\n }\r\n }\r\n free(malloced_buff);\r\n \r\n }\r\n;\r\n if (((char *)( *(coursey_fernas - 5))) != 0) \r\n free(((char *)((char *)( *(coursey_fernas - 5)))));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n \n \n if (malloced_buff[ss_i] == 0 && errno == 12) {\n printf(\"Malloc error due to ulimit\\n\");\n if (trace_flag == 0) {\n \n```", "cwe": "401"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_AES\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/aes.h>\r\n#include \"evp_locl.h\"\r\n#ifndef OPENSSL_FIPS\r\n#include \"modes_lcl.h\"\r\n#include <openssl/rand.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nAES_KEY ks;\r\nblock128_f block;\r\nunion {\r\ncbc128_f cbc;\r\nctr128_f ctr;}stream;}EVP_AES_KEY;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\nGCM128_CONTEXT gcm;\r\n\r\nunsigned char *iv;\r\n\r\nint ivlen;\r\nint taglen;\r\n\r\nint iv_gen;\r\n\r\nint tls_aad_len;\r\nctr128_f ctr;}EVP_AES_GCM_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks1;\r\nAES_KEY ks2;\r\nXTS128_CONTEXT xts;\r\nvoid (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\n\r\nint tag_set;\r\n\r\nint len_set;\r\n\r\nint L;\r\nint M;\r\nCCM128_CONTEXT ccm;\r\nccm128_f str;}EVP_AES_CCM_CTX;\r\n#define MAXBITCHUNK\t((size_t)1<<(sizeof(size_t)*8-4))\r\n#ifdef VPAES_ASM\r\nextern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\n#endif\r\n#ifdef BSAES_ASM\r\nextern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc);\r\nextern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]);\r\nextern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\n#endif\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n#ifdef AES_XTS_ASM\r\n#endif\r\n#if\tdefined(AES_ASM) && !defined(I386_ONLY) &&\t( \\\r\n\t((defined(__i386)\t|| defined(__i386__)\t|| \\\r\n\t defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \\\r\n\tdefined(__x86_64)\t|| defined(__x86_64__)\t|| \\\r\n\tdefined(_M_AMD64)\t|| defined(_M_X64)\t|| \\\r\n\tdefined(__INTEL__)\t\t\t\t)\r\nextern unsigned int OPENSSL_ia32cap_P[2];\r\n#ifdef VPAES_ASM\r\n#define VPAES_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(41-32)))\r\n#endif\r\n#ifdef BSAES_ASM\r\n#define BSAES_CAPABLE\tVPAES_CAPABLE\r\n#endif\r\n\r\n#define\tAESNI_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(57-32)))\r\nextern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc);\r\nextern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\nextern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec);\r\nextern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nextern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nint throw_uncabined = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid dionysian_bethumping(int yees_pinacoidal,char *adultoid_zig);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nstatic int aesni_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n ret = aesni_set_decrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )aesni_cbc_encrypt) : ((void *)0));\r\n }\r\n else {\r\n ret = aesni_set_encrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_encrypt);\r\n if (mode == 0x2) {\r\n dat -> stream . cbc = ((cbc128_f )aesni_cbc_encrypt);\r\n }\r\n else {\r\n if (mode == 0x5) {\r\n dat -> stream . ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n dat -> stream . cbc = ((void *)0);\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,165,143,\"e_aes.c\",258);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n aesni_cbc_encrypt(in,out,len,(ctx -> cipher_data),ctx -> iv,ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n aesni_ecb_encrypt(in,out,len,(ctx -> cipher_data),ctx -> encrypt);\r\n return 1;\r\n}\r\n#define aesni_ofb_cipher aes_ofb_cipher\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb_cipher aes_cfb_cipher\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb8_cipher aes_cfb8_cipher\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb1_cipher aes_cfb1_cipher\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_ctr_cipher aes_ctr_cipher\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )aesni_encrypt));\r\n gctx -> ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n#define aesni_gcm_cipher aes_gcm_cipher\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n\r\n if (enc) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_encrypt);\r\n xctx -> stream = aesni_xts_encrypt;\r\n }\r\n else {\r\n aesni_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_decrypt);\r\n xctx -> stream = aesni_xts_decrypt;\r\n }\r\n aesni_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )aesni_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n#define aesni_xts_cipher aes_xts_cipher\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )aesni_encrypt));\r\n cctx -> str = (enc?((ccm128_f )aesni_ccm64_encrypt_blocks) : ((ccm128_f )aesni_ccm64_decrypt_blocks));\r\n cctx -> key_set = 1;\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n#define aesni_ccm_cipher aes_ccm_cipher\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_init_key,\t\t\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,\t\\\r\n\tkeylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_##mode##_init_key,\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#else\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#endif\r\n#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)\t\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)\r\n\r\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x2) {\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = ((cbc128_f )bsaes_cbc_encrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n }\r\n }\r\n }\r\n else {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x5) {\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,133,143,\"e_aes.c\",567);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . cbc) {\r\n ( *dat -> stream . cbc)(in,out,len,(&dat -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n else {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n size_t i;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n for ((i = 0 , len -= bl); i <= len; i += bl) \r\n ( *dat -> block)(in + i,out + i,(&dat -> ks));\r\n return 1;\r\n}\r\n\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_ofb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_8_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (ctx -> flags & 0x2000) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n }\r\n while(len >= ((size_t )1) << sizeof(size_t ) * 8 - 4){\r\n CRYPTO_cfb128_1_encrypt(in,out,(((size_t )1) << sizeof(size_t ) * 8 - 4) * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n len -= ((size_t )1) << sizeof(size_t ) * 8 - 4;\r\n }\r\n if (len) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n unsigned int num = (ctx -> num);\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . ctr) {\r\n CRYPTO_ctr128_encrypt_ctr32(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> stream . ctr);\r\n }\r\n else {\r\n CRYPTO_ctr128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> block);\r\n }\r\n ctx -> num = ((size_t )num);\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cbc : &aes_128_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ecb : &aes_128_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ofb : &aes_128_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb : &aes_128_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb1 : &aes_128_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb8 : &aes_128_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ctr : &aes_128_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cbc : &aes_192_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ecb : &aes_192_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ofb : &aes_192_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb : &aes_192_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb1 : &aes_192_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb8()\r\n{\r\n int preromantic_wycliffist = 7;\r\n char *marlpit_diamicton = 0;\r\n int **************************************************inundation_metropolitanism = 0;\r\n int *************************************************scapoid_unmodulative = 0;\r\n int ************************************************doglike_quimbaya = 0;\r\n int ***********************************************faradization_burleys = 0;\r\n int **********************************************luminaries_unedging = 0;\r\n int *********************************************shoshanna_nonconductors = 0;\r\n int ********************************************chrysochlorous_toxicohaemia = 0;\r\n int *******************************************aprosopous_papistries = 0;\r\n int ******************************************shamash_typhous = 0;\r\n int *****************************************steatomata_lineless = 0;\r\n int ****************************************knies_muting = 0;\r\n int ***************************************stoloniferous_catafalque = 0;\r\n int **************************************coxodynia_theodora = 0;\r\n int *************************************aliipoe_depasture = 0;\r\n int ************************************gigantological_exudate = 0;\r\n int ***********************************chirurgic_metallized = 0;\r\n int **********************************wordishly_metallicize = 0;\r\n int *********************************mononucleosises_overincrust = 0;\r\n int ********************************cavalcade_partaker = 0;\r\n int *******************************interempire_tetrapyrenous = 0;\r\n int ******************************antifemale_restorer = 0;\r\n int *****************************micawberism_epidermatous = 0;\r\n int ****************************needlessly_trucemaking = 0;\r\n int ***************************eclipsis_nephite = 0;\r\n int **************************fermin_polishings = 0;\r\n int *************************levyist_mouthes = 0;\r\n int ************************sphaeraphides_chambrel = 0;\r\n int ***********************smoggy_botein = 0;\r\n int **********************allantoides_oversness = 0;\r\n int *********************irrisoridae_baudery = 0;\r\n int ********************authoriser_vimful = 0;\r\n int *******************arnoldsburg_bungtown = 0;\r\n int ******************consonantally_sedgewake = 0;\r\n int *****************tunicate_undull = 0;\r\n int ****************outpursued_crablike = 0;\r\n int ***************doolie_adversus = 0;\r\n int **************bolshy_fetisheer = 0;\r\n int *************yeared_emlynne = 0;\r\n int ************boers_consulating = 0;\r\n int ***********gomphocarpus_gibson = 0;\r\n int **********cenesthesis_unoratorial = 0;\r\n int *********unslowed_fossors = 0;\r\n int ********dextropedal_achorn = 0;\r\n int *******kostelanetz_metioche = 0;\r\n int ******stonecutting_privateer = 0;\r\n int *****trustifying_prebronchial = 0;\r\n int ****kienan_bluegrass = 0;\r\n int ***ravenswood_kansan = 0;\r\n int **thammuz_bottlefuls = 0;\r\n int *divests_hasa = 0;\r\n int sedging_unserene;\r\n char *teloi_tenebricose[10] = {0};\r\n char *redeposits_quizzification;;\r\n if (__sync_bool_compare_and_swap(&throw_uncabined,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n redeposits_quizzification = getenv(\"MOKES_MANDARINING\");\r\n if (redeposits_quizzification != 0) {;\r\n sedging_unserene = 5;\r\n divests_hasa = &sedging_unserene;\r\n thammuz_bottlefuls = &divests_hasa;\r\n ravenswood_kansan = &thammuz_bottlefuls;\r\n kienan_bluegrass = &ravenswood_kansan;\r\n trustifying_prebronchial = &kienan_bluegrass;\r\n stonecutting_privateer = &trustifying_prebronchial;\r\n kostelanetz_metioche = &stonecutting_privateer;\r\n dextropedal_achorn = &kostelanetz_metioche;\r\n unslowed_fossors = &dextropedal_achorn;\r\n cenesthesis_unoratorial = &unslowed_fossors;\r\n gomphocarpus_gibson = &cenesthesis_unoratorial;\r\n boers_consulating = &gomphocarpus_gibson;\r\n yeared_emlynne = &boers_consulating;\r\n bolshy_fetisheer = &yeared_emlynne;\r\n doolie_adversus = &bolshy_fetisheer;\r\n outpursued_crablike = &doolie_adversus;\r\n tunicate_undull = &outpursued_crablike;\r\n consonantally_sedgewake = &tunicate_undull;\r\n arnoldsburg_bungtown = &consonantally_sedgewake;\r\n authoriser_vimful = &arnoldsburg_bungtown;\r\n irrisoridae_baudery = &authoriser_vimful;\r\n allantoides_oversness = &irrisoridae_baudery;\r\n smoggy_botein = &allantoides_oversness;\r\n sphaeraphides_chambrel = &smoggy_botein;\r\n levyist_mouthes = &sphaeraphides_chambrel;\r\n fermin_polishings = &levyist_mouthes;\r\n eclipsis_nephite = &fermin_polishings;\r\n needlessly_trucemaking = &eclipsis_nephite;\r\n micawberism_epidermatous = &needlessly_trucemaking;\r\n antifemale_restorer = &micawberism_epidermatous;\r\n interempire_tetrapyrenous = &antifemale_restorer;\r\n cavalcade_partaker = &interempire_tetrapyrenous;\r\n mononucleosises_overincrust = &cavalcade_partaker;\r\n wordishly_metallicize = &mononucleosises_overincrust;\r\n chirurgic_metallized = &wordishly_metallicize;\r\n gigantological_exudate = &chirurgic_metallized;\r\n aliipoe_depasture = &gigantological_exudate;\r\n coxodynia_theodora = &aliipoe_depasture;\r\n stoloniferous_catafalque = &coxodynia_theodora;\r\n knies_muting = &stoloniferous_catafalque;\r\n steatomata_lineless = &knies_muting;\r\n shamash_typhous = &steatomata_lineless;\r\n aprosopous_papistries = &shamash_typhous;\r\n chrysochlorous_toxicohaemia = &aprosopous_papistries;\r\n shoshanna_nonconductors = &chrysochlorous_toxicohaemia;\r\n luminaries_unedging = &shoshanna_nonconductors;\r\n faradization_burleys = &luminaries_unedging;\r\n doglike_quimbaya = &faradization_burleys;\r\n scapoid_unmodulative = &doglike_quimbaya;\r\n inundation_metropolitanism = &scapoid_unmodulative;\r\n teloi_tenebricose[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *inundation_metropolitanism)))))))))))))))))))))))))))))))))))))))))))))))))] = redeposits_quizzification;\r\n marlpit_diamicton = teloi_tenebricose[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *inundation_metropolitanism)))))))))))))))))))))))))))))))))))))))))))))))))];\r\n dionysian_bethumping(preromantic_wycliffist,marlpit_diamicton);\r\n }\r\n }\r\n }\r\n ;\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb8 : &aes_192_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ctr : &aes_192_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cbc : &aes_256_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ecb : &aes_256_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ofb : &aes_256_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb : &aes_256_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb1 : &aes_256_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb8 : &aes_256_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ctr : &aes_256_ctr;\r\n}\r\n\r\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n OPENSSL_cleanse((&gctx -> gcm),sizeof(gctx -> gcm));\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic void ctr64_inc(unsigned char *counter)\r\n{\r\n int n = 8;\r\n unsigned char c;\r\n do {\r\n --n;\r\n c = counter[n];\r\n ++c;\r\n counter[n] = c;\r\n if (c) {\r\n return ;\r\n }\r\n }while (n);\r\n}\r\n\r\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n gctx -> key_set = 0;\r\n gctx -> iv_set = 0;\r\n gctx -> ivlen = c -> cipher -> iv_len;\r\n gctx -> iv = c -> iv;\r\n gctx -> taglen = - 1;\r\n gctx -> iv_gen = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return 1;\r\n }\r\n case 0x9:\r\n{\r\n if (arg <= 0) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n#endif\r\n\r\n if (arg > 16 && arg > gctx -> ivlen) {\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n gctx -> iv = (CRYPTO_malloc(((int )arg),\"e_aes.c\",728));\r\n if (!gctx -> iv) {\r\n return 0;\r\n }\r\n }\r\n gctx -> ivlen = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg <= 0 || arg > 16 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> taglen = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (arg <= 0 || arg > 16 || !c -> encrypt || gctx -> taglen < 0) {\r\n return 0;\r\n }\r\n memcpy(ptr,(c -> buf),arg);\r\n return 1;\r\n }\r\n case 0x12:\r\n{\r\n\r\n if (arg == - 1) {\r\n memcpy((gctx -> iv),ptr,(gctx -> ivlen));\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n\r\n if (arg < 4 || gctx -> ivlen - arg < 8) {\r\n return 0;\r\n }\r\n if (arg) {\r\n memcpy((gctx -> iv),ptr,arg);\r\n }\r\n if (c -> encrypt && RAND_bytes(gctx -> iv + arg,gctx -> ivlen - arg) <= 0) {\r\n return 0;\r\n }\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n case 0x13:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0) {\r\n return 0;\r\n }\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n if (arg <= 0 || arg > gctx -> ivlen) {\r\n arg = gctx -> ivlen;\r\n }\r\n memcpy(ptr,(gctx -> iv + gctx -> ivlen - arg),arg);\r\n\r\n ctr64_inc(gctx -> iv + gctx -> ivlen - 8);\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x18:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((gctx -> iv + gctx -> ivlen - arg),ptr,arg);\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x16:\r\n{\r\n\r\n if (arg != 13) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> tls_aad_len = arg;\r\n{\r\n unsigned int len = (c -> buf[arg - 2] << 8 | c -> buf[arg - 1]);\r\n\r\n len -= 8;\r\n\r\n if (!c -> encrypt) {\r\n len -= 16;\r\n }\r\n c -> buf[arg - 2] = (len >> 8);\r\n c -> buf[arg - 1] = (len & 0xff);\r\n }\r\n\r\n return 16;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n gctx -> ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n break; \r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )vpaes_encrypt));\r\n gctx -> ctr = ((void *)0);\r\n break; \r\n }\r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n#ifdef AES_CTR_ASM\r\n#else\r\n gctx -> ctr = ((void *)0);\r\n#endif\r\n }while (0);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n int rv = - 1;\r\n\r\n if (out != in || len < (8 + 16)) {\r\n return - 1;\r\n }\r\n\r\n if (EVP_CIPHER_CTX_ctrl(ctx,(ctx -> encrypt?0x13 : 0x18),8,out) <= 0) {\r\n goto err;\r\n }\r\n\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,(ctx -> buf),(gctx -> tls_aad_len))) {\r\n goto err;\r\n }\r\n\r\n in += 8;\r\n out += 8;\r\n len -= (8 + 16);\r\n if (ctx -> encrypt) {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n out += len;\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,out,16);\r\n rv = (len + 8 + 16);\r\n }\r\n else {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n\r\n if (memcmp((ctx -> buf),(in + len),16)) {\r\n OPENSSL_cleanse(out,len);\r\n goto err;\r\n }\r\n rv = len;\r\n }\r\n err:\r\n gctx -> iv_set = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return rv;\r\n}\r\n\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n\r\n if (!gctx -> key_set) {\r\n return - 1;\r\n }\r\n if (gctx -> tls_aad_len >= 0) {\r\n return aes_gcm_tls_cipher(ctx,out,in,len);\r\n }\r\n if (!gctx -> iv_set) {\r\n return - 1;\r\n }\r\n if (in) {\r\n if (out == ((void *)0)) {\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,in,len)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n else {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n }\r\n return len;\r\n }\r\n else {\r\n if (!ctx -> encrypt) {\r\n if (gctx -> taglen < 0) {\r\n return - 1;\r\n }\r\n if (CRYPTO_gcm128_finish(&gctx -> gcm,(ctx -> buf),(gctx -> taglen)) != 0) {\r\n return - 1;\r\n }\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n gctx -> taglen = 16;\r\n\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n}\r\n#define CUSTOM_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 \\\r\n\t\t| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\\r\n\t\t| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_gcm : &aes_128_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_gcm : &aes_192_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_gcm : &aes_256_gcm;\r\n}\r\n\r\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (c -> cipher_data);\r\n if (type != 0) {\r\n return - 1;\r\n }\r\n\r\n xctx -> xts . key1 = ((void *)0);\r\n xctx -> xts . key2 = ((void *)0);\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef AES_XTS_ASM\r\n#else\r\n xctx -> stream = ((void *)0);\r\n#endif\r\n\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n xctx -> stream = (enc?bsaes_xts_encrypt : bsaes_xts_decrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n if (enc) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_encrypt);\r\n }\r\n else {\r\n vpaes_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_decrypt);\r\n }\r\n vpaes_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )vpaes_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n break; \r\n }\r\n }\r\n#endif\r\n if (enc) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_encrypt);\r\n }\r\n else {\r\n AES_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_decrypt);\r\n }\r\n AES_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )AES_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }while (0);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!xctx -> xts . key1 || !xctx -> xts . key2) {\r\n return 0;\r\n }\r\n if (!out || !in || len < 16) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n\r\n#endif\r\n if (xctx -> stream) {\r\n ( *xctx -> stream)(in,out,len,xctx -> xts . key1,xctx -> xts . key2,(ctx -> iv));\r\n }\r\n else {\r\n if (CRYPTO_xts128_encrypt((&xctx -> xts),(ctx -> iv),in,out,len,ctx -> encrypt)) {\r\n return 0;\r\n }\r\n }\r\n return 1;\r\n}\r\n#define aes_xts_cleanup NULL\r\n#define XTS_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\\r\n\t\t\t | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_xts : &aes_128_xts;\r\n}\r\nstatic const EVP_CIPHER aesni_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_xts : &aes_256_xts;\r\n}\r\n\r\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n cctx -> key_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> L = 8;\r\n cctx -> M = 12;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n case 0x9:\r\n arg = 15 - arg;\r\n case 0x14:\r\n{\r\n if (arg < 2 || arg > 8) {\r\n return 0;\r\n }\r\n cctx -> L = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg & 1 || arg < 4 || arg > 16) {\r\n return 0;\r\n }\r\n if (c -> encrypt && ptr || !c -> encrypt && !ptr) {\r\n return 0;\r\n }\r\n if (ptr) {\r\n cctx -> tag_set = 1;\r\n memcpy((c -> buf),ptr,arg);\r\n }\r\n cctx -> M = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (!c -> encrypt || !cctx -> tag_set) {\r\n return 0;\r\n }\r\n if (!CRYPTO_ccm128_tag(&cctx -> ccm,ptr,((size_t )arg))) {\r\n return 0;\r\n }\r\n cctx -> tag_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )vpaes_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n break; \r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )AES_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n }while (0);\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n CCM128_CONTEXT *ccm = &cctx -> ccm;\r\n\r\n if (!cctx -> iv_set && !cctx -> key_set) {\r\n return - 1;\r\n }\r\n if (!ctx -> encrypt && !cctx -> tag_set) {\r\n return - 1;\r\n }\r\n if (!out) {\r\n if (!in) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n return len;\r\n }\r\n\r\n if (!cctx -> len_set && len) {\r\n return - 1;\r\n }\r\n CRYPTO_ccm128_aad(ccm,in,len);\r\n return len;\r\n }\r\n\r\n if (!in) {\r\n return 0;\r\n }\r\n\r\n if (!cctx -> len_set) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n }\r\n if (ctx -> encrypt) {\r\n if (cctx -> str?CRYPTO_ccm128_encrypt_ccm64(ccm,in,out,len,cctx -> str) : CRYPTO_ccm128_encrypt(ccm,in,out,len)) {\r\n return - 1;\r\n }\r\n cctx -> tag_set = 1;\r\n return len;\r\n }\r\n else {\r\n int rv = - 1;\r\n if (cctx -> str?!CRYPTO_ccm128_decrypt_ccm64(ccm,in,out,len,cctx -> str) : !CRYPTO_ccm128_decrypt(ccm,in,out,len)) {\r\n unsigned char tag[16];\r\n if (CRYPTO_ccm128_tag(ccm,tag,(cctx -> M))) {\r\n if (!memcmp(tag,(ctx -> buf),(cctx -> M))) {\r\n rv = len;\r\n }\r\n }\r\n }\r\n if (rv == - 1) {\r\n OPENSSL_cleanse(out,len);\r\n }\r\n cctx -> iv_set = 0;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return rv;\r\n }\r\n}\r\n#define aes_ccm_cleanup NULL\r\nstatic const EVP_CIPHER aesni_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ccm : &aes_128_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ccm : &aes_192_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ccm : &aes_256_ccm;\r\n}\r\n\r\nvoid dionysian_bethumping(int yees_pinacoidal,char *adultoid_zig)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *undull_marmelos = 0;\r\n ++global_variable;\r\n yees_pinacoidal--;\r\n if (yees_pinacoidal > 0) {\r\n dionysian_bethumping(yees_pinacoidal,adultoid_zig);\r\n return ;\r\n }\r\n undull_marmelos = ((char *)adultoid_zig);\r\n \r\n buffer_value = atoi(undull_marmelos);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(malloc_buffer,0,size_buffer);\n printf(\"Buffer size is %d\\n\", size_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint gorgoneum_prospero = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid demisable_unparalysed(char *const unmitigatedly_intolerable);\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int movie_gweduck = 0;\r\n char *sweetbriar_overdoses = 0;\r\n int validation_jasmone = 61;\r\n char *aminated_staghunter;;\r\n if (__sync_bool_compare_and_swap(&gorgoneum_prospero,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&aminated_staghunter,\"1152\",validation_jasmone);\r\n if (aminated_staghunter != 0) {;\r\n movie_gweduck = ((int )(strlen(aminated_staghunter)));\r\n sweetbriar_overdoses = ((char *)(malloc(movie_gweduck + 1)));\r\n if (sweetbriar_overdoses == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(sweetbriar_overdoses,0,movie_gweduck + 1);\r\n memcpy(sweetbriar_overdoses,aminated_staghunter,movie_gweduck);\r\n if (aminated_staghunter != 0) \r\n free(((char *)aminated_staghunter));\r\n demisable_unparalysed(sweetbriar_overdoses);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid demisable_unparalysed(char *const unmitigatedly_intolerable)\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[1020];\r\n char filename[80];\r\n char *dapperest_ujiji = 0;\r\n int jawed_bundoc;\r\n int uncavilling_anencephalic;\r\n ++global_variable;;\r\n uncavilling_anencephalic = 5;\r\n while(1 == 1){\r\n uncavilling_anencephalic = uncavilling_anencephalic * 2;\r\n uncavilling_anencephalic = uncavilling_anencephalic + 2;\r\n if (uncavilling_anencephalic > 1000) {\r\n break; \r\n }\r\n }\r\n jawed_bundoc = uncavilling_anencephalic;\r\n dapperest_ujiji = ((char *)((char *)unmitigatedly_intolerable));\r\n \r\n files = fopen(dapperest_ujiji,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n if (files != 0)\r\n fclose(files);\r\n \r\n;\r\n if (((char *)unmitigatedly_intolerable) != 0) \r\n free(((char *)((char *)unmitigatedly_intolerable)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi] = file;\n ssi++;\n }\n```", "cwe": "775"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint undeficiently_bundweed = 0;\r\nint global_variable;\r\n\r\nunion bastard_typicality \r\n{\r\n char *corder_felonwood;\r\n double malpighiaceae_piddled;\r\n char *metachemical_jubilate;\r\n char counterflashing_danella;\r\n int schomberger_sensomobile;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid polychromatize_unanemic(int inharmony_btn,union bastard_typicality **************************************************unresuscitative_beaverwood);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n int deficit_geothlypis = 7;\r\n union bastard_typicality **************************************************slayable_moorman = 0;\r\n union bastard_typicality *************************************************furmark_shrier = 0;\r\n union bastard_typicality ************************************************xanthochroid_sphenopalatine = 0;\r\n union bastard_typicality ***********************************************overpained_participants = 0;\r\n union bastard_typicality **********************************************covetousness_bistros = 0;\r\n union bastard_typicality *********************************************clervaux_shuns = 0;\r\n union bastard_typicality ********************************************missourian_splendora = 0;\r\n union bastard_typicality *******************************************phosphoresced_ruddiness = 0;\r\n union bastard_typicality ******************************************pep_granes = 0;\r\n union bastard_typicality *****************************************egidius_mayapple = 0;\r\n union bastard_typicality ****************************************inexecutable_winterly = 0;\r\n union bastard_typicality ***************************************originary_shamefast = 0;\r\n union bastard_typicality **************************************goliard_starchiness = 0;\r\n union bastard_typicality *************************************strich_dyspeptically = 0;\r\n union bastard_typicality ************************************outwatching_sphacelism = 0;\r\n union bastard_typicality ***********************************respectfully_panpsychism = 0;\r\n union bastard_typicality **********************************vapourescent_spleninii = 0;\r\n union bastard_typicality *********************************sesuvium_stauroscope = 0;\r\n union bastard_typicality ********************************unconscionably_oscilloscopes = 0;\r\n union bastard_typicality *******************************defalcator_lohengrin = 0;\r\n union bastard_typicality ******************************spirochetal_insurgence = 0;\r\n union bastard_typicality *****************************polyonymy_bluenesses = 0;\r\n union bastard_typicality ****************************unauthorized_tenour = 0;\r\n union bastard_typicality ***************************enemied_lurries = 0;\r\n union bastard_typicality **************************mervin_mesodermal = 0;\r\n union bastard_typicality *************************troparion_dacryolite = 0;\r\n union bastard_typicality ************************gorhen_aurify = 0;\r\n union bastard_typicality ***********************buffalo_unendable = 0;\r\n union bastard_typicality **********************mammitis_flinthearted = 0;\r\n union bastard_typicality *********************tatie_untentered = 0;\r\n union bastard_typicality ********************foveas_strawier = 0;\r\n union bastard_typicality *******************yorubaland_ballooner = 0;\r\n union bastard_typicality ******************infraspinate_bumtrap = 0;\r\n union bastard_typicality *****************flossies_holmun = 0;\r\n union bastard_typicality ****************walchia_nonvulval = 0;\r\n union bastard_typicality ***************gallophobe_burnight = 0;\r\n union bastard_typicality **************gymnite_porcelanite = 0;\r\n union bastard_typicality *************toused_printings = 0;\r\n union bastard_typicality ************dechlog_tussy = 0;\r\n union bastard_typicality ***********exudative_jon = 0;\r\n union bastard_typicality **********styloglossus_necrotizing = 0;\r\n union bastard_typicality *********bordereaux_podical = 0;\r\n union bastard_typicality ********restream_unattestedness = 0;\r\n union bastard_typicality *******bieennia_owlishly = 0;\r\n union bastard_typicality ******uromelus_unsacrament = 0;\r\n union bastard_typicality *****unbusk_leukoblast = 0;\r\n union bastard_typicality ****frigate_anoine = 0;\r\n union bastard_typicality ***glancer_cirripedia = 0;\r\n union bastard_typicality **pondside_underbrace = 0;\r\n union bastard_typicality *domiculture_resnatron = 0;\r\n union bastard_typicality pinkify_stoot = {0};\r\n union bastard_typicality killing_farrow;\r\n int cryptomnesic_vend = 53;\r\n char *mastosquamose_gasser;;\r\n if (__sync_bool_compare_and_swap(&undeficiently_bundweed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&mastosquamose_gasser,\"8433\",cryptomnesic_vend);\r\n if (mastosquamose_gasser != 0) {;\r\n killing_farrow . corder_felonwood = mastosquamose_gasser;\r\n domiculture_resnatron = &killing_farrow;\r\n pondside_underbrace = &domiculture_resnatron;\r\n glancer_cirripedia = &pondside_underbrace;\r\n frigate_anoine = &glancer_cirripedia;\r\n unbusk_leukoblast = &frigate_anoine;\r\n uromelus_unsacrament = &unbusk_leukoblast;\r\n bieennia_owlishly = &uromelus_unsacrament;\r\n restream_unattestedness = &bieennia_owlishly;\r\n bordereaux_podical = &restream_unattestedness;\r\n styloglossus_necrotizing = &bordereaux_podical;\r\n exudative_jon = &styloglossus_necrotizing;\r\n dechlog_tussy = &exudative_jon;\r\n toused_printings = &dechlog_tussy;\r\n gymnite_porcelanite = &toused_printings;\r\n gallophobe_burnight = &gymnite_porcelanite;\r\n walchia_nonvulval = &gallophobe_burnight;\r\n flossies_holmun = &walchia_nonvulval;\r\n infraspinate_bumtrap = &flossies_holmun;\r\n yorubaland_ballooner = &infraspinate_bumtrap;\r\n foveas_strawier = &yorubaland_ballooner;\r\n tatie_untentered = &foveas_strawier;\r\n mammitis_flinthearted = &tatie_untentered;\r\n buffalo_unendable = &mammitis_flinthearted;\r\n gorhen_aurify = &buffalo_unendable;\r\n troparion_dacryolite = &gorhen_aurify;\r\n mervin_mesodermal = &troparion_dacryolite;\r\n enemied_lurries = &mervin_mesodermal;\r\n unauthorized_tenour = &enemied_lurries;\r\n polyonymy_bluenesses = &unauthorized_tenour;\r\n spirochetal_insurgence = &polyonymy_bluenesses;\r\n defalcator_lohengrin = &spirochetal_insurgence;\r\n unconscionably_oscilloscopes = &defalcator_lohengrin;\r\n sesuvium_stauroscope = &unconscionably_oscilloscopes;\r\n vapourescent_spleninii = &sesuvium_stauroscope;\r\n respectfully_panpsychism = &vapourescent_spleninii;\r\n outwatching_sphacelism = &respectfully_panpsychism;\r\n strich_dyspeptically = &outwatching_sphacelism;\r\n goliard_starchiness = &strich_dyspeptically;\r\n originary_shamefast = &goliard_starchiness;\r\n inexecutable_winterly = &originary_shamefast;\r\n egidius_mayapple = &inexecutable_winterly;\r\n pep_granes = &egidius_mayapple;\r\n phosphoresced_ruddiness = &pep_granes;\r\n missourian_splendora = &phosphoresced_ruddiness;\r\n clervaux_shuns = &missourian_splendora;\r\n covetousness_bistros = &clervaux_shuns;\r\n overpained_participants = &covetousness_bistros;\r\n xanthochroid_sphenopalatine = &overpained_participants;\r\n furmark_shrier = &xanthochroid_sphenopalatine;\r\n slayable_moorman = &furmark_shrier;\r\n polychromatize_unanemic(deficit_geothlypis,slayable_moorman);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid polychromatize_unanemic(int inharmony_btn,union bastard_typicality **************************************************unresuscitative_beaverwood)\r\n{\r\n int oc_i = 0;\r\n char * data = 0;\r\n char *worrit_thundershower = 0;\r\n ++global_variable;\r\n inharmony_btn--;\r\n if (inharmony_btn > 0) {\r\n polychromatize_unanemic(inharmony_btn,unresuscitative_beaverwood);\r\n return ;\r\n }\r\n worrit_thundershower = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unresuscitative_beaverwood)))))))))))))))))))))))))))))))))))))))))))))))))) . corder_felonwood);\r\n \r\n data = (char*) malloc(8 * sizeof(char));\r\n if (data != NULL) {\r\n \r\n \r\n \r\n \r\n \r\n strncpy(data, worrit_thundershower, strlen(worrit_thundershower) + 1);\r\n for (; oc_i < strlen(data); ++oc_i) {\r\n data[oc_i] = toupper(data[oc_i]);\r\n }\r\n printf(\"%s\\n\", data);\r\n \r\n \r\n free(data);\r\n }\r\n \r\n;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unresuscitative_beaverwood)))))))))))))))))))))))))))))))))))))))))))))))))) . corder_felonwood != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unresuscitative_beaverwood)))))))))))))))))))))))))))))))))))))))))))))))))) . corder_felonwood));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n strncpy(data, worrit_thundershower, strlen(worrit_thundershower) + 1);\n for (; oc_i < strlen(data); ++oc_i) {\n data[oc_i] = toupper(data[oc_i]);\n }\n printf(\"%s\\n\", data);\n```", "cwe": "805"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint lalopathy_tollgatherer = 0;\r\nint global_variable;\r\nvoid handle_taint(char *counterbend_greenbackism);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&lalopathy_tollgatherer,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\n\r\nvoid handle_taint(char *counterbend_greenbackism)\r\n{\r\n char buffer_stack[128] = {0};\r\n char *regeneracy_preregal = 0;\r\n jmp_buf bissextus_spumier;\r\n int firers_purloins;\r\n char **dispend_rehabilitative = 0;\r\n int **********undemolished_transylvanian = 0;\r\n int *********amroc_globetrotters = 0;\r\n int ********fluxweed_shechina = 0;\r\n int *******substantify_invincibility = 0;\r\n int ******probationerhood_sulphuretting = 0;\r\n int *****chilostome_basic = 0;\r\n int ****cichocki_marshalsea = 0;\r\n int ***archpriesthood_australianism = 0;\r\n int **oppositiflorous_cycling = 0;\r\n int *servette_physicomorphic = 0;\r\n int cautionary_triturated;\r\n char **deutscher_george[10] = {0};\r\n char *olathe_polychromy[70] = {0};\r\n ++global_variable;;\r\n if (counterbend_greenbackism != 0) {;\r\n olathe_polychromy[61] = counterbend_greenbackism;\r\n cautionary_triturated = 5;\r\n servette_physicomorphic = &cautionary_triturated;\r\n oppositiflorous_cycling = &servette_physicomorphic;\r\n archpriesthood_australianism = &oppositiflorous_cycling;\r\n cichocki_marshalsea = &archpriesthood_australianism;\r\n chilostome_basic = &cichocki_marshalsea;\r\n probationerhood_sulphuretting = &chilostome_basic;\r\n substantify_invincibility = &probationerhood_sulphuretting;\r\n fluxweed_shechina = &substantify_invincibility;\r\n amroc_globetrotters = &fluxweed_shechina;\r\n undemolished_transylvanian = &amroc_globetrotters;\r\n deutscher_george[ *( *( *( *( *( *( *( *( *( *undemolished_transylvanian)))))))))] = olathe_polychromy;\r\n dispend_rehabilitative = deutscher_george[ *( *( *( *( *( *( *( *( *( *undemolished_transylvanian)))))))))];\r\n firers_purloins = setjmp(bissextus_spumier);\r\n if (firers_purloins == 0) {\r\n longjmp(bissextus_spumier,1);\r\n }\r\n regeneracy_preregal = ((char *)dispend_rehabilitative[61]);\r\n \r\n \r\n \r\n \r\n \r\n sprintf(buffer_stack,regeneracy_preregal);\r\n \r\n printf(\"%s\\n\",buffer_stack);\r\n \r\n \r\n;\r\n if (dispend_rehabilitative[61] != 0) \r\n free(((char *)dispend_rehabilitative[61]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n sprintf(buffer_stack,regeneracy_preregal);\n \n printf(\"%s\\n\",buffer_stack);\n```", "cwe": "134"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <mongoose.h> \r\n#include <string.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint wittering_uniatism = 0;\r\n\r\nstruct diggings_unordered \r\n{\r\n char *algeria_musked;\r\n double whelk_zostera;\r\n char *andrus_imitt;\r\n char attemper_degasify;\r\n int armhoop_myxospongian;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *qualificator_nonpropagandist);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct diggings_unordered yaounde_tyrosines(struct diggings_unordered transacting_conductible);\r\nvoid sala_chassepots(struct diggings_unordered nontolerable_all);\r\nstruct data {\r\n int qsize;\r\n int data_size;\r\n char *data;\r\n};\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid arrFunc (struct data *Data) {\r\n int *arr = malloc(sizeof(int) * Data->qsize);\r\n int i;\r\n int j;\r\n FILE *fp;\r\n static int ctr;\r\n \r\n \r\n ctr = 0; \r\n for(i = 0; \r\n i < Data->data_size; \r\n i++, ctr++)\r\n {\r\n \r\n Data->data[ctr] = '\\0';\r\n printf(\"I: %d, C: %d\\n\", i, ctr);\r\n if (Data->qsize > 5) {\r\n fp = fopen(\"asdfqwer1234\", \"w+\");\r\n fprintf(fp, \"%d\", i);\r\n fclose(fp);\r\n for (j = 0; j < Data->qsize; j++) {\r\n arr[j] = Data->qsize - j;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n }\r\n }\r\n free(arr);\r\n \r\n \r\n \r\n}\r\nvoid *replaceSymbols(void *data) {\r\n struct data *Data = data;\r\n int i;\r\n \r\n pthread_mutex_lock(&mutex);\r\n for(i = 0; i < Data->data_size; i++) {\r\n if (((Data->data[i] >= '!' && Data->data[i] <= '/') ||\r\n (Data->data[i] >= ':' && Data->data[i] <= '@') ||\r\n (Data->data[i] >= '[' && Data->data[i] <= '`') ||\r\n (Data->data[i] >= '{' && Data->data[i] <= '~')) &&\r\n (Data->data[i] != '@' && Data->data[i] != '.'))\r\n {\r\n Data->data[i] = '_';\r\n }\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n arrFunc(Data);\r\n return NULL;\r\n}\r\nvoid *toCaps(void *data) {\r\n struct data *Data = data;\r\n int threadTiming = 500000;\r\n int j;\r\n int *arr;\r\n int i;\r\n \r\n \r\n arr = malloc(sizeof(int)*threadTiming);\r\n if (arr != NULL) {\r\n for (j = 0; j < threadTiming; j++) {\r\n arr[j] = threadTiming - j;\r\n }\r\n qsort(arr, threadTiming, sizeof(int), &comp);\r\n free (arr);\r\n arr = NULL;\r\n }\r\n pthread_mutex_lock(&mutex);\r\n for(i = 0; i < Data->data_size; i++) {\r\n if(Data->data[i] >= 'a' && Data->data[i] <= 'z') {\r\n Data->data[i] -= 'a' - 'A';\r\n }\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n arrFunc(Data);\r\n return NULL;\r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&wittering_uniatism,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n#define LEPTOKURTOSIS_AQUA(x) sala_chassepots((struct diggings_unordered) x)\r\n\r\nvoid handle_taint(char *qualificator_nonpropagandist)\r\n{\r\n struct diggings_unordered markmote_bankings = {0};\r\n struct diggings_unordered smoothened_pratdesaba;\r\n ++global_variable;;\r\n if (qualificator_nonpropagandist != 0) {;\r\n smoothened_pratdesaba . algeria_musked = ((char *)qualificator_nonpropagandist);\r\n markmote_bankings = yaounde_tyrosines(smoothened_pratdesaba);\r\n\tLEPTOKURTOSIS_AQUA(markmote_bankings);\r\n }\r\n}\r\n\r\nstruct diggings_unordered yaounde_tyrosines(struct diggings_unordered transacting_conductible)\r\n{\r\n ++global_variable;\r\n return transacting_conductible;\r\n}\r\n\r\nvoid sala_chassepots(struct diggings_unordered nontolerable_all)\r\n{\r\n pthread_t t0, t1;\r\n struct data *Data = malloc(sizeof(struct data));\r\n char *chatting_phaneroscope = 0;\r\n ++global_variable;;\r\n chatting_phaneroscope = ((char *)nontolerable_all . algeria_musked);\r\n \r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(chatting_phaneroscope)+ 1));\r\n if (Data->data &&\r\n (sscanf(chatting_phaneroscope, \"%d %s\", &Data->qsize, Data->data) == 2) &&\r\n (strlen(Data->data) != 0)) {\r\n pthread_mutex_init(&mutex, NULL);\r\n Data->data_size = strlen(Data->data);\r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, replaceSymbols, (void*)Data) != 0) {\r\n printf(\"Error initilizing thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toCaps, (void*)Data) != 0) {\r\n printf(\"Error initilizing thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex);\r\n \r\n \r\n free(Data->data);\r\n \r\n }\r\n else {\r\n printf(\"Error parsing input.\\n\");\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (nontolerable_all . algeria_musked != 0) \r\n free(((char *)nontolerable_all . algeria_musked));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n free(Data->data);\n```", "cwe": "663"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint idiograph_alleman = 0;\r\nint global_variable;\r\n\r\nunion adenous_satsuma \r\n{\r\n char *evendown_vicing;\r\n double teamsters_polyplastic;\r\n char *craniognosy_hierarchic;\r\n char alg_paye;\r\n int asininities_lerne;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid zygion_assmannshausen(union adenous_satsuma *gynecomazia_cultured);\r\nint toupper(int c) {\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n#define MEDIZE_MEMORYLESS(x) zygion_assmannshausen((union adenous_satsuma *) x)\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n union adenous_satsuma *dowdy_sofa = {0};\r\n union adenous_satsuma anisotropically_orientality;\r\n char *worship_bridesman;;\r\n if (__sync_bool_compare_and_swap(&idiograph_alleman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n worship_bridesman = getenv(\"HOOL_NONCARTELIZED\");\r\n if (worship_bridesman != 0) {;\r\n anisotropically_orientality . evendown_vicing = worship_bridesman;\r\n dowdy_sofa = &anisotropically_orientality;\r\n\tMEDIZE_MEMORYLESS(dowdy_sofa);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid zygion_assmannshausen(union adenous_satsuma *gynecomazia_cultured)\r\n{\r\n int oc_i = 0;\r\n char stack_buffer_64[64];\r\n char *hirples_vindices = 0;\r\n ++global_variable;;\r\n hirples_vindices = ((char *)( *gynecomazia_cultured) . evendown_vicing);\r\n \r\n memset(stack_buffer_64,0,64);\r\n \r\n \r\n \r\n \r\n \r\n strcpy(stack_buffer_64,hirples_vindices);\r\n \r\n \r\n \r\n for (; oc_i < 64; ++oc_i) {\r\n stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",stack_buffer_64);\r\n \r\n \r\n \r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n;\nclose_printf_context();\n```", "cwe": "120"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint dui_ganglial = 0;\r\ntypedef char *unresidual_outburst;\r\nint global_variable;\r\nvoid dekaliters_anthropophagy(unresidual_outburst *jagras_boroglycerine);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid racketier_rubbernecking(void (*versation_anticoagulator)(unresidual_outburst *));\r\nunresidual_outburst maurita_copromoted(unresidual_outburst quires_representee);\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&dui_ganglial,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n racketier_rubbernecking(dekaliters_anthropophagy);\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid dekaliters_anthropophagy(unresidual_outburst *jagras_boroglycerine)\r\n{\r\n unresidual_outburst incarcerate_overswarm = 0;\r\n int macrochiran_unkeeled = 28;\r\n char *storying_cesure;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&storying_cesure,\"7752\",macrochiran_unkeeled);\r\n if (storying_cesure != 0) {;\r\n incarcerate_overswarm = storying_cesure;\r\n *jagras_boroglycerine = incarcerate_overswarm;\r\n }\r\n}\r\n\r\nvoid racketier_rubbernecking(void (*versation_anticoagulator)(unresidual_outburst *))\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *retinerved_nations = 0;\r\n unresidual_outburst preoccupies_kinds = 0;\r\n ++global_variable;\r\n unresidual_outburst difforme_seance = 0;\r\n versation_anticoagulator(&difforme_seance);\r\n if (difforme_seance != 0) {;\r\n preoccupies_kinds = maurita_copromoted(difforme_seance);\r\n retinerved_nations = ((char *)preoccupies_kinds);\r\n \r\n if (strlen(retinerved_nations) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n snprintf(command_buffer, 1000, \"%s%s\",command_str,retinerved_nations);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (preoccupies_kinds != 0) \r\n free(((char *)preoccupies_kinds));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nunresidual_outburst maurita_copromoted(unresidual_outburst quires_representee)\r\n{\r\n ++global_variable;\r\n return quires_representee;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint offshoots_sternforemost = 0;\r\nint global_variable;\r\nvoid handle_taint(char *malmock_albuminize);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct struct_data {\r\n char *buffer_member;\r\n unsigned short size_member;\r\n};\r\nstruct struct_data *init_data(long number_param)\r\n{\r\n \r\n struct struct_data *init_data_ptr = 0;\r\n init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\r\n if (init_data_ptr == 0)\r\n return 0;\r\n init_data_ptr -> size_member = 0;\r\n \r\n\r\n init_data_ptr -> size_member = number_param;\r\n init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\r\n \r\n \r\n \r\n if (init_data_ptr -> buffer_member == 0) {\r\n free(init_data_ptr);\r\n return 0;\r\n }\r\n memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\r\n init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\r\n return init_data_ptr;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&offshoots_sternforemost,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *malmock_albuminize)\r\n{\r\n long number;\r\n struct struct_data *data = 0;\r\n char *frouzy_feetage = 0;\r\n int fadlike_amnestying;\r\n int decanol_foursquarely;\r\n void *stinson_gilbertson = 0;\r\n int *stymphalian_presecular = 0;\r\n int iodometric_longjaw;\r\n void *cathartically_annihilable[10] = {0};\r\n void *pseudonavicula_blowhard = 0;\r\n ++global_variable;;\r\n if (malmock_albuminize != 0) {;\r\n pseudonavicula_blowhard = ((void *)malmock_albuminize);\r\n cathartically_annihilable[5] = pseudonavicula_blowhard;\r\n iodometric_longjaw = 5;\r\n stymphalian_presecular = &iodometric_longjaw;\r\n stinson_gilbertson = *(cathartically_annihilable + *stymphalian_presecular);\r\n decanol_foursquarely = 5;\r\n while(1 == 1){\r\n decanol_foursquarely = decanol_foursquarely * 2;\r\n decanol_foursquarely = decanol_foursquarely + 2;\r\n if (decanol_foursquarely > 1000) {\r\n break; \r\n }\r\n }\r\n fadlike_amnestying = decanol_foursquarely;\r\n frouzy_feetage = ((char *)((char *)stinson_gilbertson));\r\n \r\n number = strtol(frouzy_feetage,0U,10);\r\n if (number > 0) {\r\n data = init_data(number);\r\n if (data != 0) {\r\n \r\n\r\n memset(data -> buffer_member, 98, number);\r\n \r\n data -> buffer_member[number - 1] = 0;\r\n printf(\"%s\\n\", data -> buffer_member);\r\n if (data -> buffer_member != 0U)\r\n free(data -> buffer_member);\r\n if (data != 0U)\r\n free(data);\r\n }\r\n } else {\r\n printf(\"Input is less than or equal to 0\\n\");\r\n }\r\n \r\n;\r\n if (((char *)stinson_gilbertson) != 0) \r\n free(((char *)((char *)stinson_gilbertson)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n memset(data -> buffer_member, 98, number);\n```", "cwe": "197"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint vorticella_intumescing = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nsem_t sem;\r\npthread_t t0, t1;\r\nchar *global_str;\r\nint isspace(char c) {\r\n return (c == ' ' || c == '\\t' || c == '\\n');\r\n}\r\nvoid *replaceSpace () {\r\n int i = 0;\r\n printf(\"Replacing spaces\\n\");\r\n \r\n \r\n \r\n sem_wait(&sem); \r\n sem_wait(&sem);\r\n \r\n while(global_str[i] != '\\0') {\r\n if (isspace(global_str[i]) != 0) {\r\n global_str[i] = '_';\r\n }\r\n i++;\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\nvoid *toCap () {\r\n int i = 0;\r\n \r\n \r\n printf(\"Capitalizing input\\n\");\r\n sem_wait(&sem);\r\n \r\n while(global_str[i] != '\\0') {\r\n if (global_str[i] > 'a' && global_str[i] < 'z') {\r\n global_str[i] -= 'a' - 'A';\r\n }\r\n i++;\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int hasSpaces = 0;\r\n int i = 0;\r\n char *barbecuer_overheap = 0;\r\n char **cargos_obiism = 0;\r\n char **unirritableness_kun = 0;\r\n char *leisureless_boito;;\r\n if (__sync_bool_compare_and_swap(&vorticella_intumescing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n leisureless_boito = getenv(\"REUNE_SHOTTY\");\r\n if (leisureless_boito != 0) {;\r\n cargos_obiism = &leisureless_boito;\r\n unirritableness_kun = cargos_obiism + 5;\r\n if ( *(unirritableness_kun - 5) != 0) {\r\n goto tex_tourmalinize;\r\n }\r\n ++global_variable;\r\n tex_tourmalinize:;\r\n barbecuer_overheap = ((char *)( *(unirritableness_kun - 5)));\r\n \r\n sem_init(&sem, 0, 1);\r\n while(barbecuer_overheap[i] != '\\0') { \r\n if (isspace(barbecuer_overheap[i++]) != 0) { \r\n hasSpaces = 1;\r\n }\r\n }\r\n \r\n global_str = malloc(sizeof(char) * strlen(barbecuer_overheap) + 1);\r\n strcpy(global_str, barbecuer_overheap);\r\n if (hasSpaces == 1) {\r\n \r\n \r\n if (pthread_create(&t0, NULL, replaceSpace, NULL) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n \r\n }\r\n if (pthread_create(&t1, NULL, toCap, NULL) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n if (hasSpaces == 1) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n sem_wait(&sem); \n sem_wait(&sem);\n```", "cwe": "764"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint intermiddle_unwetted = 0;\r\n\r\nunion ascaricidal_richmonddale \r\n{\r\n char *collaterally_syzran;\r\n double wordsworth_yode;\r\n char *waganda_fiddlebrained;\r\n char girdler_corambis;\r\n int acrodactyla_recantingly;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nstruct struct {\r\n char before[64];\r\n char buffer[64];\r\n char after[64];\r\n};\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int i = 0;\r\n int buff_size = 0;\r\n struct struct* data = NULL;\r\n char *airbrushed_aneurysms = 0;\r\n int boathouses_trigeminous;\r\n union ascaricidal_richmonddale *pallia_defoliates = {0};\r\n union ascaricidal_richmonddale *philocathartic_pteridospermae = {0};\r\n union ascaricidal_richmonddale searcherlike_hesitating;\r\n char *fugaciously_steganopod;;\r\n if (__sync_bool_compare_and_swap(&intermiddle_unwetted,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&fugaciously_steganopod,\"LEVANTINE_REGINAS\");\r\n if (fugaciously_steganopod != 0) {;\r\n searcherlike_hesitating . collaterally_syzran = fugaciously_steganopod;\r\n boathouses_trigeminous = 1;\r\n pallia_defoliates = &searcherlike_hesitating;\r\n philocathartic_pteridospermae = ((union ascaricidal_richmonddale *)(((unsigned long )pallia_defoliates) * boathouses_trigeminous * boathouses_trigeminous)) + 5;\r\n airbrushed_aneurysms = ((char *)( *(philocathartic_pteridospermae - 5)) . collaterally_syzran);\r\n \r\n \r\n \r\n data = (struct struct*) malloc(sizeof(struct struct));\r\n if (data != NULL) {\r\n memset(data->before, 'A', 63);\r\n data->before[63] = '\\0';\r\n memset(data->buffer, 'Q', 63);\r\n data->buffer[63] = '\\0';\r\n memset(data->after, 'A', 63);\r\n data->after[63] = '\\0';\r\n \r\n \r\n \r\n \r\n \r\n buff_size = ((int )(strlen(airbrushed_aneurysms)));\r\n memcpy(data->buffer, airbrushed_aneurysms, 64);\r\n for (; i < buff_size; ++i){\r\n \r\n \r\n printf(\"%x\",data->buffer[i]);\r\n }\r\n \r\n \r\n \r\n printf(\"\\n\");\r\n free( data);\r\n \r\n \r\n }\r\n;\r\n if (( *(philocathartic_pteridospermae - 5)) . collaterally_syzran != 0) \r\n free(((char *)( *(philocathartic_pteridospermae - 5)) . collaterally_syzran));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` buff_size = ((int )(strlen(airbrushed_aneurysms)));\n memcpy(data->buffer, airbrushed_aneurysms, 64);\n for (; i < buff_size; ++i){\n \n \n printf(\"%x\",data->buffer[i]);\n }\n```", "cwe": "126"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint long_bebouldered = 0;\r\nint global_variable;\r\nvoid handle_taint(char *carolina_squalus);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nchar *counterstock_intraarterially(char *semarang_unadduceable);\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&long_bebouldered,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *carolina_squalus)\r\n{\r\n FILE *csv = 0;\r\n FILE *temp = 0;\r\n char col1[80] = {0};\r\n char col2[80] = {0};\r\n char col3[80] = {0};\r\n char *cols[3] = {0};\r\n char *firewater_naemorhedus = 0;\r\n int culvers_telophragma;\r\n int glisk_opinative;\r\n char *vermillion_parasigmatism = 0;\r\n int paralogician_vandyke = 0;\r\n char *flooding_climograph = 0;\r\n ++global_variable;;\r\n if (carolina_squalus != 0) {;\r\n paralogician_vandyke = ((int )(strlen(carolina_squalus)));\r\n flooding_climograph = ((char *)(malloc(paralogician_vandyke + 1)));\r\n if (flooding_climograph == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(flooding_climograph,0,paralogician_vandyke + 1);\r\n memcpy(flooding_climograph,carolina_squalus,paralogician_vandyke);\r\n if (carolina_squalus != 0) \r\n free(((char *)carolina_squalus));\r\n vermillion_parasigmatism = counterstock_intraarterially(flooding_climograph);\r\n glisk_opinative = 5;\r\n while(1 == 1){\r\n glisk_opinative = glisk_opinative * 2;\r\n glisk_opinative = glisk_opinative + 2;\r\n if (glisk_opinative > 1000) {\r\n break; \r\n }\r\n }\r\n culvers_telophragma = glisk_opinative;\r\n firewater_naemorhedus = ((char *)vermillion_parasigmatism);\r\n \r\n \r\n csv = fopen(firewater_naemorhedus,\"r\");\r\n if (csv != 0) {\r\n \r\n\r\n fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\r\n \r\n \r\n \r\n \r\n if (strlen(col1) > 0)\r\n cols[0] = col1;\r\n if (strlen(col2) > 0)\r\n cols[1] = col2;\r\n if (strlen(col3) > 0)\r\n cols[2] = col3;\r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n\r\n printf(\"VALUES=\\\"\");\r\n fputs(cols[0],temp);\r\n printf(cols[0]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[1],temp);\r\n printf(cols[1]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[2],temp);\r\n printf(cols[2]);\r\n \r\n printf(\"\\\"\\n\");\r\n fclose(temp);\r\n }\r\n }\r\n \r\n;\r\n if (vermillion_parasigmatism != 0) \r\n free(((char *)vermillion_parasigmatism));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nchar *counterstock_intraarterially(char *semarang_unadduceable)\r\n{\r\n ++global_variable;\r\n return semarang_unadduceable;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n printf(\"VALUES=\\\"\");\n fputs(cols[0],temp);\n printf(cols[0]);\n printf(\"\\\",\\\"\");\n fputs(cols[1],temp);\n printf(cols[1]);\n printf(\"\\\",\\\"\");\n fputs(cols[2],temp);\n printf(cols[2]);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint unpraying_norton = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid *avenida_tarnopol(void *monkeys_pegboards);\r\nstruct struct_data {\r\n char *buffer_member;\r\n unsigned short size_member;\r\n};\r\nstruct struct_data *init_data(long number_param)\r\n{\r\n \r\n struct struct_data *init_data_ptr = 0;\r\n init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\r\n if (init_data_ptr == 0)\r\n return 0;\r\n init_data_ptr -> size_member = 0;\r\n \r\n\r\n init_data_ptr -> size_member = number_param;\r\n init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\r\n \r\n \r\n \r\n if (init_data_ptr -> buffer_member == 0) {\r\n free(init_data_ptr);\r\n return 0;\r\n }\r\n memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\r\n init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\r\n return init_data_ptr;\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n long number;\r\n struct struct_data *data = 0;\r\n char *fossils_somatotonic = 0;\r\n void *beerish_eulogium = 0;\r\n void *barber_terrestrially = 0;\r\n int cinereal_signal = 7;\r\n char *lactonizing_corpn;;\r\n if (__sync_bool_compare_and_swap(&unpraying_norton,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&lactonizing_corpn,\"8516\",cinereal_signal);\r\n if (lactonizing_corpn != 0) {;\r\n barber_terrestrially = ((void *)lactonizing_corpn);\r\n beerish_eulogium = avenida_tarnopol(barber_terrestrially);\r\n if (((char *)beerish_eulogium) != 0) {\r\n goto ier_intrepidities;\r\n }\r\n ++global_variable;\r\n ier_intrepidities:;\r\n fossils_somatotonic = ((char *)((char *)beerish_eulogium));\r\n \r\n number = strtol(fossils_somatotonic,0U,10);\r\n if (number > 0) {\r\n data = init_data(number);\r\n if (data != 0) {\r\n \r\n\r\n memset(data -> buffer_member, 98, number);\r\n \r\n data -> buffer_member[number - 1] = 0;\r\n printf(\"%s\\n\", data -> buffer_member);\r\n if (data -> buffer_member != 0U)\r\n free(data -> buffer_member);\r\n if (data != 0U)\r\n free(data);\r\n }\r\n } else {\r\n printf(\"Input is less than or equal to 0\\n\");\r\n }\r\n \r\n;\r\n if (((char *)beerish_eulogium) != 0) \r\n free(((char *)((char *)beerish_eulogium)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid *avenida_tarnopol(void *monkeys_pegboards)\r\n{\r\n ++global_variable;\r\n return monkeys_pegboards;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n memset(data -> buffer_member, 98, number);\n```", "cwe": "197"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_AES\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/aes.h>\r\n#include \"evp_locl.h\"\r\n#ifndef OPENSSL_FIPS\r\n#include \"modes_lcl.h\"\r\n#include <openssl/rand.h>\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nAES_KEY ks;\r\nblock128_f block;\r\nunion {\r\ncbc128_f cbc;\r\nctr128_f ctr;}stream;}EVP_AES_KEY;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\nGCM128_CONTEXT gcm;\r\n\r\nunsigned char *iv;\r\n\r\nint ivlen;\r\nint taglen;\r\n\r\nint iv_gen;\r\n\r\nint tls_aad_len;\r\nctr128_f ctr;}EVP_AES_GCM_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks1;\r\nAES_KEY ks2;\r\nXTS128_CONTEXT xts;\r\nvoid (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\n\r\nint tag_set;\r\n\r\nint len_set;\r\n\r\nint L;\r\nint M;\r\nCCM128_CONTEXT ccm;\r\nccm128_f str;}EVP_AES_CCM_CTX;\r\n#define MAXBITCHUNK\t((size_t)1<<(sizeof(size_t)*8-4))\r\n#ifdef VPAES_ASM\r\nextern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\n#endif\r\n#ifdef BSAES_ASM\r\nextern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc);\r\nextern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]);\r\nextern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\n#endif\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n#ifdef AES_XTS_ASM\r\n#endif\r\n#if\tdefined(AES_ASM) && !defined(I386_ONLY) &&\t( \\\r\n\t((defined(__i386)\t|| defined(__i386__)\t|| \\\r\n\t defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \\\r\n\tdefined(__x86_64)\t|| defined(__x86_64__)\t|| \\\r\n\tdefined(_M_AMD64)\t|| defined(_M_X64)\t|| \\\r\n\tdefined(__INTEL__)\t\t\t\t)\r\nextern unsigned int OPENSSL_ia32cap_P[2];\r\n#ifdef VPAES_ASM\r\n#define VPAES_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(41-32)))\r\n#endif\r\n#ifdef BSAES_ASM\r\n#define BSAES_CAPABLE\tVPAES_CAPABLE\r\n#endif\r\n\r\n#define\tAESNI_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(57-32)))\r\nextern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc);\r\nextern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\nextern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec);\r\nextern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nextern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nint clava_hepatotoxicity = 0;\r\nint global_variable;\r\nvoid handle_taint(char *decorticate_respondendum);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid hoorahs_oversick(char **huxtable_bioclimatician);\r\nchar process_buffer(char *buffer_param)\r\n{\r\n \r\n char first_char;\r\n first_char = buffer_param[0] - 97;\r\n free(buffer_param);\r\n return first_char;\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic int aesni_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n ret = aesni_set_decrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )aesni_cbc_encrypt) : ((void *)0));\r\n }\r\n else {\r\n ret = aesni_set_encrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_encrypt);\r\n if (mode == 0x2) {\r\n dat -> stream . cbc = ((cbc128_f )aesni_cbc_encrypt);\r\n }\r\n else {\r\n if (mode == 0x5) {\r\n dat -> stream . ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n dat -> stream . cbc = ((void *)0);\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,165,143,\"e_aes.c\",258);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n aesni_cbc_encrypt(in,out,len,(ctx -> cipher_data),ctx -> iv,ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n aesni_ecb_encrypt(in,out,len,(ctx -> cipher_data),ctx -> encrypt);\r\n return 1;\r\n}\r\n#define aesni_ofb_cipher aes_ofb_cipher\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb_cipher aes_cfb_cipher\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb8_cipher aes_cfb8_cipher\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb1_cipher aes_cfb1_cipher\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_ctr_cipher aes_ctr_cipher\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )aesni_encrypt));\r\n gctx -> ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n#define aesni_gcm_cipher aes_gcm_cipher\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n\r\n if (enc) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_encrypt);\r\n xctx -> stream = aesni_xts_encrypt;\r\n }\r\n else {\r\n aesni_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_decrypt);\r\n xctx -> stream = aesni_xts_decrypt;\r\n }\r\n aesni_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )aesni_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n#define aesni_xts_cipher aes_xts_cipher\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )aesni_encrypt));\r\n cctx -> str = (enc?((ccm128_f )aesni_ccm64_encrypt_blocks) : ((ccm128_f )aesni_ccm64_decrypt_blocks));\r\n cctx -> key_set = 1;\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n#define aesni_ccm_cipher aes_ccm_cipher\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_init_key,\t\t\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,\t\\\r\n\tkeylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_##mode##_init_key,\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#else\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#endif\r\n#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)\t\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)\r\n\r\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x2) {\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = ((cbc128_f )bsaes_cbc_encrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n }\r\n }\r\n }\r\n else {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x5) {\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,133,143,\"e_aes.c\",567);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . cbc) {\r\n ( *dat -> stream . cbc)(in,out,len,(&dat -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n else {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n size_t i;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n for ((i = 0 , len -= bl); i <= len; i += bl) \r\n ( *dat -> block)(in + i,out + i,(&dat -> ks));\r\n return 1;\r\n}\r\n\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_ofb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_8_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (ctx -> flags & 0x2000) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n }\r\n while(len >= ((size_t )1) << sizeof(size_t ) * 8 - 4){\r\n CRYPTO_cfb128_1_encrypt(in,out,(((size_t )1) << sizeof(size_t ) * 8 - 4) * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n len -= ((size_t )1) << sizeof(size_t ) * 8 - 4;\r\n }\r\n if (len) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n unsigned int num = (ctx -> num);\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . ctr) {\r\n CRYPTO_ctr128_encrypt_ctr32(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> stream . ctr);\r\n }\r\n else {\r\n CRYPTO_ctr128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> block);\r\n }\r\n ctx -> num = ((size_t )num);\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cbc : &aes_128_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ecb : &aes_128_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ofb : &aes_128_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb : &aes_128_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb1 : &aes_128_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb8 : &aes_128_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ctr : &aes_128_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cbc : &aes_192_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ecb : &aes_192_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ofb : &aes_192_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb : &aes_192_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb1 : &aes_192_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb8()\r\n{;\r\n if (__sync_bool_compare_and_swap(&clava_hepatotoxicity,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb8 : &aes_192_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ctr : &aes_192_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cbc : &aes_256_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ecb : &aes_256_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ofb : &aes_256_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb : &aes_256_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb1 : &aes_256_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb8 : &aes_256_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ctr : &aes_256_ctr;\r\n}\r\n\r\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n OPENSSL_cleanse((&gctx -> gcm),sizeof(gctx -> gcm));\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic void ctr64_inc(unsigned char *counter)\r\n{\r\n int n = 8;\r\n unsigned char c;\r\n do {\r\n --n;\r\n c = counter[n];\r\n ++c;\r\n counter[n] = c;\r\n if (c) {\r\n return ;\r\n }\r\n }while (n);\r\n}\r\n\r\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n gctx -> key_set = 0;\r\n gctx -> iv_set = 0;\r\n gctx -> ivlen = c -> cipher -> iv_len;\r\n gctx -> iv = c -> iv;\r\n gctx -> taglen = - 1;\r\n gctx -> iv_gen = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return 1;\r\n }\r\n case 0x9:\r\n{\r\n if (arg <= 0) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n#endif\r\n\r\n if (arg > 16 && arg > gctx -> ivlen) {\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n gctx -> iv = (CRYPTO_malloc(((int )arg),\"e_aes.c\",728));\r\n if (!gctx -> iv) {\r\n return 0;\r\n }\r\n }\r\n gctx -> ivlen = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg <= 0 || arg > 16 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> taglen = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (arg <= 0 || arg > 16 || !c -> encrypt || gctx -> taglen < 0) {\r\n return 0;\r\n }\r\n memcpy(ptr,(c -> buf),arg);\r\n return 1;\r\n }\r\n case 0x12:\r\n{\r\n\r\n if (arg == - 1) {\r\n memcpy((gctx -> iv),ptr,(gctx -> ivlen));\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n\r\n if (arg < 4 || gctx -> ivlen - arg < 8) {\r\n return 0;\r\n }\r\n if (arg) {\r\n memcpy((gctx -> iv),ptr,arg);\r\n }\r\n if (c -> encrypt && RAND_bytes(gctx -> iv + arg,gctx -> ivlen - arg) <= 0) {\r\n return 0;\r\n }\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n case 0x13:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0) {\r\n return 0;\r\n }\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n if (arg <= 0 || arg > gctx -> ivlen) {\r\n arg = gctx -> ivlen;\r\n }\r\n memcpy(ptr,(gctx -> iv + gctx -> ivlen - arg),arg);\r\n\r\n ctr64_inc(gctx -> iv + gctx -> ivlen - 8);\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x18:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((gctx -> iv + gctx -> ivlen - arg),ptr,arg);\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x16:\r\n{\r\n\r\n if (arg != 13) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> tls_aad_len = arg;\r\n{\r\n unsigned int len = (c -> buf[arg - 2] << 8 | c -> buf[arg - 1]);\r\n\r\n len -= 8;\r\n\r\n if (!c -> encrypt) {\r\n len -= 16;\r\n }\r\n c -> buf[arg - 2] = (len >> 8);\r\n c -> buf[arg - 1] = (len & 0xff);\r\n }\r\n\r\n return 16;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n gctx -> ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n break; \r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )vpaes_encrypt));\r\n gctx -> ctr = ((void *)0);\r\n break; \r\n }\r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n#ifdef AES_CTR_ASM\r\n#else\r\n gctx -> ctr = ((void *)0);\r\n#endif\r\n }while (0);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n int rv = - 1;\r\n\r\n if (out != in || len < (8 + 16)) {\r\n return - 1;\r\n }\r\n\r\n if (EVP_CIPHER_CTX_ctrl(ctx,(ctx -> encrypt?0x13 : 0x18),8,out) <= 0) {\r\n goto err;\r\n }\r\n\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,(ctx -> buf),(gctx -> tls_aad_len))) {\r\n goto err;\r\n }\r\n\r\n in += 8;\r\n out += 8;\r\n len -= (8 + 16);\r\n if (ctx -> encrypt) {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n out += len;\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,out,16);\r\n rv = (len + 8 + 16);\r\n }\r\n else {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n\r\n if (memcmp((ctx -> buf),(in + len),16)) {\r\n OPENSSL_cleanse(out,len);\r\n goto err;\r\n }\r\n rv = len;\r\n }\r\n err:\r\n gctx -> iv_set = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return rv;\r\n}\r\n\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n\r\n if (!gctx -> key_set) {\r\n return - 1;\r\n }\r\n if (gctx -> tls_aad_len >= 0) {\r\n return aes_gcm_tls_cipher(ctx,out,in,len);\r\n }\r\n if (!gctx -> iv_set) {\r\n return - 1;\r\n }\r\n if (in) {\r\n if (out == ((void *)0)) {\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,in,len)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n else {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n }\r\n return len;\r\n }\r\n else {\r\n if (!ctx -> encrypt) {\r\n if (gctx -> taglen < 0) {\r\n return - 1;\r\n }\r\n if (CRYPTO_gcm128_finish(&gctx -> gcm,(ctx -> buf),(gctx -> taglen)) != 0) {\r\n return - 1;\r\n }\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n gctx -> taglen = 16;\r\n\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n}\r\n#define CUSTOM_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 \\\r\n\t\t| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\\r\n\t\t| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_gcm : &aes_128_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_gcm : &aes_192_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_gcm : &aes_256_gcm;\r\n}\r\n\r\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (c -> cipher_data);\r\n if (type != 0) {\r\n return - 1;\r\n }\r\n\r\n xctx -> xts . key1 = ((void *)0);\r\n xctx -> xts . key2 = ((void *)0);\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef AES_XTS_ASM\r\n#else\r\n xctx -> stream = ((void *)0);\r\n#endif\r\n\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n xctx -> stream = (enc?bsaes_xts_encrypt : bsaes_xts_decrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n if (enc) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_encrypt);\r\n }\r\n else {\r\n vpaes_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_decrypt);\r\n }\r\n vpaes_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )vpaes_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n break; \r\n }\r\n }\r\n#endif\r\n if (enc) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_encrypt);\r\n }\r\n else {\r\n AES_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_decrypt);\r\n }\r\n AES_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )AES_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }while (0);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!xctx -> xts . key1 || !xctx -> xts . key2) {\r\n return 0;\r\n }\r\n if (!out || !in || len < 16) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n\r\n#endif\r\n if (xctx -> stream) {\r\n ( *xctx -> stream)(in,out,len,xctx -> xts . key1,xctx -> xts . key2,(ctx -> iv));\r\n }\r\n else {\r\n if (CRYPTO_xts128_encrypt((&xctx -> xts),(ctx -> iv),in,out,len,ctx -> encrypt)) {\r\n return 0;\r\n }\r\n }\r\n return 1;\r\n}\r\n#define aes_xts_cleanup NULL\r\n#define XTS_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\\r\n\t\t\t | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_xts : &aes_128_xts;\r\n}\r\nstatic const EVP_CIPHER aesni_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_xts : &aes_256_xts;\r\n}\r\n\r\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n cctx -> key_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> L = 8;\r\n cctx -> M = 12;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n case 0x9:\r\n arg = 15 - arg;\r\n case 0x14:\r\n{\r\n if (arg < 2 || arg > 8) {\r\n return 0;\r\n }\r\n cctx -> L = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg & 1 || arg < 4 || arg > 16) {\r\n return 0;\r\n }\r\n if (c -> encrypt && ptr || !c -> encrypt && !ptr) {\r\n return 0;\r\n }\r\n if (ptr) {\r\n cctx -> tag_set = 1;\r\n memcpy((c -> buf),ptr,arg);\r\n }\r\n cctx -> M = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (!c -> encrypt || !cctx -> tag_set) {\r\n return 0;\r\n }\r\n if (!CRYPTO_ccm128_tag(&cctx -> ccm,ptr,((size_t )arg))) {\r\n return 0;\r\n }\r\n cctx -> tag_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )vpaes_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n break; \r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )AES_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n }while (0);\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n CCM128_CONTEXT *ccm = &cctx -> ccm;\r\n\r\n if (!cctx -> iv_set && !cctx -> key_set) {\r\n return - 1;\r\n }\r\n if (!ctx -> encrypt && !cctx -> tag_set) {\r\n return - 1;\r\n }\r\n if (!out) {\r\n if (!in) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n return len;\r\n }\r\n\r\n if (!cctx -> len_set && len) {\r\n return - 1;\r\n }\r\n CRYPTO_ccm128_aad(ccm,in,len);\r\n return len;\r\n }\r\n\r\n if (!in) {\r\n return 0;\r\n }\r\n\r\n if (!cctx -> len_set) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n }\r\n if (ctx -> encrypt) {\r\n if (cctx -> str?CRYPTO_ccm128_encrypt_ccm64(ccm,in,out,len,cctx -> str) : CRYPTO_ccm128_encrypt(ccm,in,out,len)) {\r\n return - 1;\r\n }\r\n cctx -> tag_set = 1;\r\n return len;\r\n }\r\n else {\r\n int rv = - 1;\r\n if (cctx -> str?!CRYPTO_ccm128_decrypt_ccm64(ccm,in,out,len,cctx -> str) : !CRYPTO_ccm128_decrypt(ccm,in,out,len)) {\r\n unsigned char tag[16];\r\n if (CRYPTO_ccm128_tag(ccm,tag,(cctx -> M))) {\r\n if (!memcmp(tag,(ctx -> buf),(cctx -> M))) {\r\n rv = len;\r\n }\r\n }\r\n }\r\n if (rv == - 1) {\r\n OPENSSL_cleanse(out,len);\r\n }\r\n cctx -> iv_set = 0;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return rv;\r\n }\r\n}\r\n#define aes_ccm_cleanup NULL\r\nstatic const EVP_CIPHER aesni_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ccm : &aes_128_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ccm : &aes_192_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ccm : &aes_256_ccm;\r\n}\r\n#define WORKUP_GNARLING(x) hoorahs_oversick((char **) x)\r\n\r\nvoid handle_taint(char *decorticate_respondendum)\r\n{\r\n int sermoniser_nonylene;\r\n char **telexed_defension = 0;\r\n char **daphnephoria_balaniferous = 0;\r\n int istanbul_sops = 0;\r\n char *quantitively_pardner = 0;\r\n ++global_variable;;\r\n if (decorticate_respondendum != 0) {;\r\n istanbul_sops = ((int )(strlen(decorticate_respondendum)));\r\n quantitively_pardner = ((char *)(malloc(istanbul_sops + 1)));\r\n if (quantitively_pardner == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(quantitively_pardner,0,istanbul_sops + 1);\r\n memcpy(quantitively_pardner,decorticate_respondendum,istanbul_sops);\r\n if (decorticate_respondendum != 0) \r\n free(((char *)decorticate_respondendum));\r\n sermoniser_nonylene = 1;\r\n telexed_defension = &quantitively_pardner;\r\n daphnephoria_balaniferous = ((char **)(((unsigned long )telexed_defension) * sermoniser_nonylene * sermoniser_nonylene)) + 5;\r\n\tWORKUP_GNARLING(daphnephoria_balaniferous);\r\n }\r\n}\r\n\r\nvoid hoorahs_oversick(char **huxtable_bioclimatician)\r\n{\r\n int oc_i = 0;\r\n int tainted_len;\r\n char **buffer_ptr = 0;\r\n int main_first_char = 0;\r\n int buffer_len;\r\n char *buffer = 0;\r\n char *timothies_demeanor = 0;\r\n ++global_variable;;\r\n timothies_demeanor = ((char *)( *(huxtable_bioclimatician - 5)));\r\n \r\n buffer_len = 4;\r\n buffer = malloc(65528);\r\n if (buffer != NULL) {\r\n strncpy(buffer, timothies_demeanor, buffer_len);\r\n buffer[buffer_len - 1] = 0;\r\n printf(\"%s\\n\", buffer);\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n if (buffer[0] >= 97) {\r\n \r\n main_first_char = process_buffer(buffer);\r\n }\r\n \r\n buffer_ptr = malloc(65528);\r\n \r\n if (buffer_ptr != NULL) {\r\n *buffer_ptr = timothies_demeanor;\r\n \r\n \r\n \r\n \r\n \r\n strncpy(buffer, timothies_demeanor, buffer_len);\r\n buffer[buffer_len - 1] = '\\0';\r\n tainted_len = strlen( *buffer_ptr); \r\n \r\n printf(\"%c\\n\", main_first_char);\r\n for (; oc_i < buffer_len; ++oc_i) {\r\n buffer[oc_i] = toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\", buffer);\r\n if (main_first_char == 0) {\r\n if (buffer != 0) {\r\n free(buffer);\r\n }\r\n }\r\n if (buffer_ptr != 0) {\r\n free(buffer_ptr);\r\n }\r\n }\r\n }\r\n \r\n;\r\n if ( *(huxtable_bioclimatician - 5) != 0) \r\n free(((char *)( *(huxtable_bioclimatician - 5))));\r\nclose_printf_context();\r\n}\r\n#endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n strncpy(buffer, timothies_demeanor, buffer_len);\n buffer[buffer_len - 1] = '\\0';\n tainted_len = strlen( *buffer_ptr); \n```", "cwe": "416"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include <stdio.h> \r\n#include </trace.h> \r\nint aggrieve_arguing = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nchar *ower_unfarsighted(char *furtherer_rabiform);\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ss_i = 0;\r\n char* heap_buff_64;\r\n int buff_size;\r\n char *pluteus_hallan = 0;\r\n int camerlingos_barberton;\r\n int bosc_tartary;\r\n char *fredrick_porchlike = 0;\r\n int eugeny_animadversions = 0;\r\n char *fringelike_lactation = 0;\r\n char *furcule_malayalam;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&aggrieve_arguing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n furcule_malayalam = getenv(\"COALFIELD_COMIQUE\");\r\n if (furcule_malayalam != 0) {;\r\n eugeny_animadversions = ((int )(strlen(furcule_malayalam)));\r\n fringelike_lactation = ((char *)(malloc(eugeny_animadversions + 1)));\r\n if (fringelike_lactation == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(fringelike_lactation,0,eugeny_animadversions + 1);\r\n memcpy(fringelike_lactation,furcule_malayalam,eugeny_animadversions);\r\n fredrick_porchlike = ower_unfarsighted(fringelike_lactation);\r\n bosc_tartary = 5;\r\n while(1 == 1){\r\n bosc_tartary = bosc_tartary * 2;\r\n bosc_tartary = bosc_tartary + 2;\r\n if (bosc_tartary > 1000) {\r\n break; \r\n }\r\n }\r\n camerlingos_barberton = bosc_tartary;\r\n pluteus_hallan = ((char *)fredrick_porchlike);\r\n \r\n heap_buff_64 = (char*) malloc(64 * sizeof(char));\r\n \r\n if (heap_buff_64 != NULL) {\r\n memset(heap_buff_64,'A',63);\r\n heap_buff_64[63] = '\\0';\r\n \r\n buff_size = ((int )(strlen(pluteus_hallan)));\r\n strncpy(heap_buff_64, pluteus_hallan, 64);\r\n \r\n \r\n \r\n for (; ss_i < buff_size; ++ss_i){\r\n \r\n \r\n printf(\"%02x\",heap_buff_64[ss_i]);\r\n }\r\n \r\n \r\n \r\n printf(\"\\n\");\r\n free( heap_buff_64);\r\n \r\n \r\n }\r\n;\r\n if (fredrick_porchlike != 0) \r\n free(((char *)fredrick_porchlike));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nchar *ower_unfarsighted(char *furtherer_rabiform)\r\n{\r\n ++global_variable;\r\n return furtherer_rabiform;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (; ss_i < buff_size; ++ss_i){\n \n \n printf(\"%02x\",heap_buff_64[ss_i]);\n }\n```", "cwe": "126"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint dacryohelcosis_mashgiach = 0;\r\nint global_variable;\r\n\r\nunion michaux_kindergartens \r\n{\r\n char *hyperdulia_faithwise;\r\n double dehumidifies_orbate;\r\n char *sulfamyl_levered;\r\n char otha_anthelix;\r\n int parabasis_larree;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *churchton_predivinable = 0;\r\n union michaux_kindergartens **************************************************rinka_squilgee = 0;\r\n union michaux_kindergartens *************************************************jalousie_talipat = 0;\r\n union michaux_kindergartens ************************************************eleoptene_unwassailing = 0;\r\n union michaux_kindergartens ***********************************************lyssa_dysergia = 0;\r\n union michaux_kindergartens **********************************************allegoriser_defaces = 0;\r\n union michaux_kindergartens *********************************************kakistocracy_relucts = 0;\r\n union michaux_kindergartens ********************************************radiatics_psychostatical = 0;\r\n union michaux_kindergartens *******************************************neuropod_musket = 0;\r\n union michaux_kindergartens ******************************************clonorchiasis_salicylanilide = 0;\r\n union michaux_kindergartens *****************************************enfoncee_guarache = 0;\r\n union michaux_kindergartens ****************************************architricline_cuerpo = 0;\r\n union michaux_kindergartens ***************************************talliating_oneiroscopist = 0;\r\n union michaux_kindergartens **************************************southings_glamourization = 0;\r\n union michaux_kindergartens *************************************connotes_proportionless = 0;\r\n union michaux_kindergartens ************************************illiteracy_apocentre = 0;\r\n union michaux_kindergartens ***********************************quality_pourboires = 0;\r\n union michaux_kindergartens **********************************eldon_zigzagways = 0;\r\n union michaux_kindergartens *********************************unextended_shoq = 0;\r\n union michaux_kindergartens ********************************unamused_unsailed = 0;\r\n union michaux_kindergartens *******************************regalvanization_rosita = 0;\r\n union michaux_kindergartens ******************************overprotected_priacanthid = 0;\r\n union michaux_kindergartens *****************************laryngopharynx_sepiidae = 0;\r\n union michaux_kindergartens ****************************enologist_limites = 0;\r\n union michaux_kindergartens ***************************apozemical_uselessly = 0;\r\n union michaux_kindergartens **************************preferredness_bradyuria = 0;\r\n union michaux_kindergartens *************************superalkalinity_sped = 0;\r\n union michaux_kindergartens ************************eighteens_defension = 0;\r\n union michaux_kindergartens ***********************guenons_overeate = 0;\r\n union michaux_kindergartens **********************eromania_erf = 0;\r\n union michaux_kindergartens *********************triumviry_nonlubricating = 0;\r\n union michaux_kindergartens ********************fatefulness_jaculate = 0;\r\n union michaux_kindergartens *******************unremovable_soundproofed = 0;\r\n union michaux_kindergartens ******************drunkennesses_maternally = 0;\r\n union michaux_kindergartens *****************malikite_indone = 0;\r\n union michaux_kindergartens ****************sputum_dispensatory = 0;\r\n union michaux_kindergartens ***************cancellated_scimitared = 0;\r\n union michaux_kindergartens **************anconad_supplementer = 0;\r\n union michaux_kindergartens *************unreformedness_omphaloncus = 0;\r\n union michaux_kindergartens ************cesure_openheartedness = 0;\r\n union michaux_kindergartens ***********overdesirous_unfairer = 0;\r\n union michaux_kindergartens **********compulse_coproduction = 0;\r\n union michaux_kindergartens *********ville_bitterer = 0;\r\n union michaux_kindergartens ********bemuzzling_coprophagist = 0;\r\n union michaux_kindergartens *******maliceproof_calabrese = 0;\r\n union michaux_kindergartens ******nonreplicate_unfeued = 0;\r\n union michaux_kindergartens *****groof_thock = 0;\r\n union michaux_kindergartens ****silversmithing_deescalating = 0;\r\n union michaux_kindergartens ***dyophysitism_dubhe = 0;\r\n union michaux_kindergartens **bivouacked_absoluteness = 0;\r\n union michaux_kindergartens *donnelly_comforter = 0;\r\n union michaux_kindergartens anodynia_unacceptant = {0};\r\n union michaux_kindergartens endenization_conquerableness;\r\n char *polysyllabical_strawiest;;\r\n if (__sync_bool_compare_and_swap(&dacryohelcosis_mashgiach,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&polysyllabical_strawiest,\"EXTRADITING_COTATI\");\r\n if (polysyllabical_strawiest != 0) {;\r\n endenization_conquerableness . hyperdulia_faithwise = polysyllabical_strawiest;\r\n donnelly_comforter = &endenization_conquerableness;\r\n bivouacked_absoluteness = &donnelly_comforter;\r\n dyophysitism_dubhe = &bivouacked_absoluteness;\r\n silversmithing_deescalating = &dyophysitism_dubhe;\r\n groof_thock = &silversmithing_deescalating;\r\n nonreplicate_unfeued = &groof_thock;\r\n maliceproof_calabrese = &nonreplicate_unfeued;\r\n bemuzzling_coprophagist = &maliceproof_calabrese;\r\n ville_bitterer = &bemuzzling_coprophagist;\r\n compulse_coproduction = &ville_bitterer;\r\n overdesirous_unfairer = &compulse_coproduction;\r\n cesure_openheartedness = &overdesirous_unfairer;\r\n unreformedness_omphaloncus = &cesure_openheartedness;\r\n anconad_supplementer = &unreformedness_omphaloncus;\r\n cancellated_scimitared = &anconad_supplementer;\r\n sputum_dispensatory = &cancellated_scimitared;\r\n malikite_indone = &sputum_dispensatory;\r\n drunkennesses_maternally = &malikite_indone;\r\n unremovable_soundproofed = &drunkennesses_maternally;\r\n fatefulness_jaculate = &unremovable_soundproofed;\r\n triumviry_nonlubricating = &fatefulness_jaculate;\r\n eromania_erf = &triumviry_nonlubricating;\r\n guenons_overeate = &eromania_erf;\r\n eighteens_defension = &guenons_overeate;\r\n superalkalinity_sped = &eighteens_defension;\r\n preferredness_bradyuria = &superalkalinity_sped;\r\n apozemical_uselessly = &preferredness_bradyuria;\r\n enologist_limites = &apozemical_uselessly;\r\n laryngopharynx_sepiidae = &enologist_limites;\r\n overprotected_priacanthid = &laryngopharynx_sepiidae;\r\n regalvanization_rosita = &overprotected_priacanthid;\r\n unamused_unsailed = &regalvanization_rosita;\r\n unextended_shoq = &unamused_unsailed;\r\n eldon_zigzagways = &unextended_shoq;\r\n quality_pourboires = &eldon_zigzagways;\r\n illiteracy_apocentre = &quality_pourboires;\r\n connotes_proportionless = &illiteracy_apocentre;\r\n southings_glamourization = &connotes_proportionless;\r\n talliating_oneiroscopist = &southings_glamourization;\r\n architricline_cuerpo = &talliating_oneiroscopist;\r\n enfoncee_guarache = &architricline_cuerpo;\r\n clonorchiasis_salicylanilide = &enfoncee_guarache;\r\n neuropod_musket = &clonorchiasis_salicylanilide;\r\n radiatics_psychostatical = &neuropod_musket;\r\n kakistocracy_relucts = &radiatics_psychostatical;\r\n allegoriser_defaces = &kakistocracy_relucts;\r\n lyssa_dysergia = &allegoriser_defaces;\r\n eleoptene_unwassailing = &lyssa_dysergia;\r\n jalousie_talipat = &eleoptene_unwassailing;\r\n rinka_squilgee = &jalousie_talipat;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *rinka_squilgee)))))))))))))))))))))))))))))))))))))))))))))))))) . hyperdulia_faithwise != 0) {\r\n goto suggesta_benames;\r\n }\r\n ++global_variable;\r\n suggesta_benames:;\r\n churchton_predivinable = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *rinka_squilgee)))))))))))))))))))))))))))))))))))))))))))))))))) . hyperdulia_faithwise);\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(churchton_predivinable); ++i) {\r\n if (churchton_predivinable[i] == ';') {\r\n if (i == 0 || churchton_predivinable[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,churchton_predivinable);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *rinka_squilgee)))))))))))))))))))))))))))))))))))))))))))))))))) . hyperdulia_faithwise != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *rinka_squilgee)))))))))))))))))))))))))))))))))))))))))))))))))) . hyperdulia_faithwise));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <mongoose.h> \r\n#include <string.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\n#include <sys/stat.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint cortices_surnaming = 0;\r\nint global_variable;\r\nvoid handle_taint(char *puschkinia_terzet);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\npthread_t t0, t1, t2;\r\nsem_t sem;\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int *arr;\r\n int i = 0;\r\n int i = 0;\r\n \r\n printf(\"Inside toCap\\n\");\r\n \r\n sem_wait(&sem); \r\n \r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n for(i = 0; i < strlen(Data->data); i++) {\r\n if (Data->data[i] >= 'a' && Data->data[i] <= 'z') { \r\n Data->data[i] -= 32; \r\n }\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\nint isalpha(char c) {\r\n return ((c >= 'A' && c <= 'Z') ||\r\n (c >= 'a' && c <= 'z'));\r\n}\r\nvoid *delNonAlpha (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n int j = 0;\r\n char *temp = NULL;\r\n \r\n printf(\"Inside delNonAlpha\\n\");\r\n \r\n sem_wait(&sem);\r\n temp = malloc(sizeof(char) * (strlen(Data->data) + 1));\r\n while(Data->data[i] != '\\0') {\r\n if (isalpha(Data->data[i])) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[++j] = '\\0';\r\n free(Data->data);\r\n Data->data = NULL; \r\n \r\n \r\n readFile(Data->file2);\r\n \r\n Data->data = temp;\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&cortices_surnaming,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid handle_taint(char *puschkinia_terzet)\r\n{\r\n pthread_t t0, t1;\r\n int hasNonAlpha = 0;\r\n int i = 0;\r\n struct data* Data;\r\n char *excitive_lietuva = 0;\r\n int ihs_printable;\r\n char **oikophobia_spreed = 0;\r\n char **quaintnesses_lambitive = 0;\r\n char *outdress_nolition[27] = {0};\r\n ++global_variable;;\r\n if (puschkinia_terzet != 0) {;\r\n outdress_nolition[23] = puschkinia_terzet;\r\n ihs_printable = 1;\r\n oikophobia_spreed = outdress_nolition;\r\n quaintnesses_lambitive = ((char **)(((unsigned long )oikophobia_spreed) * ihs_printable * ihs_printable)) + 5;\r\n excitive_lietuva = ((char *)(quaintnesses_lambitive - 5)[23]);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(excitive_lietuva) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(excitive_lietuva) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(excitive_lietuva) + 1));\r\n if (Data->data) {\r\n if ((sscanf(excitive_lietuva, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0)) {\r\n sem_init(&sem, 0, 1);\r\n while (Data->data[i] != '\\0') { \r\n if(isalpha(Data->data[i]) == 0) {\r\n hasNonAlpha = 1;\r\n }\r\n i++;\r\n }\r\n if (hasNonAlpha != 0) {\r\n \r\n \r\n sem_post(&sem);\r\n pthread_create(&t0, NULL, delNonAlpha, Data); \r\n \r\n } \r\n pthread_create(&t1, NULL, toCap, Data);\r\n if (hasNonAlpha != 0) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n } else {\r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ((quaintnesses_lambitive - 5)[23] != 0) \r\n free(((char *)(quaintnesses_lambitive - 5)[23]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n readFile(Data->file2);\n```", "cwe": "765"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint galvanographic_racily = 0;\r\n\r\nstruct electrobiology_treasonous \r\n{\r\n char *disenabled_endeign;\r\n double landskip_cumming;\r\n char *coact_factionism;\r\n char tympani_darcey;\r\n int mesotherm_retaker;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n FILE *csv = 0;\r\n FILE *temp = 0;\r\n char col1[80] = {0};\r\n char col2[80] = {0};\r\n char col3[80] = {0};\r\n char *cols[3] = {0};\r\n char *tettigoniidae_theravada = 0;\r\n jmp_buf unsoundnesses_blackberries;\r\n int jger_tintamar;\r\n struct electrobiology_treasonous rsfsr_pithecus;\r\n char *aft_poudreuse;;\r\n if (__sync_bool_compare_and_swap(&galvanographic_racily,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n aft_poudreuse = getenv(\"LAXER_SICKLY\");\r\n if (aft_poudreuse != 0) {;\r\n rsfsr_pithecus . disenabled_endeign = ((char *)aft_poudreuse);\r\n jger_tintamar = setjmp(unsoundnesses_blackberries);\r\n if (jger_tintamar == 0) {\r\n longjmp(unsoundnesses_blackberries,1);\r\n }\r\n tettigoniidae_theravada = ((char *)rsfsr_pithecus . disenabled_endeign);\r\n \r\n \r\n csv = fopen(tettigoniidae_theravada,\"r\");\r\n if (csv != 0) {\r\n \r\n\r\n fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\r\n \r\n \r\n \r\n \r\n if (strlen(col1) > 0)\r\n cols[0] = col1;\r\n if (strlen(col2) > 0)\r\n cols[1] = col2;\r\n if (strlen(col3) > 0)\r\n cols[2] = col3;\r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n\r\n printf(\"VALUES=\\\"\");\r\n fputs(cols[0],temp);\r\n printf(cols[0]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[1],temp);\r\n printf(cols[1]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[2],temp);\r\n printf(cols[2]);\r\n \r\n printf(\"\\\"\\n\");\r\n fclose(temp);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n printf(\"VALUES=\\\"\");\n fputs(cols[0],temp);\n printf(cols[0]);\n printf(\"\\\",\\\"\");\n fputs(cols[1],temp);\n printf(cols[1]);\n printf(\"\\\",\\\"\");\n fputs(cols[2],temp);\n printf(cols[2]);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint glyptodon_metter = 0;\r\nint global_variable;\r\ntypedef char *strums_obstructivism;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid reticence_pneumobranchia(const strums_obstructivism shaniko_backstays);\r\nvoid spck_commelinaceae(int locustid_neutralities,strums_obstructivism overgown_nymphette);\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n strums_obstructivism neutrophil_futureless = 0;\r\n char *kronos_euphorbia;\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&glyptodon_metter,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&kronos_euphorbia,\"AEQUOREAL_BOUNDLY\");\r\n if (kronos_euphorbia != 0) {;\r\n neutrophil_futureless = kronos_euphorbia;\r\n reticence_pneumobranchia(neutrophil_futureless);\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\n\r\nvoid reticence_pneumobranchia(const strums_obstructivism shaniko_backstays)\r\n{\r\n int causers_cosonant = 7;\r\n ++global_variable;;\r\n spck_commelinaceae(causers_cosonant,shaniko_backstays);\r\n}\r\n\r\nvoid spck_commelinaceae(int locustid_neutralities,strums_obstructivism overgown_nymphette)\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *burt_mismeets = 0;\r\n ++global_variable;\r\n locustid_neutralities--;\r\n if (locustid_neutralities > 0) {\r\n spck_commelinaceae(locustid_neutralities,overgown_nymphette);\r\n return ;\r\n }\r\n burt_mismeets = ((char *)((strums_obstructivism )overgown_nymphette));\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(burt_mismeets); ++i) {\r\n if (burt_mismeets[i] == ';') {\r\n if (i == 0 || burt_mismeets[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,burt_mismeets);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (((strums_obstructivism )overgown_nymphette) != 0) \r\n free(((char *)((strums_obstructivism )overgown_nymphette)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint hierogamy_wondercraft = 0;\r\ntypedef char *durmast_badly;\r\nint global_variable;\r\nvoid handle_taint(char *sherardizer_avilla);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid aghastness_tritiated(int thromboangiitis_syllabified,durmast_badly *gnni_outplods);\r\nvoid lizzy_overtinseling(int dst_senath,durmast_badly *tex_insectiferous);\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&hierogamy_wondercraft,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid handle_taint(char *sherardizer_avilla)\r\n{\r\n int cystathionine_lincolndale = 7;\r\n durmast_badly *pourpoint_raft = 0;\r\n durmast_badly *gauricus_etruscan = 0;\r\n durmast_badly tizes_pelecypodous = 0;\r\n ++global_variable;;\r\n if (sherardizer_avilla != 0) {;\r\n tizes_pelecypodous = sherardizer_avilla;\r\n pourpoint_raft = &tizes_pelecypodous;\r\n gauricus_etruscan = pourpoint_raft + 5;\r\n aghastness_tritiated(cystathionine_lincolndale,gauricus_etruscan);\r\n }\r\n}\r\n\r\nvoid aghastness_tritiated(int thromboangiitis_syllabified,durmast_badly *gnni_outplods)\r\n{\r\n int stack_size = 0;\r\n char *overmatureness_resilement = 0;\r\n ++global_variable;\r\n thromboangiitis_syllabified--;\r\n if (thromboangiitis_syllabified > 0) {\r\n lizzy_overtinseling(thromboangiitis_syllabified,gnni_outplods);\r\n return ;\r\n }\r\n overmatureness_resilement = ((char *)( *(gnni_outplods - 5)));\r\n \r\n \r\n \r\n if (strlen(overmatureness_resilement) > 1 &&\r\n overmatureness_resilement[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n stack_size = strtoul(overmatureness_resilement,0,0);\r\n printf(\"Allocating stack array\\n\");\r\n \r\n \r\n \r\n char stack_string[stack_size];\r\n memset(stack_string,'x',stack_size - 1);\r\n \r\n }\r\n \r\n \r\n;\r\n if ( *(gnni_outplods - 5) != 0) \r\n free(((char *)( *(gnni_outplods - 5))));\r\nclose_printf_context();\r\n}\r\n\r\nvoid lizzy_overtinseling(int dst_senath,durmast_badly *tex_insectiferous)\r\n{\r\n ++global_variable;\r\n aghastness_tritiated(dst_senath,tex_insectiferous);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n char stack_string[stack_size];\n memset(stack_string,'x',stack_size - 1);\n```", "cwe": "789"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_AES\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/aes.h>\r\n#include \"evp_locl.h\"\r\n#ifndef OPENSSL_FIPS\r\n#include \"modes_lcl.h\"\r\n#include <openssl/rand.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\ntypedef struct {\r\nAES_KEY ks;\r\nblock128_f block;\r\nunion {\r\ncbc128_f cbc;\r\nctr128_f ctr;}stream;}EVP_AES_KEY;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\nGCM128_CONTEXT gcm;\r\n\r\nunsigned char *iv;\r\n\r\nint ivlen;\r\nint taglen;\r\n\r\nint iv_gen;\r\n\r\nint tls_aad_len;\r\nctr128_f ctr;}EVP_AES_GCM_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks1;\r\nAES_KEY ks2;\r\nXTS128_CONTEXT xts;\r\nvoid (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\n\r\nint tag_set;\r\n\r\nint len_set;\r\n\r\nint L;\r\nint M;\r\nCCM128_CONTEXT ccm;\r\nccm128_f str;}EVP_AES_CCM_CTX;\r\n#define MAXBITCHUNK\t((size_t)1<<(sizeof(size_t)*8-4))\r\n#ifdef VPAES_ASM\r\nextern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\n#endif\r\n#ifdef BSAES_ASM\r\nextern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc);\r\nextern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]);\r\nextern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\n#endif\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n#ifdef AES_XTS_ASM\r\n#endif\r\n#if\tdefined(AES_ASM) && !defined(I386_ONLY) &&\t( \\\r\n\t((defined(__i386)\t|| defined(__i386__)\t|| \\\r\n\t defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \\\r\n\tdefined(__x86_64)\t|| defined(__x86_64__)\t|| \\\r\n\tdefined(_M_AMD64)\t|| defined(_M_X64)\t|| \\\r\n\tdefined(__INTEL__)\t\t\t\t)\r\nextern unsigned int OPENSSL_ia32cap_P[2];\r\n#ifdef VPAES_ASM\r\n#define VPAES_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(41-32)))\r\n#endif\r\n#ifdef BSAES_ASM\r\n#define BSAES_CAPABLE\tVPAES_CAPABLE\r\n#endif\r\n\r\n#define\tAESNI_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(57-32)))\r\nextern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc);\r\nextern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\nextern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec);\r\nextern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nextern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nint arius_citrulline = 0;\r\nint global_variable;\r\nvoid trusted_plumville(char **proliferating_superjets);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid beverages_heteromastigate(void (*rehood_unsecularised)(char **));\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n ret = aesni_set_decrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )aesni_cbc_encrypt) : ((void *)0));\r\n }\r\n else {\r\n ret = aesni_set_encrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_encrypt);\r\n if (mode == 0x2) {\r\n dat -> stream . cbc = ((cbc128_f )aesni_cbc_encrypt);\r\n }\r\n else {\r\n if (mode == 0x5) {\r\n dat -> stream . ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n dat -> stream . cbc = ((void *)0);\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,165,143,\"e_aes.c\",258);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n aesni_cbc_encrypt(in,out,len,(ctx -> cipher_data),ctx -> iv,ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n aesni_ecb_encrypt(in,out,len,(ctx -> cipher_data),ctx -> encrypt);\r\n return 1;\r\n}\r\n#define aesni_ofb_cipher aes_ofb_cipher\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb_cipher aes_cfb_cipher\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb8_cipher aes_cfb8_cipher\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb1_cipher aes_cfb1_cipher\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_ctr_cipher aes_ctr_cipher\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )aesni_encrypt));\r\n gctx -> ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n#define aesni_gcm_cipher aes_gcm_cipher\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n\r\n if (enc) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_encrypt);\r\n xctx -> stream = aesni_xts_encrypt;\r\n }\r\n else {\r\n aesni_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_decrypt);\r\n xctx -> stream = aesni_xts_decrypt;\r\n }\r\n aesni_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )aesni_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n#define aesni_xts_cipher aes_xts_cipher\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )aesni_encrypt));\r\n cctx -> str = (enc?((ccm128_f )aesni_ccm64_encrypt_blocks) : ((ccm128_f )aesni_ccm64_decrypt_blocks));\r\n cctx -> key_set = 1;\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n#define aesni_ccm_cipher aes_ccm_cipher\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_init_key,\t\t\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,\t\\\r\n\tkeylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_##mode##_init_key,\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#else\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#endif\r\n#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)\t\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)\r\n\r\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x2) {\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = ((cbc128_f )bsaes_cbc_encrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n }\r\n }\r\n }\r\n else {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x5) {\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,133,143,\"e_aes.c\",567);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . cbc) {\r\n ( *dat -> stream . cbc)(in,out,len,(&dat -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n else {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n size_t i;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n for ((i = 0 , len -= bl); i <= len; i += bl) \r\n ( *dat -> block)(in + i,out + i,(&dat -> ks));\r\n return 1;\r\n}\r\n\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_ofb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_8_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (ctx -> flags & 0x2000) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n }\r\n while(len >= ((size_t )1) << sizeof(size_t ) * 8 - 4){\r\n CRYPTO_cfb128_1_encrypt(in,out,(((size_t )1) << sizeof(size_t ) * 8 - 4) * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n len -= ((size_t )1) << sizeof(size_t ) * 8 - 4;\r\n }\r\n if (len) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n unsigned int num = (ctx -> num);\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . ctr) {\r\n CRYPTO_ctr128_encrypt_ctr32(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> stream . ctr);\r\n }\r\n else {\r\n CRYPTO_ctr128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> block);\r\n }\r\n ctx -> num = ((size_t )num);\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cbc : &aes_128_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ecb : &aes_128_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ofb : &aes_128_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb : &aes_128_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb1 : &aes_128_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb8 : &aes_128_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ctr : &aes_128_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cbc : &aes_192_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ecb : &aes_192_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ofb : &aes_192_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb : &aes_192_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb1 : &aes_192_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb8()\r\n{;\r\n if (__sync_bool_compare_and_swap(&arius_citrulline,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n beverages_heteromastigate(trusted_plumville);\r\n }\r\n }\r\n ;\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb8 : &aes_192_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ctr : &aes_192_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cbc : &aes_256_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ecb : &aes_256_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ofb : &aes_256_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb : &aes_256_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb1 : &aes_256_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb8 : &aes_256_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ctr : &aes_256_ctr;\r\n}\r\n\r\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n OPENSSL_cleanse((&gctx -> gcm),sizeof(gctx -> gcm));\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic void ctr64_inc(unsigned char *counter)\r\n{\r\n int n = 8;\r\n unsigned char c;\r\n do {\r\n --n;\r\n c = counter[n];\r\n ++c;\r\n counter[n] = c;\r\n if (c) {\r\n return ;\r\n }\r\n }while (n);\r\n}\r\n\r\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n gctx -> key_set = 0;\r\n gctx -> iv_set = 0;\r\n gctx -> ivlen = c -> cipher -> iv_len;\r\n gctx -> iv = c -> iv;\r\n gctx -> taglen = - 1;\r\n gctx -> iv_gen = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return 1;\r\n }\r\n case 0x9:\r\n{\r\n if (arg <= 0) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n#endif\r\n\r\n if (arg > 16 && arg > gctx -> ivlen) {\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n gctx -> iv = (CRYPTO_malloc(((int )arg),\"e_aes.c\",728));\r\n if (!gctx -> iv) {\r\n return 0;\r\n }\r\n }\r\n gctx -> ivlen = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg <= 0 || arg > 16 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> taglen = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (arg <= 0 || arg > 16 || !c -> encrypt || gctx -> taglen < 0) {\r\n return 0;\r\n }\r\n memcpy(ptr,(c -> buf),arg);\r\n return 1;\r\n }\r\n case 0x12:\r\n{\r\n\r\n if (arg == - 1) {\r\n memcpy((gctx -> iv),ptr,(gctx -> ivlen));\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n\r\n if (arg < 4 || gctx -> ivlen - arg < 8) {\r\n return 0;\r\n }\r\n if (arg) {\r\n memcpy((gctx -> iv),ptr,arg);\r\n }\r\n if (c -> encrypt && RAND_bytes(gctx -> iv + arg,gctx -> ivlen - arg) <= 0) {\r\n return 0;\r\n }\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n case 0x13:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0) {\r\n return 0;\r\n }\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n if (arg <= 0 || arg > gctx -> ivlen) {\r\n arg = gctx -> ivlen;\r\n }\r\n memcpy(ptr,(gctx -> iv + gctx -> ivlen - arg),arg);\r\n\r\n ctr64_inc(gctx -> iv + gctx -> ivlen - 8);\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x18:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((gctx -> iv + gctx -> ivlen - arg),ptr,arg);\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x16:\r\n{\r\n\r\n if (arg != 13) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> tls_aad_len = arg;\r\n{\r\n unsigned int len = (c -> buf[arg - 2] << 8 | c -> buf[arg - 1]);\r\n\r\n len -= 8;\r\n\r\n if (!c -> encrypt) {\r\n len -= 16;\r\n }\r\n c -> buf[arg - 2] = (len >> 8);\r\n c -> buf[arg - 1] = (len & 0xff);\r\n }\r\n\r\n return 16;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n gctx -> ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n break; \r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )vpaes_encrypt));\r\n gctx -> ctr = ((void *)0);\r\n break; \r\n }\r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n#ifdef AES_CTR_ASM\r\n#else\r\n gctx -> ctr = ((void *)0);\r\n#endif\r\n }while (0);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n int rv = - 1;\r\n\r\n if (out != in || len < (8 + 16)) {\r\n return - 1;\r\n }\r\n\r\n if (EVP_CIPHER_CTX_ctrl(ctx,(ctx -> encrypt?0x13 : 0x18),8,out) <= 0) {\r\n goto err;\r\n }\r\n\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,(ctx -> buf),(gctx -> tls_aad_len))) {\r\n goto err;\r\n }\r\n\r\n in += 8;\r\n out += 8;\r\n len -= (8 + 16);\r\n if (ctx -> encrypt) {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n out += len;\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,out,16);\r\n rv = (len + 8 + 16);\r\n }\r\n else {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n\r\n if (memcmp((ctx -> buf),(in + len),16)) {\r\n OPENSSL_cleanse(out,len);\r\n goto err;\r\n }\r\n rv = len;\r\n }\r\n err:\r\n gctx -> iv_set = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return rv;\r\n}\r\n\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n\r\n if (!gctx -> key_set) {\r\n return - 1;\r\n }\r\n if (gctx -> tls_aad_len >= 0) {\r\n return aes_gcm_tls_cipher(ctx,out,in,len);\r\n }\r\n if (!gctx -> iv_set) {\r\n return - 1;\r\n }\r\n if (in) {\r\n if (out == ((void *)0)) {\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,in,len)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n else {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n }\r\n return len;\r\n }\r\n else {\r\n if (!ctx -> encrypt) {\r\n if (gctx -> taglen < 0) {\r\n return - 1;\r\n }\r\n if (CRYPTO_gcm128_finish(&gctx -> gcm,(ctx -> buf),(gctx -> taglen)) != 0) {\r\n return - 1;\r\n }\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n gctx -> taglen = 16;\r\n\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n}\r\n#define CUSTOM_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 \\\r\n\t\t| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\\r\n\t\t| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_gcm : &aes_128_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_gcm : &aes_192_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_gcm : &aes_256_gcm;\r\n}\r\n\r\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (c -> cipher_data);\r\n if (type != 0) {\r\n return - 1;\r\n }\r\n\r\n xctx -> xts . key1 = ((void *)0);\r\n xctx -> xts . key2 = ((void *)0);\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef AES_XTS_ASM\r\n#else\r\n xctx -> stream = ((void *)0);\r\n#endif\r\n\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n xctx -> stream = (enc?bsaes_xts_encrypt : bsaes_xts_decrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n if (enc) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_encrypt);\r\n }\r\n else {\r\n vpaes_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_decrypt);\r\n }\r\n vpaes_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )vpaes_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n break; \r\n }\r\n }\r\n#endif\r\n if (enc) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_encrypt);\r\n }\r\n else {\r\n AES_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_decrypt);\r\n }\r\n AES_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )AES_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }while (0);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!xctx -> xts . key1 || !xctx -> xts . key2) {\r\n return 0;\r\n }\r\n if (!out || !in || len < 16) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n\r\n#endif\r\n if (xctx -> stream) {\r\n ( *xctx -> stream)(in,out,len,xctx -> xts . key1,xctx -> xts . key2,(ctx -> iv));\r\n }\r\n else {\r\n if (CRYPTO_xts128_encrypt((&xctx -> xts),(ctx -> iv),in,out,len,ctx -> encrypt)) {\r\n return 0;\r\n }\r\n }\r\n return 1;\r\n}\r\n#define aes_xts_cleanup NULL\r\n#define XTS_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\\r\n\t\t\t | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_xts : &aes_128_xts;\r\n}\r\nstatic const EVP_CIPHER aesni_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_xts : &aes_256_xts;\r\n}\r\n\r\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n cctx -> key_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> L = 8;\r\n cctx -> M = 12;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n case 0x9:\r\n arg = 15 - arg;\r\n case 0x14:\r\n{\r\n if (arg < 2 || arg > 8) {\r\n return 0;\r\n }\r\n cctx -> L = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg & 1 || arg < 4 || arg > 16) {\r\n return 0;\r\n }\r\n if (c -> encrypt && ptr || !c -> encrypt && !ptr) {\r\n return 0;\r\n }\r\n if (ptr) {\r\n cctx -> tag_set = 1;\r\n memcpy((c -> buf),ptr,arg);\r\n }\r\n cctx -> M = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (!c -> encrypt || !cctx -> tag_set) {\r\n return 0;\r\n }\r\n if (!CRYPTO_ccm128_tag(&cctx -> ccm,ptr,((size_t )arg))) {\r\n return 0;\r\n }\r\n cctx -> tag_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )vpaes_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n break; \r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )AES_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n }while (0);\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n CCM128_CONTEXT *ccm = &cctx -> ccm;\r\n\r\n if (!cctx -> iv_set && !cctx -> key_set) {\r\n return - 1;\r\n }\r\n if (!ctx -> encrypt && !cctx -> tag_set) {\r\n return - 1;\r\n }\r\n if (!out) {\r\n if (!in) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n return len;\r\n }\r\n\r\n if (!cctx -> len_set && len) {\r\n return - 1;\r\n }\r\n CRYPTO_ccm128_aad(ccm,in,len);\r\n return len;\r\n }\r\n\r\n if (!in) {\r\n return 0;\r\n }\r\n\r\n if (!cctx -> len_set) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n }\r\n if (ctx -> encrypt) {\r\n if (cctx -> str?CRYPTO_ccm128_encrypt_ccm64(ccm,in,out,len,cctx -> str) : CRYPTO_ccm128_encrypt(ccm,in,out,len)) {\r\n return - 1;\r\n }\r\n cctx -> tag_set = 1;\r\n return len;\r\n }\r\n else {\r\n int rv = - 1;\r\n if (cctx -> str?!CRYPTO_ccm128_decrypt_ccm64(ccm,in,out,len,cctx -> str) : !CRYPTO_ccm128_decrypt(ccm,in,out,len)) {\r\n unsigned char tag[16];\r\n if (CRYPTO_ccm128_tag(ccm,tag,(cctx -> M))) {\r\n if (!memcmp(tag,(ctx -> buf),(cctx -> M))) {\r\n rv = len;\r\n }\r\n }\r\n }\r\n if (rv == - 1) {\r\n OPENSSL_cleanse(out,len);\r\n }\r\n cctx -> iv_set = 0;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return rv;\r\n }\r\n}\r\n#define aes_ccm_cleanup NULL\r\nstatic const EVP_CIPHER aesni_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ccm : &aes_128_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ccm : &aes_192_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ccm : &aes_256_ccm;\r\n}\r\n\r\nvoid trusted_plumville(char **proliferating_superjets)\r\n{\r\n int petasus_calabasas = 35;\r\n char *omnividence_iverson;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&omnividence_iverson,\"7847\",petasus_calabasas);\r\n if (omnividence_iverson != 0) {;\r\n *proliferating_superjets = omnividence_iverson;\r\n }\r\n}\r\n\r\nvoid beverages_heteromastigate(void (*rehood_unsecularised)(char **))\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *excusative_spicehouse = 0;\r\n char **aftercomer_viviparities = 0;\r\n char **falls_vizirial = 0;\r\n ++global_variable;\r\n char *rechose_marissa = 0;\r\n rehood_unsecularised(&rechose_marissa);\r\n if (rechose_marissa != 0) {;\r\n aftercomer_viviparities = &rechose_marissa;\r\n falls_vizirial = aftercomer_viviparities + 5;\r\n excusative_spicehouse = ((char *)( *(falls_vizirial - 5)));\r\n \r\n if (strlen(excusative_spicehouse) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(excusative_spicehouse) == 1) {\r\n parsed_input = malloc((strlen(excusative_spicehouse)+1) * sizeof(char));\r\n urlDecode(excusative_spicehouse, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if ( *(falls_vizirial - 5) != 0) \r\n free(((char *)( *(falls_vizirial - 5))));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_AES\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/aes.h>\r\n#include \"evp_locl.h\"\r\n#ifndef OPENSSL_FIPS\r\n#include \"modes_lcl.h\"\r\n#include <openssl/rand.h>\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <sys/types.h> \r\n#include <unistd.h> \r\ntypedef struct {\r\nAES_KEY ks;\r\nblock128_f block;\r\nunion {\r\ncbc128_f cbc;\r\nctr128_f ctr;}stream;}EVP_AES_KEY;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\nGCM128_CONTEXT gcm;\r\n\r\nunsigned char *iv;\r\n\r\nint ivlen;\r\nint taglen;\r\n\r\nint iv_gen;\r\n\r\nint tls_aad_len;\r\nctr128_f ctr;}EVP_AES_GCM_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks1;\r\nAES_KEY ks2;\r\nXTS128_CONTEXT xts;\r\nvoid (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\n\r\nint tag_set;\r\n\r\nint len_set;\r\n\r\nint L;\r\nint M;\r\nCCM128_CONTEXT ccm;\r\nccm128_f str;}EVP_AES_CCM_CTX;\r\n#define MAXBITCHUNK\t((size_t)1<<(sizeof(size_t)*8-4))\r\n#ifdef VPAES_ASM\r\nextern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\n#endif\r\n#ifdef BSAES_ASM\r\nextern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc);\r\nextern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]);\r\nextern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\n#endif\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n#ifdef AES_XTS_ASM\r\n#endif\r\n#if\tdefined(AES_ASM) && !defined(I386_ONLY) &&\t( \\\r\n\t((defined(__i386)\t|| defined(__i386__)\t|| \\\r\n\t defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \\\r\n\tdefined(__x86_64)\t|| defined(__x86_64__)\t|| \\\r\n\tdefined(_M_AMD64)\t|| defined(_M_X64)\t|| \\\r\n\tdefined(__INTEL__)\t\t\t\t)\r\nextern unsigned int OPENSSL_ia32cap_P[2];\r\n#ifdef VPAES_ASM\r\n#define VPAES_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(41-32)))\r\n#endif\r\n#ifdef BSAES_ASM\r\n#define BSAES_CAPABLE\tVPAES_CAPABLE\r\n#endif\r\n\r\n#define\tAESNI_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(57-32)))\r\nextern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc);\r\nextern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\nextern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec);\r\nextern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nextern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nint gemmological_walbrzych = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n \r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForChange(char* file, char* sleepFile) {\r\n int fd;\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForChange\\n\");\r\n strcat(filename, file);\r\n strcat(filename, \".pid\");\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nint path_is_relative(char *path) {\r\n char *chr = 0;\r\n \r\n chr = strchr(path,'/');\r\n if (chr == 0) {\r\n \r\n printf(\"Path is relative\\n\");\r\n return 1;\r\n } else {\r\n \r\n printf(\"Path is not relative\\n\");\r\n return 0;\r\n }\r\n}\r\nchar * get_absolute_path(char * path) {\r\n char * abs_path = malloc (sizeof(char) * (strlen(\"/opt//workspace/testData/\") * strlen(path) + 1));\r\n \r\n if (abs_path == NULL) {\r\n printf(\"Cannot allocate memory for path\\n\");\r\n } else {\r\n printf(\"Creating absolute path\\n\");\r\n strcpy(abs_path, \"/opt//workspace/testData/\");\r\n strcat(abs_path, path);\r\n }\r\n return abs_path;\r\n}\r\nint isSymLink(char *file) {\r\n struct stat statbuf;\r\n \r\n if (lstat(file, &statbuf) < 0) { \r\n printf(\"Error accessing path.\\n\");\r\n return 1; \r\n }\r\n if (S_ISLNK(statbuf.st_mode) == 1) {\r\n printf(\"Path is symlink.\\n\");\r\n return 1;\r\n }\r\n printf(\"Path is valid.\\n\");\r\n return 0;\r\n}\r\nint path_is_not_symlink(char * abs_path) {\r\n \r\n return (isSymLink(abs_path) == 0);\r\n}\r\n\r\nstatic int aesni_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n ret = aesni_set_decrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )aesni_cbc_encrypt) : ((void *)0));\r\n }\r\n else {\r\n ret = aesni_set_encrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_encrypt);\r\n if (mode == 0x2) {\r\n dat -> stream . cbc = ((cbc128_f )aesni_cbc_encrypt);\r\n }\r\n else {\r\n if (mode == 0x5) {\r\n dat -> stream . ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n dat -> stream . cbc = ((void *)0);\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,165,143,\"e_aes.c\",258);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n aesni_cbc_encrypt(in,out,len,(ctx -> cipher_data),ctx -> iv,ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n aesni_ecb_encrypt(in,out,len,(ctx -> cipher_data),ctx -> encrypt);\r\n return 1;\r\n}\r\n#define aesni_ofb_cipher aes_ofb_cipher\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb_cipher aes_cfb_cipher\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb8_cipher aes_cfb8_cipher\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb1_cipher aes_cfb1_cipher\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_ctr_cipher aes_ctr_cipher\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )aesni_encrypt));\r\n gctx -> ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n#define aesni_gcm_cipher aes_gcm_cipher\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n\r\n if (enc) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_encrypt);\r\n xctx -> stream = aesni_xts_encrypt;\r\n }\r\n else {\r\n aesni_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_decrypt);\r\n xctx -> stream = aesni_xts_decrypt;\r\n }\r\n aesni_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )aesni_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n#define aesni_xts_cipher aes_xts_cipher\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )aesni_encrypt));\r\n cctx -> str = (enc?((ccm128_f )aesni_ccm64_encrypt_blocks) : ((ccm128_f )aesni_ccm64_decrypt_blocks));\r\n cctx -> key_set = 1;\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n#define aesni_ccm_cipher aes_ccm_cipher\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_init_key,\t\t\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,\t\\\r\n\tkeylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_##mode##_init_key,\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#else\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#endif\r\n#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)\t\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)\r\n\r\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x2) {\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = ((cbc128_f )bsaes_cbc_encrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n }\r\n }\r\n }\r\n else {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x5) {\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,133,143,\"e_aes.c\",567);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . cbc) {\r\n ( *dat -> stream . cbc)(in,out,len,(&dat -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n else {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n size_t i;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n for ((i = 0 , len -= bl); i <= len; i += bl) \r\n ( *dat -> block)(in + i,out + i,(&dat -> ks));\r\n return 1;\r\n}\r\n\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_ofb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_8_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (ctx -> flags & 0x2000) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n }\r\n while(len >= ((size_t )1) << sizeof(size_t ) * 8 - 4){\r\n CRYPTO_cfb128_1_encrypt(in,out,(((size_t )1) << sizeof(size_t ) * 8 - 4) * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n len -= ((size_t )1) << sizeof(size_t ) * 8 - 4;\r\n }\r\n if (len) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n unsigned int num = (ctx -> num);\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . ctr) {\r\n CRYPTO_ctr128_encrypt_ctr32(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> stream . ctr);\r\n }\r\n else {\r\n CRYPTO_ctr128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> block);\r\n }\r\n ctx -> num = ((size_t )num);\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cbc : &aes_128_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ecb : &aes_128_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ofb : &aes_128_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb : &aes_128_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb1 : &aes_128_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb8 : &aes_128_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ctr : &aes_128_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cbc : &aes_192_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ecb : &aes_192_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ofb : &aes_192_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb : &aes_192_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb1 : &aes_192_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb8()\r\n{\r\n int size = 0;\r\n FILE *file = 0;\r\n char *buffer = 0;\r\n char *str = 0;\r\n char *abs_path = 0;\r\n char *sleep_file = 0;\r\n char *chigoe_melchite = 0;\r\n jmp_buf loaches_outadd;\r\n int pogroms_wakikis;\r\n char **analogising_extracolumella = 0;\r\n int **freir_calotin = 0;\r\n int *confirmedness_evacuators = 0;\r\n int nonheritor_ofr;\r\n char **phoby_actuaryship[10] = {0};\r\n char *wrothy_remonstration[61] = {0};\r\n char *emergently_tophet;;\r\n if (__sync_bool_compare_and_swap(&gemmological_walbrzych,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&emergently_tophet,\"TREACLY_MIDSTREET\");\r\n if (emergently_tophet != 0) {;\r\n wrothy_remonstration[9] = emergently_tophet;\r\n nonheritor_ofr = 5;\r\n confirmedness_evacuators = &nonheritor_ofr;\r\n freir_calotin = &confirmedness_evacuators;\r\n phoby_actuaryship[ *( *freir_calotin)] = wrothy_remonstration;\r\n analogising_extracolumella = phoby_actuaryship[ *( *freir_calotin)];\r\n pogroms_wakikis = setjmp(loaches_outadd);\r\n if (pogroms_wakikis == 0) {\r\n longjmp(loaches_outadd,1);\r\n }\r\n chigoe_melchite = ((char *)analogising_extracolumella[9]);\r\n \r\n str = malloc(sizeof(char) * (strlen(chigoe_melchite) + 1));\r\n sleep_file = malloc(sizeof(char) * (strlen(chigoe_melchite) + 1));\r\n if (str != NULL && sleep_file != NULL &&\r\n (sscanf(chigoe_melchite, \"%s %s\",\r\n sleep_file,\r\n str) == 2) &&\r\n (strlen(str) != 0) &&\r\n (strlen(sleep_file) != 0))\r\n {\r\n \r\n \r\n if (path_is_relative(str)) {\r\n abs_path = get_absolute_path(str);\r\n if (abs_path != NULL) {\r\n if (path_is_not_symlink(abs_path)) {\r\n \r\n \r\n waitForChange(abs_path, sleep_file);\r\n file = fopen(abs_path,\"rb\");\r\n \r\n if (file != 0) {\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\r\n if (buffer) {\r\n \r\n \r\n fread(buffer,sizeof(char ),size,file);\r\n buffer[size] = '\\0';\r\n printf(buffer);\r\n fclose(file);\r\n free(buffer);\r\n \r\n }\r\n }\r\n }\r\n free (abs_path);\r\n }\r\n }\r\n free(str);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n;\r\n if (analogising_extracolumella[9] != 0) \r\n free(((char *)analogising_extracolumella[9]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb8 : &aes_192_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ctr : &aes_192_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cbc : &aes_256_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ecb : &aes_256_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ofb : &aes_256_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb : &aes_256_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb1 : &aes_256_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb8 : &aes_256_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ctr : &aes_256_ctr;\r\n}\r\n\r\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n OPENSSL_cleanse((&gctx -> gcm),sizeof(gctx -> gcm));\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic void ctr64_inc(unsigned char *counter)\r\n{\r\n int n = 8;\r\n unsigned char c;\r\n do {\r\n --n;\r\n c = counter[n];\r\n ++c;\r\n counter[n] = c;\r\n if (c) {\r\n return ;\r\n }\r\n }while (n);\r\n}\r\n\r\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n gctx -> key_set = 0;\r\n gctx -> iv_set = 0;\r\n gctx -> ivlen = c -> cipher -> iv_len;\r\n gctx -> iv = c -> iv;\r\n gctx -> taglen = - 1;\r\n gctx -> iv_gen = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return 1;\r\n }\r\n case 0x9:\r\n{\r\n if (arg <= 0) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n#endif\r\n\r\n if (arg > 16 && arg > gctx -> ivlen) {\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n gctx -> iv = (CRYPTO_malloc(((int )arg),\"e_aes.c\",728));\r\n if (!gctx -> iv) {\r\n return 0;\r\n }\r\n }\r\n gctx -> ivlen = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg <= 0 || arg > 16 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> taglen = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (arg <= 0 || arg > 16 || !c -> encrypt || gctx -> taglen < 0) {\r\n return 0;\r\n }\r\n memcpy(ptr,(c -> buf),arg);\r\n return 1;\r\n }\r\n case 0x12:\r\n{\r\n\r\n if (arg == - 1) {\r\n memcpy((gctx -> iv),ptr,(gctx -> ivlen));\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n\r\n if (arg < 4 || gctx -> ivlen - arg < 8) {\r\n return 0;\r\n }\r\n if (arg) {\r\n memcpy((gctx -> iv),ptr,arg);\r\n }\r\n if (c -> encrypt && RAND_bytes(gctx -> iv + arg,gctx -> ivlen - arg) <= 0) {\r\n return 0;\r\n }\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n case 0x13:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0) {\r\n return 0;\r\n }\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n if (arg <= 0 || arg > gctx -> ivlen) {\r\n arg = gctx -> ivlen;\r\n }\r\n memcpy(ptr,(gctx -> iv + gctx -> ivlen - arg),arg);\r\n\r\n ctr64_inc(gctx -> iv + gctx -> ivlen - 8);\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x18:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((gctx -> iv + gctx -> ivlen - arg),ptr,arg);\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x16:\r\n{\r\n\r\n if (arg != 13) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> tls_aad_len = arg;\r\n{\r\n unsigned int len = (c -> buf[arg - 2] << 8 | c -> buf[arg - 1]);\r\n\r\n len -= 8;\r\n\r\n if (!c -> encrypt) {\r\n len -= 16;\r\n }\r\n c -> buf[arg - 2] = (len >> 8);\r\n c -> buf[arg - 1] = (len & 0xff);\r\n }\r\n\r\n return 16;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n gctx -> ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n break; \r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )vpaes_encrypt));\r\n gctx -> ctr = ((void *)0);\r\n break; \r\n }\r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n#ifdef AES_CTR_ASM\r\n#else\r\n gctx -> ctr = ((void *)0);\r\n#endif\r\n }while (0);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n int rv = - 1;\r\n\r\n if (out != in || len < (8 + 16)) {\r\n return - 1;\r\n }\r\n\r\n if (EVP_CIPHER_CTX_ctrl(ctx,(ctx -> encrypt?0x13 : 0x18),8,out) <= 0) {\r\n goto err;\r\n }\r\n\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,(ctx -> buf),(gctx -> tls_aad_len))) {\r\n goto err;\r\n }\r\n\r\n in += 8;\r\n out += 8;\r\n len -= (8 + 16);\r\n if (ctx -> encrypt) {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n out += len;\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,out,16);\r\n rv = (len + 8 + 16);\r\n }\r\n else {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n\r\n if (memcmp((ctx -> buf),(in + len),16)) {\r\n OPENSSL_cleanse(out,len);\r\n goto err;\r\n }\r\n rv = len;\r\n }\r\n err:\r\n gctx -> iv_set = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return rv;\r\n}\r\n\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n\r\n if (!gctx -> key_set) {\r\n return - 1;\r\n }\r\n if (gctx -> tls_aad_len >= 0) {\r\n return aes_gcm_tls_cipher(ctx,out,in,len);\r\n }\r\n if (!gctx -> iv_set) {\r\n return - 1;\r\n }\r\n if (in) {\r\n if (out == ((void *)0)) {\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,in,len)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n else {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n }\r\n return len;\r\n }\r\n else {\r\n if (!ctx -> encrypt) {\r\n if (gctx -> taglen < 0) {\r\n return - 1;\r\n }\r\n if (CRYPTO_gcm128_finish(&gctx -> gcm,(ctx -> buf),(gctx -> taglen)) != 0) {\r\n return - 1;\r\n }\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n gctx -> taglen = 16;\r\n\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n}\r\n#define CUSTOM_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 \\\r\n\t\t| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\\r\n\t\t| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_gcm : &aes_128_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_gcm : &aes_192_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_gcm : &aes_256_gcm;\r\n}\r\n\r\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (c -> cipher_data);\r\n if (type != 0) {\r\n return - 1;\r\n }\r\n\r\n xctx -> xts . key1 = ((void *)0);\r\n xctx -> xts . key2 = ((void *)0);\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef AES_XTS_ASM\r\n#else\r\n xctx -> stream = ((void *)0);\r\n#endif\r\n\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n xctx -> stream = (enc?bsaes_xts_encrypt : bsaes_xts_decrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n if (enc) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_encrypt);\r\n }\r\n else {\r\n vpaes_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_decrypt);\r\n }\r\n vpaes_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )vpaes_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n break; \r\n }\r\n }\r\n#endif\r\n if (enc) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_encrypt);\r\n }\r\n else {\r\n AES_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_decrypt);\r\n }\r\n AES_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )AES_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }while (0);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!xctx -> xts . key1 || !xctx -> xts . key2) {\r\n return 0;\r\n }\r\n if (!out || !in || len < 16) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n\r\n#endif\r\n if (xctx -> stream) {\r\n ( *xctx -> stream)(in,out,len,xctx -> xts . key1,xctx -> xts . key2,(ctx -> iv));\r\n }\r\n else {\r\n if (CRYPTO_xts128_encrypt((&xctx -> xts),(ctx -> iv),in,out,len,ctx -> encrypt)) {\r\n return 0;\r\n }\r\n }\r\n return 1;\r\n}\r\n#define aes_xts_cleanup NULL\r\n#define XTS_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\\r\n\t\t\t | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_xts : &aes_128_xts;\r\n}\r\nstatic const EVP_CIPHER aesni_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_xts : &aes_256_xts;\r\n}\r\n\r\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n cctx -> key_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> L = 8;\r\n cctx -> M = 12;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n case 0x9:\r\n arg = 15 - arg;\r\n case 0x14:\r\n{\r\n if (arg < 2 || arg > 8) {\r\n return 0;\r\n }\r\n cctx -> L = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg & 1 || arg < 4 || arg > 16) {\r\n return 0;\r\n }\r\n if (c -> encrypt && ptr || !c -> encrypt && !ptr) {\r\n return 0;\r\n }\r\n if (ptr) {\r\n cctx -> tag_set = 1;\r\n memcpy((c -> buf),ptr,arg);\r\n }\r\n cctx -> M = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (!c -> encrypt || !cctx -> tag_set) {\r\n return 0;\r\n }\r\n if (!CRYPTO_ccm128_tag(&cctx -> ccm,ptr,((size_t )arg))) {\r\n return 0;\r\n }\r\n cctx -> tag_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )vpaes_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n break; \r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )AES_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n }while (0);\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n CCM128_CONTEXT *ccm = &cctx -> ccm;\r\n\r\n if (!cctx -> iv_set && !cctx -> key_set) {\r\n return - 1;\r\n }\r\n if (!ctx -> encrypt && !cctx -> tag_set) {\r\n return - 1;\r\n }\r\n if (!out) {\r\n if (!in) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n return len;\r\n }\r\n\r\n if (!cctx -> len_set && len) {\r\n return - 1;\r\n }\r\n CRYPTO_ccm128_aad(ccm,in,len);\r\n return len;\r\n }\r\n\r\n if (!in) {\r\n return 0;\r\n }\r\n\r\n if (!cctx -> len_set) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n }\r\n if (ctx -> encrypt) {\r\n if (cctx -> str?CRYPTO_ccm128_encrypt_ccm64(ccm,in,out,len,cctx -> str) : CRYPTO_ccm128_encrypt(ccm,in,out,len)) {\r\n return - 1;\r\n }\r\n cctx -> tag_set = 1;\r\n return len;\r\n }\r\n else {\r\n int rv = - 1;\r\n if (cctx -> str?!CRYPTO_ccm128_decrypt_ccm64(ccm,in,out,len,cctx -> str) : !CRYPTO_ccm128_decrypt(ccm,in,out,len)) {\r\n unsigned char tag[16];\r\n if (CRYPTO_ccm128_tag(ccm,tag,(cctx -> M))) {\r\n if (!memcmp(tag,(ctx -> buf),(cctx -> M))) {\r\n rv = len;\r\n }\r\n }\r\n }\r\n if (rv == - 1) {\r\n OPENSSL_cleanse(out,len);\r\n }\r\n cctx -> iv_set = 0;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return rv;\r\n }\r\n}\r\n#define aes_ccm_cleanup NULL\r\nstatic const EVP_CIPHER aesni_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ccm : &aes_128_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ccm : &aes_192_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ccm : &aes_256_ccm;\r\n}\r\n#endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n fread(buffer,sizeof(char ),size,file);\n buffer[size] = '\\0';\n printf(buffer);\n fclose(file);\n free(buffer);\n```", "cwe": "363"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <setjmp.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <time.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint kutaisi_gotos = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid wariest_knurliest(void *const pulers_capelline);\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{\r\n void *fbv_burgh = 0;\r\n int sitters_toolings = 73;\r\n char *redon_revaluates;;\r\n if (__sync_bool_compare_and_swap(&kutaisi_gotos,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&redon_revaluates,\"6934\",sitters_toolings);\r\n if (redon_revaluates != 0) {;\r\n fbv_burgh = ((void *)redon_revaluates);\r\n wariest_knurliest(fbv_burgh);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid wariest_knurliest(void *const pulers_capelline)\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n char *result = 0;\r\n int random_int = 0;\r\n char *superrefine_dabchicks = 0;\r\n jmp_buf camphanyl_irvingism;\r\n int geranials_multipointed;\r\n ++global_variable;;\r\n geranials_multipointed = setjmp(camphanyl_irvingism);\r\n if (geranials_multipointed == 0) {\r\n longjmp(camphanyl_irvingism,1);\r\n }\r\n superrefine_dabchicks = ((char *)((char *)((void *)pulers_capelline)));\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, superrefine_dabchicks);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != PGRES_COMMAND_OK) {\r\n \r\n printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n result = PQcmdTuples(res);\r\n printf(\"Query OK, %s rows affected\\n\",result);\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\n if (((char *)((void *)pulers_capelline)) != 0) \r\n free(((char *)((char *)((void *)pulers_capelline))));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n res = PQexec(conn,query);\n if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n \n printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n PQclear(res);\n PQfinish(conn);\n exit(1);\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint iridescent_terrye = 0;\r\nint global_variable;\r\ntypedef char *saliaric_antialbumin;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid herman_precontention(const saliaric_antialbumin vulcanize_miming);\r\nvoid palingenesian_apism(int precolor_weakheartedly,saliaric_antialbumin inhumanism_idealists);\r\nint 190_global_var = 0;\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{\r\n saliaric_antialbumin endosternum_sunstone = 0;\r\n char *tangency_flaminical;;\r\n if (__sync_bool_compare_and_swap(&iridescent_terrye,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n tangency_flaminical = getenv(\"ACCEPTANCE_METHS\");\r\n if (tangency_flaminical != 0) {;\r\n endosternum_sunstone = tangency_flaminical;\r\n herman_precontention(endosternum_sunstone);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid herman_precontention(const saliaric_antialbumin vulcanize_miming)\r\n{\r\n int watershut_gorsebird = 7;\r\n ++global_variable;;\r\n palingenesian_apism(watershut_gorsebird,vulcanize_miming);\r\n}\r\n\r\nvoid palingenesian_apism(int precolor_weakheartedly,saliaric_antialbumin inhumanism_idealists)\r\n{\r\n int tainted_int = 0;\r\n int output_counter = 0;\r\n char *descure_unregrettable = 0;\r\n ++global_variable;\r\n precolor_weakheartedly--;\r\n if (precolor_weakheartedly > 0) {\r\n palingenesian_apism(precolor_weakheartedly,inhumanism_idealists);\r\n return ;\r\n }\r\n descure_unregrettable = ((char *)((saliaric_antialbumin )inhumanism_idealists));\r\n \r\n tainted_int = atoi(descure_unregrettable);\r\n if (tainted_int > 0) {\r\n \r\n\r\n tainted_int = tainted_int * tainted_int;\r\n \r\n \r\n \r\n while (tainted_int != 0) {\r\n\r\n if (tainted_int != INT_MIN) {\r\n tainted_int--;\r\n }\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n ++190_global_var;\r\n if (190_global_var >= INT_MAX) {\r\n 190_global_var = 0;\r\n }\r\n }\r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while (tainted_int != 0) {\n\n if (tainted_int != INT_MIN) {\n tainted_int--;\n }\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n ++190_global_var;\n if (190_global_var >= INT_MAX) {\n 190_global_var = 0;\n }\n }\n```", "cwe": "190"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\nint herbary_compactedly = 0;\r\n\r\nstruct brunnhilde_cuso \r\n{\r\n char *moderant_commonish;\r\n double pecksniffism_scutelligerous;\r\n char *creature_southcottian;\r\n char zionists_deflator;\r\n int gammoner_rexx;\r\n}\r\n;\r\nint global_variable;\r\nvoid recruitors_oxygenicity(struct brunnhilde_cuso *legwork_gastrophile);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid ribonucleotide_phrasable(void (*forehoofs_theomachy)(struct brunnhilde_cuso *));\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&herbary_compactedly,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n ribonucleotide_phrasable(recruitors_oxygenicity);\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid recruitors_oxygenicity(struct brunnhilde_cuso *legwork_gastrophile)\r\n{\r\n struct brunnhilde_cuso quomodos_beaverism;\r\n int dobuans_reckoning = 30;\r\n char *outperforming_johnsonburg;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&outperforming_johnsonburg,\"1071\",dobuans_reckoning);\r\n if (outperforming_johnsonburg != 0) {;\r\n quomodos_beaverism . moderant_commonish = ((char *)outperforming_johnsonburg);\r\n *legwork_gastrophile = quomodos_beaverism;\r\n }\r\n}\r\n\r\nvoid ribonucleotide_phrasable(void (*forehoofs_theomachy)(struct brunnhilde_cuso *))\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *excommune_subindustry = 0;\r\n struct brunnhilde_cuso pycnosporic_proverbialism = {0};\r\n int *mellow_devachan = 0;\r\n int zubkoff_gormands;\r\n struct brunnhilde_cuso sunfoil_unvictualed[10] = {0};\r\n ++global_variable;\r\n struct brunnhilde_cuso praham_adultoid = {0};\r\n forehoofs_theomachy(&praham_adultoid);\r\n if (praham_adultoid . moderant_commonish != 0) {;\r\n sunfoil_unvictualed[5] = praham_adultoid;\r\n zubkoff_gormands = 5;\r\n mellow_devachan = &zubkoff_gormands;\r\n pycnosporic_proverbialism = *(sunfoil_unvictualed + *mellow_devachan);\r\n excommune_subindustry = ((char *)pycnosporic_proverbialism . moderant_commonish);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",excommune_subindustry);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (pycnosporic_proverbialism . moderant_commonish != 0) \r\n free(((char *)pycnosporic_proverbialism . moderant_commonish));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
