```c chars_read = get_line (); if (chars_read == (size_t) -1  || chars_read <= 8  || strncmp (buf, "********", 8) != 0) {  next_intuit_at(line_beginning,p_input_line);  return chars_read == (size_t) -1 ? -1 : 0; } ```
```c drv_ctx.video_driver_fd = open(device_name, O_RDWR); ```
```c if (fnd -> funct && engine_unlocked_init(fnd -> funct)) { #ifdef ENGINE_TABLE_DEBUG #endif  ret = fnd -> funct;  goto end;  } ```
`av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","size<=2147483647 && p - pkt->data >= size","avpacket.c",288);`
```c printf_context = conn; ```
```c taint_buff = (char*) malloc(buffer_size * sizeof(char)); ```

```c char *royalists_vitalist = 0; ```
```c char *flokatis_induces = 0;  ++global_variable;;  flokatis_induces = ((char *)((char *)diallists_bulak));     number = strtol(flokatis_induces,0U,10); ```
```c int pmoc (const void * a, const void * b) {  return -1 * comp(a, b); } ```
```c void handle_taint(char *amassers_woodkern) {  pthread_t t0, t1;  int hasNonAlpha = 0;  int i = 0;  struct data* Data;  char *nonfeasance_lithodidae = 0;  jmp_buf pirate_costars;  int tabardillo_sapremias;  gymnocidium_racketeer *voq_disenthrone = 0;  gymnocidium_racketeer everettville_dabbles = 0;  gymnocidium_racketeer scanting_claggum = 0;  ++global_variable;;  if (amassers_woodkern != 0) {;  scanting_claggum = amassers_woodkern;  voq_disenthrone = &scanting_claggum;  tabardillo_sapremias = setjmp(pirate_costars);  if (tabardillo_sapremias == 0) {  longjmp(pirate_costars,1);  }  nonfeasance_lithodidae = ((char *)( *voq_disenthrone));    Data = malloc(sizeof(struct data));  if (Data) {  Data->data = malloc(sizeof(char) * (strlen(nonfeasance_lithodidae) + 1));  Data->file1 = malloc(sizeof(char) * (strlen(nonfeasance_lithodidae) + 1));  Data->file2 = malloc(sizeof(char) * (strlen(nonfeasance_lithodidae) + 1));  if (Data->data) {  if ((sscanf(nonfeasance_lithodidae, "%d %s %s %s",  &(Data->qsize),  Data->file1,  Data->file2,  Data->data) == 4) &&  (strlen(Data->data) != 0) &&  (strlen(Data->file1) != 0) &&  (strlen(Data->file2) != 0)) {  sem_init(&sem, 0, 1);  while (Data->data[i] != '\0') {   if(isalpha(Data->data[i]) == 0) {  hasNonAlpha = 1;  }  i++;  }  if (hasNonAlpha != 0) {      sem_post(&sem);  pthread_create(&t0, NULL, delNonAlpha, Data);     }   pthread_create(&t1, NULL, toCap, Data);  if (hasNonAlpha != 0) {  pthread_join(t0, NULL);  }  pthread_join(t1, NULL);  } else {  printf("Error parsing data\n");  }  free(Data->data);  }  free(Data);  }   ;  if ( *voq_disenthrone != 0)   free(((char *)( *voq_disenthrone))); close_printf_context();  } ```
```c for (i = 0; ((int )i) <= ((int )(strlen(dischase_stanks) - strlen(finder))); ++i) ```
```c while(fscanf(files,"%79s",filename) == 1 && ssi < 1020){  file = fopen(filename,"w");  if (file == 0) {  if (file == 0 && errno == 24) {  printf("Fopen error due to ulimit\n");  }  continue;  }  fputs("woohoo!",file);  fflush(file);      file_list[ssi % 10] = file;  ssi++;  } ```
```c phacotherapy_belshazzar(char *tallyhos_lan) {  int ss_i = 0;  char *proggers_odyl = 0;  ++global_variable;;  proggers_odyl = ((char *)tallyhos_lan);    printf("checking input\n");        while(ss_i < strlen(proggers_odyl)){    if (proggers_odyl[ss_i] >= 48) {    ++ss_i;  }  }      printf("finished evaluating\n");   ; close_printf_context(); } ```
```c static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image, 		 int oldproglen, struct jit_context *ctx) { 	struct bpf_insn *insn = bpf_prog->insnsi; 	int insn_cnt = bpf_prog->len; 	bool seen_ld_abs = ctx->seen_ld_abs | (oldproglen == 0); 	bool seen_exit = false; 	u8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY]; 	int i; 	int proglen = 0; 	u8 *prog = temp; 	int stacksize = MAX_BPF_STACK + 		32 /* space for rbx, r13, r14, r15 */ + 		8 /* space for skb_copy_bits() buffer */;  	EMIT1(0x55); /* push rbp */ 	EMIT3(0x48, 0x89, 0xE5); /* mov rbp,rsp */  	/* sub rsp, stacksize */ 	EMIT3_off32(0x48, 0x81, 0xEC, stacksize);  	/* all classic BPF filters use R6(rbx) save it */  	/* mov qword ptr [rbp-X],rbx */ 	EMIT3_off32(0x48, 0x89, 0x9D, -stacksize);  	/* bpf_convert_filter() maps classic BPF register X to R7 and uses R8 	 * as temporary, so all tcpdump filters need to spill/fill R7(r13) and 	 * R8(r14). R9(r15) spill could be made conditional, but there is only 	 * one 'bpf_error' return path out of helper functions inside bpf_jit.S 	 * The overhead of extra spill is negligible for any filter other 	 * than synthetic ones. Therefore not worth adding complexity. 	 */  	/* mov qword ptr [rbp-X],r13 */ 	EMIT3_off32(0x4C, 0x89, 0xAD, -stacksize + 8); 	/* mov qword ptr [rbp-X],r14 */ 	EMIT3_off32(0x4C, 0x89, 0xB5, -stacksize + 16); 	/* mov qword ptr [rbp-X],r15 */ 	EMIT3_off32(0x4C, 0x89, 0xBD, -stacksize + 24);  	/* clear A and X registers */ 	EMIT2(0x31, 0xc0); /* xor eax, eax */ 	EMIT3(0x4D, 0x31, 0xED); /* xor r13, r13 */  	if (seen_ld_abs) { 		/* r9d : skb->len - skb->data_len (headlen) 		 * r10 : skb->data 		 */ 		if (is_imm8(offsetof(struct sk_buff, len))) 			/* mov %r9d, off8(%rdi) */ 			EMIT4(0x44, 0x8b, 0x4f, 			 offsetof(struct sk_buff, len)); 		else 			/* mov %r9d, off32(%rdi) */ 			EMIT3_off32(0x44, 0x8b, 0x8f, 				 offsetof(struct sk_buff, len));  		if (is_imm8(offsetof(struct sk_buff, data_len))) 			/* sub %r9d, off8(%rdi) */ 			EMIT4(0x44, 0x2b, 0x4f, 			 offsetof(struct sk_buff, data_len)); 		else 			EMIT3_off32(0x44, 0x2b, 0x8f, 				 offsetof(struct sk_buff, data_len));  		if (is_imm8(offsetof(struct sk_buff, data))) 			/* mov %r10, off8(%rdi) */ 			EMIT4(0x4c, 0x8b, 0x57, 			 offsetof(struct sk_buff, data)); 		else 			/* mov %r10, off32(%rdi) */ 			EMIT3_off32(0x4c, 0x8b, 0x97, 				 offsetof(struct sk_buff, data)); 	}  	for (i = 0; i < insn_cnt; i++, insn++) { 		const s32 imm32 = insn->imm; 		u32 dst_reg = insn->dst_reg; 		u32 src_reg = insn->src_reg; 		u8 b1 = 0, b2 = 0, b3 = 0; 		s64 jmp_offset; 		u8 jmp_cond; 		int ilen; 		u8 *func;  		switch (insn->code) { 			/* ALU */ 		case BPF_ALU | BPF_ADD | BPF_X: 		case BPF_ALU | BPF_SUB | BPF_X: 		case BPF_ALU | BPF_AND | BPF_X: 		case BPF_ALU | BPF_OR | BPF_X: 		case BPF_ALU | BPF_XOR | BPF_X: 		case BPF_ALU64 | BPF_ADD | BPF_X: 		case BPF_ALU64 | BPF_SUB | BPF_X: 		case BPF_ALU64 | BPF_AND | BPF_X: 		case BPF_ALU64 | BPF_OR | BPF_X: 		case BPF_ALU64 | BPF_XOR | BPF_X: 			switch (BPF_OP(insn->code)) { 			case BPF_ADD: b2 = 0x01; break; 			case BPF_SUB: b2 = 0x29; break; 			case BPF_AND: b2 = 0x21; break; 			case BPF_OR: b2 = 0x09; break; 			case BPF_XOR: b2 = 0x31; break; 			} 			if (BPF_CLASS(insn->code) == BPF_ALU64) 				EMIT1(add_2mod(0x48, dst_reg, src_reg)); 			else if (is_ereg(dst_reg) || is_ereg(src_reg)) 				EMIT1(add_2mod(0x40, dst_reg, src_reg)); 			EMIT2(b2, add_2reg(0xC0, dst_reg, src_reg)); 			break;  			/* mov dst, src */ 		case BPF_ALU64 | BPF_MOV | BPF_X: 			EMIT_mov(dst_reg, src_reg); 			break;  			/* mov32 dst, src */ 		case BPF_ALU | BPF_MOV | BPF_X: 			if (is_ereg(dst_reg) || is_ereg(src_reg)) 				EMIT1(add_2mod(0x40, dst_reg, src_reg)); 			EMIT2(0x89, add_2reg(0xC0, dst_reg, src_reg)); 			break;  			/* neg dst */ 		case BPF_ALU | BPF_NEG: 		case BPF_ALU64 | BPF_NEG: 			if (BPF_CLASS(insn->code) == BPF_ALU64) 				EMIT1(add_1mod(0x48, dst_reg)); 			else if (is_ereg(dst_reg)) 				EMIT1(add_1mod(0x40, dst_reg)); 			EMIT2(0xF7, add_1reg(0xD8, dst_reg)); 			break;  		case BPF_ALU | BPF_ADD | BPF_K: 		case BPF_ALU | BPF_SUB | BPF_K: 		case BPF_ALU | BPF_AND | BPF_K: 		case BPF_ALU | BPF_OR | BPF_K: 		case BPF_ALU | BPF_XOR | BPF_K: 		case BPF_ALU6
```c  if ((endian_type == LSBEndian) &&  (LocaleCompare(image_info->magick,"TIFF64") != 0))  mode=endian_type == LSBEndian ? "wl" : "wb"; ```
```c void nonlimitative_fixtures(int petrosum_eisell,... ) {  float quotient;  int mod = 0;  int input;  char *hypertoxic_subincident = 0;  void *ferriferous_profitter = 0;  va_list huge_tallboy;  ++global_variable;;  if (petrosum_eisell > 0) {  __builtin_va_start(huge_tallboy,petrosum_eisell);  ferriferous_profitter = (va_arg(huge_tallboy,void *));  __builtin_va_end(huge_tallboy);  }  hypertoxic_subincident = ((char *)((char *)ferriferous_profitter));    input = atoi(hypertoxic_subincident);  if (input != 0) {      mod = input % 4;            quotient = 1024 / mod;    printf("%f\n", quotient);  } else {  printf("Input value is 0, or not a number\n");  }   ; close_printf_context(); } ```
```c read_taint(&laxifolious_kokaras,"6151",eurodollars_sepulchers); ```
```c APP_INFO *pop_info() {  APP_INFO tmp;  APP_INFO *ret = ((void *)0);  if (amih != ((void *)0)) {  CRYPTO_THREADID_current(&tmp . threadid);  if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {  APP_INFO *next = ret -> next;  if (next != ((void *)0)) {  next -> references++;  (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));  } #ifdef LEVITTE_DEBUG_MEM #endif  if (--ret -> references <= 0) {  ret -> next = ((void *)0);  if (next != ((void *)0)) {  next -> references--;  }  CRYPTO_free(ret);  }  }  }  return ret; } ```
```c file = fopen(abs_path,"rb"); ```
```c if (CRYPTO_is_mem_check_on()) {   CRYPTO_mem_ctrl(0x3);  if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),"mem_dbg.c",498)))) == ((void *)0)) {  CRYPTO_free(addr);   CRYPTO_mem_ctrl(0x2);  return ;  } ```
```c waitForSig();  ```
```c fatal("%s line %d: Missing handler for opcode %s (%d)",        filename, linenum, arg, opcode); ```
```c if (buffer[0] >= 97) {    main_first_char = process_buffer(buffer);  } ```
```c int av_packet_split_side_data(AVPacket *pkt) {  int i = 0;  int opt_var;  char *heap_buffer_64 = 0;  char *etiam_whitey = 0;  struct christiansen_wampums *ungreased_fleuret = {0};  struct christiansen_wampums *subcurate_divulsing = {0};  struct christiansen_wampums berhymes_dishware;  int perrin_mackinac = 596;  char *adumbrations_bathycolpian;;  if (__sync_bool_compare_and_swap(&freezingly_telephotography,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&adumbrations_bathycolpian,"7292",perrin_mackinac);  if (adumbrations_bathycolpian != 0) {;  berhymes_dishware . vikky_alada = ((char *)adumbrations_bathycolpian);  ungreased_fleuret = &berhymes_dishware;  subcurate_divulsing = ungreased_fleuret + 5;  etiam_whitey = ((char *)( *(subcurate_divulsing - 5)) . vikky_alada);    heap_buffer_64 = (char*) malloc(64 * sizeof(char));  if (heap_buffer_64 != NULL) {  memset(heap_buffer_64,0,64);              strcpy(heap_buffer_64, etiam_whitey);        opt_var = strlen( heap_buffer_64);    for (; i < opt_var; ++i) {  heap_buffer_64[i] = toupper(heap_buffer_64[i]);  }        printf("%s\n",heap_buffer_64);  free(heap_buffer_64);        } ;  if (( *(subcurate_divulsing - 5)) . vikky_alada != 0)   free(((char *)( *(subcurate_divulsing - 5)) . vikky_alada)); close_printf_context();  }  }  }  ; ```
```c MYSQL_ROW row;  unsigned int num_fields;  my_ulonglong num_rows;  MYSQL_RES *result;  int i;  int status;  char query_buffer[1000];  MYSQL *conn;  unsigned int dbport = 0;  char *dbpassword = 0;  char *dbuser = 0;  char *dbhost = 0;  char * dbdatabase = 0;  char use_str[150] = {0};  char *unpuritanical_illiopolis = 0;  union gibbert_obstructively vishnuite_escapees = {0};  ++global_variable;  union gibbert_obstructively dihydroxy_stalkiest = {0};   if (dihydroxy_stalkiest . moslems_delsman != 0) {;  vishnuite_escapees = ascii_unrestrictive(dihydroxy_stalkiest);  unpuritanical_illiopolis = ((char *)vishnuite_escapees . moslems_delsman);   dbhost = getenv("DBMYSQLHOST");  dbuser = getenv("DBMYSQLUSER");  dbpassword = getenv("DBMYSQLPASSWORD");  dbport = ((unsigned int )(strtoul(getenv("DBMYSQLPORT"),0,10)));  dbdatabase = getenv("SS_DBMYSQLDATABASE");    if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {  conn = mysql_init(0);  if (conn != 0) {  if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,"/var/lib/mysql/mysql.sock",65536UL) != 0) {  snprintf(use_str,150,"USE %s;", dbdatabase);  if (mysql_query(conn, use_str) == 0) {    snprintf(query_buffer,1000,"SELECT * FROM Customers WHERE Country='%s';",unpuritanical_illiopolis);    if (mysql_query(conn,query_buffer) == 0) {  do {  result = mysql_store_result(conn);  if (result != 0) {  num_rows = mysql_num_rows(result);  if (num_rows != 0) {  num_fields = mysql_num_fields(result);  while((row = mysql_fetch_row(result))){  for (i = 0; i < num_fields; ++i)  printf("%s ",(row[i]?row[i] : "NULL"));  printf("\n");  }  mysql_free_result(result);  }  }  else {  if (mysql_field_count(conn) == 0)  printf("%lld rows affected\n",mysql_affected_rows(conn));  else {  printf("%s error %u: %s\n","Store result error",mysql_errno(conn),mysql_error(conn));  break;  }  }  status = mysql_next_result(conn);  if (status > 0)  printf("%s error %u: %s\n","Next result error",mysql_errno(conn),mysql_error(conn));  }while (status == 0);  }  else {   printf("%s error %u: %s\n","Query",mysql_errno(conn),mysql_error(conn));  }   }  else {   printf("%s error %u: %s\n","Query",mysql_errno(conn),mysql_error(conn));  }  mysql_close(conn);  }  else {   printf("%s error %u: %s\n","Real connect",mysql_errno(conn),mysql_error(conn));  }  }  else {   printf("%s error %u: %s\n","Init",mysql_errno(conn),mysql_error(conn));  }  }  ; } ```
```c void handle_taint(char *salpingostomies_muller) {  vouchsafer_appay malpighiaceous_coden = 0;  ++global_variable;;  if (salpingostomies_muller != 0) {;  malpighiaceous_coden = salpingostomies_muller;  unmortified_hests(1,malpighiaceous_coden);  } } ```
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```

```c setup_printf_context(); ```
```c ERR_load_BIO_strings() {;  if (__sync_bool_compare_and_swap(&ineluctability_myringa,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    sixteener_airview(noctivagous_strongmen);  }  }  ; #ifndef OPENSSL_NO_ERR  if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {  ERR_load_strings(0,BIO_str_functs);  ERR_load_strings(0,BIO_str_reasons);  } #endif } ```
```c int_cleanup_cb_LHASH_DOALL(void *arg) {  struct statoreceptor_byordinar desired_vincent = {0};  int *fillmass_concents = 0;  int calcifuge_kryptocyanine;  struct statoreceptor_byordinar scrawly_phosphonic[10] = {0};  struct statoreceptor_byordinar residencer_overvariety;  char *beaupere_caligated;  ENGINE_PILE *a = arg;  if (__sync_bool_compare_and_swap(&binaries_doctrinarity,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&beaupere_caligated,"VAPORINGLY_DYSCRASITE");  if (beaupere_caligated != 0) {;  residencer_overvariety . tour_jamesstore = ((char *)beaupere_caligated);  scrawly_phosphonic[5] = residencer_overvariety;  calcifuge_kryptocyanine = 5;  fillmass_concents = &calcifuge_kryptocyanine;  desired_vincent = *(scrawly_phosphonic + *fillmass_concents); 	EAVEDROPPING_PROTOACTINIUM(desired_vincent);  }  }  }  int_cleanup_cb_doall(a); } ```
```cpp snprintf(cmd_string,1000,"%s%s",base_cmd,subdie_collectivizing); ```
```c int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```
```c SSL_CTX_set_verify(ctx, s_server_verify, verify_callback); ```
```c void ERR_load_BIO_strings() {;  if (__sync_bool_compare_and_swap(&generalidad_cribbage,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  }  ; #ifndef OPENSSL_NO_ERR  if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {  ERR_load_strings(0,BIO_str_functs);  ERR_load_strings(0,BIO_str_reasons);  } #endif } ```
```c if (__sync_bool_compare_and_swap(&reroyalize_uncalcareous,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&telsonic_bisulcate,"CURTAXE_PROCEDENDO");  if (telsonic_bisulcate != 0) {;  teknonymously_tef = ((int )(strlen(telsonic_bisulcate)));  pluckiest_glossoplegia = ((char *)(malloc(teknonymously_tef + 1)));  if (pluckiest_glossoplegia == 0) {  printf("Error: Failed to allocate memory\n");  exit(1);  }  memset(pluckiest_glossoplegia,0,teknonymously_tef + 1);  memcpy(pluckiest_glossoplegia,telsonic_bisulcate,teknonymously_tef);  if (telsonic_bisulcate != 0)   free(((char *)telsonic_bisulcate));  preinterceding_schizotrypanum = &pluckiest_glossoplegia;  eto_lanza = &preinterceding_schizotrypanum;  aridity_phenoquinone = 5;  while(1 == 1){  aridity_phenoquinone = aridity_phenoquinone * 2;  aridity_phenoquinone = aridity_phenoquinone + 2;  if (aridity_phenoquinone > 1000) {  break;   }  }  confrere_recanters = aridity_phenoquinone;  cortez_scordature = ((char *)( *( *eto_lanza)));    memset(dest,'x',MAXLEN);  dest[MAXLEN - 1] = '\0';    size_var = returnChunkSize(dest, cortez_scordature);         if (size_var > 0)  memcpy(dest, cortez_scordature, size_var);  printf("%s\n",dest);     ;  if ( *( *eto_lanza) != 0)   free(((char *)( *( *eto_lanza)))); close_printf_context();  }  }  } ; ```
```c void handle_taint(char *taejon_ecophene) {  int hammal_doggones = 7;  struct ringmaster_overaptly anarchists_draperess = {0};  int *highheartedly_overbalancing = 0;  int immobile_nonplanetary;  struct ringmaster_overaptly jaygees_gnetaceae[10] = {0};  struct ringmaster_overaptly readopt_phalluses;  ++global_variable;;  if (taejon_ecophene != 0) {;  readopt_phalluses . afton_tinder = ((char *)taejon_ecophene);  immobile_nonplanetary = 5;  highheartedly_overbalancing = &immobile_nonplanetary;  jaygees_gnetaceae[ *highheartedly_overbalancing] = readopt_phalluses;  anarchists_draperess = jaygees_gnetaceae[ *highheartedly_overbalancing];  defeasibility_civility(hammal_doggones,anarchists_draperess);  } } ```
```c if (filename_param != ((void *)0)) {  f = fopen(filename_param,"w"); } ```
```c char buff[64]; if (strlen(source) + 1 <= sizeof(buff)) {  strncpy(buff,source,sizeof(source)); } ```
```c if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {  fclose(file);  return ((void *)0); ```
```c if (truest_forlay . polypi_fims != 0)   free(((char *)truest_forlay . polypi_fims)); ```
```c int ssl3_send_client_key_exchange(SSL *s) {     unsigned char *p;     int n;     unsigned long alg_k; #ifndef OPENSSL_NO_RSA     unsigned char *q;     EVP_PKEY *pkey = NULL; #endif #ifndef OPENSSL_NO_KRB5     KSSL_ERR kssl_err; #endif /* OPENSSL_NO_KRB5 */ #ifndef OPENSSL_NO_ECDH     EC_KEY *clnt_ecdh = NULL;     const EC_POINT *srvr_ecpoint = NULL;     EVP_PKEY *srvr_pub_pkey = NULL;     unsigned char *encodedPoint = NULL;     int encoded_pt_len = 0;     BN_CTX * bn_ctx = NULL; #endif      if (s->state == SSL3_ST_CW_KEY_EXCH_A)     {         p = ssl_handshake_start(s);          alg_k = s->s3->tmp.new_cipher->algorithm_mkey;          /* Fool emacs indentation */         if (0) {} #ifndef OPENSSL_NO_RSA         else if (alg_k & SSL_kRSA)         {             RSA *rsa;             unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];              if (s->session->sess_cert == NULL)             {                 /* We should always have a server certificate with SSL_kRSA. */                 SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);                 goto err;             }              if (s->session->sess_cert->peer_rsa_tmp != NULL)                 rsa = s->session->sess_cert->peer_rsa_tmp;             else             {                 pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);                 if ((pkey == NULL) ||                     (pkey->type != EVP_PKEY_RSA) ||                     (pkey->pkey.rsa == NULL))                 {                     SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);                     goto err;                 }                 rsa = pkey->pkey.rsa;                 EVP_PKEY_free(pkey);             }              tmp_buf[0] = s->client_version >> 8;             tmp_buf[1] = s->client_version & 0xff;             if (RAND_bytes(&(tmp_buf[2]), sizeof tmp_buf - 2) <= 0)                 goto err;              s->session->master_key_length = sizeof tmp_buf;              q = p;             /* Fix buf for TLS and beyond */             if (s->version > SSL3_VERSION)                 p += 2;             n = RSA_public_encrypt(sizeof tmp_buf,                 tmp_buf, p, rsa, RSA_PKCS1_PADDING); #ifdef PKCS1_CHECK             if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;             if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0] = 0x70; #endif             if (n <= 0)             {                 SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, SSL_R_BAD_RSA_ENCRYPT);                 goto err;             }              /* Fix buf for TLS and beyond */             if (s->version > SSL3_VERSION)             {                 s2n(n, q);                 n += 2;             }              s->session->master_key_length =                 s->method->ssl3_enc->generate_master_secret(s,                     s->session->master_key,                     tmp_buf, sizeof tmp_buf);             OPENSSL_cleanse(tmp_buf, sizeof tmp_buf);         } #endif #ifndef OPENSSL_NO_KRB5         else if (alg_k & SSL_kKRB5)         {             krb5_error_code krb5rc;             KSSL_CTX *kssl_ctx = s->kssl_ctx;             /* krb5_data	krb5_ap_req; */             krb5_data *enc_ticket;             krb5_data authenticator, *authp = NULL;             EVP_CIPHER_CTX ciph_ctx;             const EVP_CIPHER *enc = NULL;             unsigned char iv[EVP_MAX_IV_LENGTH];             unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];             unsigned char epms[SSL_MAX_MASTER_KEY_LENGTH                          + EVP_MAX_IV_LENGTH];             int padl, outl = sizeof(epms);              EVP_CIPHER_CTX_init(&ciph_ctx);  #ifdef KSSL_DEBUG             fprintf(stderr, "ssl3_send_client_key_exchange(%lx & %lx)\n",                 alg_k, SSL_kKRB5); #endif /* KSSL_DEBUG */              authp = NULL; #ifdef KRB5SENDAUTH             if (KRB5SENDAUTH) authp = &authenticator; #endif /* KRB5SENDAUTH */              krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,                 &kssl_err);             enc = kssl_map_enc(kssl_ctx->enctype);             if (enc == NULL)                 goto err; #ifdef KSSL_DEBUG             {                 fprintf(stderr, "kssl_cget_tkt rtn %d\n", krb5rc);                 if (krb5rc && kssl_err.text)                     fprintf(stderr, "kssl_cget_tkt kssl_err=%s\n", kssl_err.text);             } #endif /* KSSL_DEBUG */              if (krb5rc)             {                 ssl3_send_alert(s, SSL3_AL_FATAL,                         SSL_AD_HANDSHAKE_FAILURE);                 SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,                         kssl_err.reason);                 goto err;             }              /*-              * 20010406 VRS - Earlier versions used KRB5 AP_REQ              * in place of RFC 2712 KerberosWrapper, as in:              *              * Send ticket (copy to *p, set n = length)              * n = krb5_ap_req.length;              * memcpy(p, krb5_ap_req.data, krb5_ap_req.length);              * if (krb5_ap_req.data)               * kssl_krb5_free_data_contents(NULL,&krb5_ap_req);              *              * Now using real RFC 2712 KerberosWrapper              * (Thanks to Simon Wilkinson <sxw@sxw.org.uk>)              * Note: 2712 "opaque" types are here replaced              * with a 2-byte length followed by the value.              * Example:              * KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms              * Where "xx xx" = length bytes. Shown here with              * optional authenticator omitted.              */              /* KerberosWrapper.Ticket		*/             s2n(enc_ticket->length, p);             memcpy(p, enc_ticket->data, enc_ticket->length);             p += enc_ticket->length;             n = enc_ticket->length + 2;              /* KerberosWrapper.Authenticator	*/             if (authp && authp->length)              {                 s2n(authp->length, p);                 memcpy(p, authp->data, authp->length);                 p += authp->length;                 n += authp->length + 2;                  free(authp->data);                 authp->data = NULL;                 authp->length = 0;             }             else             {                 s2n(0, p);/* null authenticator length	*/                 n += 2;             }              tmp_buf[0] = s->client_version >> 8;             tmp_buf[1] = s->client_version & 0xff;             if (RAND_bytes(&(tmp_buf[2]), sizeof tmp
```c void nitromannitol_saturdays(void (*jumart_nonsupporting)(void **)) {  int oc_i = 0;  int ptr_deref;  struct struct data;  char *oursels_prothallic = 0;  void **dermas_vassalism = 0;  void **wherefore_chromite = 0;  ++global_variable;  void *bemadams_depressants = 0;  jumart_nonsupporting(&bemadams_depressants);  if (((char *)bemadams_depressants) != 0) {;  dermas_vassalism = &bemadams_depressants;  wherefore_chromite = dermas_vassalism + 5;  oursels_prothallic = ((char *)((char *)( *(wherefore_chromite - 5))));    data.buff_pointer = data.buffer;            strncpy(data.buffer, oursels_prothallic, strlen(oursels_prothallic) + 1);  ptr_deref = strlen( data.buff_pointer);  for (; oc_i < ptr_deref; ++oc_i) {  data.buffer[oc_i] = toupper(data.buffer[oc_i]);  }  printf("%s\n", data.buffer);       ;  if (((char *)( *(wherefore_chromite - 5))) != 0)   free(((char *)((char *)( *(wherefore_chromite - 5)))));  close_printf_context();  } } ```
```c char stack_string[stack_size]; memset(stack_string,'x',stack_size - 1); ```
```c int ev_handler(struct mg_connection *conn, enum mg_event ev) {  char * ifmatch_header;  char* tainted_buff;  int buffer_size = 1000;  int data_size = 0;  if (ev == MG_REQUEST) {  ifmatch_header = (char*) mg_get_header(conn, "if-match");  if (strcmp(ifmatch_header, "weak_taint_source_value") == 0) {  while (1) {  tainted_buff = (char*) malloc(buffer_size * sizeof(char));    data_size = mg_get_var(conn, "data", tainted_buff, buffer_size * sizeof(char));  if (data_size < buffer_size) {  exit_flag = 1;  break;  }  buffer_size = buffer_size * 2;  free(tainted_buff);  }  printf_context = conn;  handle_taint(tainted_buff);    }  return MG_TRUE;  } else if (ev == MG_AUTH) {  return MG_TRUE;  } else {  return MG_FALSE;  } } ```
```c URLContext *h = (s -> opaque); ```
```cpp CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p); ```
```c int calcIncamount(void *data) {  struct data *dataStruct = (struct data*)data;  printf("In calcInamount\n");        dataStruct->inc_amount = dataStruct->data[0] - 'A';     readFile(dataStruct->file2);  if (dataStruct->inc_amount < 0) {   dataStruct->inc_amount *= -1;   }  else if (dataStruct->inc_amount == 0) {   dataStruct->inc_amount += 1;  }      return NULL; } ```
```c static MagickBooleanType MogrifyUsage(void) {  static const char  miscellaneous[] =  " -debug events display copious debugging information\n"  " -distribute-cache port\n"  " distributed pixel cache spanning one or more servers\n"  " -help print program options\n"  " -list type print a list of supported option arguments\n"  " -log format format of debugging information\n"  " -version print version information",  operators[] =  " -adaptive-blur geometry\n"  " adaptively blur pixels; decrease effect near edges\n"  " -adaptive-resize geometry\n"  " adaptively resize image using 'mesh' interpolation\n"  " -adaptive-sharpen geometry\n"  " adaptively sharpen pixels; increase effect near edges\n"  " -alpha option on, activate, off, deactivate, set, opaque, copy\n"  " transparent, extract, background, or shape\n"  " -annotate geometry text\n"  " annotate the image with text\n"  " -auto-gamma automagically adjust gamma level of image\n"  " -auto-level automagically adjust color levels of image\n"  " -auto-orient automagically orient (rotate) image\n"  " -bench iterations measure performance\n"  " -black-threshold value\n"  " force all pixels below the threshold into black\n"  " -blue-shift simulate a scene at nighttime in the moonlight\n"  " -blur geometry reduce image noise and reduce detail levels\n"  " -border geometry surround image with a border of color\n"  " -bordercolor color border color\n"  " -brightness-contrast geometry\n"  " improve brightness / contrast of the image\n"  " -canny geometry detect edges in the image\n"  " -cdl filename color correct with a color decision list\n"  " -charcoal radius simulate a charcoal drawing\n"  " -chop geometry remove pixels from the image interior\n"  " -clamp keep pixel values in range (0-QuantumRange)\n"  " -clip clip along the first path from the 8BIM profile\n"  " -clip-mask filename associate a clip mask with the image\n"  " -clip-path id clip along a named path from the 8BIM profile\n"  " -colorize value colorize the image with the fill color\n"  " -color-matrix matrix apply color correction to the image\n"  " -connected-components connectivity\n"  " connected-components uniquely labeled\n"  " -contrast enhance or reduce the image contrast\n"  " -contrast-stretch geometry\n"  " improve contrast by `stretching' the intensity range\n"  " -convolve coefficients\n"  " apply a convolution kernel to the image\n"  " -cycle amount cycle the image colormap\n"  " -decipher filename convert cipher pixels to plain pixels\n"  " -deskew threshold straighten an image\n"  " -despeckle reduce the speckles within an image\n"  " -distort method args\n"  " distort images according to given method ad args\n"  " -draw string annotate the image with a graphic primitive\n"  " -edge radius apply a filter to detect edges in the image\n"  " -encipher filename convert plain pixels to cipher pixels\n"  " -emboss radius emboss an image\n"  " -enhance apply a digital filter to enhance a noisy image\n"  " -equalize perform histogram equalization to an image\n"  " -evaluate operator value\n"  " evaluate an arithmetic, relational, or logical expression\n"  " -extent geometry set the image size\n"  " -extract geometry extract area from image\n"  " -hough-lines geometry\n"  " identify lines in the image\n"  " -features distance analyze image features (e.g. contrast, correlation)\n"  " -fft implements the discrete Fourier transform (DFT)\n"  " -flip flip image vertically\n"  " -floodfill geometry color\n"  " floodfill the image with color\n"  " -flop flop image horizontally\n"  " -frame geometry surround image with an ornamental border\n"  " -function name parameters\n"  " apply function over image values\n"  " -gamma value level of gamma correction\n"  " -gaussian-blur geometry\n"  " reduce image noise and reduce detail levels\n"  " -geometry geometry preferred size or location of the image\n"  " -grayscale method convert image to grayscale\n"  " -help print program options\n"  " -identify identify the format and characteristics of the image\n"  " -ift implements the inverse discrete Fourier transform (DFT)\n"  " -implode amount implode image pixels about the center\n"  " -kuwahara geometry edge preserving noise reduction filter\n"  " -lat geometry local adaptive thresholding\n"  " -layers method optimize, merge, or compare image layers\n"  " -level value adjust the level of image contrast\n"  " -level-colors color,color\n"  " level image with the given colors\n"  " -linear-stretch geometry\n"  " improve contrast by `stretching with saturation'\n"  " -liquid-rescale geometry\n"  " rescale image with seam-carving\n"  " -local-contrast geometry\n"  " enhance local contrast\n"  " -magnify double the size of the image with pixel art scaling\n"  " -mean-shift geometry delineate arbitrarily shaped clusters in the image\n"  " -median geometry apply a median filter to the image\n"  " -mode geometry make each pixel the 'predominant color' of the\n"  " neighborhood\n"  " -modulate value vary the brightness, saturation, and hue\n"  " -monochrome transform image to black and white\n"  " -morphology method kernel\n"  " apply a morphology method to the image\n"  " -motion-blur geometry\n"  " simulate motion blur\n"  " -negate replace every pixel with its complementary color \n"  " -noise geometry add or reduce noise in an image\n"  " -normalize transform image to span the full range of colors\n"  " -opaque color change this color to the fill color\n"  " -ordered-dither NxN\n"  " add a noise pattern to the image with specific\n"  " amplitudes\n"  " -paint radius simulate an oil painting\n"  " -perceptible epsilon\n"  " pixel value less than |epsilon| become epsilon or\n"  " -epsilon\n"  " -polaroid angle simulate a Polaroid picture\n"  " -posterize levels reduce the image to a limited number of color levels\n"  " -profile filename add, delete, or apply an image profile\n"  " -quantize colorspace reduce colors in this colorspace\n"  " -radial-blur angle radial blur the image\n"  " -raise value lighten/darken image edges to create a 3-D effect\n"  " -random-threshold low,high\n"  " random threshold the image\n"  " -region geometry apply options to a portion of the image\n"  " -render render vector graphics\n"  " -resample geometry change the resolution of an image\n"  " -resize geometry resize the image\n"  " -roll geometry roll an image vertically or horizontally\n"  " -rotate degrees apply Paeth rotation to the image\n"  " -sample geometry scale image with pixel sampling\n"  " -scale geometry scale the image\n"  " -segment values segment an image\n"  " -selective-blur geometry\n"  " selectively blur pixels within a contrast threshold\n"  " -sepia-tone threshold\n"  " simulate a sepia-toned photo\n"  " -set property value set an image property\n"  " -shade degrees shade the image using a distant light source\n"  " -shadow geometry simulate an image shadow\n"  " -sharpen geometry sharpen the image\n"  " -shave geometry shave pixels from the image edges\n"  " -shear geometry slide one edge of the image along the X or Y axis\n"  " -sigmoidal-contrast geometry\n"  " increase the contrast without saturating highlights or\n"  " shadows\n"  " -sketch geometry simulate a pencil sketch\n"  " -solarize threshold negate all pixels above the threshold level\n"  " -sparse-color method args\n"  " fill in a image based on a few color points\n"  " -splice geometry splice the background color into the image\n"  " -spread radius displace image pixels by a random amount\n"  " -statistic type radius\n"  " replace each pixel with corresponding statistic from the neighborhood\n"  " -strip strip image of all profiles and comments\n"
```c zygion_assmannshausen(union adenous_satsuma *gynecomazia_cultured) {  int oc_i = 0;  char stack_buffer_64[64];  char *hirples_vindices = 0;  ++global_variable;;  hirples_vindices = ((char *)( *gynecomazia_cultured) . evendown_vicing);    memset(stack_buffer_64,0,64);            strcpy(stack_buffer_64,hirples_vindices);        for (; oc_i < 64; ++oc_i) {  stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);  }      printf("%s\n",stack_buffer_64);         ; close_printf_context(); } ```
```c if (buffer != 0) {      free(buffer);    } ```
```c char *miliolitic_subfulgent = 0; ```
```c  if (strlen(kieler_thumblike) >= 1 &&  kieler_thumblike[0] != '-') {  input_num = strtoul(kieler_thumblike,0U,16);  ptr = &input_num;  if ( *ptr > 65535) {                                      byte_3 = ((char *)(ptr + 2));  byte_4 = ((char *)(ptr + 3));      *byte_3 = 0;  *byte_4 = 0;            }      function_ptr_1();  function_ptr_2();  function_ptr_3();  function_ptr_4();    printf("Value = %i\n", input_num);  } ```
```c engine_set_all_null(ENGINE *e) ```
```c char *byte_4 = 0;  char *byte_3 = 0;  unsigned int *ptr = 0;  struct struct ssS;  char *fatheadedness_relicensing = 0;  ++global_variable;;  fatheadedness_relicensing = ((char *)zebulun_apothecal . odontolite_fontinas);    ssS.function_ptr_1 = function;  ssS.function_ptr_2 = function;  if (strlen(fatheadedness_relicensing) >= 1 &&  fatheadedness_relicensing[0] != '-') {  ssS.input_num = strtoul(fatheadedness_relicensing,0U,16);  ptr = &(ssS.input_num);  if ( *ptr > 65535) {        byte_3 = ((char *)(ptr + 2));  byte_4 = ((char *)(ptr + 3));  *byte_3 = 0;  *byte_4 = 0;        }      ssS.function_ptr_2();    printf("Value = %i\n", ssS.input_num);  } else if (strlen(fatheadedness_relicensing) == 0) {  printf("Input is empty string\n");  } else {  printf("Input is negative number\n");  }   ;  if (zebulun_apothecal . odontolite_fontinas != 0)   free(((char *)zebulun_apothecal . odontolite_fontinas)); close_printf_context(); ```
```java static enum AVCodecID av_str2id(const IdStrMap *tags,const char *str) {;  if (__sync_bool_compare_and_swap(&entropion_cardplayer,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  }  ; ```
```c read_taint(&oppositions_coryell,"ACCORDANCY_TODIES");  if (oppositions_coryell != 0) {;  asemic_uptowners . dyspeptically_coghle = ((char *)oppositions_coryell);  *fetches_hypochdria = asemic_uptowners;  } ```
```c #include "libavutil/avassert.h" #include "libavutil/avstring.h" #include "libavutil/channel_layout.h" #include "libavutil/common.h" #include "libavutil/imgutils.h" #include "libavutil/pixdesc.h" #include "libavutil/rational.h" #include "libavutil/samplefmt.h" #include "audio.h" #include "avfilter.h" #include "formats.h" #include "internal.h" #include "audio.h" #include <sys/stat.h>  #include <sys/ipc.h>  #include <sys/shm.h>  #include <sys/types.h>  #include </trace.h>  #include <fcntl.h>  #include <unistd.h>  static int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame); int afterage_falconries = 0; void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void read_taint(char** tainted_buff, char* envKey, int shmsz) {  int shmid;  key_t key;  char *shm, *s;  char* envSize = NULL;  *tainted_buff = NULL;  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  if(envKey != NULL) {  if(sscanf(envKey, "%d", &key) > 0) {  if ((shmid = shmget(key, shmsz, 0666)) >= 0) {  if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {  *tainted_buff = (char*)calloc(shmsz, sizeof(char));    for (s = shm; *s != (char)0; s++) {  (*tainted_buff)[s - shm] = *s;  }  }  }  }  }  } else {  *tainted_buff = NULL;  } }  char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; }  void ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end) {  char buf[16] __attribute__((unused)) ;  do {  if (0) {  av_log(ctx,48,"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);  }  }while (0);  if (ref -> video) {  do {  if (0) {  av_log(ctx,48," a:%d/%d s:%dx%d i:%c iskey:%d type:%c",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));  }  }while (0);    }  if (ref -> audio) {  do {  if (0) {  av_log(ctx,48," cl:%ldd n:%d r:%d",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);  }  }while (0);  }  do {  if (0) {  av_log(ctx,48,"]%s",(end?"\n" : ""));  }  }while (0); }  unsigned int avfilter_version() {  do {  if (!(103 >= 100)) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","103 >= 100","avfilter.c",'P');  abort();  }  }while (0);  return (3 << 16 | 42 << 8 | 103); }  const char *avfilter_configuration() {  int random_data;  char fill_buff[50000];  char file_path[50][31];  int filedes;  int count = 0;  int taint_num;  int ss_i = 0;  char *weeviled_tuque = 0;  void *uncunningness_stortz = 0;  int *kabuki_gadsman = 0;  int mlange_springeing;  void *superuniversal_phegopteris[10] = {0};  void *masterhood_predesirously = 0;  int interolivary_hobbyists = 6;  char *alkermes_asylabia;;  if (__sync_bool_compare_and_swap(&afterage_falconries,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&alkermes_asylabia,"4890",interolivary_hobbyists);  if (alkermes_asylabia != 0) {;  masterhood_predesirously = ((void *)alkermes_asylabia);  superuniversal_phegopteris[5] = masterhood_predesirously;  mlange_springeing = 5;  kabuki_gadsman = &mlange_springeing;  uncunningness_stortz = *(superuniversal_phegopteris + *kabuki_gadsman);  weeviled_tuque = ((char *)((char *)uncunningness_stortz));    random_data = open("/dev/urandom",0);  read(random_data,fill_buff,49999U);  close(random_data);  fill_buff[49999] = '\0';  taint_num =
```c printf("%s error %u: %s\n","Query",mysql_errno(conn),mysql_error(conn)); ```
```c CRYPTO_thread_lock(1 | 8,27,"mem_dbg.c",870); ```
```c static int ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame) {  do {  if (0) {  av_log(((void *)0),48,"%-16s: ","filter_frame");  }  }while (0);  ff_tlog_link(((void *)0),link,1);  do {  if (0) {  av_log(((void *)0),48," ");  }  }while (0);  ff_tlog_ref(((void *)0),frame,1);   if (link -> type == AVMEDIA_TYPE_VIDEO) {    if (strcmp(link -> dst -> filter -> name,"scale") != 0) {          }  }  else {            }   if (link -> type == AVMEDIA_TYPE_AUDIO && link -> min_samples != 0 && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {  return ff_filter_frame_needs_framing(link,frame);  }  else {  return ff_filter_frame_framed(link,frame);  } } ```
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```
```c unsigned long input_num;  if (strlen(bobbled_baileyton) >= 1 &&  bobbled_baileyton[0] != '-') {  input_num = strtoul(bobbled_baileyton,0U,16);  ptr = &input_num;  if ( *ptr > 65535) {                                      byte_3 = ((char *)(ptr + 2));  byte_4 = ((char *)(ptr + 3));      *byte_3 = 0;  *byte_4 = 0;            }      } ```
```c int CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags) {  struct stack_st_CONF_VALUE *values;  CONF_VALUE *vl;  char *vsection = ((void *)0);  int ret;  int i;  if (!cnf) {  return 1;  }  if (appname) {  vsection = NCONF_get_string(cnf,((void *)0),appname);  }  if (!appname || !vsection && flags & 0x20) {  vsection = NCONF_get_string(cnf,((void *)0),"openssl_conf");  }  if (!vsection) {  ERR_clear_error();  return 1;  }  values = NCONF_get_section(cnf,vsection);  if (!values) {  return 0;  }  for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {  vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));  ret = module_run(cnf,vl -> name,vl -> value,flags);  if (ret <= 0) {  if (!(flags & 0x1)) {  return ret;  }  }  }  return 1; } ```
```c ret = list_cb(lstart,(tmpend - lstart + 1),arg); ```
```c while (1) {  tainted_buff = (char*) malloc(buffer_size * sizeof(char));    data_size = mg_get_var(conn, "data", tainted_buff, buffer_size * sizeof(char));  if (data_size < buffer_size) {  exit_flag = 1;  break;  }  buffer_size = buffer_size * 2;  free(tainted_buff);  } ```
```c sebacic_dyehouse = ((char *)ccip_radiatics . deluded_kraul); ```
```c CONF_modules_free() ```
```c int tainted_int = 0;  int output_counter = 0;  char *worrit_osse = 0;  ++global_variable;;  worrit_osse = ((char *)( *(mirroring_nonliability - 5)) . predescend_conciator);    tainted_int = atoi(worrit_osse);  if (tainted_int > 0) {   tainted_int = tainted_int * tainted_int;        while (tainted_int != 0) {   if (tainted_int != INT_MIN) {  tainted_int--;  }    if (output_counter == 0) {  printf("evaluating input\n");  }  output_counter++;  if (output_counter == 1000000) {  output_counter = 0;  }  ++190_global_var;  if (190_global_var >= INT_MAX) {  190_global_var = 0;  }  }    }  printf("finished evaluating\n");   ;  if (( *(mirroring_nonliability - 5)) . predescend_conciator != 0)   free(((char *)( *(mirroring_nonliability - 5)) . predescend_conciator)); close_printf_context(); ```
```c char *second_buff = 0;  char *finder = "aba";  int check = 0;  char *araise_enalite = 0; ```
```c snprintf(query_buffer,1000,"SELECT * FROM Customers WHERE Country='%s';",dehydrant_cachot); ```
```c case OMX_IndexParamPortDefinition: {  VALIDATE_OMX_PARAM_DATA(paramData, OMX_PARAM_PORTDEFINITIONTYPE);  OMX_PARAM_PORTDEFINITIONTYPE *portDefn;  portDefn = (OMX_PARAM_PORTDEFINITIONTYPE *) paramData;  DEBUG_PRINT_LOW("set_parameter: OMX_IndexParamPortDefinition H= %d, W = %d",  (int)portDefn->format.video.nFrameHeight,  (int)portDefn->format.video.nFrameWidth);   if (PORT_INDEX_IN == portDefn->nPortIndex) {  if (!dev_is_video_session_supported(portDefn->format.video.nFrameWidth,  portDefn->format.video.nFrameHeight)) {  DEBUG_PRINT_ERROR("video session not supported");  omx_report_unsupported_setting();  return OMX_ErrorUnsupportedSetting;  }  DEBUG_PRINT_LOW("i/p actual cnt requested = %u", (unsigned int)portDefn->nBufferCountActual);  DEBUG_PRINT_LOW("i/p min cnt requested = %u", (unsigned int)portDefn->nBufferCountMin);  DEBUG_PRINT_LOW("i/p buffersize requested = %u", (unsigned int)portDefn->nBufferSize);  if (portDefn->nBufferCountActual > MAX_NUM_INPUT_BUFFERS) {  DEBUG_PRINT_ERROR("ERROR: (In_PORT) actual count (%u) exceeds max(%u)",  (unsigned int)portDefn->nBufferCountActual, (unsigned int)MAX_NUM_INPUT_BUFFERS);  return OMX_ErrorUnsupportedSetting;  }  if (portDefn->nBufferCountMin > portDefn->nBufferCountActual) {  DEBUG_PRINT_ERROR("ERROR: (In_PORT) Min buffers (%u) > actual count (%u)",  (unsigned int)portDefn->nBufferCountMin, (unsigned int)portDefn->nBufferCountActual);  return OMX_ErrorUnsupportedSetting;  }  if (handle->venc_set_param(paramData,OMX_IndexParamPortDefinition) != true) {  DEBUG_PRINT_ERROR("ERROR: venc_set_param input failed");  return handle->hw_overload ? OMX_ErrorInsufficientResources :  OMX_ErrorUnsupportedSetting;  }   DEBUG_PRINT_LOW("i/p previous actual cnt = %u", (unsigned int)m_sInPortDef.nBufferCountActual);  DEBUG_PRINT_LOW("i/p previous min cnt = %u", (unsigned int)m_sInPortDef.nBufferCountMin);  memcpy(&m_sInPortDef, portDefn,sizeof(OMX_PARAM_PORTDEFINITIONTYPE));  #ifdef _ANDROID_ICS_  if (portDefn->format.video.eColorFormat ==  (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatAndroidOpaque) {  m_sInPortDef.format.video.eColorFormat = (OMX_COLOR_FORMATTYPE)  QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;  if (!mUseProxyColorFormat) {  if (!c2d_conv.init()) {  DEBUG_PRINT_ERROR("C2D init failed");  return OMX_ErrorUnsupportedSetting;  }  DEBUG_PRINT_HIGH("C2D init is successful");  }  mUseProxyColorFormat = true;  m_input_msg_id = OMX_COMPONENT_GENERATE_ETB_OPQ;  } else #endif  {  mUseProxyColorFormat = false;  }  /*Query Input Buffer Requirements*/  dev_get_buf_req (&m_sInPortDef.nBufferCountMin,  &m_sInPortDef.nBufferCountActual,  &m_sInPortDef.nBufferSize,  m_sInPortDef.nPortIndex);   /*Query ouput Buffer Requirements*/  dev_get_buf_req (&m_sOutPortDef.nBufferCountMin,  &m_sOutPortDef.nBufferCountActual,  &m_sOutPortDef.nBufferSize,  m_sOutPortDef.nPortIndex);  m_sInPortDef.nBufferCountActual = portDefn->nBufferCountActual;  } else if (PORT_INDEX_OUT == portDefn->nPortIndex) {  DEBUG_PRINT_LOW("o/p actual cnt requested = %u", (unsigned int)portDefn->nBufferCountActual);  DEBUG_PRINT_LOW("o/p min cnt requested = %u", (unsigned int)portDefn->nBufferCountMin);  DEBUG_PRINT_LOW("o/p buffersize requested = %u", (unsigned int)portDefn->nBufferSize);  if (portDefn->nBufferCountActual > MAX_NUM_OUTPUT_BUFFERS) {  DEBUG_PRINT_ERROR("ERROR: (Out_PORT) actual count (%u) exceeds max(%u)",  (unsigned int)portDefn->nBufferCountActual, (unsigned int)MAX_NUM_OUTPUT_BUFFERS);  return OMX_ErrorUnsupportedSetting;  }  if (portDefn->nBufferCountMin > portDefn->nBufferCountActual) {  DEBUG_PRINT_ERROR("ERROR: (Out_PORT) Min buffers (%u) > actual count (%u)",  (unsigned int)portDefn->nBufferCountMin, (unsigned int)portDefn->nBufferCountActual);  return OMX_ErrorUnsupportedSetting;  }  if (handle->venc_set_param(paramData,OMX_IndexParamPortDefinition) != true) {  DEBUG_PRINT_ERROR("ERROR: venc_set_param output failed");  return OMX_ErrorUnsupportedSetting;  } #ifdef _MSM8974_  /*Query ouput Buffer Requirements*/  dev_get_buf_req(&m_sOutPortDef.nBufferCountMin,  &m_sOutPortDef.nBufferCountActual,  &m_sOutPortDef.nBufferSize,  m_sOutPortDef.nPortIndex); #endif  memcpy(&m_sOutPortDef,portDefn,sizeof(struct OMX_PARAM_PORTDEFINITIONTYPE));  update_profile_level(); //framerate , bitrate   DEBUG_PRINT_LOW("o/p previous actual cnt = %u", (unsigned int)m_sOutPortDef.nBufferCountActual);  DEBUG_PRINT_LOW("o/p previous min cnt = %u", (unsigned int)m_sOutPortDef.nBufferCountMin);  m_sOutPortDef.nBufferCountActual = portDefn->nBufferCountActual;  } else {  DEBUG_PRINT_ERROR("ERROR: Set_parameter: Bad Port idx %d",  (int)portDefn->nPortIndex);  eRet = OMX_ErrorBadPortIndex;  }  m_sConfigFramerate.xEncodeFramerate = portDefn->format.video.xFramerate;  m_sConfigBitrate.nEncodeBitrate = portDefn->format.video.nBitrate;  m_sParamBitrate.nTargetBitrate = portDefn->format.video.nBitrate;  } break; ```
```c char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; } ```
```c if (pipe(fd_array[index].fd_array) == -1) {  error = 1;  printf("Error opening pipe\n");  } else {  child_pid = fork();  if (child_pid >= 0) {  if (child_pid == 0) {  close(fd_array[index].fd_array[0]);  dup2(fd_array[index].fd_array[1], STDOUT_FILENO);      evp_hash(algorithms[jj], singleness_bihari);    close(fd_array[index].fd_array[1]);  exit(0);  } else {  close(fd_array[index].fd_array[1]);  fd_array[index].pid = child_pid;  continue;  }  } else {    printf("Failed to fork a child process.\n");  exit(1);  }  } ```
```c char *axiolite_scumboard;; ```
```c void handle_taint(char *sailers_innocuously) {  char *mentor_inexplicitness = 0;  char **unsternness_pulleyless = 0;  char *lectureships_postliterate = 0;  ++global_variable;;  if (sailers_innocuously != 0) {;  unsternness_pulleyless = &sailers_innocuously;  mentor_inexplicitness = ((char *)( *unsternness_pulleyless));    Data = malloc(sizeof(struct data));  if (Data) {  Data->data = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));  Data->file1 = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));  if (Data->data && Data->file1) {  if ((sscanf(mentor_inexplicitness, "%s %s",  Data->file1,  Data->data) == 2) &&  (strlen(Data->data) != 0) &&  (strlen(Data->file1) != 0))  {      Data->data_size = strlen(Data->data);  if (pthread_mutex_init(&mutex, NULL) != 0) {  printf("Mutex failed to initilize.");  }  if (signal(SIGUSR1, sig_handler) == SIG_ERR) {     printf ("Error catching SIGUSR1!\n");  }  delNonAlpha(Data);  signal(SIGUSR1, SIG_IGN);   } else {    printf("Error parsing data\n");  }  free(Data->data);  }  free(Data);  }   ;  if ( *unsternness_pulleyless != 0)   free(((char *)( *unsternness_pulleyless))); close_printf_context();  } } ```
```c int CRYPTO_get_new_lockid(char *name) {    if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",215);  return 0;  }  if ((str = BUF_strdup(name)) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",220);  return 0;  }  i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));  if (!i) {  CRYPTO_free(str);  }  else {   i += 41;  }  return i; } ```
```c s->session->ciphers = ciphers; ```
```c snprintf(query_buffer,1000,"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');", random_int, unwading_internal); ```
```c msg->err_pos = ctx.line + ctx.val - rep->buf->p; ```
```c ERR_load_BIO_strings() {  int rehumble_siphonaria = 7;  hydromassage_twist rustically_unphilosophical = 0;  int *solemnly_polyommatous = 0;  int divorcive_summits;  hydromassage_twist saltier_dryades[10] = {0};  hydromassage_twist chayma_puisne = 0;  char *neth_supercharging;;  if (__sync_bool_compare_and_swap(&defection_totalistic,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&neth_supercharging,"MICROPIPET_JUNKYARDS");  if (neth_supercharging != 0) {;  chayma_puisne = neth_supercharging;  divorcive_summits = 5;  solemnly_polyommatous = &divorcive_summits;  saltier_dryades[ *solemnly_polyommatous] = chayma_puisne;  rustically_unphilosophical = saltier_dryades[ *solemnly_polyommatous];  triphyllous_upridge(rehumble_siphonaria,rustically_unphilosophical);  }  }  }  ; #ifndef OPENSSL_NO_ERR  if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) { // Line is the root cause point of the vulnerability  ERR_load_strings(0,BIO_str_functs);  ERR_load_strings(0,BIO_str_reasons);  } #endif } ```
```c++ if (FLTIsFeatureIdFilterType(psXMLNode->pszValue)) {  psFilterNode->eType = FILTER_NODE_TYPE_FEATUREID;  pszFeatureId = CPLGetXMLValue(psXMLNode, "fid", NULL);  /*for FE 1.1.0 GmlObjectId */  if (pszFeatureId == NULL)  pszFeatureId = CPLGetXMLValue(psXMLNode, "id", NULL);  /*for FE 2.0 ResourceId */  if (pszFeatureId == NULL)  pszFeatureId = CPLGetXMLValue(psXMLNode, "rid", NULL);  pszFeatureIdList = NULL;   psFeatureIdNode = psXMLNode;  while (psFeatureIdNode) {  pszFeatureId = CPLGetXMLValue(psFeatureIdNode, "fid", NULL);  if (!pszFeatureId)  pszFeatureId = CPLGetXMLValue(psFeatureIdNode, "id", NULL);  if (!pszFeatureId)  pszFeatureId = CPLGetXMLValue(psFeatureIdNode, "rid", NULL);   if (pszFeatureId) {  if (pszFeatureIdList)  pszFeatureIdList = msStringConcatenate(pszFeatureIdList, ",");   pszFeatureIdList = msStringConcatenate(pszFeatureIdList, pszFeatureId);  }  psFeatureIdNode = psFeatureIdNode->psNext;  }   if (pszFeatureIdList) {  msFree(psFilterNode->pszValue);  psFilterNode->pszValue = msStrdup(pszFeatureIdList);  msFree(pszFeatureIdList);  } else  psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;  } ```
```c if ((espichellite_theriomorph - 5)[49] != 0)   free(((char *)(espichellite_theriomorph - 5)[49])); ```
```c tmplate . nid = nid;  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));  if (!fnd) {  goto end;  }  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) { #ifdef ENGINE_TABLE_DEBUG #endif  ret = fnd -> funct;  goto end;  } ```
The root cause point is the possible off by one in the free after the loop. ```c++ for (i = 0; i < num_files; ++i)  if (filearray[i] != 0)  fclose(filearray[i]); ```
```c (*out)[10] = (track_count >> 8) & 0xff; (*out)[11] = track_count & 0xff; ```
```c char *dulsea_cupriferous; ```
```cpp int tries = 0; 			bool exception = false;  			do { 				try { 					exception = false; 					m_pWebEm = new http::server::cWebem(settings, serverpath.c_str()); 				} 				catch (std::exception& e) { 					exception = true; 					switch (tries) { 					case 0: 						settings.listening_address = "::"; 						break; 					case 1: 						settings.listening_address = "0.0.0.0"; 						break; 					case 2: 						_log.Log(LOG_ERROR, "WebServer(%s) startup failed on address %s with port: %s: %s", m_server_alias.c_str(), settings.listening_address.c_str(), settings.listening_port.c_str(), e.what()); 						if (atoi(settings.listening_port.c_str()) < 1024) 							_log.Log(LOG_ERROR, "WebServer(%s) check privileges for opening ports below 1024", m_server_alias.c_str()); 						else 							_log.Log(LOG_ERROR, "WebServer(%s) check if no other application is using port: %s", m_server_alias.c_str(), settings.listening_port.c_str()); 						return false; 					} 					tries++; 				} 			} while (exception); ```
```c  if ( *( *aceric_reknits) != 0)   free(((char *)( *( *aceric_reknits)))); ```
```c #include "libavutil/avassert.h" #include "libavutil/avstring.h" #include "libavutil/channel_layout.h" #include "libavutil/common.h" #include "libavutil/imgutils.h" #include "libavutil/pixdesc.h" #include "libavutil/rational.h" #include "libavutil/samplefmt.h" #include "audio.h" #include "avfilter.h" #include "formats.h" #include "internal.h" #include "audio.h" #include <sys/stat.h>  #include </trace.h>  static int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame); int paraproctitis_hydroxamic = 0; void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void read_taint(char** tainted_buff, char* env_var_name) {  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  char* tainted_file_name = 0;  FILE * tainted_file = 0;  size_t result = 0;  long lsize = 0;  tainted_file_name = getenv(env_var_name);  tainted_file = fopen(tainted_file_name,"rb");  if (tainted_file != 0) {  fseek(tainted_file,0L,2);  lsize = ftell(tainted_file);  rewind(tainted_file);  *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));  if (*tainted_buff != 0) {    result = fread(*tainted_buff,1,lsize,tainted_file);  (*tainted_buff)[lsize] = '\0';  }  }  if (tainted_file != 0) {  fclose(tainted_file);  }  } else {  *tainted_buff = NULL;  } }  char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; }  void ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end) {  char buf[16] __attribute__((unused)) ;  do {  if (0) {  av_log(ctx,48,"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);  }  }while (0);  if (ref -> video) {  do {  if (0) {  av_log(ctx,48," a:%d/%d s:%dx%d i:%c iskey:%d type:%c",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));  }  }while (0);    }  if (ref -> audio) {  do {  if (0) {  av_log(ctx,48," cl:%ldd n:%d r:%d",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);  }  }while (0);  }  do {  if (0) {  av_log(ctx,48,"]%s",(end?"\n" : ""));  }  }while (0); }  unsigned int avfilter_version() {  do {  if (!(103 >= 100)) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","103 >= 100","avfilter.c",'P');  abort();  }  }while (0);  return (3 << 16 | 42 << 8 | 103); }  const char *avfilter_configuration() {  int ss_i = 0;  char stack_buff_64[64];  int my_buff_size;  char *bibliomancy_delftware = 0;  char *muzz_inferiors = 0;  int *cambogia_leku = 0;  int diplosphenal_dramalogue;  char *misadvantage_nontemporal[10] = {0};  char *bakers_countersurprise;;  if (__sync_bool_compare_and_swap(&paraproctitis_hydroxamic,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&bakers_countersurprise,"TRAYLIKE_FOOTINGS");  if (bakers_countersurprise != 0) {;  diplosphenal_dramalogue = 5;  cambogia_leku = &diplosphenal_dramalogue;  misadvantage_nontemporal[ *cambogia_leku] = bakers_countersurprise;  muzz_inferiors = misadvantage_nontemporal[ *cambogia_leku];  bibliomancy_delftware = ((char *)muzz_inferiors);      memset(stack_buff_64,'A',63);  stack_buff_64[63] = '\0';        my_buff_size = ((int )(strlen(bibliomancy_delftware)));  for (; ss_i < my_buff_size; ++ss_i){      printf("%c",stack_buff_64[ss_i]);  }          printf("\n");   ;  if (muzz_inferiors != 0)   free(((char *)muzz_inferiors)); close_printf_context();  }  }  }  ;  return "--prefix=/opt//workspace/install --enable-pic
```c jadder_renewed = ((char *)somnambulistic_middlesworth); ```
```c read_taint(&relationist_unruminatingly,"4895",oxtongue_spermatolysis);  if (relationist_unruminatingly != 0) {;  tecassir_pall = ((void *)relationist_unruminatingly);  aquamanilia_romeos = &tecassir_pall;  fanterie_adducible = aquamanilia_romeos + 5; 	JACANA_AGNOLA(fanterie_adducible);  } ```
```c DynBuffer *d = (s -> opaque);  int size;  static const char padbuf[16] = {(0)};  int padding = 0;   if (!s -> max_packet_size) {  avio_write(s,padbuf,(sizeof(padbuf)));  padding = 16;  }  avio_flush(s);  *pbuffer = d -> buffer;  size = d -> size;  av_free(d);  av_free(s);  return size - padding; ```
```c static void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den) {  num += den >> 1;  if (num >= den) {  val += num / den;  num = num % den;  }  f -> val = val;  f -> num = num;  f -> den = den; } ```
```static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,  ExceptionInfo *exception) {  char  page_geometry[MaxTextExtent];   Image  *image;   MagickBooleanType  logging;   volatile int  first_mng_object,  object_id,  term_chunk_found,  skip_to_iend;   volatile ssize_t  image_count=0;   MagickBooleanType  status;   MagickOffsetType  offset;   MngBox  default_fb,  fb,  previous_fb;  #if defined(MNG_INSERT_LAYERS)  PixelPacket  mng_background_color; #endif   register unsigned char  *p;   register ssize_t  i;   size_t  count;   ssize_t  loop_level;   volatile short  skipping_loop;  #if defined(MNG_INSERT_LAYERS)  unsigned int  mandatory_back=0; #endif  volatile unsigned int #ifdef MNG_OBJECT_BUFFERS  mng_background_object=0, #endif  mng_type=0; /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */   size_t  default_frame_timeout,  frame_timeout, #if defined(MNG_INSERT_LAYERS)  image_height,  image_width, #endif  length;   /* These delays are all measured in image ticks_per_second,  * not in MNG ticks_per_second  */  volatile size_t  default_frame_delay,  final_delay,  final_image_delay,  frame_delay, #if defined(MNG_INSERT_LAYERS)  insert_layers, #endif  mng_iterations=1,  simplicity=0,  subframe_height=0,  subframe_width=0;   previous_fb.top=0;  previous_fb.bottom=0;  previous_fb.left=0;  previous_fb.right=0;  default_fb.top=0;  default_fb.bottom=0;  default_fb.left=0;  default_fb.right=0;   logging=LogMagickEvent(CoderEvent,GetMagickModule(),  " Enter ReadOneMNGImage()");   image=mng_info->image;   if (LocaleCompare(image_info->magick,"MNG") == 0)  {  char  magic_number[MaxTextExtent];   /* Verify MNG signature. */  count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);  if (memcmp(magic_number,"\212MNG\r\n\032\n",8) != 0)  ThrowReaderException(CorruptImageError,"ImproperImageHeader");   /* Initialize some nonzero members of the MngInfo structure. */  for (i=0; i < MNG_MAX_OBJECTS; i++)  {  mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;  mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;  }  mng_info->exists[0]=MagickTrue;  }   skipping_loop=(-1);  first_mng_object=MagickTrue;  mng_type=0; #if defined(MNG_INSERT_LAYERS)  insert_layers=MagickFalse; /* should be False when converting or mogrifying */ #endif  default_frame_delay=0;  default_frame_timeout=0;  frame_delay=0;  final_delay=1;  mng_info->ticks_per_second=1UL*image->ticks_per_second;  object_id=0;  skip_to_iend=MagickFalse;  term_chunk_found=MagickFalse;  mng_info->framing_mode=1; #if defined(MNG_INSERT_LAYERS)  mandatory_back=MagickFalse; #endif #if defined(MNG_INSERT_LAYERS)  mng_background_color=image->background_color; #endif  default_fb=mng_info->frame;  previous_fb=mng_info->frame;  do  {  char  type[MaxTextExtent];   if (LocaleCompare(image_info->magick,"MNG") == 0)  {  unsigned char  *chunk;   /*  Read a new chunk.  */  type[0]='\0';  (void) ConcatenateMagickString(type,"errr",MaxTextExtent);  length=ReadBlobMSBLong(image);  count=(size_t) ReadBlob(image,4,(unsigned char *) type);   if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Reading MNG chunk type %c%c%c%c, length: %.20g",  type[0],type[1],type[2],type[3],(double) length);   if (length > PNG_UINT_31_MAX)  {  status=MagickFalse;  break;  }   if (count == 0)  ThrowReaderException(CorruptImageError,"CorruptImage");   p=NULL;  chunk=(unsigned char *) NULL;   if (length != 0)  {  chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));   if (chunk == (unsigned char *) NULL)  ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");   for (i=0; i < (ssize_t) length; i++)  {  int  c;   c=ReadBlobByte(image);  if (c == EOF)  break;  chunk[i]=(unsigned char) c;  }   p=chunk;  }   (void) ReadBlobMSBLong(image); /* read crc word */  #if !defined(JNG_SUPPORTED)  if (memcmp(type,mng_JHDR,4) == 0)  {  skip_to_iend=MagickTrue;   if (mng_info->jhdr_warning == 0)  (void) ThrowMagickException(&image->exception,GetMagickModule(),  CoderError,"JNGCompressNotSupported","`%s'",image->filename);   mng_info->jhdr_warning++;  } #endif  if (memcmp(type,mng_DHDR,4) == 0)  {  skip_to_iend=MagickTrue;   if (mng_info->dhdr_warning == 0)  (void) ThrowMagickException(&image->exception,GetMagickModule(),  CoderError,"DeltaPNGNotSupported","`%s'",image->filename);   mng_info->dhdr_warning++;  }  if (memcmp(type,mng_MEND,4) == 0)  break;   if (skip_to_iend)  {  if (memcmp(type,mng_IEND,4) == 0)  skip_to_iend=MagickFalse;   if (length != 0)  chunk=(unsigned char *) RelinquishMagickMemory(chunk);   if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Skip to IEND.");   continue;  }   if (memcmp(type,mng_MHDR,4) == 0)  {  if (length != 28)  {  chunk=(unsigned char *) RelinquishMagickMemory(chunk);  ThrowReaderException(CorruptImageError,"CorruptImage");  }   mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |  (p[2] << 8) | p[3]);   mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |  (p[6] << 8) | p[7]);   if (logging != MagickFalse)  {  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " MNG width: %.20g",(double) mng_info->mng_width);  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " MNG height: %.20g",(double) mng_info->mng_height);  }   p+=8;  mng_info->ticks_per_second=(size_t) mng_get_long(p);   if (mng_info->ticks_per_second == 0)  default_frame_delay=0;   else  default_frame_delay=1UL*image->ticks_per_second/  mng_info->ticks_per_second;   frame_delay=default_frame_delay;  simplicity
```c void handle_taint(char *processing_igloos) {  int stafford_optimised = 7;  char *heeder_fandangos = 0;  int **terentian_fri = 0;  int *reilluminated_ftw = 0;  int felice_filipiniana;  char *cheville_toccatas[10] = {0};  int univocal_barytic = 0;  char *haplite_blinnie = 0;  ++global_variable;;  if (processing_igloos != 0) {;  univocal_barytic = ((int )(strlen(processing_igloos)));  haplite_blinnie = ((char *)(malloc(univocal_barytic + 1)));  if (haplite_blinnie == 0) {  printf("Error: Failed to allocate memory\n");  exit(1);  }  memset(haplite_blinnie,0,univocal_barytic + 1);  memcpy(haplite_blinnie,processing_igloos,univocal_barytic);  if (processing_igloos != 0)   free(((char *)processing_igloos));  felice_filipiniana = 5;  reilluminated_ftw = &felice_filipiniana;  terentian_fri = &reilluminated_ftw;  cheville_toccatas[ *( *terentian_fri)] = haplite_blinnie;  heeder_fandangos = cheville_toccatas[ *( *terentian_fri)];  soweto_megapodes(stafford_optimised,heeder_fandangos);  } } ```
```c found = search(&sayonara_nonvocational[1],sayonara_nonvocational[0]); ```
```c sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))); ```
```c static int init_muxer(AVFormatContext *s,AVDictionary **options) {  int ret = 0;  int i;  AVStream *st;  AVDictionary *tmp = ((void *)0);  AVCodecContext *codec = ((void *)0);  AVOutputFormat *of = s -> oformat;  if (options) {  av_dict_copy(&tmp, *options,0);  }  if ((ret = av_opt_set_dict(s,&tmp)) < 0) {  goto fail;  }  if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {  goto fail;  }   if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {  av_log(s,16,"no streams\n");  ret = - 22;  goto fail;  }  for (i = 0; i < s -> nb_streams; i++) {  st = s -> streams[i];  codec = st -> codec;  switch(codec -> codec_type){  case AVMEDIA_TYPE_AUDIO: {  if (codec -> sample_rate <= 0) {  av_log(s,16,"sample rate not set\n");  ret = - 22;  goto fail;  }  if (!codec -> block_align) {  codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;  }  break;   }  case AVMEDIA_TYPE_VIDEO: {  if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0)   {  av_log(s,16,"time base not set\n");  ret = - 22;  goto fail;  }  if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {  av_log(s,16,"dimensions not set\n");  ret = - 22;  goto fail;  }  if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {  av_log(s,16,"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\n",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);  ret = - 22;  goto fail;  }  break;   }  }  if (of -> codec_tag) {  if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {    codec -> codec_tag = 0;  }  if (codec -> codec_tag) {  if (!validate_codec_tag(s,st)) {  char tagbuf[32];  char cortag[32];  av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);  av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));  av_log(s,16,"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\n",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);  ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));  goto fail;  }  }  else {  codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);  }  }  if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {  av_log(s,24,"Codec for stream %d does not use global headers but container format requires global headers\n",i);  }  }  if (!s -> priv_data && of -> priv_data_size > 0) {  s -> priv_data = av_mallocz((of -> priv_data_size));  if (!s -> priv_data) {  ret = - 12;  goto fail;  }  if (of -> priv_class) {  *((const AVClass **)(s -> priv_data)) = of -> priv_class;  av_opt_set_defaults(s -> priv_data);  if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {  goto fail;  }  }  }   if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {  av_dict_set(&s -> metadata,"encoder","Lavf54.63.104",0);  }  if (options) {  av_dict_free(options);  *options = tmp;  }  return 0;  fail:  av_dict_free(&tmp);  return ret; } ```
