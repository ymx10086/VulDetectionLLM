```c printf("%x",data->buffer[i]); ```
```c for (ss_i = 0; ss_i < strlen((char *)input_string); ++ss_i) {  if (input_string[ss_i] < 0)  continue;  ++stack_buff[input_string[ss_i]]; } ```
`av_str2id(img_tags,filename);`
```c int CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line) {  char buffer[100];  FILE *fpipe = 0;  char cmd_string[1000] = {0};  int is_valid = 1;  int i = 0;  char base_cmd[1000];  char *egret_subpartnership = 0;  int myospasmia_parrakeets;  int alliciency_humify;  okuari_vizirship unsterilized_falerno = 0;  int **hiring_refusal = 0;  int *thenceward_subclassed = 0;  int harry_housewrecker;  okuari_vizirship computerite_tranquilizer[10] = {0};  okuari_vizirship reechy_overdiversified = 0;  int vacillancy_straightway = 29;  char *repatriated_nontransient;  int ret = 0;  if (__sync_bool_compare_and_swap(&glottis_anisopodal,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&repatriated_nontransient,"8181",vacillancy_straightway);  if (repatriated_nontransient != 0) {;  reechy_overdiversified = repatriated_nontransient;  harry_housewrecker = 5;  thenceward_subclassed = &harry_housewrecker;  hiring_refusal = &thenceward_subclassed;  computerite_tranquilizer[ *( *hiring_refusal)] = reechy_overdiversified;  unsterilized_falerno = computerite_tranquilizer[ *( *hiring_refusal)];  alliciency_humify = 5;  while(1 == 1){  alliciency_humify = alliciency_humify * 2;  alliciency_humify = alliciency_humify + 2;  if (alliciency_humify > 1000) {  break;   }  }  myospasmia_parrakeets = alliciency_humify;  egret_subpartnership = ((char *)unsterilized_falerno);    snprintf(base_cmd, 1000, "find %s -iname ", "/opt//workspace/testData/temp" );    for (; i < strlen(egret_subpartnership); ++i) {  if (egret_subpartnership[i] == ';') {  if (i == 0 || egret_subpartnership[i - 1] != '\\') {  is_valid = 0;  break;  }  }  }  if (is_valid == 1) {     snprintf(cmd_string,1000,"%s%s",base_cmd,egret_subpartnership);         fpipe = popen(cmd_string,"r");  if (fpipe != 0) {  while(fgets(buffer,100,fpipe) != 0) {  printf(buffer);  }  pclose(fpipe);  }    }   ;  if (unsterilized_falerno != 0)   free(((char *)unsterilized_falerno)); close_printf_context();  }  }  }  if (add_lock_callback != ((void *)0)) { #ifdef LOCK_DEBUG #endif  ret = add_lock_callback(pointer,amount,type,file,line); #ifdef LOCK_DEBUG #endif  }  else {  CRYPTO_lock(1 | 8,type,file,line);  ret = *pointer + amount; #ifdef LOCK_DEBUG #endif  *pointer = ret;  CRYPTO_lock(2 | 8,type,file,line);  }  return ret; } ```
```c CRYPTO_mem_ctrl(0x3); ```
``` htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {  int ret = 0;  htmlParserInputPtr in;  int avail = 0;  xmlChar cur, next;   htmlParserNodeInfo node_info;  #ifdef DEBUG_PUSH  switch (ctxt->instate) { 	case XML_PARSER_EOF: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try EOF\n"); break; 	case XML_PARSER_START: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try START\n"); break; 	case XML_PARSER_MISC: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try MISC\n");break; 	case XML_PARSER_COMMENT: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try COMMENT\n");break; 	case XML_PARSER_PROLOG: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try PROLOG\n");break; 	case XML_PARSER_START_TAG: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try START_TAG\n");break; 	case XML_PARSER_CONTENT: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try CONTENT\n");break; 	case XML_PARSER_CDATA_SECTION: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try CDATA_SECTION\n");break; 	case XML_PARSER_END_TAG: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try END_TAG\n");break; 	case XML_PARSER_ENTITY_DECL: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try ENTITY_DECL\n");break; 	case XML_PARSER_ENTITY_VALUE: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try ENTITY_VALUE\n");break; 	case XML_PARSER_ATTRIBUTE_VALUE: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try ATTRIBUTE_VALUE\n");break; 	case XML_PARSER_DTD: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try DTD\n");break; 	case XML_PARSER_EPILOG: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try EPILOG\n");break; 	case XML_PARSER_PI: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try PI\n");break; 	case XML_PARSER_SYSTEM_LITERAL: 	 xmlGenericError(xmlGenericErrorContext, 		 "HPP: try SYSTEM_LITERAL\n");break;  } #endif   while (1) {  	in = ctxt->input; 	if (in == NULL) break; 	if (in->buf == NULL) 	 avail = in->length - (in->cur - in->base); 	else 	 avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base); 	if ((avail == 0) && (terminate)) { 	 htmlAutoCloseOnEnd(ctxt); 	 if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) { 		/* 		 * SAX: end of the document processing. 		 */ 		ctxt->instate = XML_PARSER_EOF; 		if ((ctxt->sax) && (ctxt->sax->endDocument != NULL)) 		 ctxt->sax->endDocument(ctxt->userData); 	 } 	}  if (avail < 1) 	 goto done; 	cur = in->cur[0]; 	if (cur == 0) { 	 SKIP(1); 	 continue; 	}   switch (ctxt->instate) {  case XML_PARSER_EOF: 	 /* 		 * Document parsing is done ! 		 */ 	 goto done;  case XML_PARSER_START: 	 /* 		 * Very first chars read from the document flow. 		 */ 		cur = in->cur[0]; 		if (IS_BLANK_CH(cur)) { 		 SKIP_BLANKS; 		 if (in->buf == NULL) 			avail = in->length - (in->cur - in->base); 		 else 			avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base); 		} 		if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) 		 ctxt->sax->setDocumentLocator(ctxt->userData, 						 &xmlDefaultSAXLocator); 		if ((ctxt->sax) && (ctxt->sax->startDocument) && 	 (!ctxt->disableSAX)) 		 ctxt->sax->startDocument(ctxt->userData);  		cur = in->cur[0]; 		next = in->cur[1]; 		if ((cur == '<') && (next == '!') && 		 (UPP(2) == 'D') && (UPP(3) == 'O') && 		 (UPP(4) == 'C') && (UPP(5) == 'T') && 		 (UPP(6) == 'Y') && (UPP(7) == 'P') && 		 (UPP(8) == 'E')) { 		 if ((!terminate) && 		 (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0)) 			goto done; #ifdef DEBUG_PUSH 		 xmlGenericError(xmlGenericErrorContext, 			 "HPP: Parsing internal subset\n"); #endif 		 htmlParseDocTypeDecl(ctxt); 		 ctxt->instate = XML_PARSER_PROLOG; #ifdef DEBUG_PUSH 		 xmlGenericError(xmlGenericErrorContext, 			 "HPP: entering PROLOG\n"); #endif 	} else { 		 ctxt->instate = XML_PARSER_MISC; #ifdef DEBUG_PUSH 		 xmlGenericError(xmlGenericErrorContext, 			 "HPP: entering MISC\n"); #endif 		} 		break;  case XML_PARSER_MISC: 		SKIP_BLANKS; 		if (in->buf == NULL) 		 avail = in->length - (in->cur - in->base); 		else 		 avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base); 		/* 		 * no chars in buffer 		 */ 		if (avail < 1) 		 goto done; 		/* 		 * not enouth chars in buffer 		 */ 		if (avail < 2) { 		 if (!terminate) 			goto done; 		 else 			next = ' '; 		} else { 		 next = in->cur[1]; 		} 		cur = in->cur[0]; 	 if ((cur == '<') && (next == '!') && 		 (in->cur[2] == '-') && (in->cur[3] == '-')) { 		 if ((!terminate) && 		 (htmlParseLookupSequence(ctxt, '-', '-', '>', 1, 1) < 0)) 			goto done; #ifdef DEBUG_PUSH 		 xmlGenericError(xmlGenericErrorContext, 			 "HPP: Parsing Comment\n"); #endif 		 htmlParseComment(ctxt); 		 ctxt->instate = XML_PARSER_MISC; 	 } else if ((cur == '<') && (next == '?')) { 		 if ((!terminate) && 		 (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0)) 			goto done; #ifdef DEBUG_PUSH 		 xmlGenericError(xmlGenericErrorContext, 			 "HPP: Parsing PI\n"); #endif 		 htmlParsePI(ctxt); 		 ctxt->instate = XML_PARSER_MISC; 		} else if ((cur == '<') && (next == '!') && 		 (UPP(2) == 'D') && (UPP(3) == 'O') && 		 (UPP(4) == 'C') && (UPP(5) == 'T') && 		 (UPP(6) == 'Y') && (UPP(7) == 'P') && 		 (UPP(8) == 'E')) { 		 if ((!terminate) && 		 (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0)) 			goto done; #ifdef DEBUG_PUSH 		 xmlGenericError(xmlGenericErrorContext, 			 "HPP: Parsing internal subset\n"); #endif 		 htmlParseDocTypeDecl(ctxt); 		 ctxt->instate = XML_PARSER_PROLOG; #ifdef DEBUG_PUSH 		 xmlGenericError(xmlGenericErrorContext, 			 "HPP: entering PROLOG\n"); #endif 		} else if ((cur == '<') && (next == '!')
```c #define _FILE_OFFSET_BITS 64 #include <stdio.h> #include <errno.h> #include "cryptlib.h" #include "bio_lcl.h" #include <openssl/err.h>  BIO *BIO_new_file(const char *filename,const char *mode) {     BIO *ret;     FILE *file = NULL; #if defined(_WIN32) && defined(CP_UTF8)     file = _wfopen(filename, mode); #else     file = fopen(filename, mode); #endif     if (file == NULL) {         ERR_put_error(2,1, *__errno_location(),"bss_file.c",169);         ERR_add_error_data(5,"fopen('",filename,"','",mode,"')");         if (*__errno_location() == 2) {             ERR_put_error(32,109,128,"bss_file.c",172);         }         else {             ERR_put_error(32,109,2,"bss_file.c",174);         }         return NULL;     }     if ((ret = BIO_new(BIO_s_file())) == NULL) {         fclose(file);         return NULL;     }     BIO_clear_flags(ret,0);     BIO_ctrl(ret,106,0x01,((char *)file));     return ret; } ```
```c ERR_load_BIO_strings() {  int kale_stickup;  union ferrety_weenong *reitboks_alisier = {0};  union ferrety_weenong *renewed_sphygmophonic = {0};  union ferrety_weenong trahern_pdn;  int coloreds_subaerial = 91;  char *diectasis_ecorse;;  if (__sync_bool_compare_and_swap(&ceryx_penuche,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&diectasis_ecorse,"8416",coloreds_subaerial);  if (diectasis_ecorse != 0) {;  trahern_pdn . vitric_medimnus = diectasis_ecorse;  kale_stickup = 1;  reitboks_alisier = &trahern_pdn;  renewed_sphygmophonic = ((union ferrety_weenong *)(((unsigned long )reitboks_alisier) * kale_stickup * kale_stickup)) + 5; 	PERIPHERICALLY_NONHUMANNESS(renewed_sphygmophonic);  }  }  }  ; ```
```c CRYPTO_get_new_lockid ```
```c int avformat_write_header(AVFormatContext *s,AVDictionary **options) {  void *amelioratory_garlen = 0;  char *antivirus_ashot;  int ret = 0;  if (__sync_bool_compare_and_swap(&wealthiness_cicatrize,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  antivirus_ashot = getenv("TRITIATE_TELHARMONY");  if (antivirus_ashot != 0) {;  amelioratory_garlen = ((void *)antivirus_ashot);  nonlimitative_fixtures(1,amelioratory_garlen);  }  }  }  if (ret = init_muxer(s,options)) {  return ret;  }  if (s -> oformat -> write_header) {  ret = ((s -> oformat -> write_header)(s));  if (ret >= 0 && s -> pb && s -> pb -> error < 0) {  ret = s -> pb -> error;  }  if (ret < 0) {  return ret;  }  }  if ((ret = init_pts(s)) < 0) {  return ret;  }  return 0; } ```
```c void omx_vdec::process_event_cb(void *ctxt, unsigned char id) {  unsigned long p1; // Parameter - 1  unsigned long p2; // Parameter - 2  unsigned long ident;  unsigned qsize=0; // qsize  omx_vdec *pThis = (omx_vdec *) ctxt;   if (!pThis) {  DEBUG_PRINT_ERROR("ERROR: %s()::Context is incorrect, bailing out",  __func__);  return;  }   do {  /*Read the message id's from the queue*/  pthread_mutex_lock(&pThis->m_lock);  qsize = pThis->m_cmd_q.m_size;  if (qsize) {  pThis->m_cmd_q.pop_entry(&p1, &p2, &ident);  }   if (qsize == 0 && pThis->m_state != OMX_StatePause) {  qsize = pThis->m_ftb_q.m_size;  if (qsize) {  pThis->m_ftb_q.pop_entry(&p1, &p2, &ident);  }  }   if (qsize == 0 && pThis->m_state != OMX_StatePause) {  qsize = pThis->m_etb_q.m_size;  if (qsize) {  pThis->m_etb_q.pop_entry(&p1, &p2, &ident);  }  }  pthread_mutex_unlock(&pThis->m_lock);   /*process message if we have one*/  if (qsize > 0) {  id = ident;  switch (id) {  case OMX_COMPONENT_GENERATE_EVENT:  if (pThis->m_cb.EventHandler) {  switch (p1) {  case OMX_CommandStateSet:  pThis->m_state = (OMX_STATETYPE) p2; //Line of code that is the root cause point of the vulnerability  DEBUG_PRINT_HIGH("OMX_CommandStateSet complete, m_state = %d",  pThis->m_state);  pThis->m_cb.EventHandler(&pThis->m_cmp, pThis->m_app_data,  OMX_EventCmdComplete, p1, p2, NULL);  break; ... ```
```c void nonoxidization_issachar(char *unmalted_leeper) {  ++global_variable;;  indochina_banquo(unmalted_leeper); } ```
```c taint_len = ((int )(strlen(ichthyosaurus_helves))); for (; taint_len >= 0; (--buff_size , --taint_len)) {   heap_buff_64[buff_size] = ichthyosaurus_helves[taint_len]; } ```
```c case OMX_QcomIndexParamSetMVSearchrange: {  DEBUG_PRINT_LOW("venc_set_config: OMX_QcomIndexParamSetMVSearchrange");  is_searchrange_set = true;  if (!venc_set_searchrange()) {  DEBUG_PRINT_ERROR("ERROR: Failed to set search range");  return false;  } } ```
```c  static unsigned long app_info_hash(const APP_INFO *a) {  PGresult *res = 0;  char query[1000];  PGconn *conn = 0;  char dbconn_str[150];  char *dbport = 0;  char *dbpassword = 0;  char *dbuser = 0;  char *dbhost = 0;  char *dbdatabase = 0;  int nFields;  int i;  int j = 0;  char *reinforceable_affectibility = 0;  jmp_buf panderize_manos;  int praham_carthorse;  char *munchausen_porphyrin[48] = {0};  char *nerstrand_laryngalgia;  unsigned long ret;  if (__sync_bool_compare_and_swap(&pharmacopolist_unicalcarate,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  nerstrand_laryngalgia = getenv("BALANDRA_CONUNDRUM");  if (nerstrand_laryngalgia != 0) {;  munchausen_porphyrin[45] = nerstrand_laryngalgia;  praham_carthorse = setjmp(panderize_manos);  if (praham_carthorse == 0) {  longjmp(panderize_manos,1);  }  reinforceable_affectibility = ((char *)munchausen_porphyrin[45]);    dbhost = getenv("DBPGHOST");  dbuser = getenv("DBPGUSER");  dbpassword = getenv("DBPGPASSWORD");  dbport = getenv("DBPGPORT");  dbdatabase = getenv("SS_DBPGDATABASE");            if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {  snprintf(dbconn_str,150,"dbname=%s host=%s user=%s password=%s port=%s",  dbdatabase, dbhost, dbuser, dbpassword, dbport);  conn = PQconnectdb(dbconn_str);  if (PQstatus(conn) != 0) {    printf("%s: %s\n","Connection to database failed", PQerrorMessage(conn));  PQfinish(conn);  exit(1);  }      snprintf(query,1000,"SELECT * FROM customers WHERE \"country\" = '%s';", reinforceable_affectibility);          res = PQexec(conn,query);  if (PQresultStatus(res) != 2) {    printf("%s: %s\n","SELECT failed",PQerrorMessage(conn));  PQclear(res);  PQfinish(conn);  exit(1);  }      nFields = PQnfields(res);  for (i = 0; i < nFields; i++)  printf("%-15s", PQfname(res, i));  printf("\n\n");    for (i = 0; i < PQntuples(res); i++)  {  for (j = 0; j < nFields; j++)  printf("%-15s", PQgetvalue(res, i, j));  printf("\n");  }  PQclear(res);  PQfinish(conn);  }   ; close_printf_context();  }  }  }  ret = CRYPTO_THREADID_hash(&a -> threadid);   ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;  return ret; }  ```
```c if (storying_cesure != 0) {; ```
```c found = search(&whiskyfied_conners[1],whiskyfied_conners[0]); ```
```c int CRYPTO_get_new_lockid(char *name) {  char *str;  int i; #if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)  #endif  if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",215);  return 0;  }  if ((str = BUF_strdup(name)) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",220);  return 0;  }  i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));  if (!i) {  CRYPTO_free(str);  }  else {   i += 41;  }  return i; } ```
```c value_f = (float)event->samples_to_next / samples_per_tick; ```
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```
```c case 0x7D: /* RDTG */  Ins_RDTG( exc ); ```
```{code} printf( ```
```c #define MAX_REGISTERED_AVFILTERS_NB 256 static AVFilter *registered_avfilters[256 + 1]; static int next_registered_avfilter_idx = 0; ```
```c if (ifmatch_header == (char*) mg_get_header(conn, "if-match"); ```
```c  if (snprintf(command_buffer, 1000, "%s%s",command_str,phototelescope_chiarra) < 0) {         }   ```
```c int to_unsign = get_int_value(tiling_copartnerships); ```
```c if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {  int i;  unsigned int size;  uint8_t *p;  p = pkt -> data + pkt -> size - 8 - 5;  for (i = 1; ; i++) {  size = av_bswap32(((const union unaligned_32 *)p) -> l);  if (size > 2147483647 || p - pkt -> data < size) {  return 0;  }  if (p[4] & 128) {  break;   }  p -= size + 5;  }  pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));  if (!pkt -> side_data) {  return - 12;  }  p = pkt -> data + pkt -> size - 8 - 5;  for (i = 0; ; i++) {  size = av_bswap32(((const union unaligned_32 *)p) -> l);  do {  if (!(size <= 2147483647 && p - pkt -> data >= size)) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","size<=2147483647 && p - pkt->data >= size","avpacket.c",288);  abort();  }  }while (0);  pkt -> side_data[i] . data = (av_malloc((size + 16)));  pkt -> side_data[i] . size = size;  pkt -> side_data[i] . type = (p[4] & 127);  if (!pkt -> side_data[i] . data) {  return - 12;  }  memcpy(pkt -> side_data[i] . data,(p - size),size);  pkt -> size -= size + 5;  if (p[4] & 128) {  break;   }  p -= size + 5;  }  pkt -> size -= 8;  pkt -> side_data_elems = i + 1;  return 1;  } ```
```c++ #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)  if ((compress_tag != COMPRESSION_NONE) &&  (TIFFIsCODECConfigured(compress_tag) == 0))  {  (void) ThrowMagickException(exception,GetMagickModule(),CoderError,  "CompressionNotSupported","`%s'",CommandOptionToMnemonic(  MagickCompressOptions,(ssize_t) compression));  compress_tag=COMPRESSION_NONE;  compression=NoCompression;  } #else  switch (compress_tag)  { #if defined(CCITT_SUPPORT)  case COMPRESSION_CCITTFAX3:  case COMPRESSION_CCITTFAX4: #endif #if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)  case COMPRESSION_JPEG: #endif #if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)  case COMPRESSION_LZMA: #endif #if defined(LZW_SUPPORT)  case COMPRESSION_LZW: #endif #if defined(PACKBITS_SUPPORT)  case COMPRESSION_PACKBITS: #endif #if defined(ZIP_SUPPORT)  case COMPRESSION_ADOBE_DEFLATE: #endif  case COMPRESSION_NONE:  break;  default:  {  (void) ThrowMagickException(exception,GetMagickModule(),CoderError,  "CompressionNotSupported","`%s'",CommandOptionToMnemonic(  MagickCompressOptions,(ssize_t) compression));  compress_tag=COMPRESSION_NONE;  compression=NoCompression;  break;  }  } #endif ```
```c if (memcmp(type,mng_JHDR,4) == 0) { if (length == 16) { jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]); jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) | (p[6] << 8) | p[7]); if ((jng_width == 0) || (jng_height == 0)) ThrowReaderException(CorruptImageError,"NegativeOrZeroImageSize"); jng_color_type=p[8]; jng_image_sample_depth=p[9]; jng_image_compression_method=p[10]; jng_image_interlace_method=p[11];  image->interlace=jng_image_interlace_method != 0 ? PNGInterlace : NoInterlace;  jng_alpha_sample_depth=p[12]; jng_alpha_compression_method=p[13]; jng_alpha_filter_method=p[14]; jng_alpha_interlace_method=p[15]; ```
```c char *kanaranzi_consolable = 0;  ++global_variable;;  kanaranzi_consolable = ((char *)( *(unprecipitous_azured - 5)) . unamazedness_redo); ```
```c #if CONFIG_NETWORK #include "network.h" #endif #undef NDEBUG #include <assert.h>  #include <stdarg.h>  #include </trace.h>  int distincter_nonvenally = 0; int global_variable; void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void read_taint(char** tainted_buff, char* env_var_name) {  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  char* tainted_file_name = 0;  FILE * tainted_file = 0;  size_t result = 0;  long lsize = 0;  tainted_file_name = getenv(env_var_name);  tainted_file = fopen(tainted_file_name,"rb");  if (tainted_file != 0) {  fseek(tainted_file,0L,2);  lsize = ftell(tainted_file);  rewind(tainted_file);  *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));  if (*tainted_buff != 0) {    result = fread(*tainted_buff,1,lsize,tainted_file);  (*tainted_buff)[lsize] = '\0';  }  }  if (tainted_file != 0) {  fclose(tainted_file);  }  } else {  *tainted_buff = NULL;  } }  ```
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```
```c char *buffer = 0U; ```
```c fptr* function_ptr = 0; ```
```c int num = 0; num = get_size(unchangingly_monied); ```
```cpp void sala_chassepots(struct diggings_unordered nontolerable_all) {  pthread_t t0, t1;  struct data *Data = malloc(sizeof(struct data));  char *chatting_phaneroscope = 0;  ++global_variable;;  chatting_phaneroscope = ((char *)nontolerable_all . algeria_musked);    if (Data) {  Data->data = malloc(sizeof(char) * (strlen(chatting_phaneroscope)+ 1));  if (Data->data &&  (sscanf(chatting_phaneroscope, "%d %s", &Data->qsize, Data->data) == 2) &&  (strlen(Data->data) != 0)) {  pthread_mutex_init(&mutex, NULL);  Data->data_size = strlen(Data->data);          if (pthread_create(&t0, NULL, replaceSymbols, (void*)Data) != 0) {  printf("Error initilizing thread 0.");  }  if (pthread_create(&t1, NULL, toCaps, (void*)Data) != 0) {  printf("Error initilizing thread 1.");  }  pthread_join(t0, NULL);  pthread_join(t1, NULL);    pthread_mutex_destroy(&mutex);      free(Data->data);    }  else {  printf("Error parsing input.\n");  }  free(Data);  }   ;  if (nontolerable_all . algeria_musked != 0)   free(((char *)nontolerable_all . algeria_musked)); close_printf_context(); } ```
```c srand(time(NULL));  random_int = (rand() % 1000) + 100;  snprintf(query_buffer,1000,"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');", random_int, synaptid_postconfinement); ```
```c glisk_opinative = 5;  while(1 == 1){  glisk_opinative = glisk_opinative * 2;  glisk_opinative = glisk_opinative + 2;  if (glisk_opinative > 1000) {  break;   }  } ```
```c int av_packet_merge_side_data(AVPacket *pkt) {  if (pkt -> side_data_elems) {  int i;  uint8_t *p;  uint64_t size = ((pkt -> size) + 8LL + 16);  AVPacket old = *pkt;  for (i = 0; i < old . side_data_elems; i++) {  size += (old . side_data[i] . size + 5);  }  if (size > 2147483647) {  return - 22;  }  p = (av_malloc(size));  if (!p) {  return - 12;  }  pkt -> data = p;  pkt -> destruct = av_destruct_packet;  pkt -> size = (size - 16);  bytestream_put_buffer(&p,old . data,old . size);  for (i = old . side_data_elems - 1; i >= 0; i--) {  bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);  bytestream_put_be32(&p,old . side_data[i] . size);  *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));  }  bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);  do {  if (!(p - pkt -> data == (pkt -> size))) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","p-pkt->data == pkt->size","avpacket.c",255);  abort();  }  }while (0);  memset(p,0,16);  av_free_packet(&old);  pkt -> side_data_elems = 0;  pkt -> side_data = ((void *)0);  return 1;  }  return 0; } ```
```c snprintf(cmd_string,1000,"%s%s",base_cmd,whalebird_fissura); ```
```c if (consecrates_synrhabdosome != 0) {;  shenstone_toponymist . bohlen_isn = consecrates_synrhabdosome;  stepping_ican(shenstone_toponymist);  } ```
```c if (sife_frierson != 0) {;  unproverbially_bespake = sife_frierson;  enteria_riverless = quamashes_biotome(unproverbially_bespake);  microanalytical_bradypepsy(unimpurpled_varus,enteria_riverless);  } ```
```c char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; } ```
`ERR_load_BIO_strings()`
```c res = PQexec(conn,query); ```
```c int avformat_write_header(AVFormatContext *s,AVDictionary **options) {  iyar_cwrite stomachaches_sanbenito = 0;  int aseptify_roomette = 28;  char *oligocarpous_electric;  int ret = 0;  if (__sync_bool_compare_and_swap(&reapply_tephillah,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&oligocarpous_electric,"4272",aseptify_roomette);  if (oligocarpous_electric != 0) {;  stomachaches_sanbenito = oligocarpous_electric;  nelson_mabyer(1,stomachaches_sanbenito);  }  }  } ```
```c case SSL3_ST_SW_KEY_EXCH_A:  case SSL3_ST_SW_KEY_EXCH_B: ```
```c for (; i < strlen(datiscoside_overbrowse); ++i) {  if (datiscoside_overbrowse[i] == ';') {  if (i == 0 || datiscoside_overbrowse[i - 1] != '\\') {  is_valid = 0;  break;  }  }  if (datiscoside_overbrowse[i] == '|') {  if (i == 0 || datiscoside_overbrowse[i - 1] != '\\') {  is_valid = 0;  break;  }  }  if (datiscoside_overbrowse[i] == '|') {  if (i == 0 || datiscoside_overbrowse[i - 1] != '|') {  is_valid = 0;  break;  }  }  if (datiscoside_overbrowse[i] == '&') {  if (i == 0 || datiscoside_overbrowse[i - 1] != '\\') {  is_valid = 0;  break;  }  }  if (datiscoside_overbrowse[i] == '&') {  if (i == 0 || datiscoside_overbrowse[i - 1] != '&') {  is_valid = 0;  break;  }  }  } ```
```c assert( pParent->nOverflow==0 || pParent->nOverflow==1 ); assert( pParent->nOverflow==0 || pParent->aiOvfl[0]==iParentIdx ); ```
```c strcpy(temp, playful_platypus);  free(playful_platypus);  playful_platypus = NULL;     waitForSig(sleepFile);    playful_platypus = temp; ```
```c read_taint(&ramulose_petunia,"ROMANO_ALGAROTH"); ```
```c file = fopen(filename,mode); ```
```c AVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission) {  AVRational q;  int j;  if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {  q = ((AVRational ){(1), st -> codec -> sample_rate});  }  else {  q = st -> codec -> time_base;  }  for (j = 2; j < 14; j += 1 + (j > 2))   while(q . den / q . num < min_precission && q . num % j == 0)  q . num /= j;  while(q . den / q . num < min_precission && q . den < 1 << 24)  q . den <<= 1;  return q; } ```
```c char *evaluates_irremeably(char *ransomers_hortensia); ```
`#if defined(OPENSSL_SYS_WINDOWS) #elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)  #elif defined(OPENSSL_SYS_MSDOS)   #elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN) #endif  { #if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN) #endif #if defined(OPENSSL_SYS_NETWARE) #endif  fp = fopen(ptr,p);  if (fp == ((void *)0)) {  ERR_put_error(2,1, *__errno_location(),"bss_file.c",398);  ERR_add_error_data(5,"fopen('",ptr,"','",p,"')");  ERR_put_error(32,116,2,"bss_file.c",400);  ret = 0;  break;   }`
```c jng_alpha_compression_method=0; ```
```c enum AVCodecID av_str2id(const IdStrMap *tags,const char *str) {  char *rukbat_hitchproof = 0;  ...  rukbat_hitchproof = ((char *)defined_manchester);   ```
```c  char *skip_malloc_buffer = 0;  char *guttery_pseudoinvalid = 0;  ++global_variable;;  guttery_pseudoinvalid = ((char *)piache_oxidation[0]);       if (strlen(guttery_pseudoinvalid) < 63) {  skip_malloc_buffer = malloc(strlen(guttery_pseudoinvalid + 1));  }         strcpy(skip_malloc_buffer,guttery_pseudoinvalid);  printf("Buffer is %s\n",skip_malloc_buffer);    if (skip_malloc_buffer != 0) {  free(skip_malloc_buffer);  }   ;  if (piache_oxidation[0] != 0)   free(((char *)piache_oxidation[0])); close_printf_context(); ```
```php PHP_MINIT_FUNCTION(curl) { 	le_curl = zend_register_list_destructors_ex(_php_curl_close, NULL, "curl", module_number); 	le_curl_multi_handle = zend_register_list_destructors_ex(_php_curl_multi_close, NULL, "curl_multi", module_number); 	le_curl_share_handle = zend_register_list_destructors_ex(_php_curl_share_close, NULL, "curl_share", module_number);  	REGISTER_INI_ENTRIES();  	/* See http://curl.haxx.se/lxr/source/docs/libcurl/symbols-in-versions 	 or curl src/docs/libcurl/symbols-in-versions for a (almost) complete list 	 of options and which version they were introduced */  	/* Constants for curl_setopt() */ 	REGISTER_CURL_CONSTANT(CURLOPT_AUTOREFERER); 	REGISTER_CURL_CONSTANT(CURLOPT_BINARYTRANSFER); 	REGISTER_CURL_CONSTANT(CURLOPT_BUFFERSIZE); 	REGISTER_CURL_CONSTANT(CURLOPT_CAINFO); 	REGISTER_CURL_CONSTANT(CURLOPT_CAPATH); 	REGISTER_CURL_CONSTANT(CURLOPT_CONNECTTIMEOUT); 	REGISTER_CURL_CONSTANT(CURLOPT_COOKIE); 	REGISTER_CURL_CONSTANT(CURLOPT_COOKIEFILE); 	REGISTER_CURL_CONSTANT(CURLOPT_COOKIEJAR); 	REGISTER_CURL_CONSTANT(CURLOPT_COOKIESESSION); 	REGISTER_CURL_CONSTANT(CURLOPT_CRLF); 	REGISTER_CURL_CONSTANT(CURLOPT_CUSTOMREQUEST); 	REGISTER_CURL_CONSTANT(CURLOPT_DNS_CACHE_TIMEOUT); 	REGISTER_CURL_CONSTANT(CURLOPT_DNS_USE_GLOBAL_CACHE); 	REGISTER_CURL_CONSTANT(CURLOPT_EGDSOCKET); 	REGISTER_CURL_CONSTANT(CURLOPT_ENCODING); 	REGISTER_CURL_CONSTANT(CURLOPT_FAILONERROR); 	REGISTER_CURL_CONSTANT(CURLOPT_FILE); 	REGISTER_CURL_CONSTANT(CURLOPT_FILETIME); 	REGISTER_CURL_CONSTANT(CURLOPT_FOLLOWLOCATION); 	REGISTER_CURL_CONSTANT(CURLOPT_FORBID_REUSE); 	REGISTER_CURL_CONSTANT(CURLOPT_FRESH_CONNECT); 	REGISTER_CURL_CONSTANT(CURLOPT_FTPAPPEND); 	REGISTER_CURL_CONSTANT(CURLOPT_FTPLISTONLY); 	REGISTER_CURL_CONSTANT(CURLOPT_FTPPORT); 	REGISTER_CURL_CONSTANT(CURLOPT_FTP_USE_EPRT); 	REGISTER_CURL_CONSTANT(CURLOPT_FTP_USE_EPSV); 	REGISTER_CURL_CONSTANT(CURLOPT_HEADER); 	REGISTER_CURL_CONSTANT(CURLOPT_HEADERFUNCTION); 	REGISTER_CURL_CONSTANT(CURLOPT_HTTP200ALIASES); 	REGISTER_CURL_CONSTANT(CURLOPT_HTTPGET); 	REGISTER_CURL_CONSTANT(CURLOPT_HTTPHEADER); 	REGISTER_CURL_CONSTANT(CURLOPT_HTTPPROXYTUNNEL); 	REGISTER_CURL_CONSTANT(CURLOPT_HTTP_VERSION); 	REGISTER_CURL_CONSTANT(CURLOPT_INFILE); 	REGISTER_CURL_CONSTANT(CURLOPT_INFILESIZE); 	REGISTER_CURL_CONSTANT(CURLOPT_INTERFACE); 	REGISTER_CURL_CONSTANT(CURLOPT_KRB4LEVEL); 	REGISTER_CURL_CONSTANT(CURLOPT_LOW_SPEED_LIMIT); 	REGISTER_CURL_CONSTANT(CURLOPT_LOW_SPEED_TIME); 	REGISTER_CURL_CONSTANT(CURLOPT_MAXCONNECTS); 	REGISTER_CURL_CONSTANT(CURLOPT_MAXREDIRS); 	REGISTER_CURL_CONSTANT(CURLOPT_NETRC); 	REGISTER_CURL_CONSTANT(CURLOPT_NOBODY); 	REGISTER_CURL_CONSTANT(CURLOPT_NOPROGRESS); 	REGISTER_CURL_CONSTANT(CURLOPT_NOSIGNAL); 	REGISTER_CURL_CONSTANT(CURLOPT_PORT); 	REGISTER_CURL_CONSTANT(CURLOPT_POST); 	REGISTER_CURL_CONSTANT(CURLOPT_POSTFIELDS); 	REGISTER_CURL_CONSTANT(CURLOPT_POSTQUOTE); 	REGISTER_CURL_CONSTANT(CURLOPT_PREQUOTE); 	REGISTER_CURL_CONSTANT(CURLOPT_PRIVATE); 	REGISTER_CURL_CONSTANT(CURLOPT_PROGRESSFUNCTION); 	REGISTER_CURL_CONSTANT(CURLOPT_PROXY); 	REGISTER_CURL_CONSTANT(CURLOPT_PROXYPORT); 	REGISTER_CURL_CONSTANT(CURLOPT_PROXYTYPE); 	REGISTER_CURL_CONSTANT(CURLOPT_PROXYUSERPWD); 	REGISTER_CURL_CONSTANT(CURLOPT_PUT); 	REGISTER_CURL_CONSTANT(CURLOPT_QUOTE); 	REGISTER_CURL_CONSTANT(CURLOPT_RANDOM_FILE); 	REGISTER_CURL_CONSTANT(CURLOPT_RANGE); 	REGISTER_CURL_CONSTANT(CURLOPT_READDATA); 	REGISTER_CURL_CONSTANT(CURLOPT_READFUNCTION); 	REGISTER_CURL_CONSTANT(CURLOPT_REFERER); 	REGISTER_CURL_CONSTANT(CURLOPT_RESUME_FROM); 	REGISTER_CURL_CONSTANT(CURLOPT_RETURNTRANSFER); 	REGISTER_CURL_CONSTANT(CURLOPT_SHARE); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLCERT); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLCERTPASSWD); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLCERTTYPE); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLENGINE); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLENGINE_DEFAULT); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLKEY); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLKEYPASSWD); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLKEYTYPE); 	REGISTER_CURL_CONSTANT(CURLOPT_SSLVERSION); 	REGISTER_CURL_CONSTANT(CURLOPT_SSL_CIPHER_LIST); 	REGISTER_CURL_CONSTANT(CURLOPT_SSL_VERIFYHOST); 	REGISTER_CURL_CONSTANT(CURLOPT_SSL_VERIFYPEER); 	REGISTER_CURL_CONSTANT(CURLOPT_STDERR); 	REGISTER_CURL_CONSTANT(CURLOPT_TELNETOPTIONS); 	REGISTER_CURL_CONSTANT(CURLOPT_TIMECONDITION); 	REGISTER_CURL_CONSTANT(CURLOPT_TIMEOUT); 	REGISTER_CURL_CONSTANT(CURLOPT_TIMEVALUE); 	REGISTER_CURL_CONSTANT(CURLOPT_TRANSFERTEXT); 	REGISTER_CURL_CONSTANT(CURLOPT_UNRESTRICTED_AUTH); 	REGISTER_CURL_CONSTANT(CURLOPT_UPLOAD); 	REGISTER_CURL_CONSTANT(CURLOPT_URL); 	REGISTER_CURL_CONSTANT(CURLOPT_USERAGENT); 	REGISTER_CURL_CONSTANT(CURLOPT_USERPWD); 	REGISTER_CURL_CONSTANT(CURLOPT_VERBOSE); 	REGISTER_CURL_CONSTANT(CURLOPT_WRITEFUNCTION); 	REGISTER_CURL_CONSTANT(CURLOPT_WRITEHEADER);  	/* */ 	REGISTER_CURL_CONSTANT(CURLE_ABORTED_BY_CALLBACK); 	REGISTER_CURL_CONSTANT(CURLE_BAD_CALLING_ORDER); 	REGISTER_CURL_CONSTANT(CURLE_BAD_CONTENT_ENCODING); 	REGISTER_CURL_CONSTANT(CURLE_BAD_DOWNLOAD_RESUME); 	REGISTER_CURL_CONSTANT(CURLE_BAD_FUNCTION_ARGUMENT); 	REGISTER_CURL_CONSTANT(CURLE_BAD_PASSWORD_ENTERED); 	REGISTER_CURL_CONSTANT(CURLE_COULDNT_CONNECT); 	REGISTER_CURL_CONSTANT(CURLE_COULDNT_RESOLVE_HOST); 	REGISTER_CURL_CONSTANT(CURLE_COULDNT_RESOLVE_PROXY); 	REGISTER_CURL_CONSTANT(CURLE_FAILED_INIT); 	REGISTER_CURL_CONSTANT(CURLE_FILE_COULDNT_READ_FILE); 	REGISTER_CURL_CONSTANT(CURLE_FTP_ACCESS_DENIED); 	REGISTER_CURL_CONSTANT(CURLE_FTP_BAD_DOWNLOAD_RESUME); 	REGISTER_CURL_CONSTANT(CURLE_FTP_CANT_GET_HOST); 	REGISTER_CURL_CONSTANT(CURLE_FTP_CANT_RECONNECT); 	REGISTER_CURL_CONSTANT(CURLE_FTP_COULDNT_GET_SIZE); 	REGISTER_CURL_CONSTANT(CURLE_FTP_COULDNT_RETR_FILE); 	REGISTER_CURL_CONSTANT(CURLE_FTP_COULDNT_SET_ASCII); 	REGISTER_CURL_CONSTANT(CURLE_FTP_COULDNT_SET_BINARY); 	REGISTER_CURL_CONSTANT(CURLE_FTP_COULDNT_STOR_FILE); 	REGISTER_CURL_CONSTANT(CURLE_FTP_COULDNT_USE_REST); 	REGISTER_CURL_CONSTANT(CURLE_FTP_PARTIAL_FILE); 	REGISTER_CURL_CONSTANT(CURLE_FTP_PORT_FAILED); 	REGISTER_CURL_CONSTANT(CURLE_FTP_QUOTE_ERROR); 	REGISTER_CURL_CONSTANT(CURLE_FTP_USER_PASSWORD_INCORRECT); 	REGISTER_CURL_CONSTANT(CURLE_FTP_WEIRD_227_FORMAT); 	REGISTER_CURL_CONSTANT(CURLE_FTP_WEIRD_PASS_REPLY); 	REGISTER_CURL_CONSTANT(CURLE_FTP_WEIRD_PASV_REPLY); 	REGISTER_CURL_CONSTANT(CURLE_FTP_WEIRD_SERVER_REPLY); 	REGISTER_CURL_CONSTANT(CUR
```c if (__sync_bool_compare_and_swap(&unepiscopally_maximes,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&wandie_abgatha,"FOLIOUSLY_PESETAS");  if (wandie_abgatha != 0) {;  clatter_vergeress = ((int )(strlen(wandie_abgatha)));  slopworks_guillem = ((char *)(malloc(clatter_vergeress + 1)));  if (slopworks_guillem == 0) {  printf("Error: Failed to allocate memory\n");  exit(1);  }  memset(slopworks_guillem,0,clatter_vergeress + 1);  memcpy(slopworks_guillem,wandie_abgatha,clatter_vergeress);  if (wandie_abgatha != 0)   free(((char *)wandie_abgatha));  vistaless_adrop = ((char *)slopworks_guillem);    Data = malloc(sizeof(struct data));  if (Data) {  Data->data = malloc(sizeof(char) * (strlen(vistaless_adrop) + 1));  Data->file1 = malloc(sizeof(char) * (strlen(vistaless_adrop) + 1));  Data->file2 = malloc(sizeof(char) * (strlen(vistaless_adrop) + 1));  if (Data->data) {  if ((sscanf(vistaless_adrop, "%s %s %s",  Data->file1,  Data->file2,  Data->data) == 3) &&  (strlen(Data->data) != 0) &&  (strlen(Data->file1) != 0) &&  (strlen(Data->file2) != 0))  {  global1 = calloc(1, sizeof(int));          if (signal(SIGUSR1, sig_handler) == SIG_ERR) {    printf ("Error catching SIGUSR1!\n");  }  printf("Set up SIGUSR1 handler\n");  if (Data->data[0] >= 'A' && Data->data[0] <= 'Z') {  if (signal(SIGUSR2, sig_handler) == SIG_ERR) {    printf ("Error catching SIGUSR2!\n");  }  printf("Set up SIGUSR2 handler\n");  }  waitForSig();  printf("After waitForSig\n");  signal(SIGUSR1, SIG_IGN);   signal(SIGUSR2, SIG_IGN);   if (global1 != NULL) {  free(global1);  global1 = NULL;  }  } else {    printf("Error parsing data\n");  }  free(Data->data);  }  free (Data);  }   ;  if (slopworks_guillem != 0)   free(((char *)slopworks_guillem)); close_printf_context();  }  }  } ```
```c  while (1) {  tainted_buff = (char*) malloc(buffer_size * sizeof(char));    data_size = mg_get_var(conn, "data", tainted_buff, buffer_size * sizeof(char));  if (data_size < buffer_size) {  exit_flag = 1;  break;  }  buffer_size = buffer_size * 2;  free(tainted_buff);  } ```
```c if (mysql_query(conn,query_buffer)) {  printf("%s error %u: %s\n","Query",mysql_errno(conn),mysql_error(conn));  } ```
```c void petaling_headliner(char **associative_tronk) {  int beglads_aconitum = 5;  char *gastromelus_jailbreaks;  ++global_variable;;  setup_printf_context();  read_taint(&gastromelus_jailbreaks,"3263",beglads_aconitum);  if (gastromelus_jailbreaks != 0) {;  *associative_tronk = gastromelus_jailbreaks;  } } ```
```c marteline_interbreeds = ((char *)( *( *( *( *( *( *( *( *( *( *archegone_circumambiency))))))))))); ```
```c void handle_taint(char *beswarm_cyclopedically) {  int scorpaena_typographical = 7;  struct jugal_cering scaphocephalism_dramatise;  ++global_variable;;  if (beswarm_cyclopedically != 0) {;  scaphocephalism_dramatise . rille_acemila = ((char *)beswarm_cyclopedically);  prelicensed_whipstall(scorpaena_typographical,scaphocephalism_dramatise);  } } ```
```c  read_taint(&quebracho_archpriesthood,"9440",mexico_shellmonger);  if (quebracho_archpriesthood != 0) {;  euktolite_yamshik = ((int )(strlen(quebracho_archpriesthood)));  repousse_casavant = ((char *)(malloc(euktolite_yamshik + 1)));  if (repousse_casavant == 0) {  printf("Error: Failed to allocate memory\n");  exit(1);  }  memset(repousse_casavant,0,euktolite_yamshik + 1);  memcpy(repousse_casavant,quebracho_archpriesthood,euktolite_yamshik);  if (quebracho_archpriesthood != 0)   free(((char *)quebracho_archpriesthood));  gnathonize_riverway(hmm_semitropics,repousse_casavant);  } ```
```c ERR_load_BIO_strings() {;  if (__sync_bool_compare_and_swap(&pabular_cockermeg,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  }  ; #ifndef OPENSSL_NO_ERR  if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {  ERR_load_strings(0,BIO_str_functs);  ERR_load_strings(0,BIO_str_reasons);  } #endif } ```
```c  if (addr1 == ((void *)0)) {  CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);  break;   } ```
```c int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) ```
```c if ((fs_attr->flags & TSK_FS_ATTR_NONRES) &&              (fs_attr->type != TSK_FS_ATTR_TYPE_HFS_COMP_REC) &&              (fs_attr->type != TSK_FS_ATTR_TYPE_HFS_ATTR_BIT_MAP)) {  if (!(istat_flags & TSK_FS_ISTAT_RUNLIST)) {                  tsk_fprintf(hFile,                      "Type: %s (%" PRIu32 "-%" PRIu16                      ") Name: %s Non-Resident%s%s%s size: %"                      PRIuOFF " init_size: %" PRIuOFF "\n", type,                      fs_attr->type,                      fs_attr->id,                      (fs_attr->name) ? fs_attr->name : "N/A",                      (fs_attr->flags & TSK_FS_ATTR_ENC) ?                      ", Encrypted" : "",                      (fs_attr->flags & TSK_FS_ATTR_COMP) ?                      ", Compressed" : "",                      (fs_attr->flags & TSK_FS_ATTR_SPARSE) ?                      ", Sparse" : "",                      fs_attr->size, fs_attr->nrd.initsize);   ```
```c buffer_value = atoi(mak_producible); ```
```c read_taint(&melvie_asylabia,"VICTIMISE_WALLSEND"); ```
``` printf_context = conn;  handle_taint(tainted_buff); ```
```c str = (strrchr(str,'.')); ```
```c strcpy(data.buffer, guyot_dinitril); ```
```c char *other_buff = 0;  int size = 0;  int num = 0;  char buff[200] = {0};  int output_counter = 0;  char *scotsmen_kiboshed = 0;  ++global_variable;;  scotsmen_kiboshed = ((char *)nonconsumption_overtimorously);    if (strlen(scotsmen_kiboshed) > 0 &&  scotsmen_kiboshed[0] == '-') {  printf("Negative number given as input\n");  } else {      num = get_size(scotsmen_kiboshed);  other_buff = getenv("SS_BUFF");        if (other_buff != 0) {  strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));  size = ((int )(strlen(buff)));      while (num < size) {    if (output_counter == 0) {  printf("evaluating input\n");  }  output_counter++;  if (output_counter == 1000000) {  output_counter = 0;  }  if (num > 0)  ++num;  }    } else {  printf("Missing value for other_buff\n");  }  printf("finished evaluating\n");  }   ;  if (nonconsumption_overtimorously != 0)   free(((char *)nonconsumption_overtimorously)); close_printf_context(); ```
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```
```c char *malloc_buffer = my_malloc(size_buffer); ```
```c abs_path = get_absolute_path(str); ```
```c int avformat_write_header(AVFormatContext *s,AVDictionary **options) {  pattersonville_magdeburg unsplendourous_stupefactions = 0;  int pleonastic_adularias = 6;  char *sunfoil_captains;  int ret = 0;  if (__sync_bool_compare_and_swap(&zig_deducement,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&sunfoil_captains,"3687",pleonastic_adularias);  if (sunfoil_captains != 0) {;  unsplendourous_stupefactions = sunfoil_captains;  republicanising_lenin(1,unsplendourous_stupefactions);  }  }  } ````
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```
`EVP_bf_cbc()`
```c buffer_len = 4; ```
```c CONF_IMODULE *imod; ```
```c if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",215);  return 0;  } ```
```c if (dynlock_lock_callback != ((void *)0)) {  struct CRYPTO_dynlock_value *pointer = CRYPTO_get_dynlock_value(type);  (void )(pointer != ((void *)0)?0 : ((OpenSSLDie("cryptlib.c",595,"pointer != NULL") , 1)));  dynlock_lock_callback(mode,pointer,file,line);  CRYPTO_destroy_dynlockid(type);  } ```
```c void underdish_par(struct coerceable_distributival taintable_cooptate) {  int ss_j;  int ss_i;  size_t taint_size;  char **malloced_buff = 0;  int trace_flag = 0;  char *weanyer_addcp = 0;  ++global_variable;;  weanyer_addcp = ((char *)taintable_cooptate . challengable_squarier);    taint_size = strlen(weanyer_addcp);    if (taint_size >= 1600) {  taint_size = 1599U;  }  malloced_buff = malloc(taint_size * sizeof(char *));      if (malloced_buff != 0) {      for (ss_i = 0; ss_i < taint_size; ++ss_i) {  malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));      if (malloced_buff[ss_i] == 0 && errno == 12) {  printf("Malloc error due to ulimit\n");  if (trace_flag == 0) {      trace_flag = 1;  }  }  if (malloced_buff[ss_i] != 0) {  for (ss_j = 0; ss_j < taint_size; ++ss_j) {  memcpy(malloced_buff[ss_i] + ss_j * taint_size,weanyer_addcp,taint_size);  }  }      if (taint_size % 2 == 0) {  if (malloced_buff[ss_i] != 0) {  free(malloced_buff[ss_i]);    }  }  }  free(malloced_buff);    } ;  if (taintable_cooptate . challengable_squarier != 0)   free(((char *)taintable_cooptate . challengable_squarier)); close_printf_context(); } ```
```cpp static unsigned long break_order_num = 0; ```
```c str = (strrchr(str,'.')); ```
```c read_taint(&pokorny_resiliate,"3161",chloromycetin_updress); ```
```c CRYPTO_dbg_malloc(addr,num,file,line,before_p); ```
```c for (i = 0; ((int )i) <= ((int )(strlen(malefeazance_dumpty) - strlen(finder))); ++i) ```
```c CONF_modules_finish(); ```
```c fct_ptr fp;  const char *rand_word = "criticisms_metallide";  fp = switch_func(centrechinoida_jenei); ```
```c static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image) {  const char  *value;   const StringInfo  *profile;   DPXInfo  dpx;   MagickBooleanType  status;   MagickOffsetType  offset;   MagickStatusType  flags;   GeometryInfo  geometry_info;   QuantumInfo  *quantum_info;   QuantumType  quantum_type;   register const PixelPacket  *p;   register ssize_t  i;   ssize_t  count,  horizontal_factor,  vertical_factor,  y;   size_t  extent;   time_t  seconds;   unsigned char  *pixels;   /*  Open output image file.  */  assert(image_info != (const ImageInfo *) NULL);  assert(image_info->signature == MagickSignature);  assert(image != (Image *) NULL);  assert(image->signature == MagickSignature);  if (image->debug != MagickFalse)  (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);  horizontal_factor=4;  vertical_factor=4;  if (image_info->sampling_factor != (char *) NULL)  {  GeometryInfo  geometry_info;   MagickStatusType  flags;   flags=ParseGeometry(image_info->sampling_factor,&geometry_info);  horizontal_factor=(ssize_t) geometry_info.rho;  vertical_factor=(ssize_t) geometry_info.sigma;  if ((flags & SigmaValue) == 0)  vertical_factor=horizontal_factor;  if ((horizontal_factor != 1) && (horizontal_factor != 2) &&  (horizontal_factor != 4) && (vertical_factor != 1) &&  (vertical_factor != 2) && (vertical_factor != 4))  ThrowWriterException(CorruptImageError,"UnexpectedSamplingFactor");  }  if ((image->colorspace == YCbCrColorspace) &&  ((horizontal_factor == 2) || (vertical_factor == 2)))  if ((image->columns % 2) != 0)  image->columns++;  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);  if (status == MagickFalse)  return(status);  /*  Write file header.  */  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));  offset=0;  dpx.file.magic=0x53445058U;  offset+=WriteBlobLong(image,dpx.file.magic);  dpx.file.image_offset=0x2000U;  profile=GetImageProfile(image,"dpx:user-data");  if (profile != (StringInfo *) NULL)  {  if (GetStringInfoLength(profile) > 1048576)  ThrowWriterException(ImageError,"WidthOrHeightExceedsLimit");  dpx.file.image_offset+=(unsigned int) GetStringInfoLength(profile);  dpx.file.image_offset=(((dpx.file.image_offset+0x2000-1)/0x2000)*0x2000);  }  offset+=WriteBlobLong(image,dpx.file.image_offset);  (void) strncpy(dpx.file.version,"V2.0",sizeof(dpx.file.version)-1);  offset+=WriteBlob(image,8,(unsigned char *) &dpx.file.version);  dpx.file.file_size=(unsigned int) (4U*image->columns*image->rows+  dpx.file.image_offset);  offset+=WriteBlobLong(image,dpx.file.file_size);  dpx.file.ditto_key=1U; /* new frame */  offset+=WriteBlobLong(image,dpx.file.ditto_key);  dpx.file.generic_size=0x00000680U;  offset+=WriteBlobLong(image,dpx.file.generic_size);  dpx.file.industry_size=0x00000180U;  offset+=WriteBlobLong(image,dpx.file.industry_size);  dpx.file.user_size=0;  if (profile != (StringInfo *) NULL)  {  dpx.file.user_size+=(unsigned int) GetStringInfoLength(profile);  dpx.file.user_size=(((dpx.file.user_size+0x2000-1)/0x2000)*0x2000);  }  offset+=WriteBlobLong(image,dpx.file.user_size);  value=GetImageArtifact(image,"dpx:file.filename");  if (value != (const char *) NULL)  (void) strncpy(dpx.file.filename,value,sizeof(dpx.file.filename)-1);  offset+=WriteBlob(image,sizeof(dpx.file.filename),(unsigned char *)  dpx.file.filename);  seconds=time((time_t *) NULL);  (void) FormatMagickTime(seconds,sizeof(dpx.file.timestamp),  dpx.file.timestamp);  offset+=WriteBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)  dpx.file.timestamp);  (void) strncpy(dpx.file.creator,GetMagickVersion((size_t *) NULL),  sizeof(dpx.file.creator)-1);  value=GetImageArtifact(image,"dpx:file.creator");  if (value != (const char *) NULL)  (void) strncpy(dpx.file.creator,value,sizeof(dpx.file.creator)-1);  offset+=WriteBlob(image,sizeof(dpx.file.creator),(unsigned char *)  dpx.file.creator);  value=GetImageArtifact(image,"dpx:file.project");  if (value != (const char *) NULL)  (void) strncpy(dpx.file.project,value,sizeof(dpx.file.project)-1);  offset+=WriteBlob(image,sizeof(dpx.file.project),(unsigned char *)  dpx.file.project);  value=GetImageArtifact(image,"dpx:file.copyright");  if (value != (const char *) NULL)  (void) strncpy(dpx.file.copyright,value,sizeof(dpx.file.copyright)-1);  offset+=WriteBlob(image,sizeof(dpx.file.copyright),(unsigned char *)  dpx.file.copyright);  dpx.file.encrypt_key=(~0U);  offset+=WriteBlobLong(image,dpx.file.encrypt_key);  offset+=WriteBlob(image,sizeof(dpx.file.reserve),(unsigned char *)  dpx.file.reserve);  /*  Write image header.  */  switch (image->orientation)  {  default:  case TopLeftOrientation: dpx.image.orientation=0; break;  case TopRightOrientation: dpx.image.orientation=1; break;  case BottomLeftOrientation: dpx.image.orientation=2; break;  case BottomRightOrientation: dpx.image.orientation=3; break;  case LeftTopOrientation: dpx.image.orientation=4; break;  case RightTopOrientation: dpx.image.orientation=5; break;  case LeftBottomOrientation: dpx.image.orientation=6; break;  case RightBottomOrientation: dpx.image.orientation=7; break;  }  offset+=WriteBlobShort(image,dpx.image.orientation);  dpx.image.number_elements=1;  offset+=WriteBlobShort(image,dpx.image.number_elements);  if ((image->columns != (unsigned int) image->columns) ||  (image->rows != (unsigned int) image->rows))  ThrowWriterException(ImageError,"WidthOrHeightExceedsLimit");  offset+=WriteBlobLong(image,(unsigned int) image->columns);  offset+=WriteBlobLong(image,(unsigned int) image->rows);  for (i=0; i < 8; i++)  {  dpx.image.image_element[i].data_sign=0U;  offset+=WriteBlobLong(image,dpx.image.image_element[i].data_sign);  dpx.image.image_element[i].low_data=0U;  offset+=WriteBlobLong(image,dpx.image.image_element[i].low_data);  dpx.image.image_element[i].low_quantity=0.0f;  offset+=WriteBlobFloat(image,dpx.image.image_element[i].low_quantity);  dpx.image.image_element[i].high_data=0U;  offset+=WriteBlobLong(image,dpx.image.image_element[
```c  ctxt->inst = cur; 		level++;  if (copy != NULL)  insert = copy; ```
```c LAWRIGHTMAN_SLAMMAKIN(clingers_athanasian); ```
```c int CRYPTO_get_new_lockid(char *name) {  char *str;  int i; #if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)  #endif  if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",215);  return 0;  }  if ((str = BUF_strdup(name)) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",220);  return 0;  }  i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));  if (!i) {  CRYPTO_free(str);  }  else {   i += 41;  }  return i; } ```
``` retval = decode_krb5_tgs_req(pkt, &request); ```
```c read_taint(&undeflowered_abastardize,"1882",bonnibel_sniffily); ```
